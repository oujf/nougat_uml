class LayoutManager
!!!28881079.java!!!	setRecyclerView(inout recyclerView : RecyclerView) : void
            if (recyclerView == null) {
                mRecyclerView = null;
                mChildHelper = null;
                mWidth = 0;
                mHeight = 0;
            } else {
                mRecyclerView = recyclerView;
                mChildHelper = recyclerView.mChildHelper;
                mWidth = recyclerView.getWidth();
                mHeight = recyclerView.getHeight();
            }
            mWidthMode = MeasureSpec.EXACTLY;
            mHeightMode = MeasureSpec.EXACTLY;
!!!28881207.java!!!	setMeasureSpecs(in wSpec : int, in hSpec : int) : void
            mWidth = MeasureSpec.getSize(wSpec);
            mWidthMode = MeasureSpec.getMode(wSpec);
            if (mWidthMode == MeasureSpec.UNSPECIFIED && !ALLOW_SIZE_IN_UNSPECIFIED_SPEC) {
                mWidth = 0;
            }

            mHeight = MeasureSpec.getSize(hSpec);
            mHeightMode = MeasureSpec.getMode(hSpec);
            if (mHeightMode == MeasureSpec.UNSPECIFIED && !ALLOW_SIZE_IN_UNSPECIFIED_SPEC) {
                mHeight = 0;
            }
!!!28881335.java!!!	setMeasuredDimensionFromChildren(in widthSpec : int, in heightSpec : int) : void
            final int count = getChildCount();
            if (count == 0) {
                mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);
                return;
            }
            int minX = Integer.MAX_VALUE;
            int minY = Integer.MAX_VALUE;
            int maxX = Integer.MIN_VALUE;
            int maxY = Integer.MIN_VALUE;

            for (int i = 0; i < count; i++) {
                View child = getChildAt(i);
                LayoutParams lp = (LayoutParams) child.getLayoutParams();
                final Rect bounds = mRecyclerView.mTempRect;
                getDecoratedBoundsWithMargins(child, bounds);
                if (bounds.left < minX) {
                    minX = bounds.left;
                }
                if (bounds.right > maxX) {
                    maxX = bounds.right;
                }
                if (bounds.top < minY) {
                    minY = bounds.top;
                }
                if (bounds.bottom > maxY) {
                    maxY = bounds.bottom;
                }
            }
            mRecyclerView.mTempRect.set(minX, minY, maxX, maxY);
            setMeasuredDimension(mRecyclerView.mTempRect, widthSpec, heightSpec);
!!!28881463.java!!!	setMeasuredDimension(inout childrenBounds : Rect, in wSpec : int, in hSpec : int) : void
            int usedWidth = childrenBounds.width() + getPaddingLeft() + getPaddingRight();
            int usedHeight = childrenBounds.height() + getPaddingTop() + getPaddingBottom();
            int width = chooseSize(wSpec, usedWidth, getMinimumWidth());
            int height = chooseSize(hSpec, usedHeight, getMinimumHeight());
            setMeasuredDimension(width, height);
!!!28881591.java!!!	requestLayout() : void
            if(mRecyclerView != null) {
                mRecyclerView.requestLayout();
            }
!!!28881719.java!!!	assertInLayoutOrScroll(in message : String) : void
            if (mRecyclerView != null) {
                mRecyclerView.assertInLayoutOrScroll(message);
            }
!!!28881847.java!!!	chooseSize(in spec : int, in desired : int, in min : int) : int
            final int mode = View.MeasureSpec.getMode(spec);
            final int size = View.MeasureSpec.getSize(spec);
            switch (mode) {
                case View.MeasureSpec.EXACTLY:
                    return size;
                case View.MeasureSpec.AT_MOST:
                    return Math.min(size, Math.max(desired, min));
                case View.MeasureSpec.UNSPECIFIED:
                default:
                    return Math.max(desired, min);
            }
!!!28881975.java!!!	assertNotInLayoutOrScroll(in message : String) : void
            if (mRecyclerView != null) {
                mRecyclerView.assertNotInLayoutOrScroll(message);
            }
!!!28882103.java!!!	setAutoMeasureEnabled(inout enabled : boolean) : void
            mAutoMeasure = enabled;
!!!28882231.java!!!	isAutoMeasureEnabled() : boolean
            return mAutoMeasure;
!!!28882359.java!!!	supportsPredictiveItemAnimations() : boolean
            return false;
!!!28882487.java!!!	dispatchAttachedToWindow(inout view : RecyclerView) : void
            mIsAttachedToWindow = true;
            onAttachedToWindow(view);
!!!28882615.java!!!	dispatchDetachedFromWindow(inout view : RecyclerView, inout recycler : RecyclerView::Recycler) : void
            mIsAttachedToWindow = false;
            onDetachedFromWindow(view, recycler);
!!!28882743.java!!!	isAttachedToWindow() : boolean
            return mIsAttachedToWindow;
!!!28882871.java!!!	postOnAnimation(inout action : Runnable) : void
            if (mRecyclerView != null) {
                ViewCompat.postOnAnimation(mRecyclerView, action);
            }
!!!28882999.java!!!	removeCallbacks(inout action : Runnable) : boolean
            if (mRecyclerView != null) {
                return mRecyclerView.removeCallbacks(action);
            }
            return false;
!!!28883255.java!!!	onDetachedFromWindow(inout view : RecyclerView) : void

!!!28883383.java!!!	onDetachedFromWindow(inout view : RecyclerView, inout recycler : RecyclerView::Recycler) : void
            onDetachedFromWindow(view);
!!!28883511.java!!!	getClipToPadding() : boolean
            return mRecyclerView != null && mRecyclerView.mClipToPadding;
!!!28883639.java!!!	onLayoutChildren(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : void
            Log.e(TAG, "You must override onLayoutChildren(Recycler recycler, State state) ");
!!!28884023.java!!!	checkLayoutParams(inout lp : ViewGroup::LayoutParams) : boolean
            return lp != null;
!!!28884151.java!!!	generateLayoutParams(inout lp : ViewGroup::LayoutParams) : ViewGroup::LayoutParams
            if (lp instanceof LayoutParams) {
                return new LayoutParams((LayoutParams) lp);
            } else if (lp instanceof MarginLayoutParams) {
                return new LayoutParams((MarginLayoutParams) lp);
            } else {
                return new LayoutParams(lp);
            }
!!!28884279.java!!!	generateLayoutParams(inout c : Context, inout attrs : AttributeSet) : ViewGroup::LayoutParams
            return new LayoutParams(c, attrs);
!!!28884407.java!!!	scrollHorizontallyBy(in dx : int, inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : int
            return 0;
!!!28884535.java!!!	scrollVerticallyBy(in dy : int, inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : int
            return 0;
!!!28884663.java!!!	canScrollHorizontally() : boolean
            return false;
!!!28884791.java!!!	canScrollVertically() : boolean
            return false;
!!!28884919.java!!!	scrollToPosition(in position : int) : void
            if (DEBUG) {
                Log.e(TAG, "You MUST implement scrollToPosition. It will soon become abstract");
            }
!!!28885047.java!!!	smoothScrollToPosition(inout recyclerView : RecyclerView, inout state : RecyclerView::State, in position : int) : void
            Log.e(TAG, "You must override smoothScrollToPosition to support smooth scrolling");
!!!28885175.java!!!	startSmoothScroll(inout smoothScroller : RecyclerView::SmoothScroller) : void
            if (mSmoothScroller != null && smoothScroller != mSmoothScroller
                    && mSmoothScroller.isRunning()) {
                mSmoothScroller.stop();
            }
            mSmoothScroller = smoothScroller;
            mSmoothScroller.start(mRecyclerView, this);
!!!28885303.java!!!	isSmoothScrolling() : boolean
            return mSmoothScroller != null && mSmoothScroller.isRunning();
!!!28885431.java!!!	getLayoutDirection() : int
            return ViewCompat.getLayoutDirection(mRecyclerView);
!!!28885559.java!!!	endAnimation(inout view : View) : void
            if (mRecyclerView.mItemAnimator != null) {
                mRecyclerView.mItemAnimator.endAnimation(getChildViewHolderInt(view));
            }
!!!28885687.java!!!	addDisappearingView(inout child : View) : void
            addDisappearingView(child, -1);
!!!28885815.java!!!	addDisappearingView(inout child : View, in index : int) : void
            addViewInt(child, index, true);
!!!28885943.java!!!	addView(inout child : View) : void
            addView(child, -1);
!!!28886071.java!!!	addView(inout child : View, in index : int) : void
            addViewInt(child, index, false);
!!!28886199.java!!!	addViewInt(inout child : View, in index : int, inout disappearing : boolean) : void
            final ViewHolder holder = getChildViewHolderInt(child);
            if (disappearing || holder.isRemoved()) {
                // these views will be hidden at the end of the layout pass.
                mRecyclerView.mViewInfoStore.addToDisappearedInLayout(holder);
            } else {
                // This may look like unnecessary but may happen if layout manager supports
                // predictive layouts and adapter removed then re-added the same item.
                // In this case, added version will be visible in the post layout (because add is
                // deferred) but RV will still bind it to the same View.
                // So if a View re-appears in post layout pass, remove it from disappearing list.
                mRecyclerView.mViewInfoStore.removeFromDisappearedInLayout(holder);
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            if (holder.wasReturnedFromScrap() || holder.isScrap()) {
                if (holder.isScrap()) {
                    holder.unScrap();
                } else {
                    holder.clearReturnedFromScrapFlag();
                }
                mChildHelper.attachViewToParent(child, index, child.getLayoutParams(), false);
                if (DISPATCH_TEMP_DETACH) {
                    ViewCompat.dispatchFinishTemporaryDetach(child);
                }
            } else if (child.getParent() == mRecyclerView) { // it was not a scrap but a valid child
                // ensure in correct position
                int currentIndex = mChildHelper.indexOfChild(child);
                if (index == -1) {
                    index = mChildHelper.getChildCount();
                }
                if (currentIndex == -1) {
                    throw new IllegalStateException("Added View has RecyclerView as parent but"
                            + " view is not a real child. Unfiltered index:"
                            + mRecyclerView.indexOfChild(child));
                }
                if (currentIndex != index) {
                    mRecyclerView.mLayout.moveView(currentIndex, index);
                }
            } else {
                mChildHelper.addView(child, index, false);
                lp.mInsetsDirty = true;
                if (mSmoothScroller != null && mSmoothScroller.isRunning()) {
                    mSmoothScroller.onChildAttachedToWindow(child);
                }
            }
            if (lp.mPendingInvalidate) {
                if (DEBUG) {
                    Log.d(TAG, "consuming pending invalidate on child " + lp.mViewHolder);
                }
                holder.itemView.invalidate();
                lp.mPendingInvalidate = false;
            }
!!!28886327.java!!!	removeView(inout child : View) : void
            mChildHelper.removeView(child);
!!!28886455.java!!!	removeViewAt(in index : int) : void
            final View child = getChildAt(index);
            if (child != null) {
                mChildHelper.removeViewAt(index);
            }
!!!28886583.java!!!	removeAllViews() : void
            // Only remove non-animating views
            final int childCount = getChildCount();
            for (int i = childCount - 1; i >= 0; i--) {
                mChildHelper.removeViewAt(i);
            }
!!!28886711.java!!!	getBaseline() : int
            return -1;
!!!28886839.java!!!	getPosition(inout view : View) : int
            return ((RecyclerView.LayoutParams) view.getLayoutParams()).getViewLayoutPosition();
!!!28886967.java!!!	getItemViewType(inout view : View) : int
            return getChildViewHolderInt(view).getItemViewType();
!!!28887095.java!!!	findContainingItemView(inout view : View) : View
            if (mRecyclerView == null) {
                return null;
            }
            View found = mRecyclerView.findContainingItemView(view);
            if (found == null) {
                return null;
            }
            if (mChildHelper.isHidden(found)) {
                return null;
            }
            return found;
!!!28887223.java!!!	findViewByPosition(in position : int) : View
            final int childCount = getChildCount();
            for (int i = 0; i < childCount; i++) {
                View child = getChildAt(i);
                ViewHolder vh = getChildViewHolderInt(child);
                if (vh == null) {
                    continue;
                }
                if (vh.getLayoutPosition() == position && !vh.shouldIgnore() &&
                        (mRecyclerView.mState.isPreLayout() || !vh.isRemoved())) {
                    return child;
                }
            }
            return null;
!!!28887351.java!!!	detachView(inout child : View) : void
            final int ind = mChildHelper.indexOfChild(child);
            if (ind >= 0) {
                detachViewInternal(ind, child);
            }
!!!28887479.java!!!	detachViewAt(in index : int) : void
            detachViewInternal(index, getChildAt(index));
!!!28887607.java!!!	detachViewInternal(in index : int, inout view : View) : void
            if (DISPATCH_TEMP_DETACH) {
                ViewCompat.dispatchStartTemporaryDetach(view);
            }
            mChildHelper.detachViewFromParent(index);
!!!28887735.java!!!	attachView(inout child : View, in index : int, inout lp : ViewGroup::LayoutParams) : void
            ViewHolder vh = getChildViewHolderInt(child);
            if (vh.isRemoved()) {
                mRecyclerView.mViewInfoStore.addToDisappearedInLayout(vh);
            } else {
                mRecyclerView.mViewInfoStore.removeFromDisappearedInLayout(vh);
            }
            mChildHelper.attachViewToParent(child, index, lp, vh.isRemoved());
            if (DISPATCH_TEMP_DETACH)  {
                ViewCompat.dispatchFinishTemporaryDetach(child);
            }
!!!28887863.java!!!	attachView(inout child : View, in index : int) : void
            attachView(child, index, (LayoutParams) child.getLayoutParams());
!!!28887991.java!!!	attachView(inout child : View) : void
            attachView(child, -1);
!!!28888119.java!!!	removeDetachedView(inout child : View) : void
            mRecyclerView.removeDetachedView(child, false);
!!!28888247.java!!!	moveView(in fromIndex : int, in toIndex : int) : void
            View view = getChildAt(fromIndex);
            if (view == null) {
                throw new IllegalArgumentException("Cannot move a child from non-existing index:"
                        + fromIndex);
            }
            detachViewAt(fromIndex);
            attachView(view, toIndex);
!!!28888375.java!!!	detachAndScrapView(inout child : View, inout recycler : RecyclerView::Recycler) : void
            int index = mChildHelper.indexOfChild(child);
            scrapOrRecycleView(recycler, index, child);
!!!28888503.java!!!	detachAndScrapViewAt(in index : int, inout recycler : RecyclerView::Recycler) : void
            final View child = getChildAt(index);
            scrapOrRecycleView(recycler, index, child);
!!!28888631.java!!!	removeAndRecycleView(inout child : View, inout recycler : RecyclerView::Recycler) : void
            removeView(child);
            recycler.recycleView(child);
!!!28888759.java!!!	removeAndRecycleViewAt(in index : int, inout recycler : RecyclerView::Recycler) : void
            final View view = getChildAt(index);
            removeViewAt(index);
            recycler.recycleView(view);
!!!28888887.java!!!	getChildCount() : int
            return mChildHelper != null ? mChildHelper.getChildCount() : 0;
!!!28889015.java!!!	getChildAt(in index : int) : View
            return mChildHelper != null ? mChildHelper.getChildAt(index) : null;
!!!28889143.java!!!	getWidthMode() : int
            return mWidthMode;
!!!28889271.java!!!	getHeightMode() : int
            return mHeightMode;
!!!28889399.java!!!	getWidth() : int
            return mWidth;
!!!28889527.java!!!	getHeight() : int
            return mHeight;
!!!28889655.java!!!	getPaddingLeft() : int
            return mRecyclerView != null ? mRecyclerView.getPaddingLeft() : 0;
!!!28889783.java!!!	getPaddingTop() : int
            return mRecyclerView != null ? mRecyclerView.getPaddingTop() : 0;
!!!28889911.java!!!	getPaddingRight() : int
            return mRecyclerView != null ? mRecyclerView.getPaddingRight() : 0;
!!!28890039.java!!!	getPaddingBottom() : int
            return mRecyclerView != null ? mRecyclerView.getPaddingBottom() : 0;
!!!28890167.java!!!	getPaddingStart() : int
            return mRecyclerView != null ? ViewCompat.getPaddingStart(mRecyclerView) : 0;
!!!28890295.java!!!	getPaddingEnd() : int
            return mRecyclerView != null ? ViewCompat.getPaddingEnd(mRecyclerView) : 0;
!!!28890423.java!!!	isFocused() : boolean
            return mRecyclerView != null && mRecyclerView.isFocused();
!!!28890551.java!!!	hasFocus() : boolean
            return mRecyclerView != null && mRecyclerView.hasFocus();
!!!28890679.java!!!	getFocusedChild() : View
            if (mRecyclerView == null) {
                return null;
            }
            final View focused = mRecyclerView.getFocusedChild();
            if (focused == null || mChildHelper.isHidden(focused)) {
                return null;
            }
            return focused;
!!!28890807.java!!!	getItemCount() : int
            final Adapter a = mRecyclerView != null ? mRecyclerView.getAdapter() : null;
            return a != null ? a.getItemCount() : 0;
!!!28890935.java!!!	offsetChildrenHorizontal(in dx : int) : void
            if (mRecyclerView != null) {
                mRecyclerView.offsetChildrenHorizontal(dx);
            }
!!!28891063.java!!!	offsetChildrenVertical(in dy : int) : void
            if (mRecyclerView != null) {
                mRecyclerView.offsetChildrenVertical(dy);
            }
!!!28891191.java!!!	ignoreView(inout view : View) : void
            if (view.getParent() != mRecyclerView || mRecyclerView.indexOfChild(view) == -1) {
                // checking this because calling this method on a recycled or detached view may
                // cause loss of state.
                throw new IllegalArgumentException("View should be fully attached to be ignored");
            }
            final ViewHolder vh = getChildViewHolderInt(view);
            vh.addFlags(ViewHolder.FLAG_IGNORE);
            mRecyclerView.mViewInfoStore.removeViewHolder(vh);
!!!28891319.java!!!	stopIgnoringView(inout view : View) : void
            final ViewHolder vh = getChildViewHolderInt(view);
            vh.stopIgnoring();
            vh.resetInternal();
            vh.addFlags(ViewHolder.FLAG_INVALID);
!!!28891447.java!!!	detachAndScrapAttachedViews(inout recycler : RecyclerView::Recycler) : void
            final int childCount = getChildCount();
            for (int i = childCount - 1; i >= 0; i--) {
                final View v = getChildAt(i);
                scrapOrRecycleView(recycler, i, v);
            }
!!!28891575.java!!!	scrapOrRecycleView(inout recycler : RecyclerView::Recycler, in index : int, inout view : View) : void
            final ViewHolder viewHolder = getChildViewHolderInt(view);
            if (viewHolder.shouldIgnore()) {
                if (DEBUG) {
                    Log.d(TAG, "ignoring view " + viewHolder);
                }
                return;
            }
            if (viewHolder.isInvalid() && !viewHolder.isRemoved() &&
                    !mRecyclerView.mAdapter.hasStableIds()) {
                removeViewAt(index);
                recycler.recycleViewHolderInternal(viewHolder);
            } else {
                detachViewAt(index);
                recycler.scrapView(view);
                mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);
            }
!!!28891703.java!!!	removeAndRecycleScrapInt(inout recycler : RecyclerView::Recycler) : void
            final int scrapCount = recycler.getScrapCount();
            // Loop backward, recycler might be changed by removeDetachedView()
            for (int i = scrapCount - 1; i >= 0; i--) {
                final View scrap = recycler.getScrapViewAt(i);
                final ViewHolder vh = getChildViewHolderInt(scrap);
                if (vh.shouldIgnore()) {
                    continue;
                }
                // If the scrap view is animating, we need to cancel them first. If we cancel it
                // here, ItemAnimator callback may recycle it which will cause double recycling.
                // To avoid this, we mark it as not recycleable before calling the item animator.
                // Since removeDetachedView calls a user API, a common mistake (ending animations on
                // the view) may recycle it too, so we guard it before we call user APIs.
                vh.setIsRecyclable(false);
                if (vh.isTmpDetached()) {
                    mRecyclerView.removeDetachedView(scrap, false);
                }
                if (mRecyclerView.mItemAnimator != null) {
                    mRecyclerView.mItemAnimator.endAnimation(vh);
                }
                vh.setIsRecyclable(true);
                recycler.quickRecycleScrapView(scrap);
            }
            recycler.clearScrap();
            if (scrapCount > 0) {
                mRecyclerView.invalidate();
            }
!!!28891831.java!!!	measureChild(inout child : View, in widthUsed : int, in heightUsed : int) : void
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();

            final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
            widthUsed += insets.left + insets.right;
            heightUsed += insets.top + insets.bottom;
            final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),
                    getPaddingLeft() + getPaddingRight() + widthUsed, lp.width,
                    canScrollHorizontally());
            final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),
                    getPaddingTop() + getPaddingBottom() + heightUsed, lp.height,
                    canScrollVertically());
            if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) {
                child.measure(widthSpec, heightSpec);
            }
!!!28891959.java!!!	shouldReMeasureChild(inout child : View, in widthSpec : int, in heightSpec : int, inout lp : ViewGroup::LayoutParams) : boolean
            return !mMeasurementCacheEnabled
                    || !isMeasurementUpToDate(child.getMeasuredWidth(), widthSpec, lp.width)
                    || !isMeasurementUpToDate(child.getMeasuredHeight(), heightSpec, lp.height);
!!!28892087.java!!!	shouldMeasureChild(inout child : View, in widthSpec : int, in heightSpec : int, inout lp : ViewGroup::LayoutParams) : boolean
            return child.isLayoutRequested()
                    || !mMeasurementCacheEnabled
                    || !isMeasurementUpToDate(child.getWidth(), widthSpec, lp.width)
                    || !isMeasurementUpToDate(child.getHeight(), heightSpec, lp.height);
!!!28892215.java!!!	isMeasurementCacheEnabled() : boolean
            return mMeasurementCacheEnabled;
!!!28892343.java!!!	setMeasurementCacheEnabled(inout measurementCacheEnabled : boolean) : void
            mMeasurementCacheEnabled = measurementCacheEnabled;
!!!28892471.java!!!	isMeasurementUpToDate(in childSize : int, in spec : int, in dimension : int) : boolean
            final int specMode = MeasureSpec.getMode(spec);
            final int specSize = MeasureSpec.getSize(spec);
            if (dimension > 0 && childSize != dimension) {
                return false;
            }
            switch (specMode) {
                case MeasureSpec.UNSPECIFIED:
                    return true;
                case MeasureSpec.AT_MOST:
                    return specSize >= childSize;
                case MeasureSpec.EXACTLY:
                    return  specSize == childSize;
            }
            return false;
!!!28892599.java!!!	measureChildWithMargins(inout child : View, in widthUsed : int, in heightUsed : int) : void
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();

            final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
            widthUsed += insets.left + insets.right;
            heightUsed += insets.top + insets.bottom;

            final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),
                    getPaddingLeft() + getPaddingRight() +
                            lp.leftMargin + lp.rightMargin + widthUsed, lp.width,
                    canScrollHorizontally());
            final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),
                    getPaddingTop() + getPaddingBottom() +
                            lp.topMargin + lp.bottomMargin + heightUsed, lp.height,
                    canScrollVertically());
            if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) {
                child.measure(widthSpec, heightSpec);
            }
!!!28892727.java!!!	getChildMeasureSpec(in parentSize : int, in padding : int, in childDimension : int, inout canScroll : boolean) : int
            int size = Math.max(0, parentSize - padding);
            int resultSize = 0;
            int resultMode = 0;
            if (canScroll) {
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = MeasureSpec.EXACTLY;
                } else {
                    // FILL_PARENT can't be applied since we can scroll in this dimension, wrap
                    // instead using UNSPECIFIED.
                    resultSize = 0;
                    resultMode = MeasureSpec.UNSPECIFIED;
                }
            } else {
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = MeasureSpec.EXACTLY;
                } else if (childDimension == LayoutParams.FILL_PARENT) {
                    resultSize = size;
                    // TODO this should be my spec.
                    resultMode = MeasureSpec.EXACTLY;
                } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                    resultSize = size;
                    resultMode = MeasureSpec.AT_MOST;
                }
            }
            return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
!!!28892855.java!!!	getChildMeasureSpec(in parentSize : int, in parentMode : int, in padding : int, in childDimension : int, inout canScroll : boolean) : int
            int size = Math.max(0, parentSize - padding);
            int resultSize = 0;
            int resultMode = 0;
            if (canScroll) {
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = MeasureSpec.EXACTLY;
                } else if (childDimension == LayoutParams.FILL_PARENT){
                    switch (parentMode) {
                        case MeasureSpec.AT_MOST:
                        case MeasureSpec.EXACTLY:
                            resultSize = size;
                            resultMode = parentMode;
                            break;
                        case MeasureSpec.UNSPECIFIED:
                            resultSize = 0;
                            resultMode = MeasureSpec.UNSPECIFIED;
                            break;
                    }
                } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                    resultSize = 0;
                    resultMode = MeasureSpec.UNSPECIFIED;
                }
            } else {
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = MeasureSpec.EXACTLY;
                } else if (childDimension == LayoutParams.FILL_PARENT) {
                    resultSize = size;
                    resultMode = parentMode;
                } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                    resultSize = size;
                    if (parentMode == MeasureSpec.AT_MOST || parentMode == MeasureSpec.EXACTLY) {
                        resultMode = MeasureSpec.AT_MOST;
                    } else {
                        resultMode = MeasureSpec.UNSPECIFIED;
                    }

                }
            }
            //noinspection WrongConstant
            return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
!!!28892983.java!!!	getDecoratedMeasuredWidth(inout child : View) : int
            final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
            return child.getMeasuredWidth() + insets.left + insets.right;
!!!28893111.java!!!	getDecoratedMeasuredHeight(inout child : View) : int
            final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
            return child.getMeasuredHeight() + insets.top + insets.bottom;
!!!28893239.java!!!	layoutDecorated(inout child : View, in left : int, in top : int, in right : int, in bottom : int) : void
            final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
            child.layout(left + insets.left, top + insets.top, right - insets.right,
                    bottom - insets.bottom);
!!!28893367.java!!!	layoutDecoratedWithMargins(inout child : View, in left : int, in top : int, in right : int, in bottom : int) : void
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final Rect insets = lp.mDecorInsets;
            child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,
                    right - insets.right - lp.rightMargin,
                    bottom - insets.bottom - lp.bottomMargin);
!!!28893495.java!!!	getTransformedBoundingBox(inout child : View, inout includeDecorInsets : boolean, inout out : Rect) : void
            if (includeDecorInsets) {
                Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
                out.set(-insets.left, -insets.top,
                        child.getWidth() + insets.right, child.getHeight() + insets.bottom);
            } else {
                out.set(0, 0, child.getWidth(), child.getHeight());
            }

            if (mRecyclerView != null) {
                final Matrix childMatrix = ViewCompat.getMatrix(child);
                if (childMatrix != null && !childMatrix.isIdentity()) {
                    final RectF tempRectF = mRecyclerView.mTempRectF;
                    tempRectF.set(out);
                    childMatrix.mapRect(tempRectF);
                    out.set(
                            (int) Math.floor(tempRectF.left),
                            (int) Math.floor(tempRectF.top),
                            (int) Math.ceil(tempRectF.right),
                            (int) Math.ceil(tempRectF.bottom)
                    );
                }
            }
            out.offset(child.getLeft(), child.getTop());
!!!28893623.java!!!	getDecoratedBoundsWithMargins(inout view : View, inout outBounds : Rect) : void
            final LayoutParams lp = (LayoutParams) view.getLayoutParams();
            final Rect insets = lp.mDecorInsets;
            outBounds.set(view.getLeft() - insets.left - lp.leftMargin,
                    view.getTop() - insets.top - lp.topMargin,
                    view.getRight() + insets.right + lp.rightMargin,
                    view.getBottom() + insets.bottom + lp.bottomMargin);
!!!28893751.java!!!	getDecoratedLeft(inout child : View) : int
            return child.getLeft() - getLeftDecorationWidth(child);
!!!28893879.java!!!	getDecoratedTop(inout child : View) : int
            return child.getTop() - getTopDecorationHeight(child);
!!!28894007.java!!!	getDecoratedRight(inout child : View) : int
            return child.getRight() + getRightDecorationWidth(child);
!!!28894135.java!!!	getDecoratedBottom(inout child : View) : int
            return child.getBottom() + getBottomDecorationHeight(child);
!!!28894263.java!!!	calculateItemDecorationsForChild(inout child : View, inout outRect : Rect) : void
            if (mRecyclerView == null) {
                outRect.set(0, 0, 0, 0);
                return;
            }
            Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
            outRect.set(insets);
!!!28894391.java!!!	getTopDecorationHeight(inout child : View) : int
            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.top;
!!!28894519.java!!!	getBottomDecorationHeight(inout child : View) : int
            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.bottom;
!!!28894647.java!!!	getLeftDecorationWidth(inout child : View) : int
            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.left;
!!!28894775.java!!!	getRightDecorationWidth(inout child : View) : int
            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.right;
!!!28894903.java!!!	onFocusSearchFailed(inout focused : View, in direction : int, inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : View
            return null;
!!!28895031.java!!!	onInterceptFocusSearch(inout focused : View, in direction : int) : View
            return null;
!!!28895159.java!!!	requestChildRectangleOnScreen(inout parent : RecyclerView, inout child : View, inout rect : Rect, inout immediate : boolean) : boolean
            final int parentLeft = getPaddingLeft();
            final int parentTop = getPaddingTop();
            final int parentRight = getWidth() - getPaddingRight();
            final int parentBottom = getHeight() - getPaddingBottom();
            final int childLeft = child.getLeft() + rect.left - child.getScrollX();
            final int childTop = child.getTop() + rect.top - child.getScrollY();
            final int childRight = childLeft + rect.width();
            final int childBottom = childTop + rect.height();

            final int offScreenLeft = Math.min(0, childLeft - parentLeft);
            final int offScreenTop = Math.min(0, childTop - parentTop);
            final int offScreenRight = Math.max(0, childRight - parentRight);
            final int offScreenBottom = Math.max(0, childBottom - parentBottom);

            // Favor the "start" layout direction over the end when bringing one side or the other
            // of a large rect into view. If we decide to bring in end because start is already
            // visible, limit the scroll such that start won't go out of bounds.
            final int dx;
            if (getLayoutDirection() == ViewCompat.LAYOUT_DIRECTION_RTL) {
                dx = offScreenRight != 0 ? offScreenRight
                        : Math.max(offScreenLeft, childRight - parentRight);
            } else {
                dx = offScreenLeft != 0 ? offScreenLeft
                        : Math.min(childLeft - parentLeft, offScreenRight);
            }

            // Favor bringing the top into view over the bottom. If top is already visible and
            // we should scroll to make bottom visible, make sure top does not go out of bounds.
            final int dy = offScreenTop != 0 ? offScreenTop
                    : Math.min(childTop - parentTop, offScreenBottom);

            if (dx != 0 || dy != 0) {
                if (immediate) {
                    parent.scrollBy(dx, dy);
                } else {
                    parent.smoothScrollBy(dx, dy);
                }
                return true;
            }
            return false;
!!!28895287.java!!!	onRequestChildFocus(inout parent : RecyclerView, inout child : View, inout focused : View) : boolean
            // eat the request if we are in the middle of a scroll or layout
            return isSmoothScrolling() || parent.isComputingLayout();
!!!28895415.java!!!	onRequestChildFocus(inout parent : RecyclerView, inout state : RecyclerView::State, inout child : View, inout focused : View) : boolean
            return onRequestChildFocus(parent, child, focused);
!!!28895671.java!!!	onAddFocusables(inout recyclerView : RecyclerView, inout views : ArrayList<View>, in direction : int, in focusableMode : int) : boolean
            return false;
!!!28896311.java!!!	onItemsUpdated(inout recyclerView : RecyclerView, in positionStart : int, in itemCount : int, inout payload : Object) : void
            onItemsUpdated(recyclerView, positionStart, itemCount);
!!!28896439.java!!!	onItemsMoved(inout recyclerView : RecyclerView, in from : int, in to : int, in itemCount : int) : void

!!!28896567.java!!!	computeHorizontalScrollExtent(inout state : RecyclerView::State) : int
            return 0;
!!!28896695.java!!!	computeHorizontalScrollOffset(inout state : RecyclerView::State) : int
            return 0;
!!!28896823.java!!!	computeHorizontalScrollRange(inout state : RecyclerView::State) : int
            return 0;
!!!28896951.java!!!	computeVerticalScrollExtent(inout state : RecyclerView::State) : int
            return 0;
!!!28897079.java!!!	computeVerticalScrollOffset(inout state : RecyclerView::State) : int
            return 0;
!!!28897207.java!!!	computeVerticalScrollRange(inout state : RecyclerView::State) : int
            return 0;
!!!28897335.java!!!	onMeasure(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, in widthSpec : int, in heightSpec : int) : void
            mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);
!!!28897463.java!!!	setMeasuredDimension(in widthSize : int, in heightSize : int) : void
            mRecyclerView.setMeasuredDimension(widthSize, heightSize);
!!!28897591.java!!!	getMinimumWidth() : int
            return ViewCompat.getMinimumWidth(mRecyclerView);
!!!28897719.java!!!	getMinimumHeight() : int
            return ViewCompat.getMinimumHeight(mRecyclerView);
!!!28897847.java!!!	onSaveInstanceState() : Parcelable
            return null;
!!!28897975.java!!!	onRestoreInstanceState(inout state : Parcelable) : void

!!!28898103.java!!!	stopSmoothScroller() : void
            if (mSmoothScroller != null) {
                mSmoothScroller.stop();
            }
!!!28898231.java!!!	onSmoothScrollerStopped(inout smoothScroller : RecyclerView::SmoothScroller) : void
            if (mSmoothScroller == smoothScroller) {
                mSmoothScroller = null;
            }
!!!28898487.java!!!	removeAndRecycleAllViews(inout recycler : RecyclerView::Recycler) : void
            for (int i = getChildCount() - 1; i >= 0; i--) {
                final View view = getChildAt(i);
                if (!getChildViewHolderInt(view).shouldIgnore()) {
                    removeAndRecycleViewAt(i, recycler);
                }
            }
!!!28898615.java!!!	onInitializeAccessibilityNodeInfo(inout info : AccessibilityNodeInfoCompat) : void
            onInitializeAccessibilityNodeInfo(mRecyclerView.mRecycler, mRecyclerView.mState, info);
!!!28898743.java!!!	onInitializeAccessibilityNodeInfo(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, inout info : AccessibilityNodeInfoCompat) : void
            if (ViewCompat.canScrollVertically(mRecyclerView, -1) ||
                    ViewCompat.canScrollHorizontally(mRecyclerView, -1)) {
                info.addAction(AccessibilityNodeInfoCompat.ACTION_SCROLL_BACKWARD);
                info.setScrollable(true);
            }
            if (ViewCompat.canScrollVertically(mRecyclerView, 1) ||
                    ViewCompat.canScrollHorizontally(mRecyclerView, 1)) {
                info.addAction(AccessibilityNodeInfoCompat.ACTION_SCROLL_FORWARD);
                info.setScrollable(true);
            }
            final AccessibilityNodeInfoCompat.CollectionInfoCompat collectionInfo
                    = AccessibilityNodeInfoCompat.CollectionInfoCompat
                    .obtain(getRowCountForAccessibility(recycler, state),
                            getColumnCountForAccessibility(recycler, state),
                            isLayoutHierarchical(recycler, state),
                            getSelectionModeForAccessibility(recycler, state));
            info.setCollectionInfo(collectionInfo);
!!!28898871.java!!!	onInitializeAccessibilityEvent(inout event : AccessibilityEvent) : void
            onInitializeAccessibilityEvent(mRecyclerView.mRecycler, mRecyclerView.mState, event);
!!!28898999.java!!!	onInitializeAccessibilityEvent(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, inout event : AccessibilityEvent) : void
            final AccessibilityRecordCompat record = AccessibilityEventCompat
                    .asRecord(event);
            if (mRecyclerView == null || record == null) {
                return;
            }
            record.setScrollable(ViewCompat.canScrollVertically(mRecyclerView, 1)
                    || ViewCompat.canScrollVertically(mRecyclerView, -1)
                    || ViewCompat.canScrollHorizontally(mRecyclerView, -1)
                    || ViewCompat.canScrollHorizontally(mRecyclerView, 1));

            if (mRecyclerView.mAdapter != null) {
                record.setItemCount(mRecyclerView.mAdapter.getItemCount());
            }
!!!28899127.java!!!	onInitializeAccessibilityNodeInfoForItem(inout host : View, inout info : AccessibilityNodeInfoCompat) : void
            final ViewHolder vh = getChildViewHolderInt(host);
            // avoid trying to create accessibility node info for removed children
            if (vh != null && !vh.isRemoved() && !mChildHelper.isHidden(vh.itemView)) {
                onInitializeAccessibilityNodeInfoForItem(mRecyclerView.mRecycler,
                        mRecyclerView.mState, host, info);
            }
!!!28899255.java!!!	onInitializeAccessibilityNodeInfoForItem(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, inout host : View, inout info : AccessibilityNodeInfoCompat) : void
            int rowIndexGuess = canScrollVertically() ? getPosition(host) : 0;
            int columnIndexGuess = canScrollHorizontally() ? getPosition(host) : 0;
            final AccessibilityNodeInfoCompat.CollectionItemInfoCompat itemInfo
                    = AccessibilityNodeInfoCompat.CollectionItemInfoCompat.obtain(rowIndexGuess, 1,
                    columnIndexGuess, 1, false, false);
            info.setCollectionItemInfo(itemInfo);
!!!28899383.java!!!	requestSimpleAnimationsInNextLayout() : void
            mRequestedSimpleAnimations = true;
!!!28899511.java!!!	getSelectionModeForAccessibility(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : int
            return AccessibilityNodeInfoCompat.CollectionInfoCompat.SELECTION_MODE_NONE;
!!!28899639.java!!!	getRowCountForAccessibility(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : int
            if (mRecyclerView == null || mRecyclerView.mAdapter == null) {
                return 1;
            }
            return canScrollVertically() ? mRecyclerView.mAdapter.getItemCount() : 1;
!!!28899767.java!!!	getColumnCountForAccessibility(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : int
            if (mRecyclerView == null || mRecyclerView.mAdapter == null) {
                return 1;
            }
            return canScrollHorizontally() ? mRecyclerView.mAdapter.getItemCount() : 1;
!!!28899895.java!!!	isLayoutHierarchical(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : boolean
            return false;
!!!28900023.java!!!	performAccessibilityAction(in action : int, inout args : Bundle) : boolean
            return performAccessibilityAction(mRecyclerView.mRecycler, mRecyclerView.mState,
                    action, args);
!!!28900151.java!!!	performAccessibilityAction(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, in action : int, inout args : Bundle) : boolean
            if (mRecyclerView == null) {
                return false;
            }
            int vScroll = 0, hScroll = 0;
            switch (action) {
                case AccessibilityNodeInfoCompat.ACTION_SCROLL_BACKWARD:
                    if (ViewCompat.canScrollVertically(mRecyclerView, -1)) {
                        vScroll = -(getHeight() - getPaddingTop() - getPaddingBottom());
                    }
                    if (ViewCompat.canScrollHorizontally(mRecyclerView, -1)) {
                        hScroll = -(getWidth() - getPaddingLeft() - getPaddingRight());
                    }
                    break;
                case AccessibilityNodeInfoCompat.ACTION_SCROLL_FORWARD:
                    if (ViewCompat.canScrollVertically(mRecyclerView, 1)) {
                        vScroll = getHeight() - getPaddingTop() - getPaddingBottom();
                    }
                    if (ViewCompat.canScrollHorizontally(mRecyclerView, 1)) {
                        hScroll = getWidth() - getPaddingLeft() - getPaddingRight();
                    }
                    break;
            }
            if (vScroll == 0 && hScroll == 0) {
                return false;
            }
            mRecyclerView.scrollBy(hScroll, vScroll);
            return true;
!!!28900279.java!!!	performAccessibilityActionForItem(inout view : View, in action : int, inout args : Bundle) : boolean
            return performAccessibilityActionForItem(mRecyclerView.mRecycler, mRecyclerView.mState,
                    view, action, args);
!!!28900407.java!!!	performAccessibilityActionForItem(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, inout view : View, in action : int, inout args : Bundle) : boolean
            return false;
!!!28900535.java!!!	getProperties(inout context : Context, inout attrs : AttributeSet, in defStyleAttr : int, in defStyleRes : int) : RecyclerView::LayoutManager::Properties
            Properties properties = new Properties();
            TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,
                    defStyleAttr, defStyleRes);
            properties.orientation = a.getInt(R.styleable.RecyclerView_android_orientation, VERTICAL);
            properties.spanCount = a.getInt(R.styleable.RecyclerView_spanCount, 1);
            properties.reverseLayout = a.getBoolean(R.styleable.RecyclerView_reverseLayout, false);
            properties.stackFromEnd = a.getBoolean(R.styleable.RecyclerView_stackFromEnd, false);
            a.recycle();
            return properties;
!!!28900663.java!!!	setExactMeasureSpecsFrom(inout recyclerView : RecyclerView) : void
            setMeasureSpecs(
                    MeasureSpec.makeMeasureSpec(recyclerView.getWidth(), MeasureSpec.EXACTLY),
                    MeasureSpec.makeMeasureSpec(recyclerView.getHeight(), MeasureSpec.EXACTLY)
            );
!!!28900791.java!!!	shouldMeasureTwice() : boolean
            return false;
!!!28900919.java!!!	hasFlexibleChildInBothOrientations() : boolean
            final int childCount = getChildCount();
            for (int i = 0; i < childCount; i++) {
                final View child = getChildAt(i);
                final ViewGroup.LayoutParams lp = child.getLayoutParams();
                if (lp.width < 0 && lp.height < 0) {
                    return true;
                }
            }
            return false;
