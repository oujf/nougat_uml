format 213
"camera2" // android::frameworks::base::core::java::android::hardware::camera2
  revision 4
  modified_by 55 "Jeff"
  // class settings
  
  classdiagramsettings member_max_width 0 end
  
  usecasediagramsettings end
  
  sequencediagramsettings end
  
  collaborationdiagramsettings end
  
  objectdiagramsettings end
  
  componentdiagramsettings
   end
  
  deploymentdiagramsettings
   end
  
  statediagramsettings
   end
  
  activitydiagramsettings
   end
  
  java_dir "D:\\Workspace\\AndroidSourceCode\\nougat_src\\frameworks/base/core/java/android/hardware/camera2/"
  java_package "android.hardware.camera2"
  classview 142007 "camera2"
    
    classdiagramsettings member_max_width 0 end
    
    collaborationdiagramsettings end
    
    objectdiagramsettings end
    
    sequencediagramsettings end
    
    statediagramsettings
     end
    
    
    activitydiagramsettings
     end
    class 7147319 "CameraAccessException"
      visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "<p><code>CameraAccessException</code> is thrown if a camera device could not
be queried or opened by the {@link CameraManager}, or if the connection to an
opened {@link CameraDevice} is no longer valid.</p>

@see CameraManager
@see CameraDevice
"
      classrelation 15648695 // <generalisation>
	relation 15648695 ---|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 15648695 // <generalisation>
	  b parent class_ref 7007287 // AndroidException
      end

      attribute 24772279 "CAMERA_IN_USE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "The camera device is in use already.

"
      end

      attribute 24772407 "MAX_CAMERAS_IN_USE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 5"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "The system-wide limit for number of open cameras or camera resources has
been reached, and more camera devices cannot be opened or torch mode
cannot be turned on until previous instances are closed.

"
      end

      attribute 24772535 "CAMERA_DISABLED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "The camera is disabled due to a device policy, and cannot be opened.

@see android.app.admin.DevicePolicyManager#setCameraDisabled(android.content.ComponentName, boolean)

"
      end

      attribute 24772663 "CAMERA_DISCONNECTED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "The camera device is removable and has been disconnected from the Android
device, or the camera id used with {@link android.hardware.camera2.CameraManager#openCamera}
is no longer valid, or the camera service has shut down the connection due to a
higher-priority access request for the camera device.

"
      end

      attribute 24772791 "CAMERA_ERROR"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "The camera device is currently in the error state.

<p>The camera has failed to open or has failed at a later time
as a result of some non-user interaction. Refer to
{@link CameraDevice.StateCallback#onError} for the exact
nature of the error.</p>

<p>No further calls to the camera will succeed. Clean up
the camera with {@link CameraDevice#close} and try
handling the error in order to successfully re-open the camera.
</p>


"
      end

      attribute 24772919 "CAMERA_DEPRECATED_HAL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1000"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "A deprecated HAL version is in use.
@hide

"
      end

      class 7147447 "AccessError"
	visibility public stereotype "@interface"
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl "${comment}${@}${visibility}${static}@interface ${name}${extends} {
${members}}
"
	java_annotation "@Retention(RetentionPolicy.SOURCE)
@IntDef(
         {CAMERA_IN_USE,
          MAX_CAMERAS_IN_USE,
          CAMERA_DISABLED,
          CAMERA_DISCONNECTED,
          CAMERA_ERROR})
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
      end

      attribute 24773047 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 5630338637471475675L"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Make the eclipse warning about serializable exceptions go away
 randomly generated"
      end

      attribute 24773175 "mReason"
	const_attribute private explicit_type "int"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 79317047 "getReason"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@AccessError
"
	
	
	
	comment "The reason for the failure to access the camera.

@see #CAMERA_DISABLED
@see #CAMERA_DISCONNECTED
@see #CAMERA_ERROR
"
      end

      operation 79317175 "CameraAccessException"
	public explicit_return_type ""
	nparams 1
	  param in name "problem" explicit_type "int"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}@AccessError ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 79317303 "CameraAccessException"
	public explicit_return_type ""
	nparams 2
	  param in name "problem" explicit_type "int"
	  param inout name "message" explicit_type "String"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}@AccessError ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 79317431 "CameraAccessException"
	public explicit_return_type ""
	nparams 3
	  param in name "problem" explicit_type "int"
	  param inout name "message" explicit_type "String"
	  param inout name "cause" explicit_type "Throwable"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}@AccessError ${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 79317559 "CameraAccessException"
	public explicit_return_type ""
	nparams 2
	  param in name "problem" explicit_type "int"
	  param inout name "cause" explicit_type "Throwable"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}@AccessError ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 79317687 "getDefaultMessage"
	class_operation public explicit_return_type "String"
	nparams 1
	  param in name "problem" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@AccessError ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@hide
"
      end

      operation 79317815 "getCombinedMessage"
	class_operation private explicit_return_type "String"
	nparams 2
	  param in name "problem" explicit_type "int"
	  param inout name "message" explicit_type "String"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@AccessError ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 79317943 "getProblemString"
	class_operation private explicit_return_type "String"
	nparams 1
	  param in name "problem" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end
    end

    class 7147575 "CameraCaptureSession"
      abstract visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A configured capture session for a {@link CameraDevice}, used for capturing images from the
camera or reprocessing images captured from the camera in the same session previously.

<p>A CameraCaptureSession is created by providing a set of target output surfaces to
{@link CameraDevice#createCaptureSession createCaptureSession}, or by providing an
{@link android.hardware.camera2.params.InputConfiguration} and a set of target output surfaces to
{@link CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession} for a
reprocessable capture session. Once created, the session is active until a new session is
created by the camera device, or the camera device is closed.</p>

<p>All capture sessions can be used for capturing images from the camera but only reprocessable
capture sessions can reprocess images captured from the camera in the same session previously.
</p>

<p>Creating a session is an expensive operation and can take several hundred milliseconds, since
it requires configuring the camera device's internal pipelines and allocating memory buffers for
sending images to the desired targets. Therefore the setup is done asynchronously, and
{@link CameraDevice#createCaptureSession createCaptureSession} and
{@link CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession} will
send the ready-to-use CameraCaptureSession to the provided listener's
{@link CameraCaptureSession.StateCallback#onConfigured onConfigured} callback. If configuration
cannot be completed, then the
{@link CameraCaptureSession.StateCallback#onConfigureFailed onConfigureFailed} is called, and the
session will not become active.</p>
<!--
<p>Any capture requests (repeating or non-repeating) submitted before the session is ready will
be queued up and will begin capture once the session becomes ready. In case the session cannot be
configured and {@link StateCallback#onConfigureFailed onConfigureFailed} is called, all queued
capture requests are discarded.</p>
-->
<p>If a new session is created by the camera device, then the previous session is closed, and its
associated {@link StateCallback#onClosed onClosed} callback will be invoked.  All
of the session methods will throw an IllegalStateException if called once the session is
closed.</p>

<p>A closed session clears any repeating requests (as if {@link #stopRepeating} had been called),
but will still complete all of its in-progress capture requests as normal, before a newly
created session takes over and reconfigures the camera device.</p>
"
      attribute 24773303 "SESSION_ID_NONE"
	class_attribute const_attribute public explicit_type "int"
	init_value " -1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Used to identify invalid session ID.
@hide

"
      end

      operation 79318071 "getDevice"
	abstract public return_type class_ref 7147703 // CameraDevice
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Get the camera device that this session is created for.
"
      end

      operation 79318199 "prepare"
	abstract public explicit_return_type "void"
	nparams 1
	  param inout name "surface" type class_ref 6952247 // Surface
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "<p>Pre-allocate all buffers for an output Surface.</p>

<p>Normally, the image buffers for a given output Surface are allocated on-demand,
to minimize startup latency and memory overhead.</p>

<p>However, in some cases, it may be desirable for the buffers to be allocated before
any requests targeting the Surface are actually submitted to the device. Large buffers
may take some time to allocate, which can result in delays in submitting requests until
sufficient buffers are allocated to reach steady-state behavior. Such delays can cause
bursts to take longer than desired, or cause skips or stutters in preview output.</p>

<p>The prepare() method can be used to perform this preallocation. It may only be called for
a given output Surface before that Surface is used as a target for a request. The number of
buffers allocated is the sum of the count needed by the consumer providing the output
Surface, and the maximum number needed by the camera device to fill its pipeline. Since this
may be a larger number than what is actually required for steady-state operation, using
prepare may result in higher memory consumption than the normal on-demand behavior results
in. Prepare() will also delay the time to first output to a given Surface, in exchange for
smoother frame rate once the allocation is complete.</p>

<p>For example, an application that creates an
{@link android.media.ImageReader#newInstance ImageReader} with a maxImages argument of 10,
but only uses 3 simultaneous Images at once would normally only cause those 3 images to be
allocated (plus what is needed by the camera device for smooth operation).  But using
prepare() on the ImageReader Surface will result in all 10 Images being allocated. So
applications using this method should take care to request only the number of buffers
actually necessary for their application.</p>

<p>If the same output Surface is used in consecutive sessions (without closing the first
session explicitly), then its already-allocated buffers are carried over, and if it was
used as a target of a capture request in the first session, prepare cannot be called on it
in the second session.</p>

<p>Once allocation is complete, {@link StateCallback#onSurfacePrepared} will be invoked with
the Surface provided to this method. Between the prepare call and the onSurfacePrepared call,
the Surface provided to prepare must not be used as a target of a CaptureRequest submitted
to this session.</p>

<p>{@link android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY}
devices cannot pre-allocate output buffers; for those devices,
{@link StateCallback#onSurfacePrepared} will be immediately called, and no preallocation is
done.</p>

@param surface the output Surface for which buffers should be pre-allocated. Must be one of
the output Surfaces used to create this session.

@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                              was explicitly closed, a new session has been created
                              or the camera device has been closed.
@throws IllegalArgumentException if the Surface is invalid, not part of this Session, or has
                                 already been used as a target of a CaptureRequest in this
                                 session or immediately prior sessions.

@see StateCallback#onSurfacePrepared
"
      end

      operation 79318327 "prepare"
	abstract public explicit_return_type "void"
	nparams 2
	  param in name "maxCount" explicit_type "int"
	  param inout name "surface" type class_ref 6952247 // Surface
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, @NonNull ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "<p>Pre-allocate at most maxCount buffers for an output Surface.</p>

<p>Like the {@link #prepare(Surface)} method, this method can be used to allocate output
buffers for a given Surface.  However, while the {@link #prepare(Surface)} method allocates
the maximum possible buffer count, this method allocates at most maxCount buffers.</p>

<p>If maxCount is greater than the possible maximum count (which is the sum of the buffer
count requested by the creator of the Surface and the count requested by the camera device),
only the possible maximum count is allocated, in which case the function acts exactly like
{@link #prepare(Surface)}.</p>

<p>The restrictions on when this method can be called are the same as for
{@link #prepare(Surface)}.</p>

<p>Repeated calls to this method are allowed, and a mix of {@link #prepare(Surface)} and
this method is also allowed. Note that after the first call to {@link #prepare(Surface)},
subsequent calls to either prepare method are effectively no-ops.  In addition, this method
is not additive in terms of buffer count.  This means calling it twice with maxCount = 2
will only allocate 2 buffers, not 4 (assuming the possible maximum is at least 2); to
allocate two buffers on the first call and two on the second, the application needs to call
prepare with prepare(surface, 2) and prepare(surface, 4).</p>

@param maxCount the buffer count to try to allocate. If this is greater than the possible
                maximum for this output, the possible maximum is allocated instead. If
                maxCount buffers are already allocated, then prepare will do nothing.
@param surface the output Surface for which buffers should be pre-allocated.

@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error.
@throws IllegalStateException if this session is no longer active, either because the
                              session was explicitly closed, a new session has been created
                              or the camera device has been closed.
@throws IllegalArgumentException if the Surface is invalid, not part of this Session,
                                 or has already been used as a target of a CaptureRequest in
                                 this session or immediately prior sessions without an
                                 intervening tearDown call.

@hide
"
      end

      operation 79318455 "tearDown"
	abstract public explicit_return_type "void"
	nparams 1
	  param inout name "surface" type class_ref 6952247 // Surface
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "<p>Free all buffers allocated for an output Surface.</p>

<p>Normally, once allocated, the image buffers for a given output Surface remain allocated
for the lifetime of the capture session, to minimize latency of captures and to reduce
memory allocation overhead.</p>

<p>However, in some cases, it may be desirable for allocated buffers to be freed to reduce
the application's memory consumption, if the particular output Surface will not be used by
the application for some time.</p>

<p>The tearDown() method can be used to perform this operation. After the call finishes, all
unfilled image buffers will have been freed. Any future use of the target Surface may require
allocation of additional buffers, as if the session had just been created.  Buffers being
held by the application (either explicitly as Image objects from ImageReader, or implicitly
as the current texture in a SurfaceTexture or the current contents of a RS Allocation, will
remain valid and allocated even when tearDown is invoked.</p>

<p>A Surface that has had tearDown() called on it is eligible to have prepare() invoked on it
again even if it was used as a request target before the tearDown() call, as long as it
doesn't get used as a target of a request between the tearDown() and prepare() calls.</p>

@param surface the output Surface for which buffers should be freed. Must be one of the
the output Surfaces used to create this session.

@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error.
@throws IllegalStateException if this session is no longer active, either because the session
                              was explicitly closed, a new session has been created
                              or the camera device has been closed.
@throws IllegalArgumentException if the Surface is invalid, not part of this Session, or has
                                 already been used as a target of a CaptureRequest in this
                                 session or immediately prior sessions.

@hide
"
      end

      operation 79318583 "capture"
	abstract public explicit_return_type "int"
	nparams 3
	  param inout name "request" type class_ref 7147831 // CaptureRequest
	  param inout name "listener" type class_ref 7147959 // CaptureCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @Nullable ${t1} ${p1}, @Nullable ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "<p>Submit a request for an image to be captured by the camera device.</p>

<p>The request defines all the parameters for capturing the single image,
including sensor, lens, flash, and post-processing settings.</p>

<p>Each request will produce one {@link CaptureResult} and produce new frames for one or more
target Surfaces, set with the CaptureRequest builder's
{@link CaptureRequest.Builder#addTarget} method. The target surfaces (set with
{@link CaptureRequest.Builder#addTarget}) must be a subset of the surfaces provided when this
capture session was created.</p>

<p>Multiple regular and reprocess requests can be in progress at once. If there are only
regular requests or reprocess requests in progress, they are processed in first-in,
first-out order. If there are both regular and reprocess requests in progress, regular
requests are processed in first-in, first-out order and reprocess requests are processed in
first-in, first-out order, respectively. However, the processing order of a regular request
and a reprocess request in progress is not specified. In other words, a regular request
will always be processed before regular requets that are submitted later. A reprocess request
will always be processed before reprocess requests that are submitted later. However, a
regular request may not be processed before reprocess requests that are submitted later.<p>

<p>Requests submitted through this method have higher priority than
those submitted through {@link #setRepeatingRequest} or
{@link #setRepeatingBurst}, and will be processed as soon as the current
repeat/repeatBurst processing completes.</p>

<p>All capture sessions can be used for capturing images from the camera but only capture
sessions created by
{@link CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession}
can submit reprocess capture requests. Submitting a reprocess request to a regular capture
session will result in an {@link IllegalArgumentException}.</p>

@param request the settings for this capture
@param listener The callback object to notify once this request has been
processed. If null, no metadata will be produced for this capture,
although image data will still be produced.
@param handler the handler on which the listener should be invoked, or
{@code null} to use the current thread's {@link android.os.Looper
looper}.

@return int A unique capture sequence ID used by
            {@link CaptureCallback#onCaptureSequenceCompleted}.

@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                              was explicitly closed, a new session has been created
                              or the camera device has been closed.
@throws IllegalArgumentException if the request targets no Surfaces or Surfaces that are not
                                 configured as outputs for this session; or the request
                                 targets a set of Surfaces that cannot be submitted
                                 simultaneously in a reprocessable capture session; or a
                                 reprocess capture request is submitted in a
                                 non-reprocessable capture session; or the reprocess capture
                                 request was created with a {@link TotalCaptureResult} from
                                 a different session; or the capture targets a Surface in
                                 the middle of being {@link #prepare prepared}; or the
                                 handler is null, the listener is not null, and the calling
                                 thread has no looper.

@see #captureBurst
@see #setRepeatingRequest
@see #setRepeatingBurst
@see #abortCaptures
@see CameraDevice#createReprocessableCaptureSession
"
      end

      class 7147959 "CaptureCallback"
	abstract visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	attribute 24773431 "NO_FRAMES_CAPTURED"
	  class_attribute const_attribute public explicit_type "int"
	  init_value " -1"
	  cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "This constant is used to indicate that no images were captured for
the request.

@hide

"
	end

	operation 79320503 "onCaptureStarted"
	  public explicit_return_type "void"
	  nparams 4
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	    param inout name "request" type class_ref 7147831 // CaptureRequest
	    param in name "timestamp" explicit_type "long"
	    param in name "frameNumber" explicit_type "long"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called when the camera device has started capturing
the output image for the request, at the beginning of image exposure, or
when the camera device has started processing an input image for a reprocess
request.

<p>For a regular capture request, this callback is invoked right as
the capture of a frame begins, so it is the most appropriate time
for playing a shutter sound, or triggering UI indicators of capture.</p>

<p>The request that is being used for this capture is provided, along
with the actual timestamp for the start of exposure. For a reprocess
request, this timestamp will be the input image's start of exposure
which matches {@link CaptureResult#SENSOR_TIMESTAMP the result timestamp field}
of the {@link TotalCaptureResult} that was used to
{@link CameraDevice#createReprocessCaptureRequest create the reprocess request}.
This timestamp matches the timestamps that will be
included in {@link CaptureResult#SENSOR_TIMESTAMP the result timestamp field},
and in the buffers sent to each output Surface. These buffer
timestamps are accessible through, for example,
{@link android.media.Image#getTimestamp() Image.getTimestamp()} or
{@link android.graphics.SurfaceTexture#getTimestamp()}.
The frame number included is equal to the frame number that will be included in
{@link CaptureResult#getFrameNumber}.</p>

<p>For the simplest way to play a shutter sound camera shutter or a
video recording start/stop sound, see the
{@link android.media.MediaActionSound} class.</p>

<p>The default implementation of this method does nothing.</p>

@param session the session returned by {@link CameraDevice#createCaptureSession}
@param request the request for the capture that just begun
@param timestamp the timestamp at start of capture for a regular request, or
                 the timestamp at the input image's start of capture for a
                 reprocess request, in nanoseconds.
@param frameNumber the frame number for this capture

@see android.media.MediaActionSound
"
	end

	operation 79320631 "onCaptureStarted"
	  public explicit_return_type "void"
	  nparams 3
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	    param inout name "request" type class_ref 7147831 // CaptureRequest
	    param in name "timestamp" explicit_type "long"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Temporary for API change transition
@hide
"
	end

	operation 79320759 "onCapturePartial"
	  public explicit_return_type "void"
	  nparams 3
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	    param inout name "request" type class_ref 7147831 // CaptureRequest
	    param inout name "result" type class_ref 7148343 // CaptureResult
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called when some results from an image capture are
available.

<p>The result provided here will contain some subset of the fields of
a full result. Multiple onCapturePartial calls may happen per
capture; a given result field will only be present in one partial
capture at most. The final onCaptureCompleted call will always
contain all the fields, whether onCapturePartial was called or
not.</p>

<p>The default implementation of this method does nothing.</p>

@param session the session returned by {@link CameraDevice#createCaptureSession}
@param request The request that was given to the CameraDevice
@param result The partial output metadata from the capture, which
includes a subset of the CaptureResult fields.

@see #capture
@see #captureBurst
@see #setRepeatingRequest
@see #setRepeatingBurst

@hide
"
	end

	operation 79320887 "onCaptureProgressed"
	  public explicit_return_type "void"
	  nparams 3
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	    param inout name "request" type class_ref 7147831 // CaptureRequest
	    param inout name "partialResult" type class_ref 7148343 // CaptureResult
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, @NonNull ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called when an image capture makes partial forward progress; some
(but not all) results from an image capture are available.

<p>The result provided here will contain some subset of the fields of
a full result. Multiple {@link #onCaptureProgressed} calls may happen per
capture; a given result field will only be present in one partial
capture at most. The final {@link #onCaptureCompleted} call will always
contain all the fields (in particular, the union of all the fields of all
the partial results composing the total result).</p>

<p>For each request, some result data might be available earlier than others. The typical
delay between each partial result (per request) is a single frame interval.
For performance-oriented use-cases, applications should query the metadata they need
to make forward progress from the partial results and avoid waiting for the completed
result.</p>

<p>For a particular request, {@link #onCaptureProgressed} may happen before or after
{@link #onCaptureStarted}.</p>

<p>Each request will generate at least {@code 1} partial results, and at most
{@link CameraCharacteristics#REQUEST_PARTIAL_RESULT_COUNT} partial results.</p>

<p>Depending on the request settings, the number of partial results per request
will vary, although typically the partial count could be the same as long as the
camera device subsystems enabled stay the same.</p>

<p>The default implementation of this method does nothing.</p>

@param session the session returned by {@link CameraDevice#createCaptureSession}
@param request The request that was given to the CameraDevice
@param partialResult The partial output metadata from the capture, which
includes a subset of the {@link TotalCaptureResult} fields.

@see #capture
@see #captureBurst
@see #setRepeatingRequest
@see #setRepeatingBurst
"
	end

	operation 79321015 "onCaptureCompleted"
	  public explicit_return_type "void"
	  nparams 3
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	    param inout name "request" type class_ref 7147831 // CaptureRequest
	    param inout name "result" type class_ref 7148471 // TotalCaptureResult
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, @NonNull ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called when an image capture has fully completed and all the
result metadata is available.

<p>This callback will always fire after the last {@link #onCaptureProgressed};
in other words, no more partial results will be delivered once the completed result
is available.</p>

<p>For performance-intensive use-cases where latency is a factor, consider
using {@link #onCaptureProgressed} instead.</p>

<p>The default implementation of this method does nothing.</p>

@param session the session returned by {@link CameraDevice#createCaptureSession}
@param request The request that was given to the CameraDevice
@param result The total output metadata from the capture, including the
final capture parameters and the state of the camera system during
capture.

@see #capture
@see #captureBurst
@see #setRepeatingRequest
@see #setRepeatingBurst
"
	end

	operation 79321143 "onCaptureFailed"
	  public explicit_return_type "void"
	  nparams 3
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	    param inout name "request" type class_ref 7147831 // CaptureRequest
	    param inout name "failure" type class_ref 7148599 // CaptureFailure
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, @NonNull ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called instead of {@link #onCaptureCompleted} when the
camera device failed to produce a {@link CaptureResult} for the
request.

<p>Other requests are unaffected, and some or all image buffers from
the capture may have been pushed to their respective output
streams.</p>

<p>The default implementation of this method does nothing.</p>

@param session
           The session returned by {@link CameraDevice#createCaptureSession}
@param request
           The request that was given to the CameraDevice
@param failure
           The output failure from the capture, including the failure reason
           and the frame number.

@see #capture
@see #captureBurst
@see #setRepeatingRequest
@see #setRepeatingBurst
"
	end

	operation 79321271 "onCaptureSequenceCompleted"
	  public explicit_return_type "void"
	  nparams 3
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	    param in name "sequenceId" explicit_type "int"
	    param in name "frameNumber" explicit_type "long"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called independently of the others in CaptureCallback,
when a capture sequence finishes and all {@link CaptureResult}
or {@link CaptureFailure} for it have been returned via this listener.

<p>In total, there will be at least one result/failure returned by this listener
before this callback is invoked. If the capture sequence is aborted before any
requests have been processed, {@link #onCaptureSequenceAborted} is invoked instead.</p>

<p>The default implementation does nothing.</p>

@param session
           The session returned by {@link CameraDevice#createCaptureSession}
@param sequenceId
           A sequence ID returned by the {@link #capture} family of functions.
@param frameNumber
           The last frame number (returned by {@link CaptureResult#getFrameNumber}
           or {@link CaptureFailure#getFrameNumber}) in the capture sequence.

@see CaptureResult#getFrameNumber()
@see CaptureFailure#getFrameNumber()
@see CaptureResult#getSequenceId()
@see CaptureFailure#getSequenceId()
@see #onCaptureSequenceAborted
"
	end

	operation 79321399 "onCaptureSequenceAborted"
	  public explicit_return_type "void"
	  nparams 2
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	    param in name "sequenceId" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called independently of the others in CaptureCallback,
when a capture sequence aborts before any {@link CaptureResult}
or {@link CaptureFailure} for it have been returned via this listener.

<p>Due to the asynchronous nature of the camera device, not all submitted captures
are immediately processed. It is possible to clear out the pending requests
by a variety of operations such as {@link CameraCaptureSession#stopRepeating} or
{@link CameraCaptureSession#abortCaptures}. When such an event happens,
{@link #onCaptureSequenceCompleted} will not be called.</p>

<p>The default implementation does nothing.</p>

@param session
           The session returned by {@link CameraDevice#createCaptureSession}
@param sequenceId
           A sequence ID returned by the {@link #capture} family of functions.

@see CaptureResult#getFrameNumber()
@see CaptureFailure#getFrameNumber()
@see CaptureResult#getSequenceId()
@see CaptureFailure#getSequenceId()
@see #onCaptureSequenceCompleted
"
	end

	operation 79321527 "onCaptureBufferLost"
	  public explicit_return_type "void"
	  nparams 4
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	    param inout name "request" type class_ref 7147831 // CaptureRequest
	    param inout name "target" type class_ref 6952247 // Surface
	    param in name "frameNumber" explicit_type "long"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, @NonNull ${t2} ${p2}, ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "<p>This method is called if a single buffer for a capture could not be sent to its
destination surface.</p>

<p>If the whole capture failed, then {@link #onCaptureFailed} will be called instead. If
some but not all buffers were captured but the result metadata will not be available,
then onCaptureFailed will be invoked with {@link CaptureFailure#wasImageCaptured}
returning true, along with one or more calls to {@link #onCaptureBufferLost} for the
failed outputs.</p>

@param session
           The session returned by {@link CameraDevice#createCaptureSession}
@param request
           The request that was given to the CameraDevice
@param target
           The target Surface that the buffer will not be produced for
@param frameNumber
           The frame number for the request
"
	end
      end

      operation 79318711 "captureBurst"
	abstract public explicit_return_type "int"
	nparams 3
	  param inout name "requests" explicit_type "List<CaptureRequest>"
	  param inout name "listener" type class_ref 7147959 // CaptureCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @Nullable ${t1} ${p1}, @Nullable ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Submit a list of requests to be captured in sequence as a burst. The
burst will be captured in the minimum amount of time possible, and will
not be interleaved with requests submitted by other capture or repeat
calls.

<p>Regular and reprocess requests can be mixed together in a single burst. Regular requests
will be captured in order and reprocess requests will be processed in order, respectively.
However, the processing order between a regular request and a reprocess request is not
specified. Each capture produces one {@link CaptureResult} and image buffers for one or more
target {@link android.view.Surface surfaces}. The target surfaces (set with
{@link CaptureRequest.Builder#addTarget}) must be a subset of the surfaces provided when
this capture session was created.</p>

<p>The main difference between this method and simply calling
{@link #capture} repeatedly is that this method guarantees that no
other requests will be interspersed with the burst.</p>

<p>All capture sessions can be used for capturing images from the camera but only capture
sessions created by
{@link CameraDevice#createReprocessableCaptureSession createReprocessableCaptureSession}
can submit reprocess capture requests. Submitting a reprocess request to a regular
capture session will result in an {@link IllegalArgumentException}.</p>

@param requests the list of settings for this burst capture
@param listener The callback object to notify each time one of the
requests in the burst has been processed. If null, no metadata will be
produced for any requests in this burst, although image data will still
be produced.
@param handler the handler on which the listener should be invoked, or
{@code null} to use the current thread's {@link android.os.Looper
looper}.

@return int A unique capture sequence ID used by
            {@link CaptureCallback#onCaptureSequenceCompleted}.

@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                              was explicitly closed, a new session has been created
                              or the camera device has been closed.
@throws IllegalArgumentException If the requests target no Surfaces, or the requests target
                                 Surfaces not currently configured as outputs; or one of the
                                 requests targets a set of Surfaces that cannot be submitted
                                 simultaneously in a reprocessable capture session; or a
                                 reprocess capture request is submitted in a
                                 non-reprocessable capture session; or one of the reprocess
                                 capture requests was created with a
                                 {@link TotalCaptureResult} from a different session; or one
                                 of the captures targets a Surface in the middle of being
                                 {@link #prepare prepared}; or if the handler is null, the
                                 listener is not null, and the calling thread has no looper.

@see #capture
@see #setRepeatingRequest
@see #setRepeatingBurst
@see #abortCaptures
"
      end

      operation 79318839 "setRepeatingRequest"
	abstract public explicit_return_type "int"
	nparams 3
	  param inout name "request" type class_ref 7147831 // CaptureRequest
	  param inout name "listener" type class_ref 7147959 // CaptureCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @Nullable ${t1} ${p1}, @Nullable ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Request endlessly repeating capture of images by this capture session.

<p>With this method, the camera device will continually capture images
using the settings in the provided {@link CaptureRequest}, at the maximum
rate possible.</p>

<p>Repeating requests are a simple way for an application to maintain a
preview or other continuous stream of frames, without having to
continually submit identical requests through {@link #capture}.</p>

<p>Repeat requests have lower priority than those submitted
through {@link #capture} or {@link #captureBurst}, so if
{@link #capture} is called when a repeating request is active, the
capture request will be processed before any further repeating
requests are processed.<p>

<p>To stop the repeating capture, call {@link #stopRepeating}. Calling
{@link #abortCaptures} will also clear the request.</p>

<p>Calling this method will replace any earlier repeating request or
burst set up by this method or {@link #setRepeatingBurst}, although any
in-progress burst will be completed before the new repeat request will be
used.</p>

<p>This method does not support reprocess capture requests because each reprocess
{@link CaptureRequest} must be created from the {@link TotalCaptureResult} that matches
the input image to be reprocessed. This is either the {@link TotalCaptureResult} of capture
that is sent for reprocessing, or one of the {@link TotalCaptureResult TotalCaptureResults}
of a set of captures, when data from the whole set is combined by the application into a
single reprocess input image. The request must be capturing images from the camera. If a
reprocess capture request is submitted, this method will throw IllegalArgumentException.</p>

@param request the request to repeat indefinitely
@param listener The callback object to notify every time the
request finishes processing. If null, no metadata will be
produced for this stream of requests, although image data will
still be produced.
@param handler the handler on which the listener should be invoked, or
{@code null} to use the current thread's {@link android.os.Looper
looper}.

@return int A unique capture sequence ID used by
            {@link CaptureCallback#onCaptureSequenceCompleted}.

@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                              was explicitly closed, a new session has been created
                              or the camera device has been closed.
@throws IllegalArgumentException If the request references no Surfaces or references Surfaces
                                 that are not currently configured as outputs; or the request
                                 is a reprocess capture request; or the capture targets a
                                 Surface in the middle of being {@link #prepare prepared}; or
                                 the handler is null, the listener is not null, and the
                                 calling thread has no looper; or no requests were passed in.

@see #capture
@see #captureBurst
@see #setRepeatingBurst
@see #stopRepeating
@see #abortCaptures
"
      end

      operation 79318967 "setRepeatingBurst"
	abstract public explicit_return_type "int"
	nparams 3
	  param inout name "requests" explicit_type "List<CaptureRequest>"
	  param inout name "listener" type class_ref 7147959 // CaptureCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @Nullable ${t1} ${p1}, @Nullable ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "<p>Request endlessly repeating capture of a sequence of images by this
capture session.</p>

<p>With this method, the camera device will continually capture images,
cycling through the settings in the provided list of
{@link CaptureRequest CaptureRequests}, at the maximum rate possible.</p>

<p>If a request is submitted through {@link #capture} or
{@link #captureBurst}, the current repetition of the request list will be
completed before the higher-priority request is handled. This guarantees
that the application always receives a complete repeat burst captured in
minimal time, instead of bursts interleaved with higher-priority
captures, or incomplete captures.</p>

<p>Repeating burst requests are a simple way for an application to
maintain a preview or other continuous stream of frames where each
request is different in a predicatable way, without having to continually
submit requests through {@link #captureBurst}.</p>

<p>To stop the repeating capture, call {@link #stopRepeating}. Any
ongoing burst will still be completed, however. Calling
{@link #abortCaptures} will also clear the request.</p>

<p>Calling this method will replace a previously-set repeating request or
burst set up by this method or {@link #setRepeatingRequest}, although any
in-progress burst will be completed before the new repeat burst will be
used.</p>

<p>This method does not support reprocess capture requests because each reprocess
{@link CaptureRequest} must be created from the {@link TotalCaptureResult} that matches
the input image to be reprocessed. This is either the {@link TotalCaptureResult} of capture
that is sent for reprocessing, or one of the {@link TotalCaptureResult TotalCaptureResults}
of a set of captures, when data from the whole set is combined by the application into a
single reprocess input image. The request must be capturing images from the camera. If a
reprocess capture request is submitted, this method will throw IllegalArgumentException.</p>

@param requests the list of requests to cycle through indefinitely
@param listener The callback object to notify each time one of the
requests in the repeating bursts has finished processing. If null, no
metadata will be produced for this stream of requests, although image
data will still be produced.
@param handler the handler on which the listener should be invoked, or
{@code null} to use the current thread's {@link android.os.Looper
looper}.

@return int A unique capture sequence ID used by
            {@link CaptureCallback#onCaptureSequenceCompleted}.

@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                              was explicitly closed, a new session has been created
                              or the camera device has been closed.
@throws IllegalArgumentException If the requests reference no Surfaces or reference Surfaces
                                 not currently configured as outputs; or one of the requests
                                 is a reprocess capture request; or one of the captures
                                 targets a Surface in the middle of being
                                 {@link #prepare prepared}; or the handler is null, the
                                 listener is not null, and the calling thread has no looper;
                                 or no requests were passed in.

@see #capture
@see #captureBurst
@see #setRepeatingRequest
@see #stopRepeating
@see #abortCaptures
"
      end

      operation 79319095 "stopRepeating"
	abstract public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "<p>Cancel any ongoing repeating capture set by either
{@link #setRepeatingRequest setRepeatingRequest} or
{@link #setRepeatingBurst}. Has no effect on requests submitted through
{@link #capture capture} or {@link #captureBurst captureBurst}.</p>

<p>Any currently in-flight captures will still complete, as will any burst that is
mid-capture. To ensure that the device has finished processing all of its capture requests
and is in ready state, wait for the {@link StateCallback#onReady} callback after
calling this method.</p>

@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                              was explicitly closed, a new session has been created
                              or the camera device has been closed.

@see #setRepeatingRequest
@see #setRepeatingBurst
@see StateCallback#onIdle
"
      end

      operation 79319223 "abortCaptures"
	abstract public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Discard all captures currently pending and in-progress as fast as possible.

<p>The camera device will discard all of its current work as fast as possible. Some in-flight
captures may complete successfully and call {@link CaptureCallback#onCaptureCompleted}, while
others will trigger their {@link CaptureCallback#onCaptureFailed} callbacks. If a repeating
request or a repeating burst is set, it will be cleared.</p>

<p>This method is the fastest way to switch the camera device to a new session with
{@link CameraDevice#createCaptureSession} or
{@link CameraDevice#createReprocessableCaptureSession}, at the cost of discarding in-progress
work. It must be called before the new session is created. Once all pending requests are
either completed or thrown away, the {@link StateCallback#onReady} callback will be called,
if the session has not been closed. Otherwise, the {@link StateCallback#onClosed}
callback will be fired when a new session is created by the camera device.</p>

<p>Cancelling will introduce at least a brief pause in the stream of data from the camera
device, since once the camera device is emptied, the first new request has to make it through
the entire camera pipeline before new output buffers are produced.</p>

<p>This means that using {@code abortCaptures()} to simply remove pending requests is not
recommended; it's best used for quickly switching output configurations, or for cancelling
long in-progress requests (such as a multi-second capture).</p>

@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if this session is no longer active, either because the session
                              was explicitly closed, a new session has been created
                              or the camera device has been closed.

@see #setRepeatingRequest
@see #setRepeatingBurst
@see CameraDevice#createCaptureSession
@see CameraDevice#createReprocessableCaptureSession
"
      end

      operation 79319351 "isReprocessable"
	abstract public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Return if the application can submit reprocess capture requests with this camera capture
session.

@return {@code true} if the application can submit reprocess capture requests with this
        camera capture session. {@code false} otherwise.

@see CameraDevice#createReprocessableCaptureSession
"
      end

      operation 79319479 "getInputSurface"
	abstract public return_type class_ref 6952247 // Surface
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Nullable
"
	
	
	
	comment "Get the input Surface associated with a reprocessable capture session.

<p>Each reprocessable capture session has an input {@link Surface} where the reprocess
capture requests get the input images from, rather than the camera device. The application
can create a {@link android.media.ImageWriter ImageWriter} with this input {@link Surface}
and use it to provide input images for reprocess capture requests. When the reprocessable
capture session is closed, the input {@link Surface} is abandoned and becomes invalid.</p>

@return The {@link Surface} where reprocessing capture requests get the input images from. If
        this is not a reprocess capture session, {@code null} will be returned.

@see CameraDevice#createReprocessableCaptureSession
@see android.media.ImageWriter
@see android.media.ImageReader
"
      end

      operation 79319607 "close"
	abstract public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "Close this capture session asynchronously.

<p>Closing a session frees up the target output Surfaces of the session for reuse with either
a new session, or to other APIs that can draw to Surfaces.</p>

<p>Note that creating a new capture session with {@link CameraDevice#createCaptureSession}
will close any existing capture session automatically, and call the older session listener's
{@link StateCallback#onClosed} callback. Using {@link CameraDevice#createCaptureSession}
directly without closing is the recommended approach for quickly switching to a new session,
since unchanged target outputs can be reused more efficiently.</p>

<p>Once a session is closed, all methods on it will throw an IllegalStateException, and any
repeating requests or bursts are stopped (as if {@link #stopRepeating()} was called).
However, any in-progress capture requests submitted to the session will be completed as
normal; once all captures have completed and the session has been torn down,
{@link StateCallback#onClosed} will be called.</p>

<p>Closing a session is idempotent; closing more than once has no effect.</p>
"
      end

      class 7148087 "StateCallback"
	abstract visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	operation 79319735 "onConfigured"
	  abstract public explicit_return_type "void"
	  nparams 1
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called when the camera device has finished configuring itself, and the
session can start processing capture requests.

<p>If there are capture requests already queued with the session, they will start
processing once this callback is invoked, and the session will call {@link #onActive}
right after this callback is invoked.</p>

<p>If no capture requests have been submitted, then the session will invoke
{@link #onReady} right after this callback.</p>

<p>If the camera device configuration fails, then {@link #onConfigureFailed} will
be invoked instead of this callback.</p>

@param session the session returned by {@link CameraDevice#createCaptureSession}
"
	end

	operation 79319863 "onConfigureFailed"
	  abstract public explicit_return_type "void"
	  nparams 1
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called if the session cannot be configured as requested.

<p>This can happen if the set of requested outputs contains unsupported sizes,
or too many outputs are requested at once.</p>

<p>The session is considered to be closed, and all methods called on it after this
callback is invoked will throw an IllegalStateException. Any capture requests submitted
to the session prior to this callback will be discarded and will not produce any
callbacks on their listeners.</p>

@param session the session returned by {@link CameraDevice#createCaptureSession}
"
	end

	operation 79319991 "onReady"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called every time the session has no more capture requests to process.

<p>During the creation of a new session, this callback is invoked right after
{@link #onConfigured} if no capture requests were submitted to the session prior to it
completing configuration.</p>

<p>Otherwise, this callback will be invoked any time the session finishes processing
all of its active capture requests, and no repeating request or burst is set up.</p>

@param session the session returned by {@link CameraDevice#createCaptureSession}

"
	end

	operation 79320119 "onActive"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called when the session starts actively processing capture requests.

<p>If capture requests are submitted prior to {@link #onConfigured} being called,
then the session will start processing those requests immediately after the callback,
and this method will be immediately called after {@link #onConfigured}.

<p>If the session runs out of capture requests to process and calls {@link #onReady},
then this callback will be invoked again once new requests are submitted for capture.</p>

@param session the session returned by {@link CameraDevice#createCaptureSession}
"
	end

	operation 79320247 "onClosed"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called when the session is closed.

<p>A session is closed when a new session is created by the parent camera device,
or when the parent camera device is closed (either by the user closing the device,
or due to a camera device disconnection or fatal error).</p>

<p>Once a session is closed, all methods on it will throw an IllegalStateException, and
any repeating requests or bursts are stopped (as if {@link #stopRepeating()} was called).
However, any in-progress capture requests submitted to the session will be completed
as normal.</p>

@param session the session returned by {@link CameraDevice#createCaptureSession}
"
	end

	operation 79320375 "onSurfacePrepared"
	  public explicit_return_type "void"
	  nparams 2
	    param inout name "session" type class_ref 7147575 // CameraCaptureSession
	    param inout name "surface" type class_ref 6952247 // Surface
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "This method is called when the buffer pre-allocation for an output Surface is complete.

<p>Buffer pre-allocation for an output Surface is started by the {@link #prepare} call.
While allocation is underway, the Surface must not be used as a capture target.
Once this callback fires, the output Surface provided can again be used as a target for
a capture request.</p>

<p>In case of a error during pre-allocation (such as running out of suitable memory),
this callback is still invoked after the error is encountered, though some buffers may
not have been successfully pre-allocated.</p>

@param session the session returned by {@link CameraDevice#createCaptureSession}
@param surface the Surface that was used with the {@link #prepare} call.
"
	end
      end

      class 7148215 "StateListener"
	abstract visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 15648951 // <generalisation>
	  relation 15648951 ---|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 15648951 // <generalisation>
	    b parent class_ref 7148087 // StateCallback
	end
      end

      class 7148727 "CaptureListener"
	abstract visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 15649079 // <generalisation>
	  relation 15649079 ---|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 15649079 // <generalisation>
	    b parent class_ref 7147959 // CaptureCallback
	end
      end
    end

    class 7147703 "CameraDevice"
      abstract visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "<p>The CameraDevice class is a representation of a single camera connected to an
Android device, allowing for fine-grain control of image capture and
post-processing at high frame rates.</p>

<p>Your application must declare the
{@link android.Manifest.permission#CAMERA Camera} permission in its manifest
in order to access camera devices.</p>

<p>A given camera device may provide support at one of two levels: limited or
full. If a device only supports the limited level, then Camera2 exposes a
feature set that is roughly equivalent to the older
{@link android.hardware.Camera Camera} API, although with a cleaner and more
efficient interface.  Devices that implement the full level of support
provide substantially improved capabilities over the older camera
API. Applications that target the limited level devices will run unchanged on
the full-level devices; if your application requires a full-level device for
proper operation, declare the \"android.hardware.camera.level.full\" feature in your
manifest.</p>

@see CameraManager#openCamera
@see android.Manifest.permission#CAMERA
"
      attribute 24799031 "TEMPLATE_PREVIEW"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Create a request suitable for a camera preview window. Specifically, this
means that high frame rate is given priority over the highest-quality
post-processing. These requests would normally be used with the
{@link CameraCaptureSession#setRepeatingRequest} method.
This template is guaranteed to be supported on all camera devices.

@see #createCaptureRequest

"
      end

      attribute 24799159 "TEMPLATE_STILL_CAPTURE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Create a request suitable for still image capture. Specifically, this
means prioritizing image quality over frame rate. These requests would
commonly be used with the {@link CameraCaptureSession#capture} method.
This template is guaranteed to be supported on all camera devices.

@see #createCaptureRequest

"
      end

      attribute 24799287 "TEMPLATE_RECORD"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Create a request suitable for video recording. Specifically, this means
that a stable frame rate is used, and post-processing is set for
recording quality. These requests would commonly be used with the
{@link CameraCaptureSession#setRepeatingRequest} method.
This template is guaranteed to be supported on all camera devices.

@see #createCaptureRequest

"
      end

      attribute 24799415 "TEMPLATE_VIDEO_SNAPSHOT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Create a request suitable for still image capture while recording
video. Specifically, this means maximizing image quality without
disrupting the ongoing recording. These requests would commonly be used
with the {@link CameraCaptureSession#capture} method while a request based on
{@link #TEMPLATE_RECORD} is is in use with {@link CameraCaptureSession#setRepeatingRequest}.
This template is guaranteed to be supported on all camera devices except
legacy devices ({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL}
{@code == }{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY})

@see #createCaptureRequest

"
      end

      attribute 24799543 "TEMPLATE_ZERO_SHUTTER_LAG"
	class_attribute const_attribute public explicit_type "int"
	init_value " 5"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Create a request suitable for zero shutter lag still capture. This means
means maximizing image quality without compromising preview frame rate.
AE/AWB/AF should be on auto mode.
This template is guaranteed to be supported on camera devices that support the
{@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING PRIVATE_REPROCESSING}
capability or the
{@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING YUV_REPROCESSING}
capability.

@see #createCaptureRequest

"
      end

      attribute 24799671 "TEMPLATE_MANUAL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 6"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "A basic template for direct application control of capture
parameters. All automatic control is disabled (auto-exposure, auto-white
balance, auto-focus), and post-processing parameters are set to preview
quality. The manual capture parameters (exposure, sensitivity, and so on)
are set to reasonable defaults, but should be overriden by the
application depending on the intended use case.
This template is guaranteed to be supported on camera devices that support the
{@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR MANUAL_SENSOR}
capability.

@see #createCaptureRequest

"
      end

      class 7151287 "RequestTemplate"
	visibility public stereotype "@interface"
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl "${comment}${@}${visibility}${static}@interface ${name}${extends} {
${members}}
"
	java_annotation "@Retention(RetentionPolicy.SOURCE)
@IntDef(
         {TEMPLATE_PREVIEW,
          TEMPLATE_STILL_CAPTURE,
          TEMPLATE_RECORD,
          TEMPLATE_VIDEO_SNAPSHOT,
          TEMPLATE_ZERO_SHUTTER_LAG,
          TEMPLATE_MANUAL })
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
      end

      operation 79324727 "getId"
	abstract public explicit_return_type "String"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Get the ID of this camera device.

<p>This matches the ID given to {@link CameraManager#openCamera} to instantiate this
this camera device.</p>

<p>This ID can be used to query the camera device's {@link
CameraCharacteristics fixed properties} with {@link
CameraManager#getCameraCharacteristics}.</p>

<p>This method can be called even if the device has been closed or has encountered
a serious error.</p>

@return the ID for this camera device

@see CameraManager#getCameraCharacteristics
@see CameraManager#getCameraIdList
"
      end

      operation 79324855 "createCaptureSession"
	abstract public explicit_return_type "void"
	nparams 3
	  param inout name "outputs" explicit_type "List<Surface>"
	  param inout name "callback" type class_ref 7148087 // StateCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, @Nullable ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "<p>Create a new camera capture session by providing the target output set of Surfaces to the
camera device.</p>

<p>The active capture session determines the set of potential output Surfaces for
the camera device for each capture request. A given request may use all
or only some of the outputs. Once the CameraCaptureSession is created, requests can be
submitted with {@link CameraCaptureSession#capture capture},
{@link CameraCaptureSession#captureBurst captureBurst},
{@link CameraCaptureSession#setRepeatingRequest setRepeatingRequest}, or
{@link CameraCaptureSession#setRepeatingBurst setRepeatingBurst}.</p>

<p>Surfaces suitable for inclusion as a camera output can be created for
various use cases and targets:</p>

<ul>

<li>For drawing to a {@link android.view.SurfaceView SurfaceView}: Once the SurfaceView's
  Surface is {@link android.view.SurfaceHolder.Callback#surfaceCreated created}, set the size
  of the Surface with {@link android.view.SurfaceHolder#setFixedSize} to be one of the sizes
  returned by {@link StreamConfigurationMap#getOutputSizes(Class)
  getOutputSizes(SurfaceHolder.class)} and then obtain the Surface by calling {@link
  android.view.SurfaceHolder#getSurface}. If the size is not set by the application, it will
  be rounded to the nearest supported size less than 1080p, by the camera device.</li>

<li>For accessing through an OpenGL texture via a {@link android.graphics.SurfaceTexture
  SurfaceTexture}: Set the size of the SurfaceTexture with {@link
  android.graphics.SurfaceTexture#setDefaultBufferSize} to be one of the sizes returned by
  {@link StreamConfigurationMap#getOutputSizes(Class) getOutputSizes(SurfaceTexture.class)}
  before creating a Surface from the SurfaceTexture with {@link Surface#Surface}. If the size
  is not set by the application, it will be set to be the smallest supported size less than
  1080p, by the camera device.</li>

<li>For recording with {@link android.media.MediaCodec}: Call
  {@link android.media.MediaCodec#createInputSurface} after configuring
  the media codec to use one of the sizes returned by
  {@link StreamConfigurationMap#getOutputSizes(Class) getOutputSizes(MediaCodec.class)}
  </li>

<li>For recording with {@link android.media.MediaRecorder}: Call
  {@link android.media.MediaRecorder#getSurface} after configuring the media recorder to use
  one of the sizes returned by
  {@link StreamConfigurationMap#getOutputSizes(Class) getOutputSizes(MediaRecorder.class)},
  or configuring it to use one of the supported
  {@link android.media.CamcorderProfile CamcorderProfiles}.</li>

<li>For efficient YUV processing with {@link android.renderscript}:
  Create a RenderScript
  {@link android.renderscript.Allocation Allocation} with a supported YUV
  type, the IO_INPUT flag, and one of the sizes returned by
  {@link StreamConfigurationMap#getOutputSizes(Class) getOutputSizes(Allocation.class)},
  Then obtain the Surface with
  {@link android.renderscript.Allocation#getSurface}.</li>

<li>For access to RAW, uncompressed YUV, or compressed JPEG data in the application: Create an
  {@link android.media.ImageReader} object with one of the supported output formats given by
  {@link StreamConfigurationMap#getOutputFormats()}, setting its size to one of the
  corresponding supported sizes by passing the chosen output format into
  {@link StreamConfigurationMap#getOutputSizes(int)}. Then obtain a
  {@link android.view.Surface} from it with {@link android.media.ImageReader#getSurface()}.
  If the ImageReader size is not set to a supported size, it will be rounded to a supported
  size less than 1080p by the camera device.
  </li>

</ul>

<p>The camera device will query each Surface's size and formats upon this
call, so they must be set to a valid setting at this time.</p>

<p>It can take several hundred milliseconds for the session's configuration to complete,
since camera hardware may need to be powered on or reconfigured. Once the configuration is
complete and the session is ready to actually capture data, the provided
{@link CameraCaptureSession.StateCallback}'s
{@link CameraCaptureSession.StateCallback#onConfigured} callback will be called.</p>

<p>If a prior CameraCaptureSession already exists when this method is called, the previous
session will no longer be able to accept new capture requests and will be closed. Any
in-progress capture requests made on the prior session will be completed before it's closed.
{@link CameraCaptureSession.StateListener#onConfigured} for the new session may be invoked
before {@link CameraCaptureSession.StateListener#onClosed} is invoked for the prior
session. Once the new session is {@link CameraCaptureSession.StateListener#onConfigured
configured}, it is able to start capturing its own requests. To minimize the transition time,
the {@link CameraCaptureSession#abortCaptures} call can be used to discard the remaining
requests for the prior capture session before a new one is created. Note that once the new
session is created, the old one can no longer have its captures aborted.</p>

<p>Using larger resolution outputs, or more outputs, can result in slower
output rate from the device.</p>

<p>Configuring a session with an empty or null list will close the current session, if
any. This can be used to release the current session's target surfaces for another use.</p>

<p>While any of the sizes from {@link StreamConfigurationMap#getOutputSizes} can be used when
a single output stream is configured, a given camera device may not be able to support all
combination of sizes, formats, and targets when multiple outputs are configured at once.  The
tables below list the maximum guaranteed resolutions for combinations of streams and targets,
given the capabilities of the camera device.</p>

<p>If an application tries to create a session using a set of targets that exceed the limits
described in the below tables, one of three possibilities may occur. First, the session may
be successfully created and work normally. Second, the session may be successfully created,
but the camera device won't meet the frame rate guarantees as described in
{@link StreamConfigurationMap#getOutputMinFrameDuration}. Or third, if the output set
cannot be used at all, session creation will fail entirely, with
{@link CameraCaptureSession.StateListener#onConfigureFailed} being invoked.</p>

<p>For the type column, {@code PRIV} refers to any target whose available sizes are found
using {@link StreamConfigurationMap#getOutputSizes(Class)} with no direct application-visible
format, {@code YUV} refers to a target Surface using the
{@link android.graphics.ImageFormat#YUV_420_888} format, {@code JPEG} refers to the
{@link android.graphics.ImageFormat#JPEG} format, and {@code RAW} refers to the
{@link android.graphics.ImageFormat#RAW_SENSOR} format.</p>

<p>For the maximum size column, {@code PREVIEW} refers to the best size match to the
device's screen resolution, or to 1080p ({@code 1920x1080}), whichever is
smaller. {@code RECORD} refers to the camera device's maximum supported recording resolution,
as determined by {@link android.media.CamcorderProfile}. And {@code MAXIMUM} refers to the
camera device's maximum output resolution for that format or target from
{@link StreamConfigurationMap#getOutputSizes}.</p>

<p>To use these tables, determine the number and the formats/targets of outputs needed, and
find the row(s) of the table with those targets. The sizes indicate the maximum set of sizes
that can be used; it is guaranteed that for those targets, the listed sizes and anything
smaller from the list given by {@link StreamConfigurationMap#getOutputSizes} can be
successfully used to create a session.  For example, if a row indicates that a 8 megapixel
(MP) YUV_420_888 output can be used together with a 2 MP {@code PRIV} output, then a session
can be created with targets {@code [8 MP YUV, 2 MP PRIV]} or targets {@code [2 MP YUV, 2 MP
PRIV]}; but a session with targets {@code [8 MP YUV, 4 MP PRIV]}, targets {@code [4 MP YUV, 4
MP PRIV]}, or targets {@code [8 MP PRIV, 2 MP YUV]} would not be guaranteed to work, unless
some other row of the table lists such a combination.</p>

<style scoped>
 #rb { border-right-width: thick; }
</style>
<p>Legacy devices ({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL}
{@code == }{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY}) support at
least the following stream combinations:

<table>
<tr><th colspan=\"7\">LEGACY-level guaranteed configurations</th></tr>
<tr> <th colspan=\"2\" id=\"rb\">Target 1</th> <th colspan=\"2\" id=\"rb\">Target 2</th>  <th colspan=\"2\" id=\"rb\">Target 3</th> <th rowspan=\"2\">Sample use case(s)</th> </tr>
<tr> <th>Type</th><th id=\"rb\">Max size</th> <th>Type</th><th id=\"rb\">Max size</th> <th>Type</th><th id=\"rb\">Max size</th></tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td colspan=\"2\" id=\"rb\"></td> <td>Simple preview, GPU video processing, or no-preview video recording.</td> </tr>
<tr> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td colspan=\"2\" id=\"rb\"></td> <td>No-viewfinder still image capture.</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td colspan=\"2\" id=\"rb\"></td> <td>In-application video/image processing.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td>Standard still imaging.</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td>In-app processing plus still capture.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td colspan=\"2\" id=\"rb\"></td> <td>Standard recording.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td colspan=\"2\" id=\"rb\"></td> <td>Preview plus in-app processing.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Still capture plus in-app processing.</td> </tr>
</table><br>
</p>

<p>Limited-level ({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL}
{@code == }{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED}) devices
support at least the following stream combinations in addition to those for
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY} devices:

<table>
<tr><th colspan=\"7\">LIMITED-level additional guaranteed configurations</th></tr>
<tr><th colspan=\"2\" id=\"rb\">Target 1</th><th colspan=\"2\" id=\"rb\">Target 2</th><th colspan=\"2\" id=\"rb\">Target 3</th> <th rowspan=\"2\">Sample use case(s)</th> </tr>
<tr><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th></tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code RECORD }</td> <td colspan=\"2\" id=\"rb\"></td> <td>High-resolution video recording with preview.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code RECORD }</td> <td colspan=\"2\" id=\"rb\"></td> <td>High-resolution in-app video processing with preview.</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code RECORD }</td> <td colspan=\"2\" id=\"rb\"></td> <td>Two-input in-app video processing.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code RECORD }</td> <td>{@code JPEG}</td><td id=\"rb\">{@code RECORD }</td> <td>High-resolution recording with video snapshot.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code RECORD }</td> <td>{@code JPEG}</td><td id=\"rb\">{@code RECORD }</td> <td>High-resolution in-app processing with video snapshot.</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Two-input in-app processing with still capture.</td> </tr>
</table><br>
</p>

<p>FULL-level ({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL}
{@code == }{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL}) devices
support at least the following stream combinations in addition to those for
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED} devices:

<table>
<tr><th colspan=\"7\">FULL-level additional guaranteed configurations</th></tr>
<tr><th colspan=\"2\" id=\"rb\">Target 1</th><th colspan=\"2\" id=\"rb\">Target 2</th><th colspan=\"2\" id=\"rb\">Target 3</th> <th rowspan=\"2\">Sample use case(s)</th> </tr>
<tr><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td>Maximum-resolution GPU processing with preview.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td>Maximum-resolution in-app processing with preview.</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td>Maximum-resolution two-input in-app processsing.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Video recording with maximum-size video snapshot</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code 640x480}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Standard video recording plus maximum-resolution in-app processing.</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code 640x480}</td> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Preview plus two-input maximum-resolution in-app processing.</td> </tr>
</table><br>
</p>

<p>RAW-capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES} includes
{@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_RAW RAW}) devices additionally support
at least the following stream combinations on both
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL} and
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED} devices:

<table>
<tr><th colspan=\"7\">RAW-capability additional guaranteed configurations</th></tr>
<tr><th colspan=\"2\" id=\"rb\">Target 1</th><th colspan=\"2\" id=\"rb\">Target 2</th><th colspan=\"2\" id=\"rb\">Target 3</th> <th rowspan=\"2\">Sample use case(s)</th> </tr>
<tr><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th> </tr>
<tr> <td>{@code RAW }</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td colspan=\"2\" id=\"rb\"></td> <td>No-preview DNG capture.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code RAW }</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td>Standard DNG capture.</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code RAW }</td><td id=\"rb\">{@code MAXIMUM}</td> <td colspan=\"2\" id=\"rb\"></td> <td>In-app processing plus DNG capture.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code RAW }</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Video recording with DNG capture.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code RAW }</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Preview with in-app processing and DNG capture.</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code RAW }</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Two-input in-app processing plus DNG capture.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code RAW }</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Still capture with simultaneous JPEG and DNG.</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code RAW }</td><td id=\"rb\">{@code MAXIMUM}</td> <td>In-app processing with simultaneous JPEG and DNG.</td> </tr>
</table><br>
</p>

<p>BURST-capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES} includes
{@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE BURST_CAPTURE}) devices
support at least the below stream combinations in addition to those for
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED} devices. Note that all
FULL-level devices support the BURST capability, and the below list is a strict subset of the
list for FULL-level devices, so this table is only relevant for LIMITED-level devices that
support the BURST_CAPTURE capability.

<table>
<tr><th colspan=\"5\">BURST-capability additional guaranteed configurations</th></tr>
<tr><th colspan=\"2\" id=\"rb\">Target 1</th><th colspan=\"2\" id=\"rb\">Target 2</th><th rowspan=\"2\">Sample use case(s)</th> </tr>
<tr><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Maximum-resolution GPU processing with preview.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Maximum-resolution in-app processing with preview.</td> </tr>
<tr> <td>{@code YUV }</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV }</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Maximum-resolution two-input in-app processsing.</td> </tr>
</table><br>
</p>

<p>LEVEL-3 ({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL}
{@code == }{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_3 LEVEL_3})
support at least the following stream combinations in addition to the combinations for
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL} and for
RAW capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES} includes
{@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_RAW RAW}):

<table>
<tr><th colspan=\"11\">LEVEL-3 additional guaranteed configurations</th></tr>
<tr><th colspan=\"2\" id=\"rb\">Target 1</th><th colspan=\"2\" id=\"rb\">Target 2</th><th colspan=\"2\" id=\"rb\">Target 3</th><th colspan=\"2\" id=\"rb\">Target 4</th><th rowspan=\"2\">Sample use case(s)</th> </tr>
<tr><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code 640x480}</td> <td>{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code RAW}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>In-app viewfinder analysis with dynamic selection of output format.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code 640x480}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code RAW}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>In-app viewfinder analysis with dynamic selection of output format.</td> </tr>
</table><br>
</p>

<p>Since the capabilities of camera devices vary greatly, a given camera device may support
target combinations with sizes outside of these guarantees, but this can only be tested for
by attempting to create a session with such targets.</p>

@param outputs The new set of Surfaces that should be made available as
               targets for captured image data.
@param callback The callback to notify about the status of the new capture session.
@param handler The handler on which the callback should be invoked, or {@code null} to use
               the current thread's {@link android.os.Looper looper}.

@throws IllegalArgumentException if the set of output Surfaces do not meet the requirements,
                                 the callback is null, or the handler is null but the current
                                 thread has no looper.
@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if the camera device has been closed

@see CameraCaptureSession
@see StreamConfigurationMap#getOutputFormats()
@see StreamConfigurationMap#getOutputSizes(int)
@see StreamConfigurationMap#getOutputSizes(Class)
"
      end

      operation 79324983 "createCaptureSessionByOutputConfigurations"
	abstract public explicit_return_type "void"
	nparams 3
	  param inout name "outputConfigurations" explicit_type "List<OutputConfiguration>"
	  param inout name "callback" type class_ref 7148087 // StateCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "<p>Create a new camera capture session by providing the target output set of Surfaces and
its corresponding surface configuration to the camera device.</p>

@see #createCaptureSession
@see OutputConfiguration
"
      end

      operation 79325111 "createReprocessableCaptureSession"
	abstract public explicit_return_type "void"
	nparams 4
	  param inout name "inputConfig" type class_ref 7151415 // InputConfiguration
	  param inout name "outputs" explicit_type "List<Surface>"
	  param inout name "callback" type class_ref 7148087 // StateCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, @NonNull ${t2} ${p2}, @Nullable ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Create a new reprocessable camera capture session by providing the desired reprocessing
input Surface configuration and the target output set of Surfaces to the camera device.

<p>If a camera device supports YUV reprocessing
({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING}) or PRIVATE
reprocessing
({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING}), besides
the capture session created via {@link #createCaptureSession createCaptureSession}, the
application can also create a reprocessable capture session to submit reprocess capture
requests in addition to regular capture requests. A reprocess capture request takes the next
available buffer from the session's input Surface, and sends it through the camera device's
processing pipeline again, to produce buffers for the request's target output Surfaces. No
new image data is captured for a reprocess request. However the input buffer provided by
the application must be captured previously by the same camera device in the same session
directly (e.g. for Zero-Shutter-Lag use case) or indirectly (e.g. combining multiple output
images).</p>

<p>The active reprocessable capture session determines an input {@link Surface} and the set
of potential output Surfaces for the camera devices for each capture request. The application
can use {@link #createCaptureRequest createCaptureRequest} to create regular capture requests
to capture new images from the camera device, and use {@link #createReprocessCaptureRequest
createReprocessCaptureRequest} to create reprocess capture requests to process buffers from
the input {@link Surface}. Some combinations of output Surfaces in a session may not be used
in a request simultaneously. The guaranteed combinations of output Surfaces that can be used
in a request simultaneously are listed in the tables under {@link #createCaptureSession
createCaptureSession}. All the output Surfaces in one capture request will come from the
same source, either from a new capture by the camera device, or from the input Surface
depending on if the request is a reprocess capture request.</p>

<p>Input formats and sizes supported by the camera device can be queried via
{@link StreamConfigurationMap#getInputFormats} and
{@link StreamConfigurationMap#getInputSizes}. For each supported input format, the camera
device supports a set of output formats and sizes for reprocessing that can be queried via
{@link StreamConfigurationMap#getValidOutputFormatsForInput} and
{@link StreamConfigurationMap#getOutputSizes}. While output Surfaces with formats that
aren't valid reprocess output targets for the input configuration can be part of a session,
they cannot be used as targets for a reprocessing request.</p>

<p>Since the application cannot access {@link android.graphics.ImageFormat#PRIVATE} images
directly, an output Surface created by {@link android.media.ImageReader#newInstance} with
{@link android.graphics.ImageFormat#PRIVATE} as the format will be considered as intended to
be used for reprocessing input and thus the {@link android.media.ImageReader} size must
match one of the supported input sizes for {@link android.graphics.ImageFormat#PRIVATE}
format. Otherwise, creating a reprocessable capture session will fail.</p>

<p>The guaranteed stream configurations listed in
{@link #createCaptureSession createCaptureSession} are also guaranteed to work for
{@link #createReprocessableCaptureSession createReprocessableCaptureSession}. In addition,
the configurations in the tables below are also guaranteed for creating a reprocessable
capture session if the camera device supports YUV reprocessing or PRIVATE reprocessing.
However, not all output targets used to create a reprocessable session may be used in a
{@link CaptureRequest} simultaneously. For devices that support only 1 output target in a
reprocess {@link CaptureRequest}, submitting a reprocess {@link CaptureRequest} with multiple
output targets will result in a {@link CaptureFailure}. For devices that support multiple
output targets in a reprocess {@link CaptureRequest}, the guaranteed output targets that can
be included in a {@link CaptureRequest} simultaneously are listed in the tables under
{@link #createCaptureSession createCaptureSession}. For example, with a FULL-capability
({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL} {@code == }
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL}) device that supports PRIVATE
reprocessing, an application can create a reprocessable capture session with 1 input,
({@code PRIV}, {@code MAXIMUM}), and 3 outputs, ({@code PRIV}, {@code MAXIMUM}),
({@code PRIV}, {@code PREVIEW}), and ({@code YUV}, {@code MAXIMUM}). However, it's not
guaranteed that an application can submit a regular or reprocess capture with ({@code PRIV},
{@code MAXIMUM}) and ({@code YUV}, {@code MAXIMUM}) outputs based on the table listed under
{@link #createCaptureSession createCaptureSession}. In other words, use the tables below to
determine the guaranteed stream configurations for creating a reprocessable capture session,
and use the tables under {@link #createCaptureSession createCaptureSession} to determine the
guaranteed output targets that can be submitted in a regular or reprocess
{@link CaptureRequest} simultaneously.</p>

<style scoped>
 #rb { border-right-width: thick; }
</style>

<p>LIMITED-level ({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL}
{@code == }{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED}) devices
support at least the following stream combinations for creating a reprocessable capture
session in addition to those listed in {@link #createCaptureSession createCaptureSession} for
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED} devices:

<table>
<tr><th colspan=\"11\">LIMITED-level additional guaranteed configurations for creating a reprocessable capture session<br>({@code PRIV} input is guaranteed only if PRIVATE reprocessing is supported. {@code YUV} input is guaranteed only if YUV reprocessing is supported)</th></tr>
<tr><th colspan=\"2\" id=\"rb\">Input</th><th colspan=\"2\" id=\"rb\">Target 1</th><th colspan=\"2\" id=\"rb\">Target 2</th><th colspan=\"2\" id=\"rb\">Target 3</th><th colspan=\"2\" id=\"rb\">Target 4</th><th rowspan=\"2\">Sample use case(s)</th> </tr>
<tr><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th></tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td></td><td id=\"rb\"></td> <td></td><td id=\"rb\"></td> <td>No-viewfinder still image reprocessing.</td> </tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td></td><td id=\"rb\"></td> <td>ZSL(Zero-Shutter-Lag) still imaging.</td> </tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td></td><td id=\"rb\"></td> <td>ZSL still and in-app processing imaging.</td> </tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>ZSL in-app processing with still capture.</td> </tr>
</table><br>
</p>

<p>FULL-level ({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL}
{@code == }{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL}) devices
support at least the following stream combinations for creating a reprocessable capture
session in addition to those for
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED} devices:

<table>
<tr><th colspan=\"11\">FULL-level additional guaranteed configurations for creating a reprocessable capture session<br>({@code PRIV} input is guaranteed only if PRIVATE reprocessing is supported. {@code YUV} input is guaranteed only if YUV reprocessing is supported)</th></tr>
<tr><th colspan=\"2\" id=\"rb\">Input</th><th colspan=\"2\" id=\"rb\">Target 1</th><th colspan=\"2\" id=\"rb\">Target 2</th><th colspan=\"2\" id=\"rb\">Target 3</th><th colspan=\"2\" id=\"rb\">Target 4</th><th rowspan=\"2\">Sample use case(s)</th> </tr>
<tr><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th></tr>
<tr> <td>{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td></td><td id=\"rb\"></td> <td></td><td id=\"rb\"></td> <td>Maximum-resolution multi-frame image fusion in-app processing with regular preview.</td> </tr>
<tr> <td>{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td></td><td id=\"rb\"></td> <td></td><td id=\"rb\"></td> <td>Maximum-resolution multi-frame image fusion two-input in-app processing.</td> </tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV}</td><td id=\"rb\">{@code RECORD}</td> <td></td><td id=\"rb\"></td> <td>High-resolution ZSL in-app video processing with regular preview.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td></td><td id=\"rb\"></td> <td>Maximum-resolution ZSL in-app processing with regular preview.</td> </tr>
<tr> <td>{@code PRIV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td></td><td id=\"rb\"></td> <td>Maximum-resolution two-input ZSL in-app processing.</td> </tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>ZSL still capture and in-app processing.</td> </tr>
</table><br>
</p>

<p>RAW-capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES} includes
{@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_RAW RAW}) devices additionally support
at least the following stream combinations for creating a reprocessable capture session
on both {@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL} and
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED} devices

<table>
<tr><th colspan=\"11\">RAW-capability additional guaranteed configurations for creating a reprocessable capture session<br>({@code PRIV} input is guaranteed only if PRIVATE reprocessing is supported. {@code YUV} input is guaranteed only if YUV reprocessing is supported)</th></tr>
<tr><th colspan=\"2\" id=\"rb\">Input</th><th colspan=\"2\" id=\"rb\">Target 1</th><th colspan=\"2\" id=\"rb\">Target 2</th><th colspan=\"2\" id=\"rb\">Target 3</th><th colspan=\"2\" id=\"rb\">Target 4</th><th rowspan=\"2\">Sample use case(s)</th> </tr>
<tr><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th></tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code RAW}</td><td id=\"rb\">{@code MAXIMUM}</td> <td></td><td id=\"rb\"></td> <td>Mutually exclusive ZSL in-app processing and DNG capture.</td> </tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code RAW}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Mutually exclusive ZSL in-app processing and preview with DNG capture.</td> </tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code RAW}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Mutually exclusive ZSL two-input in-app processing and DNG capture.</td> </tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code RAW}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Mutually exclusive ZSL still capture and preview with DNG capture.</td> </tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code RAW}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Mutually exclusive ZSL in-app processing with still capture and DNG capture.</td> </tr>
</table><br>
</p>

<p>LEVEL-3 ({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL}
{@code == }{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_3 LEVEL_3}) devices
support at least the following stream combinations for creating a reprocessable capture
session in addition to those for
{@link CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL} devices. Note that while
the second configuration allows for configuring {@code MAXIMUM} {@code YUV} and {@code JPEG}
outputs at the same time, that configuration is not listed for regular capture sessions, and
therefore simultaneous output to both targets is not allowed.

<table>
<tr><th colspan=\"13\">LEVEL-3 additional guaranteed configurations for creating a reprocessable capture session<br>({@code PRIV} input is guaranteed only if PRIVATE reprocessing is supported. {@code YUV} input is always guaranteed.</th></tr>
<tr><th colspan=\"2\" id=\"rb\">Input</th><th colspan=\"2\" id=\"rb\">Target 1</th><th colspan=\"2\" id=\"rb\">Target 2</th><th colspan=\"2\" id=\"rb\">Target 3</th><th colspan=\"2\" id=\"rb\">Target 4</th><th colspan=\"2\" id=\"rb\">Target 5</th><th rowspan=\"2\">Sample use case(s)</th> </tr>
<tr><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th><th>Type</th><th id=\"rb\">Max size</th></tr>
<tr> <td>{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code 640x480}</td> <td>{@code RAW}</td><td id=\"rb\">{@code MAXIMUM}</td> <td></td><td id=\"rb\"></td> <td>In-app viewfinder analysis with ZSL and RAW.</td> </tr>
<tr> <td>{@code PRIV}/{@code YUV}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>Same as input</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code PREVIEW}</td> <td>{@code PRIV}</td><td id=\"rb\">{@code 640x480}</td> <td>{@code RAW}</td><td id=\"rb\">{@code MAXIMUM}</td> <td>{@code JPEG}</td><td id=\"rb\">{@code MAXIMUM}</td><td>In-app viewfinder analysis with ZSL, RAW, and JPEG reprocessing output.</td> </tr>
</table><br>
</p>

@param inputConfig The configuration for the input {@link Surface}
@param outputs The new set of Surfaces that should be made available as
               targets for captured image data.
@param callback The callback to notify about the status of the new capture session.
@param handler The handler on which the callback should be invoked, or {@code null} to use
               the current thread's {@link android.os.Looper looper}.

@throws IllegalArgumentException if the input configuration is null or not supported, the set
                                 of output Surfaces do not meet the requirements, the
                                 callback is null, or the handler is null but the current
                                 thread has no looper.
@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if the camera device has been closed

@see #createCaptureSession
@see CameraCaptureSession
@see StreamConfigurationMap#getInputFormats
@see StreamConfigurationMap#getInputSizes
@see StreamConfigurationMap#getValidOutputFormatsForInput
@see StreamConfigurationMap#getOutputSizes
@see android.media.ImageWriter
@see android.media.ImageReader
"
      end

      operation 79325239 "createReprocessableCaptureSessionByConfigurations"
	abstract public explicit_return_type "void"
	nparams 4
	  param inout name "inputConfig" type class_ref 7151415 // InputConfiguration
	  param inout name "outputs" explicit_type "List<OutputConfiguration>"
	  param inout name "callback" type class_ref 7148087 // StateCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, @NonNull ${t2} ${p2}, @Nullable ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Create a new reprocessable camera capture session by providing the desired reprocessing
input configuration and output {@link OutputConfiguration}
to the camera device.

@see #createReprocessableCaptureSession
@see OutputConfiguration

"
      end

      operation 79325367 "createConstrainedHighSpeedCaptureSession"
	abstract public explicit_return_type "void"
	nparams 3
	  param inout name "outputs" explicit_type "List<Surface>"
	  param inout name "callback" type class_ref 7148087 // StateCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, @Nullable ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "<p>Create a new constrained high speed capture session.</p>

<p>The application can use normal capture session (created via {@link #createCaptureSession})
for high speed capture if the desired high speed FPS ranges are advertised by
{@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES}, in which case all API
semantics associated with normal capture sessions applies.</p>

<p>The method creates a specialized capture session that is only targeted at high speed
video recording (>=120fps) use case if the camera device supports high speed video
capability (i.e., {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES} contains
{@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO}).
Therefore, it has special characteristics compared with a normal capture session:</p>

<ul>

<li>In addition to the output target Surface requirements specified by the
  {@link #createCaptureSession} method, an active high speed capture session will support up
  to 2 output Surfaces, though the application might choose to configure just one Surface
  (e.g., preview only). All Surfaces must be either video encoder surfaces (acquired by
  {@link android.media.MediaRecorder#getSurface} or
  {@link android.media.MediaCodec#createInputSurface}) or preview surfaces (obtained from
  {@link android.view.SurfaceView}, {@link android.graphics.SurfaceTexture} via
  {@link android.view.Surface#Surface(android.graphics.SurfaceTexture)}). The Surface sizes
  must be one of the sizes reported by {@link StreamConfigurationMap#getHighSpeedVideoSizes}.
  When multiple Surfaces are configured, their size must be same.</li>

<li>An active high speed capture session only accepts request lists created via
  {@link CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList}, and the
  request list can only be submitted to this session via
  {@link CameraCaptureSession#captureBurst captureBurst}, or
  {@link CameraCaptureSession#setRepeatingBurst setRepeatingBurst}.</li>

<li>The FPS ranges being requested to this session must be selected from
  {@link StreamConfigurationMap#getHighSpeedVideoFpsRangesFor}. The application can still use
  {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE} to control the desired FPS range.
  Switching to an FPS range that has different
  {@link android.util.Range#getUpper() maximum FPS} may trigger some camera device
  reconfigurations, which may introduce extra latency. It is recommended that the
  application avoids unnecessary maximum target FPS changes as much as possible during high
  speed streaming.</li>

<li>For the request lists submitted to this session, the camera device will override the
  {@link CaptureRequest#CONTROL_MODE control mode}, auto-exposure (AE), auto-white balance
  (AWB) and auto-focus (AF) to {@link CameraMetadata#CONTROL_MODE_AUTO},
  {@link CameraMetadata#CONTROL_AE_MODE_ON}, {@link CameraMetadata#CONTROL_AWB_MODE_AUTO}
  and {@link CameraMetadata#CONTROL_AF_MODE_CONTINUOUS_VIDEO}, respectively. All
  post-processing block mode controls will be overridden to be FAST. Therefore, no manual
  control of capture and post-processing parameters is possible. Beside these, only a subset
  of controls will work, see
  {@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO} for
  more details.</li>

</ul>

@param outputs The new set of Surfaces that should be made available as
               targets for captured high speed image data.
@param callback The callback to notify about the status of the new capture session.
@param handler The handler on which the callback should be invoked, or {@code null} to use
               the current thread's {@link android.os.Looper looper}.

@throws IllegalArgumentException if the set of output Surfaces do not meet the requirements,
                                 the callback is null, or the handler is null but the current
                                 thread has no looper, or the camera device doesn't support
                                 high speed video capability.
@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if the camera device has been closed

@see #createCaptureSession
@see CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE
@see StreamConfigurationMap#getHighSpeedVideoSizes
@see StreamConfigurationMap#getHighSpeedVideoFpsRangesFor
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO
@see CameraCaptureSession#captureBurst
@see CameraCaptureSession#setRepeatingBurst
@see CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList
"
      end

      operation 79325495 "createCaptureRequest"
	abstract public return_type class_ref 7151543 // Builder
	nparams 1
	  param in name "templateType" explicit_type "int"
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@RequestTemplate ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "<p>Create a {@link CaptureRequest.Builder} for new capture requests,
initialized with template for a target use case. The settings are chosen
to be the best options for the specific camera device, so it is not
recommended to reuse the same request for a different camera device;
create a builder specific for that device and template and override the
settings as desired, instead.</p>

@param templateType An enumeration selecting the use case for this
request; one of the CameraDevice.TEMPLATE_ values. Not all template
types are supported on every device. See the documentation for each
template type for details.
@return a builder for a capture request, initialized with default
settings for that template, and no output streams

@throws IllegalArgumentException if the templateType is not supported by
this device.
@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if the camera device has been closed

@see #TEMPLATE_PREVIEW
@see #TEMPLATE_RECORD
@see #TEMPLATE_STILL_CAPTURE
@see #TEMPLATE_VIDEO_SNAPSHOT
@see #TEMPLATE_MANUAL
"
      end

      operation 79325623 "createReprocessCaptureRequest"
	abstract public return_type class_ref 7151543 // Builder
	nparams 1
	  param inout name "inputResult" type class_ref 7148471 // TotalCaptureResult
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "<p>Create a {@link CaptureRequest.Builder} for a new reprocess {@link CaptureRequest} from a
{@link TotalCaptureResult}.

<p>Each reprocess {@link CaptureRequest} processes one buffer from
{@link CameraCaptureSession}'s input {@link Surface} to all output {@link Surface Surfaces}
included in the reprocess capture request. The reprocess input images must be generated from
one or multiple output images captured from the same camera device. The application can
provide input images to camera device via {@link android.media.ImageWriter#queueInputImage}.
The application must use the capture result of one of those output images to create a
reprocess capture request so that the camera device can use the information to achieve
optimal reprocess image quality. For camera devices that support only 1 output
{@link Surface}, submitting a reprocess {@link CaptureRequest} with multiple
output targets will result in a {@link CaptureFailure}.

@param inputResult The capture result of the output image or one of the output images used
                      to generate the reprocess input image for this capture request.

@throws IllegalArgumentException if inputResult is null.
@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if the camera device has been closed

@see CaptureRequest.Builder
@see TotalCaptureResult
@see CameraDevice#createReprocessableCaptureSession
@see android.media.ImageWriter
"
      end

      operation 79325751 "close"
	abstract public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "Close the connection to this camera device as quickly as possible.

<p>Immediately after this call, all calls to the camera device or active session interface
will throw a {@link IllegalStateException}, except for calls to close(). Once the device has
fully shut down, the {@link StateCallback#onClosed} callback will be called, and the camera
is free to be re-opened.</p>

<p>Immediately after this call, besides the final {@link StateCallback#onClosed} calls, no
further callbacks from the device or the active session will occur, and any remaining
submitted capture requests will be discarded, as if
{@link CameraCaptureSession#abortCaptures} had been called, except that no success or failure
callbacks will be invoked.</p>

"
      end

      class 7151671 "StateCallback"
	abstract visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	attribute 24799799 "ERROR_CAMERA_IN_USE"
	  class_attribute const_attribute public explicit_type "int"
	  init_value " 1"
	  cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "An error code that can be reported by {@link #onError}
indicating that the camera device is in use already.

<p>
This error can be produced when opening the camera fails due to the camera
 being used by a higher-priority camera API client.
</p>

@see #onError

"
	end

	attribute 24799927 "ERROR_MAX_CAMERAS_IN_USE"
	  class_attribute const_attribute public explicit_type "int"
	  init_value " 2"
	  cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "An error code that can be reported by {@link #onError}
indicating that the camera device could not be opened
because there are too many other open camera devices.

<p>
The system-wide limit for number of open cameras has been reached,
and more camera devices cannot be opened until previous instances are
closed.
</p>

<p>
This error can be produced when opening the camera fails.
</p>

@see #onError

"
	end

	attribute 24800055 "ERROR_CAMERA_DISABLED"
	  class_attribute const_attribute public explicit_type "int"
	  init_value " 3"
	  cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "An error code that can be reported by {@link #onError}
indicating that the camera device could not be opened due to a device
policy.

@see android.app.admin.DevicePolicyManager#setCameraDisabled(android.content.ComponentName, boolean)
@see #onError

"
	end

	attribute 24800183 "ERROR_CAMERA_DEVICE"
	  class_attribute const_attribute public explicit_type "int"
	  init_value " 4"
	  cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "An error code that can be reported by {@link #onError}
indicating that the camera device has encountered a fatal error.

<p>The camera device needs to be re-opened to be used again.</p>

@see #onError

"
	end

	attribute 24800311 "ERROR_CAMERA_SERVICE"
	  class_attribute const_attribute public explicit_type "int"
	  init_value " 5"
	  cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "An error code that can be reported by {@link #onError}
indicating that the camera service has encountered a fatal error.

<p>The Android device may need to be shut down and restarted to restore
camera function, or there may be a persistent hardware problem.</p>

<p>An attempt at recovery <i>may</i> be possible by closing the
CameraDevice and the CameraManager, and trying to acquire all resources
again from scratch.</p>

@see #onError

"
	end

	class 7151799 "ErrorCode"
	  visibility public stereotype "@interface"
	  cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	  java_decl "${comment}${@}${visibility}${static}@interface ${name}${extends} {
${members}}
"
	  java_annotation "@Retention(RetentionPolicy.SOURCE)
@IntDef(
            {ERROR_CAMERA_IN_USE,
             ERROR_MAX_CAMERAS_IN_USE,
             ERROR_CAMERA_DISABLED,
             ERROR_CAMERA_DEVICE,
             ERROR_CAMERA_SERVICE })
"
	  php_decl ""
	  python_2_2 python_decl ""
	  idl_decl ""
	  explicit_switch_type ""
	  mysql_decl ""
	  
	end

	operation 79325879 "onOpened"
	  abstract public explicit_return_type "void"
	  nparams 1
	    param inout name "camera" type class_ref 7147703 // CameraDevice
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "The method called when a camera device has finished opening.

<p>At this point, the camera device is ready to use, and
{@link CameraDevice#createCaptureSession} can be called to set up the first capture
session.</p>

@param camera the camera device that has become opened
"
	end

	operation 79326007 "onClosed"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "camera" type class_ref 7147703 // CameraDevice
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Must implement

The method called when a camera device has been closed with
{@link CameraDevice#close}.

<p>Any attempt to call methods on this CameraDevice in the
future will throw a {@link IllegalStateException}.</p>

<p>The default implementation of this method does nothing.</p>

@param camera the camera device that has become closed
"
	end

	operation 79326135 "onDisconnected"
	  abstract public explicit_return_type "void"
	  nparams 1
	    param inout name "camera" type class_ref 7147703 // CameraDevice
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "The method called when a camera device is no longer available for
use.

<p>This callback may be called instead of {@link #onOpened}
if opening the camera fails.</p>

<p>Any attempt to call methods on this CameraDevice will throw a
{@link CameraAccessException}. The disconnection could be due to a
change in security policy or permissions; the physical disconnection
of a removable camera device; or the camera being needed for a
higher-priority camera API client.</p>

<p>There may still be capture callbacks that are invoked
after this method is called, or new image buffers that are delivered
to active outputs.</p>

<p>The default implementation logs a notice to the system log
about the disconnection.</p>

<p>You should clean up the camera with {@link CameraDevice#close} after
this happens, as it is not recoverable until the camera can be opened
again. For most use cases, this will be when the camera again becomes
{@link CameraManager.AvailabilityCallback#onCameraAvailable available}.
</p>

@param camera the device that has been disconnected
"
	end

	operation 79326263 "onError"
	  abstract public explicit_return_type "void"
	  nparams 2
	    param inout name "camera" type class_ref 7147703 // CameraDevice
	    param in name "error" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @ErrorCode ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Must implement

The method called when a camera device has encountered a serious error.

<p>This callback may be called instead of {@link #onOpened}
if opening the camera fails.</p>

<p>This indicates a failure of the camera device or camera service in
some way. Any attempt to call methods on this CameraDevice in the
future will throw a {@link CameraAccessException} with the
{@link CameraAccessException#CAMERA_ERROR CAMERA_ERROR} reason.
</p>

<p>There may still be capture completion or camera stream callbacks
that will be called after this error is received.</p>

<p>You should clean up the camera with {@link CameraDevice#close} after
this happens. Further attempts at recovery are error-code specific.</p>

@param camera The device reporting the error
@param error The error code, one of the
    {@code StateCallback.ERROR_*} values.

@see #ERROR_CAMERA_IN_USE
@see #ERROR_MAX_CAMERAS_IN_USE
@see #ERROR_CAMERA_DISABLED
@see #ERROR_CAMERA_DEVICE
@see #ERROR_CAMERA_SERVICE
"
	end
      end

      class 7151927 "StateListener"
	abstract visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 15663287 // <generalisation>
	  relation 15663287 ---|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 15663287 // <generalisation>
	    b parent class_ref 7151671 // StateCallback
	end
      end

      operation 79326391 "CameraDevice"
	public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "To be inherited by android.hardware.camera2.* code only.
@hide
"
      end
    end

    class 7147831 "CaptureRequest"
      visibility public 
      nactuals 1
      actual class class_ref 7148983 // CameraMetadata
        rank 0 explicit_value ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      final java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "<p>An immutable package of settings and outputs needed to capture a single
image from the camera device.</p>

<p>Contains the configuration for the capture hardware (sensor, lens, flash),
the processing pipeline, the control algorithms, and the output buffers. Also
contains the list of target Surfaces to send image data to for this
capture.</p>

<p>CaptureRequests can be created by using a {@link Builder} instance,
obtained by calling {@link CameraDevice#createCaptureRequest}</p>

<p>CaptureRequests are given to {@link CameraCaptureSession#capture} or
{@link CameraCaptureSession#setRepeatingRequest} to capture images from a camera.</p>

<p>Each request can specify a different subset of target Surfaces for the
camera to send the captured data to. All the surfaces used in a request must
be part of the surface list given to the last call to
{@link CameraDevice#createCaptureSession}, when the request is submitted to the
session.</p>

<p>For example, a request meant for repeating preview might only include the
Surface for the preview SurfaceView or SurfaceTexture, while a
high-resolution still capture would also include a Surface from a ImageReader
configured for high-resolution JPEG images.</p>

<p>A reprocess capture request allows a previously-captured image from the camera device to be
sent back to the device for further processing. It can be created with
{@link CameraDevice#createReprocessCaptureRequest}, and used with a reprocessable capture session
created with {@link CameraDevice#createReprocessableCaptureSession}.</p>

@see CameraCaptureSession#capture
@see CameraCaptureSession#setRepeatingRequest
@see CameraCaptureSession#captureBurst
@see CameraCaptureSession#setRepeatingBurst
@see CameraDevice#createCaptureRequest
@see CameraDevice#createReprocessCaptureRequest
"
      class 7149623 "Key"
	visibility public 
	nformals 1
	formal name "T" type "" explicit_default_value ""
	  explicit_extends ""
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 15665719 // mKey (<unidirectional association>)
	  relation 15665719 --->
	    a role_name "mKey" const_relation private
	      cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<T> ${name}${value};
"
	      classrelation_ref 15665719 // mKey (<unidirectional association>)
	    b parent class_ref 7149367 // Key
	end

	operation 79332663 "Key"
	  cpp_inline public explicit_return_type ""
	  nparams 2
	    param inout name "name" explicit_type "String"
	    param inout name "type" explicit_type "Class"
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1}<T> ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Visible for testing and vendor extensions only.

@hide
"
	end

	operation 79332791 "Key"
	  cpp_inline public explicit_return_type ""
	  nparams 2
	    param inout name "name" explicit_type "String"
	    param inout name "typeReference" type class_ref 7149495 // TypeReference
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1}<T> ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Visible for testing and vendor extensions only.

@hide
"
	end

	operation 79332919 "getName"
	  cpp_inline public explicit_return_type "String"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@NonNull
"
	  
	  
	  
	  comment "Return a camelCase, period separated name formatted like:
{@code \"root.section[.subsections].name\"}.

<p>Built-in keys exposed by the Android SDK are always prefixed with {@code \"android.\"};
keys that are device/platform-specific are prefixed with {@code \"com.\"}.</p>

<p>For example, {@code CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP} would
have a name of {@code \"android.scaler.streamConfigurationMap\"}; whereas a device
specific key might look like {@code \"com.google.nexus.data.private\"}.</p>

@return String representation of the key name
"
	end

	operation 79333047 "hashCode"
	  cpp_inline public explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@Override
"
	  
	  
	  
	  comment "{@inheritDoc}
"
	end

	operation 79333175 "equals"
	  cpp_inline public explicit_return_type "boolean"
	  nparams 1
	    param inout name "o" explicit_type "Object"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@SuppressWarnings(\"unchecked\")
@Override
"
	  
	  
	  
	  comment "{@inheritDoc}
"
	end

	operation 79333303 "toString"
	  cpp_inline public explicit_return_type "String"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@NonNull
@Override
"
	  
	  
	  
	  comment "Return this {@link Key} as a string representation.

<p>{@code \"CaptureRequest.Key(%s)\"}, where {@code %s} represents
the name of this key as returned by {@link #getName}.</p>

@return string representation of {@link Key}
"
	end

	operation 79333431 "getNativeKey"
	  cpp_inline public return_type class_ref 7149367 // Key
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<T> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Visible for CameraMetadataNative implementation only; do not use.

TODO: Make this private or remove it altogether.

@hide
"
	end

	operation 79333559 "Key"
	  cpp_inline package explicit_return_type ""
	  nparams 1
	    param inout name "nativeKey" type class_ref 7149367 // Key
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0}<?> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@SuppressWarnings({ \"unchecked\" })
"
	  
	  
	  
	end
      end

      class 7151543 "Builder"
	visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 15666359 // mRequest (<unidirectional association>)
	  relation 15666359 --->
	    a role_name "mRequest" const_relation private
	      cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 15666359 // mRequest (<unidirectional association>)
	    b parent class_ref 7147831 // CaptureRequest
	end

	operation 79336247 "Builder"
	  public explicit_return_type ""
	  nparams 3
	    param inout name "template" type class_ref 7149239 // CameraMetadataNative
	    param inout name "reprocess" explicit_type "boolean"
	    param in name "reprocessableSessionId" explicit_type "int"
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Initialize the builder using the template; the request takes
ownership of the template.

@param template Template settings for this capture request.
@param reprocess Indicates whether to create a reprocess capture request. {@code true}
                 to create a reprocess capture request. {@code false} to create a regular
                 capture request.
@param reprocessableSessionId The ID of the camera capture session this capture is
                              created for. This is used to validate if the application
                              submits a reprocess capture request to the same session
                              where the {@link TotalCaptureResult}, used to create the
                              reprocess capture, came from.

@throws IllegalArgumentException If creating a reprocess capture request with an invalid
                                 reprocessableSessionId.
@hide
"
	end

	operation 79336375 "addTarget"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "outputTarget" type class_ref 6952247 // Surface
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "<p>Add a surface to the list of targets for this request</p>

<p>The Surface added must be one of the surfaces included in the most
recent call to {@link CameraDevice#createCaptureSession}, when the
request is given to the camera device.</p>

<p>Adding a target more than once has no effect.</p>

@param outputTarget Surface to use as an output target for this request
"
	end

	operation 79336503 "removeTarget"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "outputTarget" type class_ref 6952247 // Surface
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "<p>Remove a surface from the list of targets for this request.</p>

<p>Removing a target that is not currently added has no effect.</p>

@param outputTarget Surface to use as an output target for this request
"
	end

	operation 79336631 "set"
	  public explicit_return_type "void"
	  nparams 2
	    param inout name "key" type class_ref 7149623 // Key
	    param inout name "value" explicit_type "T"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}@NonNull ${t0}<T> ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Set a capture request field to a value. The field definitions can be
found in {@link CaptureRequest}.

<p>Setting a field to {@code null} will remove that field from the capture request.
Unless the field is optional, removing it will likely produce an error from the camera
device when the request is submitted.</p>

@param key The metadata field to write.
@param value The value to set the field to, which must be of a matching
type to the key.
"
	end

	operation 79336759 "get"
	  public explicit_return_type "T"
	  nparams 1
	    param inout name "key" type class_ref 7149623 // Key
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@Nullable
"
	  
	  
	  
	  comment "Get a capture request field value. The field definitions can be
found in {@link CaptureRequest}.

@throws IllegalArgumentException if the key was not valid

@param key The metadata field to read.
@return The value of that key, or {@code null} if the field is not set.
"
	end

	operation 79336887 "setTag"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "tag" explicit_type "Object"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@Nullable ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Set a tag for this request.

<p>This tag is not used for anything by the camera device, but can be
used by an application to easily identify a CaptureRequest when it is
returned by
{@link CameraCaptureSession.CaptureCallback#onCaptureCompleted CaptureCallback.onCaptureCompleted}

@param tag an arbitrary Object to store with this request
@see CaptureRequest#getTag
"
	end

	operation 79337015 "setPartOfCHSRequestList"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "partOfCHSList" explicit_type "boolean"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "<p>Mark this request as part of a constrained high speed request list created by
{@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList}.
A constrained high speed request list contains some constrained high speed capture
requests with certain interleaved pattern that is suitable for high speed preview/video
streaming.</p>

@hide
"
	end

	operation 79337143 "build"
	  public return_type class_ref 7147831 // CaptureRequest
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@NonNull
"
	  
	  
	  
	  comment "Build a request using the current target Surfaces and settings.
<p>Note that, although it is possible to create a {@code CaptureRequest} with no target
{@link Surface}s, passing such a request into {@link CameraCaptureSession#capture},
{@link CameraCaptureSession#captureBurst},
{@link CameraCaptureSession#setRepeatingBurst}, or
{@link CameraCaptureSession#setRepeatingRequest} will cause that method to throw an
{@link IllegalArgumentException}.</p>

@return A new capture request instance, ready for submission to the
camera device.
"
	end

	operation 79337271 "isEmpty"
	  public explicit_return_type "boolean"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "@hide
"
	end
      end

      classrelation 15665463 // <realization>
	relation 15665463 -_-|>
	  stereotype "bind"
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 15665463 // <realization>
	  b parent class_ref 7148983 // CameraMetadata
      end

      classrelation 15665591 // <realization>
	relation 15665591 -_-|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 15665591 // <realization>
	  b parent class_ref 6932663 // Parcelable
      end

      classrelation 15665847 // mSurfaceSet (<unidirectional association>)
	relation 15665847 --->
	  stereotype "HashSet"
	  a role_name "mSurfaceSet" const_relation private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${stereotype}<${type}> ${name}${value};
"
	    classrelation_ref 15665847 // mSurfaceSet (<unidirectional association>)
	  b parent class_ref 6952247 // Surface
      end

      classrelation 15665975 // mSettings (<unidirectional association>)
	relation 15665975 --->
	  a role_name "mSettings" const_relation private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 15665975 // mSettings (<unidirectional association>)
	  b parent class_ref 7149239 // CameraMetadataNative
      end

      attribute 24802359 "mIsReprocess"
	private explicit_type "boolean"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24802487 "mIsPartOfCHSRequestList"
	private explicit_type "boolean"
	init_value " false"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " If this request is part of constrained high speed request list that was created by
 {@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList}
"
      end

      attribute 24802615 "mReprocessableSessionId"
	private explicit_type "int"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Each reprocess request must be tied to a reprocessable session ID.
 Valid only for reprocess requests (mIsReprocess == true).
"
      end

      operation 79333687 "CaptureRequest"
	private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Construct empty request.

Used by Binder to unparcel this object only.
"
      end

      operation 79333815 "CaptureRequest"
	private explicit_return_type ""
	nparams 1
	  param inout name "source" type class_ref 7147831 // CaptureRequest
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings(\"unchecked\")
"
	
	
	
	comment "Clone from source capture request.

Used by the Builder to create an immutable copy.
"
      end

      operation 79333943 "CaptureRequest"
	private explicit_return_type ""
	nparams 3
	  param inout name "settings" type class_ref 7149239 // CameraMetadataNative
	  param inout name "isReprocess" explicit_type "boolean"
	  param in name "reprocessableSessionId" explicit_type "int"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Take ownership of passed-in settings.

Used by the Builder to create a mutable CaptureRequest.

@param settings Settings for this capture request.
@param isReprocess Indicates whether to create a reprocess capture request. {@code true}
                   to create a reprocess capture request. {@code false} to create a regular
                   capture request.
@param reprocessableSessionId The ID of the camera capture session this capture is created
                              for. This is used to validate if the application submits a
                              reprocess capture request to the same session where
                              the {@link TotalCaptureResult}, used to create the reprocess
                              capture, came from.

@throws IllegalArgumentException If creating a reprocess capture request with an invalid
                                 reprocessableSessionId.

@see CameraDevice#createReprocessCaptureRequest
"
      end

      operation 79334071 "get"
	public explicit_return_type "T"
	nparams 1
	  param inout name "key" type class_ref 7149623 // Key
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Nullable
"
	
	
	
	comment "Get a capture request field value.

<p>The field definitions can be found in {@link CaptureRequest}.</p>

<p>Querying the value for the same key more than once will return a value
which is equal to the previous queried value.</p>

@throws IllegalArgumentException if the key was not valid

@param key The result field to read.
@return The value of that key, or {@code null} if the field is not set.
"
      end

      operation 79334199 "getProtected"
	protected explicit_return_type "T"
	nparams 1
	  param inout name "key" type class_ref 7149623 // Key
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<?> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings(\"unchecked\")
@Override
"
	
	
	
	comment "{@inheritDoc}
@hide
"
      end

      operation 79334327 "getKeyClass"
	protected explicit_return_type "Class"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Key<?>> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings(\"unchecked\")
@Override
"
	
	
	
	comment "{@inheritDoc}
@hide
"
      end

      operation 79334455 "getKeys"
	public return_type class_ref 7149623 // Key
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}List<${type}<?>> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
@NonNull
"
	
	
	
	comment "{@inheritDoc}
"
      end

      operation 79334583 "getTag"
	public explicit_return_type "Object"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Nullable
"
	
	
	
	comment "Retrieve the tag for this request, if any.

<p>This tag is not used for anything by the camera device, but can be
used by an application to easily identify a CaptureRequest when it is
returned by
{@link CameraCaptureSession.CaptureCallback#onCaptureCompleted CaptureCallback.onCaptureCompleted}
</p>

@return the last tag Object set on this request, or {@code null} if
    no tag has been set.
@see Builder#setTag
"
      end

      operation 79334711 "isReprocess"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Determine if this is a reprocess capture request.

<p>A reprocess capture request produces output images from an input buffer from the
{@link CameraCaptureSession}'s input {@link Surface}. A reprocess capture request can be
created by {@link CameraDevice#createReprocessCaptureRequest}.</p>

@return {@code true} if this is a reprocess capture request. {@code false} if this is not a
reprocess capture request.

@see CameraDevice#createReprocessCaptureRequest
"
      end

      operation 79334839 "isPartOfCRequestList"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "<p>Determine if this request is part of a constrained high speed request list that was
created by
{@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList}.
A constrained high speed request list contains some constrained high speed capture requests
with certain interleaved pattern that is suitable for high speed preview/video streaming. An
active constrained high speed capture session only accepts constrained high speed request
lists.  This method can be used to do the sanity check when a constrained high speed capture
session receives a request list via {@link CameraCaptureSession#setRepeatingBurst} or
{@link CameraCaptureSession#captureBurst}.  </p>


@return {@code true} if this request is part of a constrained high speed request list,
{@code false} otherwise.

@hide
"
      end

      operation 79334967 "getNativeCopy"
	public return_type class_ref 7149239 // CameraMetadataNative
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a copy of the underlying {@link CameraMetadataNative}.
@hide
"
      end

      operation 79335095 "getReprocessableSessionId"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Get the reprocessable session ID this reprocess capture request is associated with.

@return the reprocessable session ID this reprocess capture request is associated with

@throws IllegalStateException if this capture request is not a reprocess capture request.
@hide
"
      end

      operation 79335223 "equals"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "other" explicit_type "Object"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "Determine whether this CaptureRequest is equal to another CaptureRequest.

<p>A request is considered equal to another is if it's set of key/values is equal, it's
list of output surfaces is equal, the user tag is equal, and the return values of
isReprocess() are equal.</p>

@param other Another instance of CaptureRequest.

@return True if the requests are the same, false otherwise.
"
      end

      operation 79335351 "equals"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "other" type class_ref 7147831 // CaptureRequest
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 79335479 "hashCode"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
      end

      classrelation 15666231 // CREATOR (<unidirectional association>)
	relation 15666231 --->
	  a role_name "CREATOR" init_value "
            new Parcelable.Creator<CaptureRequest>() {
        @Override
        public CaptureRequest createFromParcel(Parcel in) {
            CaptureRequest request = new CaptureRequest();
            request.readFromParcel(in);

            return request;
        }

        @Override
        public CaptureRequest[] newArray(int size) {
            return new CaptureRequest[size];
        }
    }" class_relation const_relation public
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<CaptureRequest> ${name}${value};
"
	    classrelation_ref 15666231 // CREATOR (<unidirectional association>)
	  b parent class_ref 6932791 // Creator
      end

      operation 79335607 "readFromParcel"
	private explicit_return_type "void"
	nparams 1
	  param inout name "in" type class_ref 6931895 // Parcel
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Expand this object from a Parcel.
Hidden since this breaks the immutability of CaptureRequest, but is
needed to receive CaptureRequests with aidl.

@param in The parcel from which the object should be read
@hide
"
      end

      operation 79335735 "describeContents"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
      end

      operation 79335863 "writeToParcel"
	public explicit_return_type "void"
	nparams 2
	  param inout name "dest" type class_ref 6931895 // Parcel
	  param in name "flags" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
      end

      operation 79335991 "containsTarget"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "surface" type class_ref 6952247 // Surface
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@hide
"
      end

      operation 79336119 "getTargets"
	public return_type class_ref 6952247 // Surface
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}Collection<${type}> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@hide
"
      end

      classrelation 15666487 // COLOR_CORRECTION_MODE (<unidirectional association>)
	relation 15666487 --->
	  a role_name "COLOR_CORRECTION_MODE" init_value "
            new Key<Integer>(\"android.colorCorrection.mode\", int.class)" class_relation const_relation public
	    comment "@O~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~
The key entries below this point are generated from metadata
definitions in /system/media/camera/docs. Do not modify by hand or
modify the comment blocks at the start or end.
~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~

<p>The mode control selects how the image data is converted from the
sensor's native color into linear sRGB color.</p>
<p>When auto-white balance (AWB) is enabled with {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, this
control is overridden by the AWB routine. When AWB is disabled, the
application controls how the color mapping is performed.</p>
<p>We define the expected processing pipeline below. For consistency
across devices, this is always the case with TRANSFORM_MATRIX.</p>
<p>When either FULL or HIGH_QUALITY is used, the camera device may
do additional processing but {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and
{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} will still be provided by the
camera device (in the results) and be roughly correct.</p>
<p>Switching to TRANSFORM_MATRIX and using the data provided from
FAST or HIGH_QUALITY will yield a picture with the same white point
as what was produced by the camera device in the earlier frame.</p>
<p>The expected processing pipeline is as follows:</p>
<p><img alt=\"White balance processing pipeline\" src=\"../../../../images/camera2/metadata/android.colorCorrection.mode/processing_pipeline.png\" /></p>
<p>The white balance is encoded by two values, a 4-channel white-balance
gain vector (applied in the Bayer domain), and a 3x3 color transform
matrix (applied after demosaic).</p>
<p>The 4-channel white-balance gains are defined as:</p>
<pre><code>{@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} = [ R G_even G_odd B ]
</code></pre>
<p>where <code>G_even</code> is the gain for green pixels on even rows of the
output, and <code>G_odd</code> is the gain for green pixels on the odd rows.
These may be identical for a given camera device implementation; if
the camera device does not support a separate gain for even/odd green
channels, it will use the <code>G_even</code> value, and write <code>G_odd</code> equal to
<code>G_even</code> in the output result metadata.</p>
<p>The matrices for color transforms are defined as a 9-entry vector:</p>
<pre><code>{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} = [ I0 I1 I2 I3 I4 I5 I6 I7 I8 ]
</code></pre>
<p>which define a transform from input sensor colors, <code>P_in = [ r g b ]</code>,
to output linear sRGB, <code>P_out = [ r' g' b' ]</code>,</p>
<p>with colors as follows:</p>
<pre><code>r' = I0r + I1g + I2b
g' = I3r + I4g + I5b
b' = I6r + I7g + I8b
</code></pre>
<p>Both the input and output value ranges must match. Overflow/underflow
values are clipped to fit within the range.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #COLOR_CORRECTION_MODE_TRANSFORM_MATRIX TRANSFORM_MATRIX}</li>
  <li>{@link #COLOR_CORRECTION_MODE_FAST FAST}</li>
  <li>{@link #COLOR_CORRECTION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see #COLOR_CORRECTION_MODE_TRANSFORM_MATRIX
@see #COLOR_CORRECTION_MODE_FAST
@see #COLOR_CORRECTION_MODE_HIGH_QUALITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15666487 // COLOR_CORRECTION_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15666615 // COLOR_CORRECTION_TRANSFORM (<unidirectional association>)
	relation 15666615 --->
	  a role_name "COLOR_CORRECTION_TRANSFORM" init_value "
            new Key<android.hardware.camera2.params.ColorSpaceTransform>(\"android.colorCorrection.transform\", android.hardware.camera2.params.ColorSpaceTransform.class)" class_relation const_relation public
	    comment "
<p>A color transform matrix to use to transform
from sensor RGB color space to output linear sRGB color space.</p>
<p>This matrix is either set by the camera device when the request
{@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is not TRANSFORM_MATRIX, or
directly by the application in the request when the
{@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is TRANSFORM_MATRIX.</p>
<p>In the latter case, the camera device may round the matrix to account
for precision issues; the final rounded matrix should be reported back
in this matrix result metadata. The transform should keep the magnitude
of the output color values within <code>[0, 1.0]</code> (assuming input color
values is within the normalized range <code>[0, 1.0]</code>), or clipping may occur.</p>
<p>The valid range of each matrix element varies on different devices, but
values within [-1.5, 3.0] are guaranteed not to be clipped.</p>
<p><b>Units</b>: Unitless scale factors</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#COLOR_CORRECTION_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.ColorSpaceTransform> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15666615 // COLOR_CORRECTION_TRANSFORM (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15666743 // COLOR_CORRECTION_GAINS (<unidirectional association>)
	relation 15666743 --->
	  a role_name "COLOR_CORRECTION_GAINS" init_value "
            new Key<android.hardware.camera2.params.RggbChannelVector>(\"android.colorCorrection.gains\", android.hardware.camera2.params.RggbChannelVector.class)" class_relation const_relation public
	    comment "
<p>Gains applying to Bayer raw color channels for
white-balance.</p>
<p>These per-channel gains are either set by the camera device
when the request {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is not
TRANSFORM_MATRIX, or directly by the application in the
request when the {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is
TRANSFORM_MATRIX.</p>
<p>The gains in the result metadata are the gains actually
applied by the camera device to the current frame.</p>
<p>The valid range of gains varies on different devices, but gains
between [1.0, 3.0] are guaranteed not to be clipped. Even if a given
device allows gains below 1.0, this is usually not recommended because
this can create color artifacts.</p>
<p><b>Units</b>: Unitless gain factors</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#COLOR_CORRECTION_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.RggbChannelVector> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15666743 // COLOR_CORRECTION_GAINS (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15666871 // COLOR_CORRECTION_ABERRATION_MODE (<unidirectional association>)
	relation 15666871 --->
	  a role_name "COLOR_CORRECTION_ABERRATION_MODE" init_value "
            new Key<Integer>(\"android.colorCorrection.aberrationMode\", int.class)" class_relation const_relation public
	    comment "
<p>Mode of operation for the chromatic aberration correction algorithm.</p>
<p>Chromatic (color) aberration is caused by the fact that different wavelengths of light
can not focus on the same point after exiting from the lens. This metadata defines
the high level control of chromatic aberration correction algorithm, which aims to
minimize the chromatic artifacts that may occur along the object boundaries in an
image.</p>
<p>FAST/HIGH_QUALITY both mean that camera device determined aberration
correction will be applied. HIGH_QUALITY mode indicates that the camera device will
use the highest-quality aberration correction algorithms, even if it slows down
capture rate. FAST means the camera device will not slow down capture rate when
applying aberration correction.</p>
<p>LEGACY devices will always be in FAST mode.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_OFF OFF}</li>
  <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_FAST FAST}</li>
  <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES android.colorCorrection.availableAberrationModes}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES
@see #COLOR_CORRECTION_ABERRATION_MODE_OFF
@see #COLOR_CORRECTION_ABERRATION_MODE_FAST
@see #COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15666871 // COLOR_CORRECTION_ABERRATION_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15666999 // CONTROL_AE_ANTIBANDING_MODE (<unidirectional association>)
	relation 15666999 --->
	  a role_name "CONTROL_AE_ANTIBANDING_MODE" init_value "
            new Key<Integer>(\"android.control.aeAntibandingMode\", int.class)" class_relation const_relation public
	    comment "
<p>The desired setting for the camera device's auto-exposure
algorithm's antibanding compensation.</p>
<p>Some kinds of lighting fixtures, such as some fluorescent
lights, flicker at the rate of the power supply frequency
(60Hz or 50Hz, depending on country). While this is
typically not noticeable to a person, it can be visible to
a camera device. If a camera sets its exposure time to the
wrong value, the flicker may become visible in the
viewfinder as flicker or in a final captured image, as a
set of variable-brightness bands across the image.</p>
<p>Therefore, the auto-exposure routines of camera devices
include antibanding routines that ensure that the chosen
exposure value will not cause such banding. The choice of
exposure time depends on the rate of flicker, which the
camera device can detect automatically, or the expected
rate can be selected by the application using this
control.</p>
<p>A given camera device may not support all of the possible
options for the antibanding mode. The
{@link CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES android.control.aeAvailableAntibandingModes} key contains
the available modes for a given camera device.</p>
<p>AUTO mode is the default if it is available on given
camera device. When AUTO mode is not available, the
default will be either 50HZ or 60HZ, and both 50HZ
and 60HZ will be available.</p>
<p>If manual exposure control is enabled (by setting
{@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} to OFF),
then this setting has no effect, and the application must
ensure it selects exposure times that do not cause banding
issues. The {@link CaptureResult#STATISTICS_SCENE_FLICKER android.statistics.sceneFlicker} key can assist
the application in this.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AE_ANTIBANDING_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_AE_ANTIBANDING_MODE_50HZ 50HZ}</li>
  <li>{@link #CONTROL_AE_ANTIBANDING_MODE_60HZ 60HZ}</li>
  <li>{@link #CONTROL_AE_ANTIBANDING_MODE_AUTO AUTO}</li>
</ul></p>
<p><b>Available values for this device:</b><br></p>
<p>{@link CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES android.control.aeAvailableAntibandingModes}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES
@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CaptureResult#STATISTICS_SCENE_FLICKER
@see #CONTROL_AE_ANTIBANDING_MODE_OFF
@see #CONTROL_AE_ANTIBANDING_MODE_50HZ
@see #CONTROL_AE_ANTIBANDING_MODE_60HZ
@see #CONTROL_AE_ANTIBANDING_MODE_AUTO

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15666999 // CONTROL_AE_ANTIBANDING_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15667127 // CONTROL_AE_EXPOSURE_COMPENSATION (<unidirectional association>)
	relation 15667127 --->
	  a role_name "CONTROL_AE_EXPOSURE_COMPENSATION" init_value "
            new Key<Integer>(\"android.control.aeExposureCompensation\", int.class)" class_relation const_relation public
	    comment "
<p>Adjustment to auto-exposure (AE) target image
brightness.</p>
<p>The adjustment is measured as a count of steps, with the
step size defined by {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP android.control.aeCompensationStep} and the
allowed range by {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE android.control.aeCompensationRange}.</p>
<p>For example, if the exposure value (EV) step is 0.333, '6'
will mean an exposure compensation of +2 EV; -3 will mean an
exposure compensation of -1 EV. One EV represents a doubling
of image brightness. Note that this control will only be
effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} <code>!=</code> OFF. This control
will take effect even when {@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} <code>== true</code>.</p>
<p>In the event of exposure compensation value being changed, camera device
may take several frames to reach the newly requested exposure target.
During that time, {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} field will be in the SEARCHING
state. Once the new exposure target is reached, {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} will
change from SEARCHING to either CONVERGED, LOCKED (if AE lock is enabled), or
FLASH_REQUIRED (if the scene is too dark for still capture).</p>
<p><b>Units</b>: Compensation steps</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE android.control.aeCompensationRange}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE
@see CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP
@see CaptureRequest#CONTROL_AE_LOCK
@see CaptureRequest#CONTROL_AE_MODE
@see CaptureResult#CONTROL_AE_STATE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15667127 // CONTROL_AE_EXPOSURE_COMPENSATION (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15667255 // CONTROL_AE_LOCK (<unidirectional association>)
	relation 15667255 --->
	  a role_name "CONTROL_AE_LOCK" init_value "
            new Key<Boolean>(\"android.control.aeLock\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether auto-exposure (AE) is currently locked to its latest
calculated values.</p>
<p>When set to <code>true</code> (ON), the AE algorithm is locked to its latest parameters,
and will not change exposure settings until the lock is set to <code>false</code> (OFF).</p>
<p>Note that even when AE is locked, the flash may be fired if
the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is ON_AUTO_FLASH /
ON_ALWAYS_FLASH / ON_AUTO_FLASH_REDEYE.</p>
<p>When {@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation} is changed, even if the AE lock
is ON, the camera device will still adjust its exposure value.</p>
<p>If AE precapture is triggered (see {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger})
when AE is already locked, the camera device will not change the exposure time
({@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime}) and sensitivity ({@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity})
parameters. The flash may be fired if the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}
is ON_AUTO_FLASH/ON_AUTO_FLASH_REDEYE and the scene is too dark. If the
{@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is ON_ALWAYS_FLASH, the scene may become overexposed.
Similarly, AE precapture trigger CANCEL has no effect when AE is already locked.</p>
<p>When an AE precapture sequence is triggered, AE unlock will not be able to unlock
the AE if AE is locked by the camera device internally during precapture metering
sequence In other words, submitting requests with AE unlock has no effect for an
ongoing precapture metering sequence. Otherwise, the precapture metering sequence
will never succeed in a sequence of preview requests where AE lock is always set
to <code>false</code>.</p>
<p>Since the camera device has a pipeline of in-flight requests, the settings that
get locked do not necessarily correspond to the settings that were present in the
latest capture result received from the camera device, since additional captures
and AE updates may have occurred even before the result was sent out. If an
application is switching between automatic and manual control and wishes to eliminate
any flicker during the switch, the following procedure is recommended:</p>
<ol>
<li>Starting in auto-AE mode:</li>
<li>Lock AE</li>
<li>Wait for the first result to be output that has the AE locked</li>
<li>Copy exposure settings from that result into a request, set the request to manual AE</li>
<li>Submit the capture request, proceed to run manual AE as desired.</li>
</ol>
<p>See {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} for AE lock related state transition details.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION
@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureResult#CONTROL_AE_STATE
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15667255 // CONTROL_AE_LOCK (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15667383 // CONTROL_AE_MODE (<unidirectional association>)
	relation 15667383 --->
	  a role_name "CONTROL_AE_MODE" init_value "
            new Key<Integer>(\"android.control.aeMode\", int.class)" class_relation const_relation public
	    comment "
<p>The desired mode for the camera device's
auto-exposure routine.</p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} is
AUTO.</p>
<p>When set to any of the ON modes, the camera device's
auto-exposure routine is enabled, overriding the
application's selected exposure time, sensor sensitivity,
and frame duration ({@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},
{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, and
{@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}). If one of the FLASH modes
is selected, the camera device's flash unit controls are
also overridden.</p>
<p>The FLASH modes are only available if the camera device
has a flash unit ({@link CameraCharacteristics#FLASH_INFO_AVAILABLE android.flash.info.available} is <code>true</code>).</p>
<p>If flash TORCH mode is desired, this field must be set to
ON or OFF, and {@link CaptureRequest#FLASH_MODE android.flash.mode} set to TORCH.</p>
<p>When set to any of the ON modes, the values chosen by the
camera device auto-exposure routine for the overridden
fields for a given capture will be available in its
CaptureResult.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AE_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_AE_MODE_ON ON}</li>
  <li>{@link #CONTROL_AE_MODE_ON_AUTO_FLASH ON_AUTO_FLASH}</li>
  <li>{@link #CONTROL_AE_MODE_ON_ALWAYS_FLASH ON_ALWAYS_FLASH}</li>
  <li>{@link #CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE ON_AUTO_FLASH_REDEYE}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES android.control.aeAvailableModes}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#FLASH_INFO_AVAILABLE
@see CaptureRequest#FLASH_MODE
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_FRAME_DURATION
@see CaptureRequest#SENSOR_SENSITIVITY
@see #CONTROL_AE_MODE_OFF
@see #CONTROL_AE_MODE_ON
@see #CONTROL_AE_MODE_ON_AUTO_FLASH
@see #CONTROL_AE_MODE_ON_ALWAYS_FLASH
@see #CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15667383 // CONTROL_AE_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15667511 // CONTROL_AE_REGIONS (<unidirectional association>)
	relation 15667511 --->
	  a role_name "CONTROL_AE_REGIONS" init_value "
            new Key<android.hardware.camera2.params.MeteringRectangle[]>(\"android.control.aeRegions\", android.hardware.camera2.params.MeteringRectangle[].class)" class_relation const_relation public
	    comment "
<p>List of metering areas to use for auto-exposure adjustment.</p>
<p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AE android.control.maxRegionsAe} is 0.
Otherwise will always be present.</p>
<p>The maximum number of regions supported by the device is determined by the value
of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AE android.control.maxRegionsAe}.</p>
<p>The coordinate system is based on the active pixel array,
with (0,0) being the top-left pixel in the active pixel array, and
({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the
bottom-right pixel in the active pixel array.</p>
<p>The weight must be within <code>[0, 1000]</code>, and represents a weight
for every pixel in the area. This means that a large metering area
with the same weight as a smaller area will have more effect in
the metering result. Metering areas can partially overlap and the
camera device will add the weights in the overlap region.</p>
<p>The weights are relative to weights of other exposure metering regions, so if only one
region is used, all non-zero weights will have the same effect. A region with 0
weight is ignored.</p>
<p>If all regions have 0 weight, then no specific metering area needs to be used by the
camera device.</p>
<p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in
capture result metadata, the camera device will ignore the sections outside the crop
region and output only the intersection rectangle as the metering region in the result
metadata.  If the region is entirely outside the crop region, it will be ignored and
not reported in the result metadata.</p>
<p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Range of valid values:</b><br>
Coordinates must be between <code>[(0,0), (width, height))</code> of
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#CONTROL_MAX_REGIONS_AE
@see CaptureRequest#SCALER_CROP_REGION
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.MeteringRectangle[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15667511 // CONTROL_AE_REGIONS (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15667639 // CONTROL_AE_TARGET_FPS_RANGE (<unidirectional association>)
	relation 15667639 --->
	  a role_name "CONTROL_AE_TARGET_FPS_RANGE" init_value "
            new Key<android.util.Range<Integer>>(\"android.control.aeTargetFpsRange\", new TypeReference<android.util.Range<Integer>>() {{ }})" class_relation const_relation public
	    comment "
<p>Range over which the auto-exposure routine can
adjust the capture frame rate to maintain good
exposure.</p>
<p>Only constrains auto-exposure (AE) algorithm, not
manual control of {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime} and
{@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}.</p>
<p><b>Units</b>: Frames per second (FPS)</p>
<p><b>Range of valid values:</b><br>
Any of the entries in {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_FRAME_DURATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Range<Integer>> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15667639 // CONTROL_AE_TARGET_FPS_RANGE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15667767 // CONTROL_AE_PRECAPTURE_TRIGGER (<unidirectional association>)
	relation 15667767 --->
	  a role_name "CONTROL_AE_PRECAPTURE_TRIGGER" init_value "
            new Key<Integer>(\"android.control.aePrecaptureTrigger\", int.class)" class_relation const_relation public
	    comment "
<p>Whether the camera device will trigger a precapture
metering sequence when it processes this request.</p>
<p>This entry is normally set to IDLE, or is not
included at all in the request settings. When included and
set to START, the camera device will trigger the auto-exposure (AE)
precapture metering sequence.</p>
<p>When set to CANCEL, the camera device will cancel any active
precapture metering trigger, and return to its initial AE state.
If a precapture metering sequence is already completed, and the camera
device has implicitly locked the AE for subsequent still capture, the
CANCEL trigger will unlock the AE and return to its initial AE state.</p>
<p>The precapture sequence should be triggered before starting a
high-quality still capture for final metering decisions to
be made, and for firing pre-capture flash pulses to estimate
scene brightness and required final capture flash power, when
the flash is enabled.</p>
<p>Normally, this entry should be set to START for only a
single request, and the application should wait until the
sequence completes before starting a new one.</p>
<p>When a precapture metering sequence is finished, the camera device
may lock the auto-exposure routine internally to be able to accurately expose the
subsequent still capture image (<code>{@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} == STILL_CAPTURE</code>).
For this case, the AE may not resume normal scan if no subsequent still capture is
submitted. To ensure that the AE routine restarts normal scan, the application should
submit a request with <code>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} == true</code>, followed by a request
with <code>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} == false</code>, if the application decides not to submit a
still capture request after the precapture sequence completes. Alternatively, for
API level 23 or newer devices, the CANCEL can be used to unlock the camera device
internally locked AE if the application doesn't submit a still capture request after
the AE precapture trigger. Note that, the CANCEL was added in API level 23, and must not
be used in devices that have earlier API levels.</p>
<p>The exact effect of auto-exposure (AE) precapture trigger
depends on the current AE mode and state; see
{@link CaptureResult#CONTROL_AE_STATE android.control.aeState} for AE precapture state transition
details.</p>
<p>On LEGACY-level devices, the precapture trigger is not supported;
capturing a high-resolution JPEG image will automatically trigger a
precapture sequence before the high-resolution capture, including
potentially firing a pre-capture flash.</p>
<p>Using the precapture trigger and the auto-focus trigger {@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}
simultaneously is allowed. However, since these triggers often require cooperation between
the auto-focus and auto-exposure routines (for example, the may need to be enabled for a
focus sweep), the camera device may delay acting on a later trigger until the previous
trigger has been fully handled. This may lead to longer intervals between the trigger and
changes to {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} indicating the start of the precapture sequence, for
example.</p>
<p>If both the precapture and the auto-focus trigger are activated on the same request, then
the camera device will complete them in the optimal order for that device.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_IDLE IDLE}</li>
  <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_START START}</li>
  <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL CANCEL}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_LOCK
@see CaptureResult#CONTROL_AE_STATE
@see CaptureRequest#CONTROL_AF_TRIGGER
@see CaptureRequest#CONTROL_CAPTURE_INTENT
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see #CONTROL_AE_PRECAPTURE_TRIGGER_IDLE
@see #CONTROL_AE_PRECAPTURE_TRIGGER_START
@see #CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15667767 // CONTROL_AE_PRECAPTURE_TRIGGER (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15667895 // CONTROL_AF_MODE (<unidirectional association>)
	relation 15667895 --->
	  a role_name "CONTROL_AF_MODE" init_value "
            new Key<Integer>(\"android.control.afMode\", int.class)" class_relation const_relation public
	    comment "
<p>Whether auto-focus (AF) is currently enabled, and what
mode it is set to.</p>
<p>Only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} = AUTO and the lens is not fixed focus
(i.e. <code>{@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance} &gt; 0</code>). Also note that
when {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is OFF, the behavior of AF is device
dependent. It is recommended to lock AF by using {@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger} before
setting {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} to OFF, or set AF mode to OFF when AE is OFF.</p>
<p>If the lens is controlled by the camera device auto-focus algorithm,
the camera device will report the current AF status in {@link CaptureResult#CONTROL_AF_STATE android.control.afState}
in result metadata.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AF_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_AF_MODE_AUTO AUTO}</li>
  <li>{@link #CONTROL_AF_MODE_MACRO MACRO}</li>
  <li>{@link #CONTROL_AF_MODE_CONTINUOUS_VIDEO CONTINUOUS_VIDEO}</li>
  <li>{@link #CONTROL_AF_MODE_CONTINUOUS_PICTURE CONTINUOUS_PICTURE}</li>
  <li>{@link #CONTROL_AF_MODE_EDOF EDOF}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AF_AVAILABLE_MODES android.control.afAvailableModes}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CameraCharacteristics#CONTROL_AF_AVAILABLE_MODES
@see CaptureResult#CONTROL_AF_STATE
@see CaptureRequest#CONTROL_AF_TRIGGER
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE
@see #CONTROL_AF_MODE_OFF
@see #CONTROL_AF_MODE_AUTO
@see #CONTROL_AF_MODE_MACRO
@see #CONTROL_AF_MODE_CONTINUOUS_VIDEO
@see #CONTROL_AF_MODE_CONTINUOUS_PICTURE
@see #CONTROL_AF_MODE_EDOF

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15667895 // CONTROL_AF_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15668023 // CONTROL_AF_REGIONS (<unidirectional association>)
	relation 15668023 --->
	  a role_name "CONTROL_AF_REGIONS" init_value "
            new Key<android.hardware.camera2.params.MeteringRectangle[]>(\"android.control.afRegions\", android.hardware.camera2.params.MeteringRectangle[].class)" class_relation const_relation public
	    comment "
<p>List of metering areas to use for auto-focus.</p>
<p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AF android.control.maxRegionsAf} is 0.
Otherwise will always be present.</p>
<p>The maximum number of focus areas supported by the device is determined by the value
of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AF android.control.maxRegionsAf}.</p>
<p>The coordinate system is based on the active pixel array,
with (0,0) being the top-left pixel in the active pixel array, and
({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the
bottom-right pixel in the active pixel array.</p>
<p>The weight must be within <code>[0, 1000]</code>, and represents a weight
for every pixel in the area. This means that a large metering area
with the same weight as a smaller area will have more effect in
the metering result. Metering areas can partially overlap and the
camera device will add the weights in the overlap region.</p>
<p>The weights are relative to weights of other metering regions, so if only one region
is used, all non-zero weights will have the same effect. A region with 0 weight is
ignored.</p>
<p>If all regions have 0 weight, then no specific metering area needs to be used by the
camera device.</p>
<p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in
capture result metadata, the camera device will ignore the sections outside the crop
region and output only the intersection rectangle as the metering region in the result
metadata. If the region is entirely outside the crop region, it will be ignored and
not reported in the result metadata.</p>
<p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Range of valid values:</b><br>
Coordinates must be between <code>[(0,0), (width, height))</code> of
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#CONTROL_MAX_REGIONS_AF
@see CaptureRequest#SCALER_CROP_REGION
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.MeteringRectangle[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15668023 // CONTROL_AF_REGIONS (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15668151 // CONTROL_AF_TRIGGER (<unidirectional association>)
	relation 15668151 --->
	  a role_name "CONTROL_AF_TRIGGER" init_value "
            new Key<Integer>(\"android.control.afTrigger\", int.class)" class_relation const_relation public
	    comment "
<p>Whether the camera device will trigger autofocus for this request.</p>
<p>This entry is normally set to IDLE, or is not
included at all in the request settings.</p>
<p>When included and set to START, the camera device will trigger the
autofocus algorithm. If autofocus is disabled, this trigger has no effect.</p>
<p>When set to CANCEL, the camera device will cancel any active trigger,
and return to its initial AF state.</p>
<p>Generally, applications should set this entry to START or CANCEL for only a
single capture, and then return it to IDLE (or not set at all). Specifying
START for multiple captures in a row means restarting the AF operation over
and over again.</p>
<p>See {@link CaptureResult#CONTROL_AF_STATE android.control.afState} for what the trigger means for each AF mode.</p>
<p>Using the autofocus trigger and the precapture trigger {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}
simultaneously is allowed. However, since these triggers often require cooperation between
the auto-focus and auto-exposure routines (for example, the may need to be enabled for a
focus sweep), the camera device may delay acting on a later trigger until the previous
trigger has been fully handled. This may lead to longer intervals between the trigger and
changes to {@link CaptureResult#CONTROL_AF_STATE android.control.afState}, for example.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AF_TRIGGER_IDLE IDLE}</li>
  <li>{@link #CONTROL_AF_TRIGGER_START START}</li>
  <li>{@link #CONTROL_AF_TRIGGER_CANCEL CANCEL}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureResult#CONTROL_AF_STATE
@see #CONTROL_AF_TRIGGER_IDLE
@see #CONTROL_AF_TRIGGER_START
@see #CONTROL_AF_TRIGGER_CANCEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15668151 // CONTROL_AF_TRIGGER (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15668279 // CONTROL_AWB_LOCK (<unidirectional association>)
	relation 15668279 --->
	  a role_name "CONTROL_AWB_LOCK" init_value "
            new Key<Boolean>(\"android.control.awbLock\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether auto-white balance (AWB) is currently locked to its
latest calculated values.</p>
<p>When set to <code>true</code> (ON), the AWB algorithm is locked to its latest parameters,
and will not change color balance settings until the lock is set to <code>false</code> (OFF).</p>
<p>Since the camera device has a pipeline of in-flight requests, the settings that
get locked do not necessarily correspond to the settings that were present in the
latest capture result received from the camera device, since additional captures
and AWB updates may have occurred even before the result was sent out. If an
application is switching between automatic and manual control and wishes to eliminate
any flicker during the switch, the following procedure is recommended:</p>
<ol>
<li>Starting in auto-AWB mode:</li>
<li>Lock AWB</li>
<li>Wait for the first result to be output that has the AWB locked</li>
<li>Copy AWB settings from that result into a request, set the request to manual AWB</li>
<li>Submit the capture request, proceed to run manual AWB as desired.</li>
</ol>
<p>Note that AWB lock is only meaningful when
{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} is in the AUTO mode; in other modes,
AWB is already fixed to a specific setting.</p>
<p>Some LEGACY devices may not support ON; the value is then overridden to OFF.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AWB_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15668279 // CONTROL_AWB_LOCK (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15668407 // CONTROL_AWB_MODE (<unidirectional association>)
	relation 15668407 --->
	  a role_name "CONTROL_AWB_MODE" init_value "
            new Key<Integer>(\"android.control.awbMode\", int.class)" class_relation const_relation public
	    comment "
<p>Whether auto-white balance (AWB) is currently setting the color
transform fields, and what its illumination target
is.</p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} is AUTO.</p>
<p>When set to the ON mode, the camera device's auto-white balance
routine is enabled, overriding the application's selected
{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}, {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and
{@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode}. Note that when {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}
is OFF, the behavior of AWB is device dependent. It is recommened to
also set AWB mode to OFF or lock AWB by using {@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} before
setting AE mode to OFF.</p>
<p>When set to the OFF mode, the camera device's auto-white balance
routine is disabled. The application manually controls the white
balance by {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}, {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains}
and {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode}.</p>
<p>When set to any other modes, the camera device's auto-white
balance routine is disabled. The camera device uses each
particular illumination target for white balance
adjustment. The application's values for
{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform},
{@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and
{@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} are ignored.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AWB_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_AWB_MODE_AUTO AUTO}</li>
  <li>{@link #CONTROL_AWB_MODE_INCANDESCENT INCANDESCENT}</li>
  <li>{@link #CONTROL_AWB_MODE_FLUORESCENT FLUORESCENT}</li>
  <li>{@link #CONTROL_AWB_MODE_WARM_FLUORESCENT WARM_FLUORESCENT}</li>
  <li>{@link #CONTROL_AWB_MODE_DAYLIGHT DAYLIGHT}</li>
  <li>{@link #CONTROL_AWB_MODE_CLOUDY_DAYLIGHT CLOUDY_DAYLIGHT}</li>
  <li>{@link #CONTROL_AWB_MODE_TWILIGHT TWILIGHT}</li>
  <li>{@link #CONTROL_AWB_MODE_SHADE SHADE}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AWB_AVAILABLE_MODES android.control.awbAvailableModes}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_MODE
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AE_MODE
@see CameraCharacteristics#CONTROL_AWB_AVAILABLE_MODES
@see CaptureRequest#CONTROL_AWB_LOCK
@see CaptureRequest#CONTROL_MODE
@see #CONTROL_AWB_MODE_OFF
@see #CONTROL_AWB_MODE_AUTO
@see #CONTROL_AWB_MODE_INCANDESCENT
@see #CONTROL_AWB_MODE_FLUORESCENT
@see #CONTROL_AWB_MODE_WARM_FLUORESCENT
@see #CONTROL_AWB_MODE_DAYLIGHT
@see #CONTROL_AWB_MODE_CLOUDY_DAYLIGHT
@see #CONTROL_AWB_MODE_TWILIGHT
@see #CONTROL_AWB_MODE_SHADE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15668407 // CONTROL_AWB_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15668535 // CONTROL_AWB_REGIONS (<unidirectional association>)
	relation 15668535 --->
	  a role_name "CONTROL_AWB_REGIONS" init_value "
            new Key<android.hardware.camera2.params.MeteringRectangle[]>(\"android.control.awbRegions\", android.hardware.camera2.params.MeteringRectangle[].class)" class_relation const_relation public
	    comment "
<p>List of metering areas to use for auto-white-balance illuminant
estimation.</p>
<p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AWB android.control.maxRegionsAwb} is 0.
Otherwise will always be present.</p>
<p>The maximum number of regions supported by the device is determined by the value
of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AWB android.control.maxRegionsAwb}.</p>
<p>The coordinate system is based on the active pixel array,
with (0,0) being the top-left pixel in the active pixel array, and
({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the
bottom-right pixel in the active pixel array.</p>
<p>The weight must range from 0 to 1000, and represents a weight
for every pixel in the area. This means that a large metering area
with the same weight as a smaller area will have more effect in
the metering result. Metering areas can partially overlap and the
camera device will add the weights in the overlap region.</p>
<p>The weights are relative to weights of other white balance metering regions, so if
only one region is used, all non-zero weights will have the same effect. A region with
0 weight is ignored.</p>
<p>If all regions have 0 weight, then no specific metering area needs to be used by the
camera device.</p>
<p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in
capture result metadata, the camera device will ignore the sections outside the crop
region and output only the intersection rectangle as the metering region in the result
metadata.  If the region is entirely outside the crop region, it will be ignored and
not reported in the result metadata.</p>
<p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Range of valid values:</b><br>
Coordinates must be between <code>[(0,0), (width, height))</code> of
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#CONTROL_MAX_REGIONS_AWB
@see CaptureRequest#SCALER_CROP_REGION
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.MeteringRectangle[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15668535 // CONTROL_AWB_REGIONS (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15668663 // CONTROL_CAPTURE_INTENT (<unidirectional association>)
	relation 15668663 --->
	  a role_name "CONTROL_CAPTURE_INTENT" init_value "
            new Key<Integer>(\"android.control.captureIntent\", int.class)" class_relation const_relation public
	    comment "
<p>Information to the camera device 3A (auto-exposure,
auto-focus, auto-white balance) routines about the purpose
of this capture, to help the camera device to decide optimal 3A
strategy.</p>
<p>This control (except for MANUAL) is only effective if
<code>{@link CaptureRequest#CONTROL_MODE android.control.mode} != OFF</code> and any 3A routine is active.</p>
<p>ZERO_SHUTTER_LAG will be supported if {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities}
contains PRIVATE_REPROCESSING or YUV_REPROCESSING. MANUAL will be supported if
{@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains MANUAL_SENSOR. Other intent values are
always supported.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_CAPTURE_INTENT_CUSTOM CUSTOM}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_PREVIEW PREVIEW}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_STILL_CAPTURE STILL_CAPTURE}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_VIDEO_RECORD VIDEO_RECORD}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT VIDEO_SNAPSHOT}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_MANUAL MANUAL}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see #CONTROL_CAPTURE_INTENT_CUSTOM
@see #CONTROL_CAPTURE_INTENT_PREVIEW
@see #CONTROL_CAPTURE_INTENT_STILL_CAPTURE
@see #CONTROL_CAPTURE_INTENT_VIDEO_RECORD
@see #CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT
@see #CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG
@see #CONTROL_CAPTURE_INTENT_MANUAL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15668663 // CONTROL_CAPTURE_INTENT (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15668791 // CONTROL_EFFECT_MODE (<unidirectional association>)
	relation 15668791 --->
	  a role_name "CONTROL_EFFECT_MODE" init_value "
            new Key<Integer>(\"android.control.effectMode\", int.class)" class_relation const_relation public
	    comment "
<p>A special color effect to apply.</p>
<p>When this mode is set, a color effect will be applied
to images produced by the camera device. The interpretation
and implementation of these color effects is left to the
implementor of the camera device, and should not be
depended on to be consistent (or present) across all
devices.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_EFFECT_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_EFFECT_MODE_MONO MONO}</li>
  <li>{@link #CONTROL_EFFECT_MODE_NEGATIVE NEGATIVE}</li>
  <li>{@link #CONTROL_EFFECT_MODE_SOLARIZE SOLARIZE}</li>
  <li>{@link #CONTROL_EFFECT_MODE_SEPIA SEPIA}</li>
  <li>{@link #CONTROL_EFFECT_MODE_POSTERIZE POSTERIZE}</li>
  <li>{@link #CONTROL_EFFECT_MODE_WHITEBOARD WHITEBOARD}</li>
  <li>{@link #CONTROL_EFFECT_MODE_BLACKBOARD BLACKBOARD}</li>
  <li>{@link #CONTROL_EFFECT_MODE_AQUA AQUA}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AVAILABLE_EFFECTS android.control.availableEffects}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AVAILABLE_EFFECTS
@see #CONTROL_EFFECT_MODE_OFF
@see #CONTROL_EFFECT_MODE_MONO
@see #CONTROL_EFFECT_MODE_NEGATIVE
@see #CONTROL_EFFECT_MODE_SOLARIZE
@see #CONTROL_EFFECT_MODE_SEPIA
@see #CONTROL_EFFECT_MODE_POSTERIZE
@see #CONTROL_EFFECT_MODE_WHITEBOARD
@see #CONTROL_EFFECT_MODE_BLACKBOARD
@see #CONTROL_EFFECT_MODE_AQUA

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15668791 // CONTROL_EFFECT_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15668919 // CONTROL_MODE (<unidirectional association>)
	relation 15668919 --->
	  a role_name "CONTROL_MODE" init_value "
            new Key<Integer>(\"android.control.mode\", int.class)" class_relation const_relation public
	    comment "
<p>Overall mode of 3A (auto-exposure, auto-white-balance, auto-focus) control
routines.</p>
<p>This is a top-level 3A control switch. When set to OFF, all 3A control
by the camera device is disabled. The application must set the fields for
capture parameters itself.</p>
<p>When set to AUTO, the individual algorithm controls in
android.control.* are in effect, such as {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}.</p>
<p>When set to USE_SCENE_MODE, the individual controls in
android.control.* are mostly disabled, and the camera device implements
one of the scene mode settings (such as ACTION, SUNSET, or PARTY)
as it wishes. The camera device scene mode 3A settings are provided by
{@link android.hardware.camera2.CaptureResult capture results}.</p>
<p>When set to OFF_KEEP_STATE, it is similar to OFF mode, the only difference
is that this frame will not be used by camera device background 3A statistics
update, as if this frame is never captured. This mode can be used in the scenario
where the application doesn't want a 3A manual control capture to affect
the subsequent auto 3A capture results.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_MODE_AUTO AUTO}</li>
  <li>{@link #CONTROL_MODE_USE_SCENE_MODE USE_SCENE_MODE}</li>
  <li>{@link #CONTROL_MODE_OFF_KEEP_STATE OFF_KEEP_STATE}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AVAILABLE_MODES android.control.availableModes}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AF_MODE
@see CameraCharacteristics#CONTROL_AVAILABLE_MODES
@see #CONTROL_MODE_OFF
@see #CONTROL_MODE_AUTO
@see #CONTROL_MODE_USE_SCENE_MODE
@see #CONTROL_MODE_OFF_KEEP_STATE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15668919 // CONTROL_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15669047 // CONTROL_SCENE_MODE (<unidirectional association>)
	relation 15669047 --->
	  a role_name "CONTROL_SCENE_MODE" init_value "
            new Key<Integer>(\"android.control.sceneMode\", int.class)" class_relation const_relation public
	    comment "
<p>Control for which scene mode is currently active.</p>
<p>Scene modes are custom camera modes optimized for a certain set of conditions and
capture settings.</p>
<p>This is the mode that that is active when
<code>{@link CaptureRequest#CONTROL_MODE android.control.mode} == USE_SCENE_MODE</code>. Aside from FACE_PRIORITY, these modes will
disable {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}, {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, and {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}
while in use.</p>
<p>The interpretation and implementation of these scene modes is left
to the implementor of the camera device. Their behavior will not be
consistent across all devices, and any given device may only implement
a subset of these modes.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_SCENE_MODE_DISABLED DISABLED}</li>
  <li>{@link #CONTROL_SCENE_MODE_FACE_PRIORITY FACE_PRIORITY}</li>
  <li>{@link #CONTROL_SCENE_MODE_ACTION ACTION}</li>
  <li>{@link #CONTROL_SCENE_MODE_PORTRAIT PORTRAIT}</li>
  <li>{@link #CONTROL_SCENE_MODE_LANDSCAPE LANDSCAPE}</li>
  <li>{@link #CONTROL_SCENE_MODE_NIGHT NIGHT}</li>
  <li>{@link #CONTROL_SCENE_MODE_NIGHT_PORTRAIT NIGHT_PORTRAIT}</li>
  <li>{@link #CONTROL_SCENE_MODE_THEATRE THEATRE}</li>
  <li>{@link #CONTROL_SCENE_MODE_BEACH BEACH}</li>
  <li>{@link #CONTROL_SCENE_MODE_SNOW SNOW}</li>
  <li>{@link #CONTROL_SCENE_MODE_SUNSET SUNSET}</li>
  <li>{@link #CONTROL_SCENE_MODE_STEADYPHOTO STEADYPHOTO}</li>
  <li>{@link #CONTROL_SCENE_MODE_FIREWORKS FIREWORKS}</li>
  <li>{@link #CONTROL_SCENE_MODE_SPORTS SPORTS}</li>
  <li>{@link #CONTROL_SCENE_MODE_PARTY PARTY}</li>
  <li>{@link #CONTROL_SCENE_MODE_CANDLELIGHT CANDLELIGHT}</li>
  <li>{@link #CONTROL_SCENE_MODE_BARCODE BARCODE}</li>
  <li>{@link #CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO HIGH_SPEED_VIDEO}</li>
  <li>{@link #CONTROL_SCENE_MODE_HDR HDR}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES android.control.availableSceneModes}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AF_MODE
@see CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES
@see CaptureRequest#CONTROL_AWB_MODE
@see CaptureRequest#CONTROL_MODE
@see #CONTROL_SCENE_MODE_DISABLED
@see #CONTROL_SCENE_MODE_FACE_PRIORITY
@see #CONTROL_SCENE_MODE_ACTION
@see #CONTROL_SCENE_MODE_PORTRAIT
@see #CONTROL_SCENE_MODE_LANDSCAPE
@see #CONTROL_SCENE_MODE_NIGHT
@see #CONTROL_SCENE_MODE_NIGHT_PORTRAIT
@see #CONTROL_SCENE_MODE_THEATRE
@see #CONTROL_SCENE_MODE_BEACH
@see #CONTROL_SCENE_MODE_SNOW
@see #CONTROL_SCENE_MODE_SUNSET
@see #CONTROL_SCENE_MODE_STEADYPHOTO
@see #CONTROL_SCENE_MODE_FIREWORKS
@see #CONTROL_SCENE_MODE_SPORTS
@see #CONTROL_SCENE_MODE_PARTY
@see #CONTROL_SCENE_MODE_CANDLELIGHT
@see #CONTROL_SCENE_MODE_BARCODE
@see #CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO
@see #CONTROL_SCENE_MODE_HDR

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15669047 // CONTROL_SCENE_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15669175 // CONTROL_VIDEO_STABILIZATION_MODE (<unidirectional association>)
	relation 15669175 --->
	  a role_name "CONTROL_VIDEO_STABILIZATION_MODE" init_value "
            new Key<Integer>(\"android.control.videoStabilizationMode\", int.class)" class_relation const_relation public
	    comment "
<p>Whether video stabilization is
active.</p>
<p>Video stabilization automatically warps images from
the camera in order to stabilize motion between consecutive frames.</p>
<p>If enabled, video stabilization can modify the
{@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} to keep the video stream stabilized.</p>
<p>Switching between different video stabilization modes may take several
frames to initialize, the camera device will report the current mode
in capture result metadata. For example, When \"ON\" mode is requested,
the video stabilization modes in the first several capture results may
still be \"OFF\", and it will become \"ON\" when the initialization is
done.</p>
<p>In addition, not all recording sizes or frame rates may be supported for
stabilization by a device that reports stabilization support. It is guaranteed
that an output targeting a MediaRecorder or MediaCodec will be stabilized if
the recording resolution is less than or equal to 1920 x 1080 (width less than
or equal to 1920, height less than or equal to 1080), and the recording
frame rate is less than or equal to 30fps.  At other sizes, the CaptureResult
{@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode} field will return
OFF if the recording output is not stabilized, or if there are no output
Surface types that can be stabilized.</p>
<p>If a camera device supports both this mode and OIS
({@link CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode}), turning both modes on may
produce undesirable interaction, so it is recommended not to enable
both at the same time.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_VIDEO_STABILIZATION_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_VIDEO_STABILIZATION_MODE_ON ON}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE
@see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE
@see CaptureRequest#SCALER_CROP_REGION
@see #CONTROL_VIDEO_STABILIZATION_MODE_OFF
@see #CONTROL_VIDEO_STABILIZATION_MODE_ON

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15669175 // CONTROL_VIDEO_STABILIZATION_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15669303 // CONTROL_POST_RAW_SENSITIVITY_BOOST (<unidirectional association>)
	relation 15669303 --->
	  a role_name "CONTROL_POST_RAW_SENSITIVITY_BOOST" init_value "
            new Key<Integer>(\"android.control.postRawSensitivityBoost\", int.class)" class_relation const_relation public
	    comment "
<p>The amount of additional sensitivity boost applied to output images
after RAW sensor data is captured.</p>
<p>Some camera devices support additional digital sensitivity boosting in the
camera processing pipeline after sensor RAW image is captured.
Such a boost will be applied to YUV/JPEG format output images but will not
have effect on RAW output formats like RAW_SENSOR, RAW10, RAW12 or RAW_OPAQUE.</p>
<p>This key will be <code>null</code> for devices that do not support any RAW format
outputs. For devices that do support RAW format outputs, this key will always
present, and if a device does not support post RAW sensitivity boost, it will
list <code>100</code> in this key.</p>
<p>If the camera device cannot apply the exact boost requested, it will reduce the
boost to the nearest supported value.
The final boost value used will be available in the output capture result.</p>
<p>For devices that support post RAW sensitivity boost, the YUV/JPEG output images
of such device will have the total sensitivity of
<code>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity} * {@link CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST android.control.postRawSensitivityBoost} / 100</code>
The sensitivity of RAW format images will always be <code>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</code></p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to
OFF; otherwise the auto-exposure algorithm will override this value.</p>
<p><b>Units</b>: ISO arithmetic units, the same as {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE android.control.postRawSensitivityBoostRange}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST
@see CameraCharacteristics#CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15669303 // CONTROL_POST_RAW_SENSITIVITY_BOOST (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15669431 // EDGE_MODE (<unidirectional association>)
	relation 15669431 --->
	  a role_name "EDGE_MODE" init_value "
            new Key<Integer>(\"android.edge.mode\", int.class)" class_relation const_relation public
	    comment "
<p>Operation mode for edge
enhancement.</p>
<p>Edge enhancement improves sharpness and details in the captured image. OFF means
no enhancement will be applied by the camera device.</p>
<p>FAST/HIGH_QUALITY both mean camera device determined enhancement
will be applied. HIGH_QUALITY mode indicates that the
camera device will use the highest-quality enhancement algorithms,
even if it slows down capture rate. FAST means the camera device will
not slow down capture rate when applying edge enhancement. FAST may be the same as OFF if
edge enhancement will slow down capture rate. Every output stream will have a similar
amount of enhancement applied.</p>
<p>ZERO_SHUTTER_LAG is meant to be used by applications that maintain a continuous circular
buffer of high-resolution images during preview and reprocess image(s) from that buffer
into a final capture when triggered by the user. In this mode, the camera device applies
edge enhancement to low-resolution streams (below maximum recording resolution) to
maximize preview quality, but does not apply edge enhancement to high-resolution streams,
since those will be reprocessed later if necessary.</p>
<p>For YUV_REPROCESSING, these FAST/HIGH_QUALITY modes both mean that the camera
device will apply FAST/HIGH_QUALITY YUV-domain edge enhancement, respectively.
The camera device may adjust its internal edge enhancement parameters for best
image quality based on the {@link CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor}, if it is set.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #EDGE_MODE_OFF OFF}</li>
  <li>{@link #EDGE_MODE_FAST FAST}</li>
  <li>{@link #EDGE_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
  <li>{@link #EDGE_MODE_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES android.edge.availableEdgeModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR
@see #EDGE_MODE_OFF
@see #EDGE_MODE_FAST
@see #EDGE_MODE_HIGH_QUALITY
@see #EDGE_MODE_ZERO_SHUTTER_LAG

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15669431 // EDGE_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15669559 // FLASH_MODE (<unidirectional association>)
	relation 15669559 --->
	  a role_name "FLASH_MODE" init_value "
            new Key<Integer>(\"android.flash.mode\", int.class)" class_relation const_relation public
	    comment "
<p>The desired mode for for the camera device's flash control.</p>
<p>This control is only effective when flash unit is available
(<code>{@link CameraCharacteristics#FLASH_INFO_AVAILABLE android.flash.info.available} == true</code>).</p>
<p>When this control is used, the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} must be set to ON or OFF.
Otherwise, the camera device auto-exposure related flash control (ON_AUTO_FLASH,
ON_ALWAYS_FLASH, or ON_AUTO_FLASH_REDEYE) will override this control.</p>
<p>When set to OFF, the camera device will not fire flash for this capture.</p>
<p>When set to SINGLE, the camera device will fire flash regardless of the camera
device's auto-exposure routine's result. When used in still capture case, this
control should be used along with auto-exposure (AE) precapture metering sequence
({@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}), otherwise, the image may be incorrectly exposed.</p>
<p>When set to TORCH, the flash will be on continuously. This mode can be used
for use cases such as preview, auto-focus assist, still capture, or video recording.</p>
<p>The flash status will be reported by {@link CaptureResult#FLASH_STATE android.flash.state} in the capture result metadata.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #FLASH_MODE_OFF OFF}</li>
  <li>{@link #FLASH_MODE_SINGLE SINGLE}</li>
  <li>{@link #FLASH_MODE_TORCH TORCH}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CameraCharacteristics#FLASH_INFO_AVAILABLE
@see CaptureResult#FLASH_STATE
@see #FLASH_MODE_OFF
@see #FLASH_MODE_SINGLE
@see #FLASH_MODE_TORCH

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15669559 // FLASH_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15669687 // HOT_PIXEL_MODE (<unidirectional association>)
	relation 15669687 --->
	  a role_name "HOT_PIXEL_MODE" init_value "
            new Key<Integer>(\"android.hotPixel.mode\", int.class)" class_relation const_relation public
	    comment "
<p>Operational mode for hot pixel correction.</p>
<p>Hotpixel correction interpolates out, or otherwise removes, pixels
that do not accurately measure the incoming light (i.e. pixels that
are stuck at an arbitrary value or are oversensitive).</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #HOT_PIXEL_MODE_OFF OFF}</li>
  <li>{@link #HOT_PIXEL_MODE_FAST FAST}</li>
  <li>{@link #HOT_PIXEL_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES android.hotPixel.availableHotPixelModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES
@see #HOT_PIXEL_MODE_OFF
@see #HOT_PIXEL_MODE_FAST
@see #HOT_PIXEL_MODE_HIGH_QUALITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15669687 // HOT_PIXEL_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15669815 // JPEG_GPS_LOCATION (<unidirectional association>)
	relation 15669815 --->
	  a role_name "JPEG_GPS_LOCATION" init_value "
            new Key<android.location.Location>(\"android.jpeg.gpsLocation\", android.location.Location.class)" class_relation const_relation public
	    comment "
<p>A location object to use when generating image GPS metadata.</p>
<p>Setting a location object in a request will include the GPS coordinates of the location
into any JPEG images captured based on the request. These coordinates can then be
viewed by anyone who receives the JPEG image.</p>
<p>This key is available on all devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.location.Location> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15669815 // JPEG_GPS_LOCATION (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15669943 // JPEG_GPS_COORDINATES (<unidirectional association>)
	relation 15669943 --->
	  a role_name "JPEG_GPS_COORDINATES" init_value "
            new Key<double[]>(\"android.jpeg.gpsCoordinates\", double[].class)" class_relation const_relation public
	    comment "
<p>GPS coordinates to include in output JPEG
EXIF.</p>
<p><b>Range of valid values:</b><br>
(-180 - 180], [-90,90], [-inf, inf]</p>
<p>This key is available on all devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<double[]> ${name}${value};
"
	    classrelation_ref 15669943 // JPEG_GPS_COORDINATES (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15670071 // JPEG_GPS_PROCESSING_METHOD (<unidirectional association>)
	relation 15670071 --->
	  a role_name "JPEG_GPS_PROCESSING_METHOD" init_value "
            new Key<String>(\"android.jpeg.gpsProcessingMethod\", String.class)" class_relation const_relation public
	    comment "
<p>32 characters describing GPS algorithm to
include in EXIF.</p>
<p><b>Units</b>: UTF-8 null-terminated string</p>
<p>This key is available on all devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<String> ${name}${value};
"
	    classrelation_ref 15670071 // JPEG_GPS_PROCESSING_METHOD (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15670199 // JPEG_GPS_TIMESTAMP (<unidirectional association>)
	relation 15670199 --->
	  a role_name "JPEG_GPS_TIMESTAMP" init_value "
            new Key<Long>(\"android.jpeg.gpsTimestamp\", long.class)" class_relation const_relation public
	    comment "
<p>Time GPS fix was made to include in
EXIF.</p>
<p><b>Units</b>: UTC in seconds since January 1, 1970</p>
<p>This key is available on all devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Long> ${name}${value};
"
	    classrelation_ref 15670199 // JPEG_GPS_TIMESTAMP (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15670327 // JPEG_ORIENTATION (<unidirectional association>)
	relation 15670327 --->
	  a role_name "JPEG_ORIENTATION" init_value "
            new Key<Integer>(\"android.jpeg.orientation\", int.class)" class_relation const_relation public
	    comment "
<p>The orientation for a JPEG image.</p>
<p>The clockwise rotation angle in degrees, relative to the orientation
to the camera, that the JPEG picture needs to be rotated by, to be viewed
upright.</p>
<p>Camera devices may either encode this value into the JPEG EXIF header, or
rotate the image data to match this orientation. When the image data is rotated,
the thumbnail data will also be rotated.</p>
<p>Note that this orientation is relative to the orientation of the camera sensor, given
by {@link CameraCharacteristics#SENSOR_ORIENTATION android.sensor.orientation}.</p>
<p>To translate from the device orientation given by the Android sensor APIs, the following
sample code may be used:</p>
<pre><code>private int getJpegOrientation(CameraCharacteristics c, int deviceOrientation) {
    if (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN) return 0;
    int sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION);

    // Round device orientation to a multiple of 90
    deviceOrientation = (deviceOrientation + 45) / 90 * 90;

    // Reverse device orientation for front-facing cameras
    boolean facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT;
    if (facingFront) deviceOrientation = -deviceOrientation;

    // Calculate desired JPEG orientation relative to camera orientation to make
    // the image upright relative to the device orientation
    int jpegOrientation = (sensorOrientation + deviceOrientation + 360) % 360;

    return jpegOrientation;
}
</code></pre>
<p><b>Units</b>: Degrees in multiples of 90</p>
<p><b>Range of valid values:</b><br>
0, 90, 180, 270</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#SENSOR_ORIENTATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15670327 // JPEG_ORIENTATION (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15670455 // JPEG_QUALITY (<unidirectional association>)
	relation 15670455 --->
	  a role_name "JPEG_QUALITY" init_value "
            new Key<Byte>(\"android.jpeg.quality\", byte.class)" class_relation const_relation public
	    comment "
<p>Compression quality of the final JPEG
image.</p>
<p>85-95 is typical usage range.</p>
<p><b>Range of valid values:</b><br>
1-100; larger is higher quality</p>
<p>This key is available on all devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Byte> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15670455 // JPEG_QUALITY (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15670583 // JPEG_THUMBNAIL_QUALITY (<unidirectional association>)
	relation 15670583 --->
	  a role_name "JPEG_THUMBNAIL_QUALITY" init_value "
            new Key<Byte>(\"android.jpeg.thumbnailQuality\", byte.class)" class_relation const_relation public
	    comment "
<p>Compression quality of JPEG
thumbnail.</p>
<p><b>Range of valid values:</b><br>
1-100; larger is higher quality</p>
<p>This key is available on all devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Byte> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15670583 // JPEG_THUMBNAIL_QUALITY (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15670711 // JPEG_THUMBNAIL_SIZE (<unidirectional association>)
	relation 15670711 --->
	  a role_name "JPEG_THUMBNAIL_SIZE" init_value "
            new Key<android.util.Size>(\"android.jpeg.thumbnailSize\", android.util.Size.class)" class_relation const_relation public
	    comment "
<p>Resolution of embedded JPEG thumbnail.</p>
<p>When set to (0, 0) value, the JPEG EXIF will not contain thumbnail,
but the captured JPEG will still be a valid image.</p>
<p>For best results, when issuing a request for a JPEG image, the thumbnail size selected
should have the same aspect ratio as the main JPEG output.</p>
<p>If the thumbnail image aspect ratio differs from the JPEG primary image aspect
ratio, the camera device creates the thumbnail by cropping it from the primary image.
For example, if the primary image has 4:3 aspect ratio, the thumbnail image has
16:9 aspect ratio, the primary image will be cropped vertically (letterbox) to
generate the thumbnail image. The thumbnail image will always have a smaller Field
Of View (FOV) than the primary image when aspect ratios differ.</p>
<p>When an {@link CaptureRequest#JPEG_ORIENTATION android.jpeg.orientation} of non-zero degree is requested,
the camera device will handle thumbnail rotation in one of the following ways:</p>
<ul>
<li>Set the {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}
  and keep jpeg and thumbnail image data unrotated.</li>
<li>Rotate the jpeg and thumbnail image data and not set
  {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}. In this
  case, LIMITED or FULL hardware level devices will report rotated thumnail size in
  capture result, so the width and height will be interchanged if 90 or 270 degree
  orientation is requested. LEGACY device will always report unrotated thumbnail
  size.</li>
</ul>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#JPEG_AVAILABLE_THUMBNAIL_SIZES android.jpeg.availableThumbnailSizes}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#JPEG_AVAILABLE_THUMBNAIL_SIZES
@see CaptureRequest#JPEG_ORIENTATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Size> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15670711 // JPEG_THUMBNAIL_SIZE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15670839 // LENS_APERTURE (<unidirectional association>)
	relation 15670839 --->
	  a role_name "LENS_APERTURE" init_value "
            new Key<Float>(\"android.lens.aperture\", float.class)" class_relation const_relation public
	    comment "
<p>The desired lens aperture size, as a ratio of lens focal length to the
effective aperture diameter.</p>
<p>Setting this value is only supported on the camera devices that have a variable
aperture lens.</p>
<p>When this is supported and {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is OFF,
this can be set along with {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},
{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, and {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}
to achieve manual exposure control.</p>
<p>The requested aperture value may take several frames to reach the
requested value; the camera device will report the current (intermediate)
aperture size in capture result metadata while the aperture is changing.
While the aperture is still changing, {@link CaptureResult#LENS_STATE android.lens.state} will be set to MOVING.</p>
<p>When this is supported and {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is one of
the ON modes, this will be overridden by the camera device
auto-exposure algorithm, the overridden values are then provided
back to the user in the corresponding result.</p>
<p><b>Units</b>: The f-number (f/N)</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES android.lens.info.availableApertures}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES
@see CaptureResult#LENS_STATE
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_FRAME_DURATION
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15670839 // LENS_APERTURE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15670967 // LENS_FILTER_DENSITY (<unidirectional association>)
	relation 15670967 --->
	  a role_name "LENS_FILTER_DENSITY" init_value "
            new Key<Float>(\"android.lens.filterDensity\", float.class)" class_relation const_relation public
	    comment "
<p>The desired setting for the lens neutral density filter(s).</p>
<p>This control will not be supported on most camera devices.</p>
<p>Lens filters are typically used to lower the amount of light the
sensor is exposed to (measured in steps of EV). As used here, an EV
step is the standard logarithmic representation, which are
non-negative, and inversely proportional to the amount of light
hitting the sensor.  For example, setting this to 0 would result
in no reduction of the incoming light, and setting this to 2 would
mean that the filter is set to reduce incoming light by two stops
(allowing 1/4 of the prior amount of light to the sensor).</p>
<p>It may take several frames before the lens filter density changes
to the requested value. While the filter density is still changing,
{@link CaptureResult#LENS_STATE android.lens.state} will be set to MOVING.</p>
<p><b>Units</b>: Exposure Value (EV)</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES android.lens.info.availableFilterDensities}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES
@see CaptureResult#LENS_STATE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15670967 // LENS_FILTER_DENSITY (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15671095 // LENS_FOCAL_LENGTH (<unidirectional association>)
	relation 15671095 --->
	  a role_name "LENS_FOCAL_LENGTH" init_value "
            new Key<Float>(\"android.lens.focalLength\", float.class)" class_relation const_relation public
	    comment "
<p>The desired lens focal length; used for optical zoom.</p>
<p>This setting controls the physical focal length of the camera
device's lens. Changing the focal length changes the field of
view of the camera device, and is usually used for optical zoom.</p>
<p>Like {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} and {@link CaptureRequest#LENS_APERTURE android.lens.aperture}, this
setting won't be applied instantaneously, and it may take several
frames before the lens can change to the requested focal length.
While the focal length is still changing, {@link CaptureResult#LENS_STATE android.lens.state} will
be set to MOVING.</p>
<p>Optical zoom will not be supported on most devices.</p>
<p><b>Units</b>: Millimeters</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS android.lens.info.availableFocalLengths}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#LENS_APERTURE
@see CaptureRequest#LENS_FOCUS_DISTANCE
@see CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS
@see CaptureResult#LENS_STATE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15671095 // LENS_FOCAL_LENGTH (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15671223 // LENS_FOCUS_DISTANCE (<unidirectional association>)
	relation 15671223 --->
	  a role_name "LENS_FOCUS_DISTANCE" init_value "
            new Key<Float>(\"android.lens.focusDistance\", float.class)" class_relation const_relation public
	    comment "
<p>Desired distance to plane of sharpest focus,
measured from frontmost surface of the lens.</p>
<p>This control can be used for setting manual focus, on devices that support
the MANUAL_SENSOR capability and have a variable-focus lens (see
{@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance}).</p>
<p>A value of <code>0.0f</code> means infinity focus. The value set will be clamped to
<code>[0.0f, {@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance}]</code>.</p>
<p>Like {@link CaptureRequest#LENS_FOCAL_LENGTH android.lens.focalLength}, this setting won't be applied
instantaneously, and it may take several frames before the lens
can move to the requested focus distance. While the lens is still moving,
{@link CaptureResult#LENS_STATE android.lens.state} will be set to MOVING.</p>
<p>LEGACY devices support at most setting this to <code>0.0f</code>
for infinity focus.</p>
<p><b>Units</b>: See {@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration} for details</p>
<p><b>Range of valid values:</b><br>
&gt;= 0</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#LENS_FOCAL_LENGTH
@see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION
@see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE
@see CaptureResult#LENS_STATE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15671223 // LENS_FOCUS_DISTANCE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15671351 // LENS_OPTICAL_STABILIZATION_MODE (<unidirectional association>)
	relation 15671351 --->
	  a role_name "LENS_OPTICAL_STABILIZATION_MODE" init_value "
            new Key<Integer>(\"android.lens.opticalStabilizationMode\", int.class)" class_relation const_relation public
	    comment "
<p>Sets whether the camera device uses optical image stabilization (OIS)
when capturing images.</p>
<p>OIS is used to compensate for motion blur due to small
movements of the camera during capture. Unlike digital image
stabilization ({@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode}), OIS
makes use of mechanical elements to stabilize the camera
sensor, and thus allows for longer exposure times before
camera shake becomes apparent.</p>
<p>Switching between different optical stabilization modes may take several
frames to initialize, the camera device will report the current mode in
capture result metadata. For example, When \"ON\" mode is requested, the
optical stabilization modes in the first several capture results may still
be \"OFF\", and it will become \"ON\" when the initialization is done.</p>
<p>If a camera device supports both OIS and digital image stabilization
({@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode}), turning both modes on may produce undesirable
interaction, so it is recommended not to enable both at the same time.</p>
<p>Not all devices will support OIS; see
{@link CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION android.lens.info.availableOpticalStabilization} for
available controls.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #LENS_OPTICAL_STABILIZATION_MODE_OFF OFF}</li>
  <li>{@link #LENS_OPTICAL_STABILIZATION_MODE_ON ON}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION android.lens.info.availableOpticalStabilization}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION
@see #LENS_OPTICAL_STABILIZATION_MODE_OFF
@see #LENS_OPTICAL_STABILIZATION_MODE_ON

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15671351 // LENS_OPTICAL_STABILIZATION_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15671479 // NOISE_REDUCTION_MODE (<unidirectional association>)
	relation 15671479 --->
	  a role_name "NOISE_REDUCTION_MODE" init_value "
            new Key<Integer>(\"android.noiseReduction.mode\", int.class)" class_relation const_relation public
	    comment "
<p>Mode of operation for the noise reduction algorithm.</p>
<p>The noise reduction algorithm attempts to improve image quality by removing
excessive noise added by the capture process, especially in dark conditions.</p>
<p>OFF means no noise reduction will be applied by the camera device, for both raw and
YUV domain.</p>
<p>MINIMAL means that only sensor raw domain basic noise reduction is enabled ,to remove
demosaicing or other processing artifacts. For YUV_REPROCESSING, MINIMAL is same as OFF.
This mode is optional, may not be support by all devices. The application should check
{@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes} before using it.</p>
<p>FAST/HIGH_QUALITY both mean camera device determined noise filtering
will be applied. HIGH_QUALITY mode indicates that the camera device
will use the highest-quality noise filtering algorithms,
even if it slows down capture rate. FAST means the camera device will not
slow down capture rate when applying noise filtering. FAST may be the same as MINIMAL if
MINIMAL is listed, or the same as OFF if any noise filtering will slow down capture rate.
Every output stream will have a similar amount of enhancement applied.</p>
<p>ZERO_SHUTTER_LAG is meant to be used by applications that maintain a continuous circular
buffer of high-resolution images during preview and reprocess image(s) from that buffer
into a final capture when triggered by the user. In this mode, the camera device applies
noise reduction to low-resolution streams (below maximum recording resolution) to maximize
preview quality, but does not apply noise reduction to high-resolution streams, since
those will be reprocessed later if necessary.</p>
<p>For YUV_REPROCESSING, these FAST/HIGH_QUALITY modes both mean that the camera device
will apply FAST/HIGH_QUALITY YUV domain noise reduction, respectively. The camera device
may adjust the noise reduction parameters for best image quality based on the
{@link CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor} if it is set.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #NOISE_REDUCTION_MODE_OFF OFF}</li>
  <li>{@link #NOISE_REDUCTION_MODE_FAST FAST}</li>
  <li>{@link #NOISE_REDUCTION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
  <li>{@link #NOISE_REDUCTION_MODE_MINIMAL MINIMAL}</li>
  <li>{@link #NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES
@see CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR
@see #NOISE_REDUCTION_MODE_OFF
@see #NOISE_REDUCTION_MODE_FAST
@see #NOISE_REDUCTION_MODE_HIGH_QUALITY
@see #NOISE_REDUCTION_MODE_MINIMAL
@see #NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15671479 // NOISE_REDUCTION_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15671607 // REQUEST_ID (<unidirectional association>)
	relation 15671607 --->
	  a role_name "REQUEST_ID" init_value "
            new Key<Integer>(\"android.request.id\", int.class)" class_relation const_relation public
	    comment "
<p>An application-specified ID for the current
request. Must be maintained unchanged in output
frame</p>
<p><b>Units</b>: arbitrary integer assigned by application</p>
<p><b>Range of valid values:</b><br>
Any int</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    classrelation_ref 15671607 // REQUEST_ID (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15671735 // SCALER_CROP_REGION (<unidirectional association>)
	relation 15671735 --->
	  a role_name "SCALER_CROP_REGION" init_value "
            new Key<android.graphics.Rect>(\"android.scaler.cropRegion\", android.graphics.Rect.class)" class_relation const_relation public
	    comment "
<p>The desired region of the sensor to read out for this capture.</p>
<p>This control can be used to implement digital zoom.</p>
<p>The crop region coordinate system is based off
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with <code>(0, 0)</code> being the
top-left corner of the sensor active array.</p>
<p>Output streams use this rectangle to produce their output,
cropping to a smaller region if necessary to maintain the
stream's aspect ratio, then scaling the sensor input to
match the output's configured resolution.</p>
<p>The crop region is applied after the RAW to other color
space (e.g. YUV) conversion. Since raw streams
(e.g. RAW16) don't have the conversion stage, they are not
croppable. The crop region will be ignored by raw streams.</p>
<p>For non-raw streams, any additional per-stream cropping will
be done to maximize the final pixel area of the stream.</p>
<p>For example, if the crop region is set to a 4:3 aspect
ratio, then 4:3 streams will use the exact crop
region. 16:9 streams will further crop vertically
(letterbox).</p>
<p>Conversely, if the crop region is set to a 16:9, then 4:3
outputs will crop horizontally (pillarbox), and 16:9
streams will match exactly. These additional crops will
be centered within the crop region.</p>
<p>The width and height of the crop region cannot
be set to be smaller than
<code>floor( activeArraySize.width / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code> and
<code>floor( activeArraySize.height / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code>, respectively.</p>
<p>The camera device may adjust the crop region to account
for rounding and other hardware requirements; the final
crop region used will be included in the output capture
result.</p>
<p><b>Units</b>: Pixel coordinates relative to
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.graphics.Rect> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15671735 // SCALER_CROP_REGION (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15671863 // SENSOR_EXPOSURE_TIME (<unidirectional association>)
	relation 15671863 --->
	  a role_name "SENSOR_EXPOSURE_TIME" init_value "
            new Key<Long>(\"android.sensor.exposureTime\", long.class)" class_relation const_relation public
	    comment "
<p>Duration each pixel is exposed to
light.</p>
<p>If the sensor can't expose this exact duration, it will shorten the
duration exposed to the nearest possible value (rather than expose longer).
The final exposure time used will be available in the output capture result.</p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to
OFF; otherwise the auto-exposure algorithm will override this value.</p>
<p><b>Units</b>: Nanoseconds</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Long> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15671863 // SENSOR_EXPOSURE_TIME (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15671991 // SENSOR_FRAME_DURATION (<unidirectional association>)
	relation 15671991 --->
	  a role_name "SENSOR_FRAME_DURATION" init_value "
            new Key<Long>(\"android.sensor.frameDuration\", long.class)" class_relation const_relation public
	    comment "
<p>Duration from start of frame exposure to
start of next frame exposure.</p>
<p>The maximum frame rate that can be supported by a camera subsystem is
a function of many factors:</p>
<ul>
<li>Requested resolutions of output image streams</li>
<li>Availability of binning / skipping modes on the imager</li>
<li>The bandwidth of the imager interface</li>
<li>The bandwidth of the various ISP processing blocks</li>
</ul>
<p>Since these factors can vary greatly between different ISPs and
sensors, the camera abstraction tries to represent the bandwidth
restrictions with as simple a model as possible.</p>
<p>The model presented has the following characteristics:</p>
<ul>
<li>The image sensor is always configured to output the smallest
resolution possible given the application's requested output stream
sizes.  The smallest resolution is defined as being at least as large
as the largest requested output stream size; the camera pipeline must
never digitally upsample sensor data when the crop region covers the
whole sensor. In general, this means that if only small output stream
resolutions are configured, the sensor can provide a higher frame
rate.</li>
<li>Since any request may use any or all the currently configured
output streams, the sensor and ISP must be configured to support
scaling a single capture to all the streams at the same time.  This
means the camera pipeline must be ready to produce the largest
requested output size without any delay.  Therefore, the overall
frame rate of a given configured stream set is governed only by the
largest requested stream resolution.</li>
<li>Using more than one output stream in a request does not affect the
frame duration.</li>
<li>Certain format-streams may need to do additional background processing
before data is consumed/produced by that stream. These processors
can run concurrently to the rest of the camera pipeline, but
cannot process more than 1 capture at a time.</li>
</ul>
<p>The necessary information for the application, given the model above,
is provided via the {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap} field using
{@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }.
These are used to determine the maximum frame rate / minimum frame
duration that is possible for a given stream configuration.</p>
<p>Specifically, the application can use the following rules to
determine the minimum frame duration it can request from the camera
device:</p>
<ol>
<li>Let the set of currently configured input/output streams
be called <code>S</code>.</li>
<li>Find the minimum frame durations for each stream in <code>S</code>, by looking
it up in {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap} using {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }
(with its respective size/format). Let this set of frame durations be
called <code>F</code>.</li>
<li>For any given request <code>R</code>, the minimum frame duration allowed
for <code>R</code> is the maximum out of all values in <code>F</code>. Let the streams
used in <code>R</code> be called <code>S_r</code>.</li>
</ol>
<p>If none of the streams in <code>S_r</code> have a stall time (listed in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration }
using its respective size/format), then the frame duration in <code>F</code>
determines the steady state frame rate that the application will get
if it uses <code>R</code> as a repeating request. Let this special kind of
request be called <code>Rsimple</code>.</p>
<p>A repeating request <code>Rsimple</code> can be <em>occasionally</em> interleaved
by a single capture of a new request <code>Rstall</code> (which has at least
one in-use stream with a non-0 stall time) and if <code>Rstall</code> has the
same minimum frame duration this will not cause a frame rate loss
if all buffers from the previous <code>Rstall</code> have already been
delivered.</p>
<p>For more details about stalling, see
{@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration }.</p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to
OFF; otherwise the auto-exposure algorithm will override this value.</p>
<p><b>Units</b>: Nanoseconds</p>
<p><b>Range of valid values:</b><br>
See {@link CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration},
{@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap}. The duration
is capped to <code>max(duration, exposureTime + overhead)</code>.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP
@see CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Long> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15671991 // SENSOR_FRAME_DURATION (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15672119 // SENSOR_SENSITIVITY (<unidirectional association>)
	relation 15672119 --->
	  a role_name "SENSOR_SENSITIVITY" init_value "
            new Key<Integer>(\"android.sensor.sensitivity\", int.class)" class_relation const_relation public
	    comment "
<p>The amount of gain applied to sensor data
before processing.</p>
<p>The sensitivity is the standard ISO sensitivity value,
as defined in ISO 12232:2006.</p>
<p>The sensitivity must be within {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}, and
if if it less than {@link CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY android.sensor.maxAnalogSensitivity}, the camera device
is guaranteed to use only analog amplification for applying the gain.</p>
<p>If the camera device cannot apply the exact sensitivity
requested, it will reduce the gain to the nearest supported
value. The final sensitivity used will be available in the
output capture result.</p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to
OFF; otherwise the auto-exposure algorithm will override this value.</p>
<p><b>Units</b>: ISO arithmetic units</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE
@see CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15672119 // SENSOR_SENSITIVITY (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15672247 // SENSOR_TEST_PATTERN_DATA (<unidirectional association>)
	relation 15672247 --->
	  a role_name "SENSOR_TEST_PATTERN_DATA" init_value "
            new Key<int[]>(\"android.sensor.testPatternData\", int[].class)" class_relation const_relation public
	    comment "
<p>A pixel <code>[R, G_even, G_odd, B]</code> that supplies the test pattern
when {@link CaptureRequest#SENSOR_TEST_PATTERN_MODE android.sensor.testPatternMode} is SOLID_COLOR.</p>
<p>Each color channel is treated as an unsigned 32-bit integer.
The camera device then uses the most significant X bits
that correspond to how many bits are in its Bayer raw sensor
output.</p>
<p>For example, a sensor with RAW10 Bayer output would use the
10 most significant bits from each color channel.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#SENSOR_TEST_PATTERN_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15672247 // SENSOR_TEST_PATTERN_DATA (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15672375 // SENSOR_TEST_PATTERN_MODE (<unidirectional association>)
	relation 15672375 --->
	  a role_name "SENSOR_TEST_PATTERN_MODE" init_value "
            new Key<Integer>(\"android.sensor.testPatternMode\", int.class)" class_relation const_relation public
	    comment "
<p>When enabled, the sensor sends a test pattern instead of
doing a real exposure from the camera.</p>
<p>When a test pattern is enabled, all manual sensor controls specified
by android.sensor.* will be ignored. All other controls should
work as normal.</p>
<p>For example, if manual flash is enabled, flash firing should still
occur (and that the test pattern remain unmodified, since the flash
would not actually affect it).</p>
<p>Defaults to OFF.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_OFF OFF}</li>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_SOLID_COLOR SOLID_COLOR}</li>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_COLOR_BARS COLOR_BARS}</li>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY COLOR_BARS_FADE_TO_GRAY}</li>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_PN9 PN9}</li>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_CUSTOM1 CUSTOM1}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES android.sensor.availableTestPatternModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES
@see #SENSOR_TEST_PATTERN_MODE_OFF
@see #SENSOR_TEST_PATTERN_MODE_SOLID_COLOR
@see #SENSOR_TEST_PATTERN_MODE_COLOR_BARS
@see #SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY
@see #SENSOR_TEST_PATTERN_MODE_PN9
@see #SENSOR_TEST_PATTERN_MODE_CUSTOM1

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15672375 // SENSOR_TEST_PATTERN_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15672503 // SHADING_MODE (<unidirectional association>)
	relation 15672503 --->
	  a role_name "SHADING_MODE" init_value "
            new Key<Integer>(\"android.shading.mode\", int.class)" class_relation const_relation public
	    comment "
<p>Quality of lens shading correction applied
to the image data.</p>
<p>When set to OFF mode, no lens shading correction will be applied by the
camera device, and an identity lens shading map data will be provided
if <code>{@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode} == ON</code>. For example, for lens
shading map with size of <code>[ 4, 3 ]</code>,
the output {@link CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP android.statistics.lensShadingCorrectionMap} for this case will be an identity
map shown below:</p>
<pre><code>[ 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0 ]
</code></pre>
<p>When set to other modes, lens shading correction will be applied by the camera
device. Applications can request lens shading map data by setting
{@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode} to ON, and then the camera device will provide lens
shading map data in {@link CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP android.statistics.lensShadingCorrectionMap}; the returned shading map
data will be the one applied by the camera device for this capture request.</p>
<p>The shading map data may depend on the auto-exposure (AE) and AWB statistics, therefore
the reliability of the map data may be affected by the AE and AWB algorithms. When AE and
AWB are in AUTO modes({@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} <code>!=</code> OFF and {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} <code>!=</code>
OFF), to get best results, it is recommended that the applications wait for the AE and AWB
to be converged before using the returned shading map data.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #SHADING_MODE_OFF OFF}</li>
  <li>{@link #SHADING_MODE_FAST FAST}</li>
  <li>{@link #SHADING_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#SHADING_AVAILABLE_MODES android.shading.availableModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AWB_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SHADING_AVAILABLE_MODES
@see CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP
@see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE
@see #SHADING_MODE_OFF
@see #SHADING_MODE_FAST
@see #SHADING_MODE_HIGH_QUALITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15672503 // SHADING_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15672631 // STATISTICS_FACE_DETECT_MODE (<unidirectional association>)
	relation 15672631 --->
	  a role_name "STATISTICS_FACE_DETECT_MODE" init_value "
            new Key<Integer>(\"android.statistics.faceDetectMode\", int.class)" class_relation const_relation public
	    comment "
<p>Operating mode for the face detector
unit.</p>
<p>Whether face detection is enabled, and whether it
should output just the basic fields or the full set of
fields.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #STATISTICS_FACE_DETECT_MODE_OFF OFF}</li>
  <li>{@link #STATISTICS_FACE_DETECT_MODE_SIMPLE SIMPLE}</li>
  <li>{@link #STATISTICS_FACE_DETECT_MODE_FULL FULL}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES android.statistics.info.availableFaceDetectModes}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES
@see #STATISTICS_FACE_DETECT_MODE_OFF
@see #STATISTICS_FACE_DETECT_MODE_SIMPLE
@see #STATISTICS_FACE_DETECT_MODE_FULL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15672631 // STATISTICS_FACE_DETECT_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15672759 // STATISTICS_HOT_PIXEL_MAP_MODE (<unidirectional association>)
	relation 15672759 --->
	  a role_name "STATISTICS_HOT_PIXEL_MAP_MODE" init_value "
            new Key<Boolean>(\"android.statistics.hotPixelMapMode\", boolean.class)" class_relation const_relation public
	    comment "
<p>Operating mode for hot pixel map generation.</p>
<p>If set to <code>true</code>, a hot pixel map is returned in {@link CaptureResult#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap}.
If set to <code>false</code>, no hot pixel map will be returned.</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES android.statistics.info.availableHotPixelMapModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureResult#STATISTICS_HOT_PIXEL_MAP
@see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15672759 // STATISTICS_HOT_PIXEL_MAP_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15672887 // STATISTICS_LENS_SHADING_MAP_MODE (<unidirectional association>)
	relation 15672887 --->
	  a role_name "STATISTICS_LENS_SHADING_MAP_MODE" init_value "
            new Key<Integer>(\"android.statistics.lensShadingMapMode\", int.class)" class_relation const_relation public
	    comment "
<p>Whether the camera device will output the lens
shading map in output result metadata.</p>
<p>When set to ON,
android.statistics.lensShadingMap will be provided in
the output result metadata.</p>
<p>ON is always supported on devices with the RAW capability.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #STATISTICS_LENS_SHADING_MAP_MODE_OFF OFF}</li>
  <li>{@link #STATISTICS_LENS_SHADING_MAP_MODE_ON ON}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES android.statistics.info.availableLensShadingMapModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES
@see #STATISTICS_LENS_SHADING_MAP_MODE_OFF
@see #STATISTICS_LENS_SHADING_MAP_MODE_ON

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15672887 // STATISTICS_LENS_SHADING_MAP_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15673015 // TONEMAP_CURVE_BLUE (<unidirectional association>)
	relation 15673015 --->
	  a role_name "TONEMAP_CURVE_BLUE" init_value "
            new Key<float[]>(\"android.tonemap.curveBlue\", float[].class)" class_relation const_relation public
	    comment "
<p>Tonemapping / contrast / gamma curve for the blue
channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
CONTRAST_CURVE.</p>
<p>See android.tonemap.curveRed for more details.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#TONEMAP_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    classrelation_ref 15673015 // TONEMAP_CURVE_BLUE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15673143 // TONEMAP_CURVE_GREEN (<unidirectional association>)
	relation 15673143 --->
	  a role_name "TONEMAP_CURVE_GREEN" init_value "
            new Key<float[]>(\"android.tonemap.curveGreen\", float[].class)" class_relation const_relation public
	    comment "
<p>Tonemapping / contrast / gamma curve for the green
channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
CONTRAST_CURVE.</p>
<p>See android.tonemap.curveRed for more details.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#TONEMAP_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    classrelation_ref 15673143 // TONEMAP_CURVE_GREEN (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15673271 // TONEMAP_CURVE_RED (<unidirectional association>)
	relation 15673271 --->
	  a role_name "TONEMAP_CURVE_RED" init_value "
            new Key<float[]>(\"android.tonemap.curveRed\", float[].class)" class_relation const_relation public
	    comment "
<p>Tonemapping / contrast / gamma curve for the red
channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
CONTRAST_CURVE.</p>
<p>Each channel's curve is defined by an array of control points:</p>
<pre><code>android.tonemap.curveRed =
  [ P0in, P0out, P1in, P1out, P2in, P2out, P3in, P3out, ..., PNin, PNout ]
2 &lt;= N &lt;= {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}</code></pre>
<p>These are sorted in order of increasing <code>Pin</code>; it is
required that input values 0.0 and 1.0 are included in the list to
define a complete mapping. For input values between control points,
the camera device must linearly interpolate between the control
points.</p>
<p>Each curve can have an independent number of points, and the number
of points can be less than max (that is, the request doesn't have to
always provide a curve with number of points equivalent to
{@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}).</p>
<p>A few examples, and their corresponding graphical mappings; these
only specify the red channel and the precision is limited to 4
digits, for conciseness.</p>
<p>Linear mapping:</p>
<pre><code>android.tonemap.curveRed = [ 0, 0, 1.0, 1.0 ]
</code></pre>
<p><img alt=\"Linear mapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/linear_tonemap.png\" /></p>
<p>Invert mapping:</p>
<pre><code>android.tonemap.curveRed = [ 0, 1.0, 1.0, 0 ]
</code></pre>
<p><img alt=\"Inverting mapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/inverse_tonemap.png\" /></p>
<p>Gamma 1/2.2 mapping, with 16 control points:</p>
<pre><code>android.tonemap.curveRed = [
  0.0000, 0.0000, 0.0667, 0.2920, 0.1333, 0.4002, 0.2000, 0.4812,
  0.2667, 0.5484, 0.3333, 0.6069, 0.4000, 0.6594, 0.4667, 0.7072,
  0.5333, 0.7515, 0.6000, 0.7928, 0.6667, 0.8317, 0.7333, 0.8685,
  0.8000, 0.9035, 0.8667, 0.9370, 0.9333, 0.9691, 1.0000, 1.0000 ]
</code></pre>
<p><img alt=\"Gamma = 1/2.2 tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/gamma_tonemap.png\" /></p>
<p>Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:</p>
<pre><code>android.tonemap.curveRed = [
  0.0000, 0.0000, 0.0667, 0.2864, 0.1333, 0.4007, 0.2000, 0.4845,
  0.2667, 0.5532, 0.3333, 0.6125, 0.4000, 0.6652, 0.4667, 0.7130,
  0.5333, 0.7569, 0.6000, 0.7977, 0.6667, 0.8360, 0.7333, 0.8721,
  0.8000, 0.9063, 0.8667, 0.9389, 0.9333, 0.9701, 1.0000, 1.0000 ]
</code></pre>
<p><img alt=\"sRGB tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>
<p><b>Range of valid values:</b><br>
0-1 on both input and output coordinates, normalized
as a floating-point value such that 0 == black and 1 == white.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS
@see CaptureRequest#TONEMAP_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    classrelation_ref 15673271 // TONEMAP_CURVE_RED (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15673399 // TONEMAP_CURVE (<unidirectional association>)
	relation 15673399 --->
	  a role_name "TONEMAP_CURVE" init_value "
            new Key<android.hardware.camera2.params.TonemapCurve>(\"android.tonemap.curve\", android.hardware.camera2.params.TonemapCurve.class)" class_relation const_relation public
	    comment "
<p>Tonemapping / contrast / gamma curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode}
is CONTRAST_CURVE.</p>
<p>The tonemapCurve consist of three curves for each of red, green, and blue
channels respectively. The following example uses the red channel as an
example. The same logic applies to green and blue channel.
Each channel's curve is defined by an array of control points:</p>
<pre><code>curveRed =
  [ P0(in, out), P1(in, out), P2(in, out), P3(in, out), ..., PN(in, out) ]
2 &lt;= N &lt;= {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}</code></pre>
<p>These are sorted in order of increasing <code>Pin</code>; it is always
guaranteed that input values 0.0 and 1.0 are included in the list to
define a complete mapping. For input values between control points,
the camera device must linearly interpolate between the control
points.</p>
<p>Each curve can have an independent number of points, and the number
of points can be less than max (that is, the request doesn't have to
always provide a curve with number of points equivalent to
{@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}).</p>
<p>A few examples, and their corresponding graphical mappings; these
only specify the red channel and the precision is limited to 4
digits, for conciseness.</p>
<p>Linear mapping:</p>
<pre><code>curveRed = [ (0, 0), (1.0, 1.0) ]
</code></pre>
<p><img alt=\"Linear mapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/linear_tonemap.png\" /></p>
<p>Invert mapping:</p>
<pre><code>curveRed = [ (0, 1.0), (1.0, 0) ]
</code></pre>
<p><img alt=\"Inverting mapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/inverse_tonemap.png\" /></p>
<p>Gamma 1/2.2 mapping, with 16 control points:</p>
<pre><code>curveRed = [
  (0.0000, 0.0000), (0.0667, 0.2920), (0.1333, 0.4002), (0.2000, 0.4812),
  (0.2667, 0.5484), (0.3333, 0.6069), (0.4000, 0.6594), (0.4667, 0.7072),
  (0.5333, 0.7515), (0.6000, 0.7928), (0.6667, 0.8317), (0.7333, 0.8685),
  (0.8000, 0.9035), (0.8667, 0.9370), (0.9333, 0.9691), (1.0000, 1.0000) ]
</code></pre>
<p><img alt=\"Gamma = 1/2.2 tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/gamma_tonemap.png\" /></p>
<p>Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:</p>
<pre><code>curveRed = [
  (0.0000, 0.0000), (0.0667, 0.2864), (0.1333, 0.4007), (0.2000, 0.4845),
  (0.2667, 0.5532), (0.3333, 0.6125), (0.4000, 0.6652), (0.4667, 0.7130),
  (0.5333, 0.7569), (0.6000, 0.7977), (0.6667, 0.8360), (0.7333, 0.8721),
  (0.8000, 0.9063), (0.8667, 0.9389), (0.9333, 0.9701), (1.0000, 1.0000) ]
</code></pre>
<p><img alt=\"sRGB tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS
@see CaptureRequest#TONEMAP_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.TonemapCurve> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15673399 // TONEMAP_CURVE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15673527 // TONEMAP_MODE (<unidirectional association>)
	relation 15673527 --->
	  a role_name "TONEMAP_MODE" init_value "
            new Key<Integer>(\"android.tonemap.mode\", int.class)" class_relation const_relation public
	    comment "
<p>High-level global contrast/gamma/tonemapping control.</p>
<p>When switching to an application-defined contrast curve by setting
{@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} to CONTRAST_CURVE, the curve is defined
per-channel with a set of <code>(in, out)</code> points that specify the
mapping from input high-bit-depth pixel value to the output
low-bit-depth value.  Since the actual pixel ranges of both input
and output may change depending on the camera pipeline, the values
are specified by normalized floating-point numbers.</p>
<p>More-complex color mapping operations such as 3D color look-up
tables, selective chroma enhancement, or other non-linear color
transforms will be disabled when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
CONTRAST_CURVE.</p>
<p>When using either FAST or HIGH_QUALITY, the camera device will
emit its own tonemap curve in {@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}.
These values are always available, and as close as possible to the
actually used nonlinear/nonglobal transforms.</p>
<p>If a request is sent with CONTRAST_CURVE with the camera device's
provided curve in FAST or HIGH_QUALITY, the image's tonemap will be
roughly the same.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #TONEMAP_MODE_CONTRAST_CURVE CONTRAST_CURVE}</li>
  <li>{@link #TONEMAP_MODE_FAST FAST}</li>
  <li>{@link #TONEMAP_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
  <li>{@link #TONEMAP_MODE_GAMMA_VALUE GAMMA_VALUE}</li>
  <li>{@link #TONEMAP_MODE_PRESET_CURVE PRESET_CURVE}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#TONEMAP_AVAILABLE_TONE_MAP_MODES android.tonemap.availableToneMapModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#TONEMAP_AVAILABLE_TONE_MAP_MODES
@see CaptureRequest#TONEMAP_CURVE
@see CaptureRequest#TONEMAP_MODE
@see #TONEMAP_MODE_CONTRAST_CURVE
@see #TONEMAP_MODE_FAST
@see #TONEMAP_MODE_HIGH_QUALITY
@see #TONEMAP_MODE_GAMMA_VALUE
@see #TONEMAP_MODE_PRESET_CURVE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15673527 // TONEMAP_MODE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15673655 // TONEMAP_GAMMA (<unidirectional association>)
	relation 15673655 --->
	  a role_name "TONEMAP_GAMMA" init_value "
            new Key<Float>(\"android.tonemap.gamma\", float.class)" class_relation const_relation public
	    comment "
<p>Tonemapping curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
GAMMA_VALUE</p>
<p>The tonemap curve will be defined the following formula:
* OUT = pow(IN, 1.0 / gamma)
where IN and OUT is the input pixel value scaled to range [0.0, 1.0],
pow is the power function and gamma is the gamma value specified by this
key.</p>
<p>The same curve will be applied to all color channels. The camera device
may clip the input gamma value to its supported range. The actual applied
value will be returned in capture result.</p>
<p>The valid range of gamma value varies on different devices, but values
within [1.0, 5.0] are guaranteed not to be clipped.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#TONEMAP_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15673655 // TONEMAP_GAMMA (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15673783 // TONEMAP_PRESET_CURVE (<unidirectional association>)
	relation 15673783 --->
	  a role_name "TONEMAP_PRESET_CURVE" init_value "
            new Key<Integer>(\"android.tonemap.presetCurve\", int.class)" class_relation const_relation public
	    comment "
<p>Tonemapping curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
PRESET_CURVE</p>
<p>The tonemap curve will be defined by specified standard.</p>
<p>sRGB (approximated by 16 control points):</p>
<p><img alt=\"sRGB tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>
<p>Rec. 709 (approximated by 16 control points):</p>
<p><img alt=\"Rec. 709 tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/rec709_tonemap.png\" /></p>
<p>Note that above figures show a 16 control points approximation of preset
curves. Camera devices may apply a different approximation to the curve.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #TONEMAP_PRESET_CURVE_SRGB SRGB}</li>
  <li>{@link #TONEMAP_PRESET_CURVE_REC709 REC709}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#TONEMAP_MODE
@see #TONEMAP_PRESET_CURVE_SRGB
@see #TONEMAP_PRESET_CURVE_REC709

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15673783 // TONEMAP_PRESET_CURVE (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15673911 // LED_TRANSMIT (<unidirectional association>)
	relation 15673911 --->
	  a role_name "LED_TRANSMIT" init_value "
            new Key<Boolean>(\"android.led.transmit\", boolean.class)" class_relation const_relation public
	    comment "
<p>This LED is nominally used to indicate to the user
that the camera is powered on and may be streaming images back to the
Application Processor. In certain rare circumstances, the OS may
disable this when video is processed locally and not transmitted to
any untrusted applications.</p>
<p>In particular, the LED <em>must</em> always be on when the data could be
transmitted off the device. The LED <em>should</em> always be on whenever
data is stored locally on the device.</p>
<p>The LED <em>may</em> be off if a trusted application is using the data that
doesn't violate the above rules.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    classrelation_ref 15673911 // LED_TRANSMIT (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15674039 // BLACK_LEVEL_LOCK (<unidirectional association>)
	relation 15674039 --->
	  a role_name "BLACK_LEVEL_LOCK" init_value "
            new Key<Boolean>(\"android.blackLevel.lock\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether black-level compensation is locked
to its current values, or is free to vary.</p>
<p>When set to <code>true</code> (ON), the values used for black-level
compensation will not change until the lock is set to
<code>false</code> (OFF).</p>
<p>Since changes to certain capture parameters (such as
exposure time) may require resetting of black level
compensation, the camera device must report whether setting
the black level lock was successful in the output result
metadata.</p>
<p>For example, if a sequence of requests is as follows:</p>
<ul>
<li>Request 1: Exposure = 10ms, Black level lock = OFF</li>
<li>Request 2: Exposure = 10ms, Black level lock = ON</li>
<li>Request 3: Exposure = 10ms, Black level lock = ON</li>
<li>Request 4: Exposure = 20ms, Black level lock = ON</li>
<li>Request 5: Exposure = 20ms, Black level lock = ON</li>
<li>Request 6: Exposure = 20ms, Black level lock = ON</li>
</ul>
<p>And the exposure change in Request 4 requires the camera
device to reset the black level offsets, then the output
result metadata is expected to be:</p>
<ul>
<li>Result 1: Exposure = 10ms, Black level lock = OFF</li>
<li>Result 2: Exposure = 10ms, Black level lock = ON</li>
<li>Result 3: Exposure = 10ms, Black level lock = ON</li>
<li>Result 4: Exposure = 20ms, Black level lock = OFF</li>
<li>Result 5: Exposure = 20ms, Black level lock = ON</li>
<li>Result 6: Exposure = 20ms, Black level lock = ON</li>
</ul>
<p>This indicates to the application that on frame 4, black
levels were reset due to exposure value changes, and pixel
values may not be consistent across captures.</p>
<p>The camera device will maintain the lock to the extent
possible, only overriding the lock to OFF when changes to
other request parameters require a black level recalculation
or reset.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15674039 // BLACK_LEVEL_LOCK (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15674167 // REPROCESS_EFFECTIVE_EXPOSURE_FACTOR (<unidirectional association>)
	relation 15674167 --->
	  a role_name "REPROCESS_EFFECTIVE_EXPOSURE_FACTOR" init_value "
            new Key<Float>(\"android.reprocess.effectiveExposureFactor\", float.class)" class_relation const_relation public
	    comment "
<p>The amount of exposure time increase factor applied to the original output
frame by the application processing before sending for reprocessing.</p>
<p>This is optional, and will be supported if the camera device supports YUV_REPROCESSING
capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains YUV_REPROCESSING).</p>
<p>For some YUV reprocessing use cases, the application may choose to filter the original
output frames to effectively reduce the noise to the same level as a frame that was
captured with longer exposure time. To be more specific, assuming the original captured
images were captured with a sensitivity of S and an exposure time of T, the model in
the camera device is that the amount of noise in the image would be approximately what
would be expected if the original capture parameters had been a sensitivity of
S/effectiveExposureFactor and an exposure time of T*effectiveExposureFactor, rather
than S and T respectively. If the captured images were processed by the application
before being sent for reprocessing, then the application may have used image processing
algorithms and/or multi-frame image fusion to reduce the noise in the
application-processed images (input images). By using the effectiveExposureFactor
control, the application can communicate to the camera device the actual noise level
improvement in the application-processed image. With this information, the camera
device can select appropriate noise reduction and edge enhancement parameters to avoid
excessive noise reduction ({@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode}) and insufficient edge
enhancement ({@link CaptureRequest#EDGE_MODE android.edge.mode}) being applied to the reprocessed frames.</p>
<p>For example, for multi-frame image fusion use case, the application may fuse
multiple output frames together to a final frame for reprocessing. When N image are
fused into 1 image for reprocessing, the exposure time increase factor could be up to
square root of N (based on a simple photon shot noise model). The camera device will
adjust the reprocessing noise reduction and edge enhancement parameters accordingly to
produce the best quality images.</p>
<p>This is relative factor, 1.0 indicates the application hasn't processed the input
buffer in a way that affects its effective exposure time.</p>
<p>This control is only effective for YUV reprocessing capture request. For noise
reduction reprocessing, it is only effective when <code>{@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode} != OFF</code>.
Similarly, for edge enhancement reprocessing, it is only effective when
<code>{@link CaptureRequest#EDGE_MODE android.edge.mode} != OFF</code>.</p>
<p><b>Units</b>: Relative exposure time increase factor.</p>
<p><b>Range of valid values:</b><br>
&gt;= 1.0</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#EDGE_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#NOISE_REDUCTION_MODE
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15674167 // REPROCESS_EFFECTIVE_EXPOSURE_FACTOR (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end
    end

    class 7148343 "CaptureResult"
      visibility public 
      nactuals 1
      actual class class_ref 7148983 // CameraMetadata
        rank 0 explicit_value ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "<p>The subset of the results of a single image capture from the image sensor.</p>

<p>Contains a subset of the final configuration for the capture hardware (sensor, lens,
flash), the processing pipeline, the control algorithms, and the output
buffers.</p>

<p>CaptureResults are produced by a {@link CameraDevice} after processing a
{@link CaptureRequest}. All properties listed for capture requests can also
be queried on the capture result, to determine the final values used for
capture. The result also includes additional metadata about the state of the
camera device during the capture.</p>

<p>Not all properties returned by {@link CameraCharacteristics#getAvailableCaptureResultKeys()}
are necessarily available. Some results are {@link CaptureResult partial} and will
not have every key set. Only {@link TotalCaptureResult total} results are guaranteed to have
every key available that was enabled by the request.</p>

<p>{@link CaptureResult} objects are immutable.</p>

"
      class 7149751 "Key"
	visibility public 
	nformals 1
	formal name "T" type "" explicit_default_value ""
	  explicit_extends ""
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 15674551 // mKey (<unidirectional association>)
	  relation 15674551 --->
	    a role_name "mKey" const_relation private
	      cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<T> ${name}${value};
"
	      classrelation_ref 15674551 // mKey (<unidirectional association>)
	    b parent class_ref 7149367 // Key
	end

	operation 79337399 "Key"
	  cpp_inline public explicit_return_type ""
	  nparams 2
	    param inout name "name" explicit_type "String"
	    param inout name "type" explicit_type "Class"
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1}<T> ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Visible for testing and vendor extensions only.

@hide
"
	end

	operation 79337527 "Key"
	  cpp_inline public explicit_return_type ""
	  nparams 2
	    param inout name "name" explicit_type "String"
	    param inout name "typeReference" type class_ref 7149495 // TypeReference
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1}<T> ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Visible for testing and vendor extensions only.

@hide
"
	end

	operation 79337655 "getName"
	  cpp_inline public explicit_return_type "String"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@NonNull
"
	  
	  
	  
	  comment "Return a camelCase, period separated name formatted like:
{@code \"root.section[.subsections].name\"}.

<p>Built-in keys exposed by the Android SDK are always prefixed with {@code \"android.\"};
keys that are device/platform-specific are prefixed with {@code \"com.\"}.</p>

<p>For example, {@code CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP} would
have a name of {@code \"android.scaler.streamConfigurationMap\"}; whereas a device
specific key might look like {@code \"com.google.nexus.data.private\"}.</p>

@return String representation of the key name
"
	end

	operation 79337783 "hashCode"
	  cpp_inline public explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@Override
"
	  
	  
	  
	  comment "{@inheritDoc}
"
	end

	operation 79337911 "equals"
	  cpp_inline public explicit_return_type "boolean"
	  nparams 1
	    param inout name "o" explicit_type "Object"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@SuppressWarnings(\"unchecked\")
@Override
"
	  
	  
	  
	  comment "{@inheritDoc}
"
	end

	operation 79338039 "toString"
	  cpp_inline public explicit_return_type "String"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@NonNull
@Override
"
	  
	  
	  
	  comment "Return this {@link Key} as a string representation.

<p>{@code \"CaptureResult.Key(%s)\"}, where {@code %s} represents
the name of this key as returned by {@link #getName}.</p>

@return string representation of {@link Key}
"
	end

	operation 79338167 "getNativeKey"
	  cpp_inline public return_type class_ref 7149367 // Key
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<T> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Visible for CameraMetadataNative implementation only; do not use.

TODO: Make this private or remove it altogether.

@hide
"
	end

	operation 79338295 "Key"
	  cpp_inline package explicit_return_type ""
	  nparams 1
	    param inout name "nativeKey" type class_ref 7149367 // Key
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0}<?> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@SuppressWarnings({ \"unchecked\" })
"
	  
	  
	  
	end
      end

      classrelation 15674295 // <realization>
	relation 15674295 -_-|>
	  stereotype "bind"
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 15674295 // <realization>
	  b parent class_ref 7148983 // CameraMetadata
      end

      attribute 24802743 "VERBOSE"
	class_attribute const_attribute private explicit_type "boolean"
	init_value " false"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      classrelation 15674679 // mResults (<unidirectional association>)
	relation 15674679 --->
	  a role_name "mResults" const_relation private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 15674679 // mResults (<unidirectional association>)
	  b parent class_ref 7149239 // CameraMetadataNative
      end

      classrelation 15674807 // mRequest (<unidirectional association>)
	relation 15674807 --->
	  a role_name "mRequest" const_relation private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 15674807 // mRequest (<unidirectional association>)
	  b parent class_ref 7147831 // CaptureRequest
      end

      attribute 24802871 "mSequenceId"
	const_attribute private explicit_type "int"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24802999 "mFrameNumber"
	const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 79338423 "CaptureResult"
	public explicit_return_type ""
	nparams 3
	  param inout name "results" type class_ref 7149239 // CameraMetadataNative
	  param inout name "parent" type class_ref 7147831 // CaptureRequest
	  param inout name "extras" type class_ref 7153207 // CaptureResultExtras
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Takes ownership of the passed-in properties object

<p>For internal use only</p>
@hide
"
      end

      operation 79338551 "getNativeCopy"
	public return_type class_ref 7149239 // CameraMetadataNative
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a copy of the underlying {@link CameraMetadataNative}.
@hide
"
      end

      operation 79338679 "CaptureResult"
	public explicit_return_type ""
	nparams 2
	  param inout name "results" type class_ref 7149239 // CameraMetadataNative
	  param in name "sequenceId" explicit_type "int"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a request-less result.

<p><strong>For testing only.</strong></p>
@hide
"
      end

      operation 79338807 "get"
	public explicit_return_type "T"
	nparams 1
	  param inout name "key" type class_ref 7149751 // Key
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Nullable
"
	
	
	
	comment "Get a capture result field value.

<p>The field definitions can be found in {@link CaptureResult}.</p>

<p>Querying the value for the same key more than once will return a value
which is equal to the previous queried value.</p>

@throws IllegalArgumentException if the key was not valid

@param key The result field to read.
@return The value of that key, or {@code null} if the field is not set.
"
      end

      operation 79338935 "getProtected"
	protected explicit_return_type "T"
	nparams 1
	  param inout name "key" type class_ref 7149751 // Key
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<?> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings(\"unchecked\")
@Override
"
	
	
	
	comment "{@inheritDoc}
@hide
"
      end

      operation 79339063 "getKeyClass"
	protected explicit_return_type "Class"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Key<?>> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings(\"unchecked\")
@Override
"
	
	
	
	comment "{@inheritDoc}
@hide
"
      end

      operation 79339191 "dumpToLog"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Dumps the native metadata contents to logcat.

<p>Visibility for testing/debugging only. The results will not
include any synthesized keys, as they are invisible to the native layer.</p>

@hide
"
      end

      operation 79339319 "getKeys"
	public return_type class_ref 7149751 // Key
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}List<${type}<?>> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
@NonNull
"
	
	
	
	comment "{@inheritDoc}
"
      end

      operation 79339447 "getRequest"
	public return_type class_ref 7147831 // CaptureRequest
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Get the request associated with this result.

<p>Whenever a request has been fully or partially captured, with
{@link CameraCaptureSession.CaptureCallback#onCaptureCompleted} or
{@link CameraCaptureSession.CaptureCallback#onCaptureProgressed}, the {@code result}'s
{@code getRequest()} will return that {@code request}.
</p>

<p>For example,
<code><pre>cameraDevice.capture(someRequest, new CaptureCallback() {
    {@literal @}Override
    void onCaptureCompleted(CaptureRequest myRequest, CaptureResult myResult) {
        assert(myResult.getRequest.equals(myRequest) == true);
    }
}, null);
</code></pre>
</p>

@return The request associated with this result. Never {@code null}.
"
      end

      operation 79339575 "getFrameNumber"
	public explicit_return_type "long"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Get the frame number associated with this result.

<p>Whenever a request has been processed, regardless of failure or success,
it gets a unique frame number assigned to its future result/failure.</p>

<p>For the same type of request (capturing from the camera device or reprocessing), this
value monotonically increments, starting with 0, for every new result or failure and the
scope is the lifetime of the {@link CameraDevice}. Between different types of requests,
the frame number may not monotonically increment. For example, the frame number of a newer
reprocess result may be smaller than the frame number of an older result of capturing new
images from the camera device, but the frame number of a newer reprocess result will never be
smaller than the frame number of an older reprocess result.</p>

@return The frame number

@see CameraDevice#createCaptureRequest
@see CameraDevice#createReprocessCaptureRequest
"
      end

      operation 79339703 "getSequenceId"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "The sequence ID for this failure that was returned by the
{@link CameraCaptureSession#capture} family of functions.

<p>The sequence ID is a unique monotonically increasing value starting from 0,
incremented every time a new group of requests is submitted to the CameraDevice.</p>

@return int The ID for the sequence of requests that this capture result is a part of

@see CameraDevice.CaptureCallback#onCaptureSequenceCompleted
@see CameraDevice.CaptureCallback#onCaptureSequenceAborted
"
      end

      classrelation 15674935 // COLOR_CORRECTION_MODE (<unidirectional association>)
	relation 15674935 --->
	  a role_name "COLOR_CORRECTION_MODE" init_value "
            new Key<Integer>(\"android.colorCorrection.mode\", int.class)" class_relation const_relation public
	    comment "@O~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~
The key entries below this point are generated from metadata
definitions in /system/media/camera/docs. Do not modify by hand or
modify the comment blocks at the start or end.
~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~

<p>The mode control selects how the image data is converted from the
sensor's native color into linear sRGB color.</p>
<p>When auto-white balance (AWB) is enabled with {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, this
control is overridden by the AWB routine. When AWB is disabled, the
application controls how the color mapping is performed.</p>
<p>We define the expected processing pipeline below. For consistency
across devices, this is always the case with TRANSFORM_MATRIX.</p>
<p>When either FULL or HIGH_QUALITY is used, the camera device may
do additional processing but {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and
{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} will still be provided by the
camera device (in the results) and be roughly correct.</p>
<p>Switching to TRANSFORM_MATRIX and using the data provided from
FAST or HIGH_QUALITY will yield a picture with the same white point
as what was produced by the camera device in the earlier frame.</p>
<p>The expected processing pipeline is as follows:</p>
<p><img alt=\"White balance processing pipeline\" src=\"../../../../images/camera2/metadata/android.colorCorrection.mode/processing_pipeline.png\" /></p>
<p>The white balance is encoded by two values, a 4-channel white-balance
gain vector (applied in the Bayer domain), and a 3x3 color transform
matrix (applied after demosaic).</p>
<p>The 4-channel white-balance gains are defined as:</p>
<pre><code>{@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} = [ R G_even G_odd B ]
</code></pre>
<p>where <code>G_even</code> is the gain for green pixels on even rows of the
output, and <code>G_odd</code> is the gain for green pixels on the odd rows.
These may be identical for a given camera device implementation; if
the camera device does not support a separate gain for even/odd green
channels, it will use the <code>G_even</code> value, and write <code>G_odd</code> equal to
<code>G_even</code> in the output result metadata.</p>
<p>The matrices for color transforms are defined as a 9-entry vector:</p>
<pre><code>{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} = [ I0 I1 I2 I3 I4 I5 I6 I7 I8 ]
</code></pre>
<p>which define a transform from input sensor colors, <code>P_in = [ r g b ]</code>,
to output linear sRGB, <code>P_out = [ r' g' b' ]</code>,</p>
<p>with colors as follows:</p>
<pre><code>r' = I0r + I1g + I2b
g' = I3r + I4g + I5b
b' = I6r + I7g + I8b
</code></pre>
<p>Both the input and output value ranges must match. Overflow/underflow
values are clipped to fit within the range.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #COLOR_CORRECTION_MODE_TRANSFORM_MATRIX TRANSFORM_MATRIX}</li>
  <li>{@link #COLOR_CORRECTION_MODE_FAST FAST}</li>
  <li>{@link #COLOR_CORRECTION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see #COLOR_CORRECTION_MODE_TRANSFORM_MATRIX
@see #COLOR_CORRECTION_MODE_FAST
@see #COLOR_CORRECTION_MODE_HIGH_QUALITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15674935 // COLOR_CORRECTION_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15675063 // COLOR_CORRECTION_TRANSFORM (<unidirectional association>)
	relation 15675063 --->
	  a role_name "COLOR_CORRECTION_TRANSFORM" init_value "
            new Key<android.hardware.camera2.params.ColorSpaceTransform>(\"android.colorCorrection.transform\", android.hardware.camera2.params.ColorSpaceTransform.class)" class_relation const_relation public
	    comment "
<p>A color transform matrix to use to transform
from sensor RGB color space to output linear sRGB color space.</p>
<p>This matrix is either set by the camera device when the request
{@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is not TRANSFORM_MATRIX, or
directly by the application in the request when the
{@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is TRANSFORM_MATRIX.</p>
<p>In the latter case, the camera device may round the matrix to account
for precision issues; the final rounded matrix should be reported back
in this matrix result metadata. The transform should keep the magnitude
of the output color values within <code>[0, 1.0]</code> (assuming input color
values is within the normalized range <code>[0, 1.0]</code>), or clipping may occur.</p>
<p>The valid range of each matrix element varies on different devices, but
values within [-1.5, 3.0] are guaranteed not to be clipped.</p>
<p><b>Units</b>: Unitless scale factors</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#COLOR_CORRECTION_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.ColorSpaceTransform> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15675063 // COLOR_CORRECTION_TRANSFORM (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15675191 // COLOR_CORRECTION_GAINS (<unidirectional association>)
	relation 15675191 --->
	  a role_name "COLOR_CORRECTION_GAINS" init_value "
            new Key<android.hardware.camera2.params.RggbChannelVector>(\"android.colorCorrection.gains\", android.hardware.camera2.params.RggbChannelVector.class)" class_relation const_relation public
	    comment "
<p>Gains applying to Bayer raw color channels for
white-balance.</p>
<p>These per-channel gains are either set by the camera device
when the request {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is not
TRANSFORM_MATRIX, or directly by the application in the
request when the {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is
TRANSFORM_MATRIX.</p>
<p>The gains in the result metadata are the gains actually
applied by the camera device to the current frame.</p>
<p>The valid range of gains varies on different devices, but gains
between [1.0, 3.0] are guaranteed not to be clipped. Even if a given
device allows gains below 1.0, this is usually not recommended because
this can create color artifacts.</p>
<p><b>Units</b>: Unitless gain factors</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#COLOR_CORRECTION_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.RggbChannelVector> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15675191 // COLOR_CORRECTION_GAINS (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15675319 // COLOR_CORRECTION_ABERRATION_MODE (<unidirectional association>)
	relation 15675319 --->
	  a role_name "COLOR_CORRECTION_ABERRATION_MODE" init_value "
            new Key<Integer>(\"android.colorCorrection.aberrationMode\", int.class)" class_relation const_relation public
	    comment "
<p>Mode of operation for the chromatic aberration correction algorithm.</p>
<p>Chromatic (color) aberration is caused by the fact that different wavelengths of light
can not focus on the same point after exiting from the lens. This metadata defines
the high level control of chromatic aberration correction algorithm, which aims to
minimize the chromatic artifacts that may occur along the object boundaries in an
image.</p>
<p>FAST/HIGH_QUALITY both mean that camera device determined aberration
correction will be applied. HIGH_QUALITY mode indicates that the camera device will
use the highest-quality aberration correction algorithms, even if it slows down
capture rate. FAST means the camera device will not slow down capture rate when
applying aberration correction.</p>
<p>LEGACY devices will always be in FAST mode.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_OFF OFF}</li>
  <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_FAST FAST}</li>
  <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES android.colorCorrection.availableAberrationModes}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES
@see #COLOR_CORRECTION_ABERRATION_MODE_OFF
@see #COLOR_CORRECTION_ABERRATION_MODE_FAST
@see #COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15675319 // COLOR_CORRECTION_ABERRATION_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15675447 // CONTROL_AE_ANTIBANDING_MODE (<unidirectional association>)
	relation 15675447 --->
	  a role_name "CONTROL_AE_ANTIBANDING_MODE" init_value "
            new Key<Integer>(\"android.control.aeAntibandingMode\", int.class)" class_relation const_relation public
	    comment "
<p>The desired setting for the camera device's auto-exposure
algorithm's antibanding compensation.</p>
<p>Some kinds of lighting fixtures, such as some fluorescent
lights, flicker at the rate of the power supply frequency
(60Hz or 50Hz, depending on country). While this is
typically not noticeable to a person, it can be visible to
a camera device. If a camera sets its exposure time to the
wrong value, the flicker may become visible in the
viewfinder as flicker or in a final captured image, as a
set of variable-brightness bands across the image.</p>
<p>Therefore, the auto-exposure routines of camera devices
include antibanding routines that ensure that the chosen
exposure value will not cause such banding. The choice of
exposure time depends on the rate of flicker, which the
camera device can detect automatically, or the expected
rate can be selected by the application using this
control.</p>
<p>A given camera device may not support all of the possible
options for the antibanding mode. The
{@link CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES android.control.aeAvailableAntibandingModes} key contains
the available modes for a given camera device.</p>
<p>AUTO mode is the default if it is available on given
camera device. When AUTO mode is not available, the
default will be either 50HZ or 60HZ, and both 50HZ
and 60HZ will be available.</p>
<p>If manual exposure control is enabled (by setting
{@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} to OFF),
then this setting has no effect, and the application must
ensure it selects exposure times that do not cause banding
issues. The {@link CaptureResult#STATISTICS_SCENE_FLICKER android.statistics.sceneFlicker} key can assist
the application in this.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AE_ANTIBANDING_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_AE_ANTIBANDING_MODE_50HZ 50HZ}</li>
  <li>{@link #CONTROL_AE_ANTIBANDING_MODE_60HZ 60HZ}</li>
  <li>{@link #CONTROL_AE_ANTIBANDING_MODE_AUTO AUTO}</li>
</ul></p>
<p><b>Available values for this device:</b><br></p>
<p>{@link CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES android.control.aeAvailableAntibandingModes}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES
@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CaptureResult#STATISTICS_SCENE_FLICKER
@see #CONTROL_AE_ANTIBANDING_MODE_OFF
@see #CONTROL_AE_ANTIBANDING_MODE_50HZ
@see #CONTROL_AE_ANTIBANDING_MODE_60HZ
@see #CONTROL_AE_ANTIBANDING_MODE_AUTO

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15675447 // CONTROL_AE_ANTIBANDING_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15675575 // CONTROL_AE_EXPOSURE_COMPENSATION (<unidirectional association>)
	relation 15675575 --->
	  a role_name "CONTROL_AE_EXPOSURE_COMPENSATION" init_value "
            new Key<Integer>(\"android.control.aeExposureCompensation\", int.class)" class_relation const_relation public
	    comment "
<p>Adjustment to auto-exposure (AE) target image
brightness.</p>
<p>The adjustment is measured as a count of steps, with the
step size defined by {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP android.control.aeCompensationStep} and the
allowed range by {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE android.control.aeCompensationRange}.</p>
<p>For example, if the exposure value (EV) step is 0.333, '6'
will mean an exposure compensation of +2 EV; -3 will mean an
exposure compensation of -1 EV. One EV represents a doubling
of image brightness. Note that this control will only be
effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} <code>!=</code> OFF. This control
will take effect even when {@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} <code>== true</code>.</p>
<p>In the event of exposure compensation value being changed, camera device
may take several frames to reach the newly requested exposure target.
During that time, {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} field will be in the SEARCHING
state. Once the new exposure target is reached, {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} will
change from SEARCHING to either CONVERGED, LOCKED (if AE lock is enabled), or
FLASH_REQUIRED (if the scene is too dark for still capture).</p>
<p><b>Units</b>: Compensation steps</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE android.control.aeCompensationRange}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE
@see CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP
@see CaptureRequest#CONTROL_AE_LOCK
@see CaptureRequest#CONTROL_AE_MODE
@see CaptureResult#CONTROL_AE_STATE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15675575 // CONTROL_AE_EXPOSURE_COMPENSATION (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15675703 // CONTROL_AE_LOCK (<unidirectional association>)
	relation 15675703 --->
	  a role_name "CONTROL_AE_LOCK" init_value "
            new Key<Boolean>(\"android.control.aeLock\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether auto-exposure (AE) is currently locked to its latest
calculated values.</p>
<p>When set to <code>true</code> (ON), the AE algorithm is locked to its latest parameters,
and will not change exposure settings until the lock is set to <code>false</code> (OFF).</p>
<p>Note that even when AE is locked, the flash may be fired if
the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is ON_AUTO_FLASH /
ON_ALWAYS_FLASH / ON_AUTO_FLASH_REDEYE.</p>
<p>When {@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation} is changed, even if the AE lock
is ON, the camera device will still adjust its exposure value.</p>
<p>If AE precapture is triggered (see {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger})
when AE is already locked, the camera device will not change the exposure time
({@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime}) and sensitivity ({@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity})
parameters. The flash may be fired if the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}
is ON_AUTO_FLASH/ON_AUTO_FLASH_REDEYE and the scene is too dark. If the
{@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is ON_ALWAYS_FLASH, the scene may become overexposed.
Similarly, AE precapture trigger CANCEL has no effect when AE is already locked.</p>
<p>When an AE precapture sequence is triggered, AE unlock will not be able to unlock
the AE if AE is locked by the camera device internally during precapture metering
sequence In other words, submitting requests with AE unlock has no effect for an
ongoing precapture metering sequence. Otherwise, the precapture metering sequence
will never succeed in a sequence of preview requests where AE lock is always set
to <code>false</code>.</p>
<p>Since the camera device has a pipeline of in-flight requests, the settings that
get locked do not necessarily correspond to the settings that were present in the
latest capture result received from the camera device, since additional captures
and AE updates may have occurred even before the result was sent out. If an
application is switching between automatic and manual control and wishes to eliminate
any flicker during the switch, the following procedure is recommended:</p>
<ol>
<li>Starting in auto-AE mode:</li>
<li>Lock AE</li>
<li>Wait for the first result to be output that has the AE locked</li>
<li>Copy exposure settings from that result into a request, set the request to manual AE</li>
<li>Submit the capture request, proceed to run manual AE as desired.</li>
</ol>
<p>See {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} for AE lock related state transition details.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION
@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureResult#CONTROL_AE_STATE
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15675703 // CONTROL_AE_LOCK (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15675831 // CONTROL_AE_MODE (<unidirectional association>)
	relation 15675831 --->
	  a role_name "CONTROL_AE_MODE" init_value "
            new Key<Integer>(\"android.control.aeMode\", int.class)" class_relation const_relation public
	    comment "
<p>The desired mode for the camera device's
auto-exposure routine.</p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} is
AUTO.</p>
<p>When set to any of the ON modes, the camera device's
auto-exposure routine is enabled, overriding the
application's selected exposure time, sensor sensitivity,
and frame duration ({@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},
{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, and
{@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}). If one of the FLASH modes
is selected, the camera device's flash unit controls are
also overridden.</p>
<p>The FLASH modes are only available if the camera device
has a flash unit ({@link CameraCharacteristics#FLASH_INFO_AVAILABLE android.flash.info.available} is <code>true</code>).</p>
<p>If flash TORCH mode is desired, this field must be set to
ON or OFF, and {@link CaptureRequest#FLASH_MODE android.flash.mode} set to TORCH.</p>
<p>When set to any of the ON modes, the values chosen by the
camera device auto-exposure routine for the overridden
fields for a given capture will be available in its
CaptureResult.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AE_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_AE_MODE_ON ON}</li>
  <li>{@link #CONTROL_AE_MODE_ON_AUTO_FLASH ON_AUTO_FLASH}</li>
  <li>{@link #CONTROL_AE_MODE_ON_ALWAYS_FLASH ON_ALWAYS_FLASH}</li>
  <li>{@link #CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE ON_AUTO_FLASH_REDEYE}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES android.control.aeAvailableModes}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#FLASH_INFO_AVAILABLE
@see CaptureRequest#FLASH_MODE
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_FRAME_DURATION
@see CaptureRequest#SENSOR_SENSITIVITY
@see #CONTROL_AE_MODE_OFF
@see #CONTROL_AE_MODE_ON
@see #CONTROL_AE_MODE_ON_AUTO_FLASH
@see #CONTROL_AE_MODE_ON_ALWAYS_FLASH
@see #CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15675831 // CONTROL_AE_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15675959 // CONTROL_AE_REGIONS (<unidirectional association>)
	relation 15675959 --->
	  a role_name "CONTROL_AE_REGIONS" init_value "
            new Key<android.hardware.camera2.params.MeteringRectangle[]>(\"android.control.aeRegions\", android.hardware.camera2.params.MeteringRectangle[].class)" class_relation const_relation public
	    comment "
<p>List of metering areas to use for auto-exposure adjustment.</p>
<p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AE android.control.maxRegionsAe} is 0.
Otherwise will always be present.</p>
<p>The maximum number of regions supported by the device is determined by the value
of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AE android.control.maxRegionsAe}.</p>
<p>The coordinate system is based on the active pixel array,
with (0,0) being the top-left pixel in the active pixel array, and
({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the
bottom-right pixel in the active pixel array.</p>
<p>The weight must be within <code>[0, 1000]</code>, and represents a weight
for every pixel in the area. This means that a large metering area
with the same weight as a smaller area will have more effect in
the metering result. Metering areas can partially overlap and the
camera device will add the weights in the overlap region.</p>
<p>The weights are relative to weights of other exposure metering regions, so if only one
region is used, all non-zero weights will have the same effect. A region with 0
weight is ignored.</p>
<p>If all regions have 0 weight, then no specific metering area needs to be used by the
camera device.</p>
<p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in
capture result metadata, the camera device will ignore the sections outside the crop
region and output only the intersection rectangle as the metering region in the result
metadata.  If the region is entirely outside the crop region, it will be ignored and
not reported in the result metadata.</p>
<p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Range of valid values:</b><br>
Coordinates must be between <code>[(0,0), (width, height))</code> of
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#CONTROL_MAX_REGIONS_AE
@see CaptureRequest#SCALER_CROP_REGION
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.MeteringRectangle[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15675959 // CONTROL_AE_REGIONS (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15676087 // CONTROL_AE_TARGET_FPS_RANGE (<unidirectional association>)
	relation 15676087 --->
	  a role_name "CONTROL_AE_TARGET_FPS_RANGE" init_value "
            new Key<android.util.Range<Integer>>(\"android.control.aeTargetFpsRange\", new TypeReference<android.util.Range<Integer>>() {{ }})" class_relation const_relation public
	    comment "
<p>Range over which the auto-exposure routine can
adjust the capture frame rate to maintain good
exposure.</p>
<p>Only constrains auto-exposure (AE) algorithm, not
manual control of {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime} and
{@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}.</p>
<p><b>Units</b>: Frames per second (FPS)</p>
<p><b>Range of valid values:</b><br>
Any of the entries in {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_FRAME_DURATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Range<Integer>> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15676087 // CONTROL_AE_TARGET_FPS_RANGE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15676215 // CONTROL_AE_PRECAPTURE_TRIGGER (<unidirectional association>)
	relation 15676215 --->
	  a role_name "CONTROL_AE_PRECAPTURE_TRIGGER" init_value "
            new Key<Integer>(\"android.control.aePrecaptureTrigger\", int.class)" class_relation const_relation public
	    comment "
<p>Whether the camera device will trigger a precapture
metering sequence when it processes this request.</p>
<p>This entry is normally set to IDLE, or is not
included at all in the request settings. When included and
set to START, the camera device will trigger the auto-exposure (AE)
precapture metering sequence.</p>
<p>When set to CANCEL, the camera device will cancel any active
precapture metering trigger, and return to its initial AE state.
If a precapture metering sequence is already completed, and the camera
device has implicitly locked the AE for subsequent still capture, the
CANCEL trigger will unlock the AE and return to its initial AE state.</p>
<p>The precapture sequence should be triggered before starting a
high-quality still capture for final metering decisions to
be made, and for firing pre-capture flash pulses to estimate
scene brightness and required final capture flash power, when
the flash is enabled.</p>
<p>Normally, this entry should be set to START for only a
single request, and the application should wait until the
sequence completes before starting a new one.</p>
<p>When a precapture metering sequence is finished, the camera device
may lock the auto-exposure routine internally to be able to accurately expose the
subsequent still capture image (<code>{@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} == STILL_CAPTURE</code>).
For this case, the AE may not resume normal scan if no subsequent still capture is
submitted. To ensure that the AE routine restarts normal scan, the application should
submit a request with <code>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} == true</code>, followed by a request
with <code>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} == false</code>, if the application decides not to submit a
still capture request after the precapture sequence completes. Alternatively, for
API level 23 or newer devices, the CANCEL can be used to unlock the camera device
internally locked AE if the application doesn't submit a still capture request after
the AE precapture trigger. Note that, the CANCEL was added in API level 23, and must not
be used in devices that have earlier API levels.</p>
<p>The exact effect of auto-exposure (AE) precapture trigger
depends on the current AE mode and state; see
{@link CaptureResult#CONTROL_AE_STATE android.control.aeState} for AE precapture state transition
details.</p>
<p>On LEGACY-level devices, the precapture trigger is not supported;
capturing a high-resolution JPEG image will automatically trigger a
precapture sequence before the high-resolution capture, including
potentially firing a pre-capture flash.</p>
<p>Using the precapture trigger and the auto-focus trigger {@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}
simultaneously is allowed. However, since these triggers often require cooperation between
the auto-focus and auto-exposure routines (for example, the may need to be enabled for a
focus sweep), the camera device may delay acting on a later trigger until the previous
trigger has been fully handled. This may lead to longer intervals between the trigger and
changes to {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} indicating the start of the precapture sequence, for
example.</p>
<p>If both the precapture and the auto-focus trigger are activated on the same request, then
the camera device will complete them in the optimal order for that device.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_IDLE IDLE}</li>
  <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_START START}</li>
  <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL CANCEL}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_LOCK
@see CaptureResult#CONTROL_AE_STATE
@see CaptureRequest#CONTROL_AF_TRIGGER
@see CaptureRequest#CONTROL_CAPTURE_INTENT
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see #CONTROL_AE_PRECAPTURE_TRIGGER_IDLE
@see #CONTROL_AE_PRECAPTURE_TRIGGER_START
@see #CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15676215 // CONTROL_AE_PRECAPTURE_TRIGGER (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15676343 // CONTROL_AE_STATE (<unidirectional association>)
	relation 15676343 --->
	  a role_name "CONTROL_AE_STATE" init_value "
            new Key<Integer>(\"android.control.aeState\", int.class)" class_relation const_relation public
	    comment "
<p>Current state of the auto-exposure (AE) algorithm.</p>
<p>Switching between or enabling AE modes ({@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}) always
resets the AE state to INACTIVE. Similarly, switching between {@link CaptureRequest#CONTROL_MODE android.control.mode},
or {@link CaptureRequest#CONTROL_SCENE_MODE android.control.sceneMode} if <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} == USE_SCENE_MODE</code> resets all
the algorithm states to INACTIVE.</p>
<p>The camera device can do several state transitions between two results, if it is
allowed by the state transition table. For example: INACTIVE may never actually be
seen in a result.</p>
<p>The state in the result is the state for this image (in sync with this image): if
AE state becomes CONVERGED, then the image data associated with this result should
be good to use.</p>
<p>Below are state transition tables for different AE modes.</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\"></td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Camera device auto exposure algorithm is disabled</td>
</tr>
</tbody>
</table>
<p>When {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is AE_MODE_ON_*:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Camera device initiates AE scan</td>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">Values changing</td>
</tr>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is ON</td>
<td align=\"center\">LOCKED</td>
<td align=\"center\">Values locked</td>
</tr>
<tr>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">Camera device finishes AE scan</td>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Good values, not changing</td>
</tr>
<tr>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">Camera device finishes AE scan</td>
<td align=\"center\">FLASH_REQUIRED</td>
<td align=\"center\">Converged but too dark w/o flash</td>
</tr>
<tr>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is ON</td>
<td align=\"center\">LOCKED</td>
<td align=\"center\">Values locked</td>
</tr>
<tr>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Camera device initiates AE scan</td>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">Values changing</td>
</tr>
<tr>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is ON</td>
<td align=\"center\">LOCKED</td>
<td align=\"center\">Values locked</td>
</tr>
<tr>
<td align=\"center\">FLASH_REQUIRED</td>
<td align=\"center\">Camera device initiates AE scan</td>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">Values changing</td>
</tr>
<tr>
<td align=\"center\">FLASH_REQUIRED</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is ON</td>
<td align=\"center\">LOCKED</td>
<td align=\"center\">Values locked</td>
</tr>
<tr>
<td align=\"center\">LOCKED</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is OFF</td>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">Values not good after unlock</td>
</tr>
<tr>
<td align=\"center\">LOCKED</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is OFF</td>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Values good after unlock</td>
</tr>
<tr>
<td align=\"center\">LOCKED</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is OFF</td>
<td align=\"center\">FLASH_REQUIRED</td>
<td align=\"center\">Exposure good, but too dark</td>
</tr>
<tr>
<td align=\"center\">PRECAPTURE</td>
<td align=\"center\">Sequence done. {@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is OFF</td>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Ready for high-quality capture</td>
</tr>
<tr>
<td align=\"center\">PRECAPTURE</td>
<td align=\"center\">Sequence done. {@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is ON</td>
<td align=\"center\">LOCKED</td>
<td align=\"center\">Ready for high-quality capture</td>
</tr>
<tr>
<td align=\"center\">LOCKED</td>
<td align=\"center\">aeLock is ON and aePrecaptureTrigger is START</td>
<td align=\"center\">LOCKED</td>
<td align=\"center\">Precapture trigger is ignored when AE is already locked</td>
</tr>
<tr>
<td align=\"center\">LOCKED</td>
<td align=\"center\">aeLock is ON and aePrecaptureTrigger is CANCEL</td>
<td align=\"center\">LOCKED</td>
<td align=\"center\">Precapture trigger is ignored when AE is already locked</td>
</tr>
<tr>
<td align=\"center\">Any state (excluding LOCKED)</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is START</td>
<td align=\"center\">PRECAPTURE</td>
<td align=\"center\">Start AE precapture metering sequence</td>
</tr>
<tr>
<td align=\"center\">Any state (excluding LOCKED)</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is CANCEL</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Currently active precapture metering sequence is canceled</td>
</tr>
</tbody>
</table>
<p>For the above table, the camera device may skip reporting any state changes that happen
without application intervention (i.e. mode switch, trigger, locking). Any state that
can be skipped in that manner is called a transient state.</p>
<p>For example, for above AE modes (AE_MODE_ON_*), in addition to the state transitions
listed in above table, it is also legal for the camera device to skip one or more
transient states between two results. See below table for examples:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Camera device finished AE scan</td>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Values are already good, transient states are skipped by camera device.</td>
</tr>
<tr>
<td align=\"center\">Any state (excluding LOCKED)</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is START, sequence done</td>
<td align=\"center\">FLASH_REQUIRED</td>
<td align=\"center\">Converged but too dark w/o flash after a precapture sequence, transient states are skipped by camera device.</td>
</tr>
<tr>
<td align=\"center\">Any state (excluding LOCKED)</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is START, sequence done</td>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Converged after a precapture sequence, transient states are skipped by camera device.</td>
</tr>
<tr>
<td align=\"center\">Any state (excluding LOCKED)</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is CANCEL, converged</td>
<td align=\"center\">FLASH_REQUIRED</td>
<td align=\"center\">Converged but too dark w/o flash after a precapture sequence is canceled, transient states are skipped by camera device.</td>
</tr>
<tr>
<td align=\"center\">Any state (excluding LOCKED)</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is CANCEL, converged</td>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Converged after a precapture sequenceis canceled, transient states are skipped by camera device.</td>
</tr>
<tr>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Camera device finished AE scan</td>
<td align=\"center\">FLASH_REQUIRED</td>
<td align=\"center\">Converged but too dark w/o flash after a new scan, transient states are skipped by camera device.</td>
</tr>
<tr>
<td align=\"center\">FLASH_REQUIRED</td>
<td align=\"center\">Camera device finished AE scan</td>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Converged after a new scan, transient states are skipped by camera device.</td>
</tr>
</tbody>
</table>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AE_STATE_INACTIVE INACTIVE}</li>
  <li>{@link #CONTROL_AE_STATE_SEARCHING SEARCHING}</li>
  <li>{@link #CONTROL_AE_STATE_CONVERGED CONVERGED}</li>
  <li>{@link #CONTROL_AE_STATE_LOCKED LOCKED}</li>
  <li>{@link #CONTROL_AE_STATE_FLASH_REQUIRED FLASH_REQUIRED}</li>
  <li>{@link #CONTROL_AE_STATE_PRECAPTURE PRECAPTURE}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_LOCK
@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureRequest#CONTROL_MODE
@see CaptureRequest#CONTROL_SCENE_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see #CONTROL_AE_STATE_INACTIVE
@see #CONTROL_AE_STATE_SEARCHING
@see #CONTROL_AE_STATE_CONVERGED
@see #CONTROL_AE_STATE_LOCKED
@see #CONTROL_AE_STATE_FLASH_REQUIRED
@see #CONTROL_AE_STATE_PRECAPTURE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15676343 // CONTROL_AE_STATE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15676471 // CONTROL_AF_MODE (<unidirectional association>)
	relation 15676471 --->
	  a role_name "CONTROL_AF_MODE" init_value "
            new Key<Integer>(\"android.control.afMode\", int.class)" class_relation const_relation public
	    comment "
<p>Whether auto-focus (AF) is currently enabled, and what
mode it is set to.</p>
<p>Only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} = AUTO and the lens is not fixed focus
(i.e. <code>{@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance} &gt; 0</code>). Also note that
when {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is OFF, the behavior of AF is device
dependent. It is recommended to lock AF by using {@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger} before
setting {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} to OFF, or set AF mode to OFF when AE is OFF.</p>
<p>If the lens is controlled by the camera device auto-focus algorithm,
the camera device will report the current AF status in {@link CaptureResult#CONTROL_AF_STATE android.control.afState}
in result metadata.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AF_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_AF_MODE_AUTO AUTO}</li>
  <li>{@link #CONTROL_AF_MODE_MACRO MACRO}</li>
  <li>{@link #CONTROL_AF_MODE_CONTINUOUS_VIDEO CONTINUOUS_VIDEO}</li>
  <li>{@link #CONTROL_AF_MODE_CONTINUOUS_PICTURE CONTINUOUS_PICTURE}</li>
  <li>{@link #CONTROL_AF_MODE_EDOF EDOF}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AF_AVAILABLE_MODES android.control.afAvailableModes}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CameraCharacteristics#CONTROL_AF_AVAILABLE_MODES
@see CaptureResult#CONTROL_AF_STATE
@see CaptureRequest#CONTROL_AF_TRIGGER
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE
@see #CONTROL_AF_MODE_OFF
@see #CONTROL_AF_MODE_AUTO
@see #CONTROL_AF_MODE_MACRO
@see #CONTROL_AF_MODE_CONTINUOUS_VIDEO
@see #CONTROL_AF_MODE_CONTINUOUS_PICTURE
@see #CONTROL_AF_MODE_EDOF

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15676471 // CONTROL_AF_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15676599 // CONTROL_AF_REGIONS (<unidirectional association>)
	relation 15676599 --->
	  a role_name "CONTROL_AF_REGIONS" init_value "
            new Key<android.hardware.camera2.params.MeteringRectangle[]>(\"android.control.afRegions\", android.hardware.camera2.params.MeteringRectangle[].class)" class_relation const_relation public
	    comment "
<p>List of metering areas to use for auto-focus.</p>
<p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AF android.control.maxRegionsAf} is 0.
Otherwise will always be present.</p>
<p>The maximum number of focus areas supported by the device is determined by the value
of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AF android.control.maxRegionsAf}.</p>
<p>The coordinate system is based on the active pixel array,
with (0,0) being the top-left pixel in the active pixel array, and
({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the
bottom-right pixel in the active pixel array.</p>
<p>The weight must be within <code>[0, 1000]</code>, and represents a weight
for every pixel in the area. This means that a large metering area
with the same weight as a smaller area will have more effect in
the metering result. Metering areas can partially overlap and the
camera device will add the weights in the overlap region.</p>
<p>The weights are relative to weights of other metering regions, so if only one region
is used, all non-zero weights will have the same effect. A region with 0 weight is
ignored.</p>
<p>If all regions have 0 weight, then no specific metering area needs to be used by the
camera device.</p>
<p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in
capture result metadata, the camera device will ignore the sections outside the crop
region and output only the intersection rectangle as the metering region in the result
metadata. If the region is entirely outside the crop region, it will be ignored and
not reported in the result metadata.</p>
<p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Range of valid values:</b><br>
Coordinates must be between <code>[(0,0), (width, height))</code> of
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#CONTROL_MAX_REGIONS_AF
@see CaptureRequest#SCALER_CROP_REGION
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.MeteringRectangle[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15676599 // CONTROL_AF_REGIONS (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15676727 // CONTROL_AF_TRIGGER (<unidirectional association>)
	relation 15676727 --->
	  a role_name "CONTROL_AF_TRIGGER" init_value "
            new Key<Integer>(\"android.control.afTrigger\", int.class)" class_relation const_relation public
	    comment "
<p>Whether the camera device will trigger autofocus for this request.</p>
<p>This entry is normally set to IDLE, or is not
included at all in the request settings.</p>
<p>When included and set to START, the camera device will trigger the
autofocus algorithm. If autofocus is disabled, this trigger has no effect.</p>
<p>When set to CANCEL, the camera device will cancel any active trigger,
and return to its initial AF state.</p>
<p>Generally, applications should set this entry to START or CANCEL for only a
single capture, and then return it to IDLE (or not set at all). Specifying
START for multiple captures in a row means restarting the AF operation over
and over again.</p>
<p>See {@link CaptureResult#CONTROL_AF_STATE android.control.afState} for what the trigger means for each AF mode.</p>
<p>Using the autofocus trigger and the precapture trigger {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}
simultaneously is allowed. However, since these triggers often require cooperation between
the auto-focus and auto-exposure routines (for example, the may need to be enabled for a
focus sweep), the camera device may delay acting on a later trigger until the previous
trigger has been fully handled. This may lead to longer intervals between the trigger and
changes to {@link CaptureResult#CONTROL_AF_STATE android.control.afState}, for example.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AF_TRIGGER_IDLE IDLE}</li>
  <li>{@link #CONTROL_AF_TRIGGER_START START}</li>
  <li>{@link #CONTROL_AF_TRIGGER_CANCEL CANCEL}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureResult#CONTROL_AF_STATE
@see #CONTROL_AF_TRIGGER_IDLE
@see #CONTROL_AF_TRIGGER_START
@see #CONTROL_AF_TRIGGER_CANCEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15676727 // CONTROL_AF_TRIGGER (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15676855 // CONTROL_AF_STATE (<unidirectional association>)
	relation 15676855 --->
	  a role_name "CONTROL_AF_STATE" init_value "
            new Key<Integer>(\"android.control.afState\", int.class)" class_relation const_relation public
	    comment "
<p>Current state of auto-focus (AF) algorithm.</p>
<p>Switching between or enabling AF modes ({@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}) always
resets the AF state to INACTIVE. Similarly, switching between {@link CaptureRequest#CONTROL_MODE android.control.mode},
or {@link CaptureRequest#CONTROL_SCENE_MODE android.control.sceneMode} if <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} == USE_SCENE_MODE</code> resets all
the algorithm states to INACTIVE.</p>
<p>The camera device can do several state transitions between two results, if it is
allowed by the state transition table. For example: INACTIVE may never actually be
seen in a result.</p>
<p>The state in the result is the state for this image (in sync with this image): if
AF state becomes FOCUSED, then the image data associated with this result should
be sharp.</p>
<p>Below are state transition tables for different AF modes.</p>
<p>When {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode} is AF_MODE_OFF or AF_MODE_EDOF:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\"></td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Never changes</td>
</tr>
</tbody>
</table>
<p>When {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode} is AF_MODE_AUTO or AF_MODE_MACRO:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">ACTIVE_SCAN</td>
<td align=\"center\">Start AF sweep, Lens now moving</td>
</tr>
<tr>
<td align=\"center\">ACTIVE_SCAN</td>
<td align=\"center\">AF sweep done</td>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">Focused, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">ACTIVE_SCAN</td>
<td align=\"center\">AF sweep done</td>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">Not focused, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">ACTIVE_SCAN</td>
<td align=\"center\">AF_CANCEL</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Cancel/reset AF, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">AF_CANCEL</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Cancel/reset AF</td>
</tr>
<tr>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">ACTIVE_SCAN</td>
<td align=\"center\">Start new sweep, Lens now moving</td>
</tr>
<tr>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">AF_CANCEL</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Cancel/reset AF</td>
</tr>
<tr>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">ACTIVE_SCAN</td>
<td align=\"center\">Start new sweep, Lens now moving</td>
</tr>
<tr>
<td align=\"center\">Any state</td>
<td align=\"center\">Mode change</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\"></td>
</tr>
</tbody>
</table>
<p>For the above table, the camera device may skip reporting any state changes that happen
without application intervention (i.e. mode switch, trigger, locking). Any state that
can be skipped in that manner is called a transient state.</p>
<p>For example, for these AF modes (AF_MODE_AUTO and AF_MODE_MACRO), in addition to the
state transitions listed in above table, it is also legal for the camera device to skip
one or more transient states between two results. See below table for examples:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">Focus is already good or good after a scan, lens is now locked.</td>
</tr>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">Focus failed after a scan, lens is now locked.</td>
</tr>
<tr>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">Focus is already good or good after a scan, lens is now locked.</td>
</tr>
<tr>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">Focus is good after a scan, lens is not locked.</td>
</tr>
</tbody>
</table>
<p>When {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode} is AF_MODE_CONTINUOUS_VIDEO:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Camera device initiates new scan</td>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">Start AF scan, Lens now moving</td>
</tr>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">AF state query, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">Camera device completes current scan</td>
<td align=\"center\">PASSIVE_FOCUSED</td>
<td align=\"center\">End AF scan, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">Camera device fails current scan</td>
<td align=\"center\">PASSIVE_UNFOCUSED</td>
<td align=\"center\">End AF scan, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">Immediate transition, if focus is good. Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">Immediate transition, if focus is bad. Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">AF_CANCEL</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Reset lens position, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_FOCUSED</td>
<td align=\"center\">Camera device initiates new scan</td>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">Start AF scan, Lens now moving</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_UNFOCUSED</td>
<td align=\"center\">Camera device initiates new scan</td>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">Start AF scan, Lens now moving</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_FOCUSED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">Immediate transition, lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_UNFOCUSED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">Immediate transition, lens now locked</td>
</tr>
<tr>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">No effect</td>
</tr>
<tr>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">AF_CANCEL</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Restart AF scan</td>
</tr>
<tr>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">No effect</td>
</tr>
<tr>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">AF_CANCEL</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Restart AF scan</td>
</tr>
</tbody>
</table>
<p>When {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode} is AF_MODE_CONTINUOUS_PICTURE:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Camera device initiates new scan</td>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">Start AF scan, Lens now moving</td>
</tr>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">AF state query, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">Camera device completes current scan</td>
<td align=\"center\">PASSIVE_FOCUSED</td>
<td align=\"center\">End AF scan, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">Camera device fails current scan</td>
<td align=\"center\">PASSIVE_UNFOCUSED</td>
<td align=\"center\">End AF scan, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">Eventual transition once the focus is good. Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">Eventual transition if cannot find focus. Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">AF_CANCEL</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Reset lens position, Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_FOCUSED</td>
<td align=\"center\">Camera device initiates new scan</td>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">Start AF scan, Lens now moving</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_UNFOCUSED</td>
<td align=\"center\">Camera device initiates new scan</td>
<td align=\"center\">PASSIVE_SCAN</td>
<td align=\"center\">Start AF scan, Lens now moving</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_FOCUSED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">Immediate trans. Lens now locked</td>
</tr>
<tr>
<td align=\"center\">PASSIVE_UNFOCUSED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">Immediate trans. Lens now locked</td>
</tr>
<tr>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">No effect</td>
</tr>
<tr>
<td align=\"center\">FOCUSED_LOCKED</td>
<td align=\"center\">AF_CANCEL</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Restart AF scan</td>
</tr>
<tr>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">AF_TRIGGER</td>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">No effect</td>
</tr>
<tr>
<td align=\"center\">NOT_FOCUSED_LOCKED</td>
<td align=\"center\">AF_CANCEL</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Restart AF scan</td>
</tr>
</tbody>
</table>
<p>When switch between AF_MODE_CONTINUOUS_* (CAF modes) and AF_MODE_AUTO/AF_MODE_MACRO
(AUTO modes), the initial INACTIVE or PASSIVE_SCAN states may be skipped by the
camera device. When a trigger is included in a mode switch request, the trigger
will be evaluated in the context of the new mode in the request.
See below table for examples:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">any state</td>
<td align=\"center\">CAF--&gt;AUTO mode switch</td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Mode switch without trigger, initial state must be INACTIVE</td>
</tr>
<tr>
<td align=\"center\">any state</td>
<td align=\"center\">CAF--&gt;AUTO mode switch with AF_TRIGGER</td>
<td align=\"center\">trigger-reachable states from INACTIVE</td>
<td align=\"center\">Mode switch with trigger, INACTIVE is skipped</td>
</tr>
<tr>
<td align=\"center\">any state</td>
<td align=\"center\">AUTO--&gt;CAF mode switch</td>
<td align=\"center\">passively reachable states from INACTIVE</td>
<td align=\"center\">Mode switch without trigger, passive transient state is skipped</td>
</tr>
</tbody>
</table>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AF_STATE_INACTIVE INACTIVE}</li>
  <li>{@link #CONTROL_AF_STATE_PASSIVE_SCAN PASSIVE_SCAN}</li>
  <li>{@link #CONTROL_AF_STATE_PASSIVE_FOCUSED PASSIVE_FOCUSED}</li>
  <li>{@link #CONTROL_AF_STATE_ACTIVE_SCAN ACTIVE_SCAN}</li>
  <li>{@link #CONTROL_AF_STATE_FOCUSED_LOCKED FOCUSED_LOCKED}</li>
  <li>{@link #CONTROL_AF_STATE_NOT_FOCUSED_LOCKED NOT_FOCUSED_LOCKED}</li>
  <li>{@link #CONTROL_AF_STATE_PASSIVE_UNFOCUSED PASSIVE_UNFOCUSED}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AF_MODE
@see CaptureRequest#CONTROL_MODE
@see CaptureRequest#CONTROL_SCENE_MODE
@see #CONTROL_AF_STATE_INACTIVE
@see #CONTROL_AF_STATE_PASSIVE_SCAN
@see #CONTROL_AF_STATE_PASSIVE_FOCUSED
@see #CONTROL_AF_STATE_ACTIVE_SCAN
@see #CONTROL_AF_STATE_FOCUSED_LOCKED
@see #CONTROL_AF_STATE_NOT_FOCUSED_LOCKED
@see #CONTROL_AF_STATE_PASSIVE_UNFOCUSED

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15676855 // CONTROL_AF_STATE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15676983 // CONTROL_AWB_LOCK (<unidirectional association>)
	relation 15676983 --->
	  a role_name "CONTROL_AWB_LOCK" init_value "
            new Key<Boolean>(\"android.control.awbLock\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether auto-white balance (AWB) is currently locked to its
latest calculated values.</p>
<p>When set to <code>true</code> (ON), the AWB algorithm is locked to its latest parameters,
and will not change color balance settings until the lock is set to <code>false</code> (OFF).</p>
<p>Since the camera device has a pipeline of in-flight requests, the settings that
get locked do not necessarily correspond to the settings that were present in the
latest capture result received from the camera device, since additional captures
and AWB updates may have occurred even before the result was sent out. If an
application is switching between automatic and manual control and wishes to eliminate
any flicker during the switch, the following procedure is recommended:</p>
<ol>
<li>Starting in auto-AWB mode:</li>
<li>Lock AWB</li>
<li>Wait for the first result to be output that has the AWB locked</li>
<li>Copy AWB settings from that result into a request, set the request to manual AWB</li>
<li>Submit the capture request, proceed to run manual AWB as desired.</li>
</ol>
<p>Note that AWB lock is only meaningful when
{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} is in the AUTO mode; in other modes,
AWB is already fixed to a specific setting.</p>
<p>Some LEGACY devices may not support ON; the value is then overridden to OFF.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AWB_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15676983 // CONTROL_AWB_LOCK (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15677111 // CONTROL_AWB_MODE (<unidirectional association>)
	relation 15677111 --->
	  a role_name "CONTROL_AWB_MODE" init_value "
            new Key<Integer>(\"android.control.awbMode\", int.class)" class_relation const_relation public
	    comment "
<p>Whether auto-white balance (AWB) is currently setting the color
transform fields, and what its illumination target
is.</p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} is AUTO.</p>
<p>When set to the ON mode, the camera device's auto-white balance
routine is enabled, overriding the application's selected
{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}, {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and
{@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode}. Note that when {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}
is OFF, the behavior of AWB is device dependent. It is recommened to
also set AWB mode to OFF or lock AWB by using {@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} before
setting AE mode to OFF.</p>
<p>When set to the OFF mode, the camera device's auto-white balance
routine is disabled. The application manually controls the white
balance by {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}, {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains}
and {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode}.</p>
<p>When set to any other modes, the camera device's auto-white
balance routine is disabled. The camera device uses each
particular illumination target for white balance
adjustment. The application's values for
{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform},
{@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and
{@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} are ignored.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AWB_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_AWB_MODE_AUTO AUTO}</li>
  <li>{@link #CONTROL_AWB_MODE_INCANDESCENT INCANDESCENT}</li>
  <li>{@link #CONTROL_AWB_MODE_FLUORESCENT FLUORESCENT}</li>
  <li>{@link #CONTROL_AWB_MODE_WARM_FLUORESCENT WARM_FLUORESCENT}</li>
  <li>{@link #CONTROL_AWB_MODE_DAYLIGHT DAYLIGHT}</li>
  <li>{@link #CONTROL_AWB_MODE_CLOUDY_DAYLIGHT CLOUDY_DAYLIGHT}</li>
  <li>{@link #CONTROL_AWB_MODE_TWILIGHT TWILIGHT}</li>
  <li>{@link #CONTROL_AWB_MODE_SHADE SHADE}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AWB_AVAILABLE_MODES android.control.awbAvailableModes}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_MODE
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AE_MODE
@see CameraCharacteristics#CONTROL_AWB_AVAILABLE_MODES
@see CaptureRequest#CONTROL_AWB_LOCK
@see CaptureRequest#CONTROL_MODE
@see #CONTROL_AWB_MODE_OFF
@see #CONTROL_AWB_MODE_AUTO
@see #CONTROL_AWB_MODE_INCANDESCENT
@see #CONTROL_AWB_MODE_FLUORESCENT
@see #CONTROL_AWB_MODE_WARM_FLUORESCENT
@see #CONTROL_AWB_MODE_DAYLIGHT
@see #CONTROL_AWB_MODE_CLOUDY_DAYLIGHT
@see #CONTROL_AWB_MODE_TWILIGHT
@see #CONTROL_AWB_MODE_SHADE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15677111 // CONTROL_AWB_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15677239 // CONTROL_AWB_REGIONS (<unidirectional association>)
	relation 15677239 --->
	  a role_name "CONTROL_AWB_REGIONS" init_value "
            new Key<android.hardware.camera2.params.MeteringRectangle[]>(\"android.control.awbRegions\", android.hardware.camera2.params.MeteringRectangle[].class)" class_relation const_relation public
	    comment "
<p>List of metering areas to use for auto-white-balance illuminant
estimation.</p>
<p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AWB android.control.maxRegionsAwb} is 0.
Otherwise will always be present.</p>
<p>The maximum number of regions supported by the device is determined by the value
of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AWB android.control.maxRegionsAwb}.</p>
<p>The coordinate system is based on the active pixel array,
with (0,0) being the top-left pixel in the active pixel array, and
({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the
bottom-right pixel in the active pixel array.</p>
<p>The weight must range from 0 to 1000, and represents a weight
for every pixel in the area. This means that a large metering area
with the same weight as a smaller area will have more effect in
the metering result. Metering areas can partially overlap and the
camera device will add the weights in the overlap region.</p>
<p>The weights are relative to weights of other white balance metering regions, so if
only one region is used, all non-zero weights will have the same effect. A region with
0 weight is ignored.</p>
<p>If all regions have 0 weight, then no specific metering area needs to be used by the
camera device.</p>
<p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in
capture result metadata, the camera device will ignore the sections outside the crop
region and output only the intersection rectangle as the metering region in the result
metadata.  If the region is entirely outside the crop region, it will be ignored and
not reported in the result metadata.</p>
<p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Range of valid values:</b><br>
Coordinates must be between <code>[(0,0), (width, height))</code> of
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#CONTROL_MAX_REGIONS_AWB
@see CaptureRequest#SCALER_CROP_REGION
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.MeteringRectangle[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15677239 // CONTROL_AWB_REGIONS (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15677367 // CONTROL_CAPTURE_INTENT (<unidirectional association>)
	relation 15677367 --->
	  a role_name "CONTROL_CAPTURE_INTENT" init_value "
            new Key<Integer>(\"android.control.captureIntent\", int.class)" class_relation const_relation public
	    comment "
<p>Information to the camera device 3A (auto-exposure,
auto-focus, auto-white balance) routines about the purpose
of this capture, to help the camera device to decide optimal 3A
strategy.</p>
<p>This control (except for MANUAL) is only effective if
<code>{@link CaptureRequest#CONTROL_MODE android.control.mode} != OFF</code> and any 3A routine is active.</p>
<p>ZERO_SHUTTER_LAG will be supported if {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities}
contains PRIVATE_REPROCESSING or YUV_REPROCESSING. MANUAL will be supported if
{@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains MANUAL_SENSOR. Other intent values are
always supported.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_CAPTURE_INTENT_CUSTOM CUSTOM}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_PREVIEW PREVIEW}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_STILL_CAPTURE STILL_CAPTURE}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_VIDEO_RECORD VIDEO_RECORD}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT VIDEO_SNAPSHOT}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>
  <li>{@link #CONTROL_CAPTURE_INTENT_MANUAL MANUAL}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see #CONTROL_CAPTURE_INTENT_CUSTOM
@see #CONTROL_CAPTURE_INTENT_PREVIEW
@see #CONTROL_CAPTURE_INTENT_STILL_CAPTURE
@see #CONTROL_CAPTURE_INTENT_VIDEO_RECORD
@see #CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT
@see #CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG
@see #CONTROL_CAPTURE_INTENT_MANUAL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15677367 // CONTROL_CAPTURE_INTENT (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15677495 // CONTROL_AWB_STATE (<unidirectional association>)
	relation 15677495 --->
	  a role_name "CONTROL_AWB_STATE" init_value "
            new Key<Integer>(\"android.control.awbState\", int.class)" class_relation const_relation public
	    comment "
<p>Current state of auto-white balance (AWB) algorithm.</p>
<p>Switching between or enabling AWB modes ({@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}) always
resets the AWB state to INACTIVE. Similarly, switching between {@link CaptureRequest#CONTROL_MODE android.control.mode},
or {@link CaptureRequest#CONTROL_SCENE_MODE android.control.sceneMode} if <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} == USE_SCENE_MODE</code> resets all
the algorithm states to INACTIVE.</p>
<p>The camera device can do several state transitions between two results, if it is
allowed by the state transition table. So INACTIVE may never actually be seen in
a result.</p>
<p>The state in the result is the state for this image (in sync with this image): if
AWB state becomes CONVERGED, then the image data associated with this result should
be good to use.</p>
<p>Below are state transition tables for different AWB modes.</p>
<p>When <code>{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} != AWB_MODE_AUTO</code>:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\"></td>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Camera device auto white balance algorithm is disabled</td>
</tr>
</tbody>
</table>
<p>When {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} is AWB_MODE_AUTO:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Camera device initiates AWB scan</td>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">Values changing</td>
</tr>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} is ON</td>
<td align=\"center\">LOCKED</td>
<td align=\"center\">Values locked</td>
</tr>
<tr>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">Camera device finishes AWB scan</td>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Good values, not changing</td>
</tr>
<tr>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} is ON</td>
<td align=\"center\">LOCKED</td>
<td align=\"center\">Values locked</td>
</tr>
<tr>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Camera device initiates AWB scan</td>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">Values changing</td>
</tr>
<tr>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} is ON</td>
<td align=\"center\">LOCKED</td>
<td align=\"center\">Values locked</td>
</tr>
<tr>
<td align=\"center\">LOCKED</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} is OFF</td>
<td align=\"center\">SEARCHING</td>
<td align=\"center\">Values not good after unlock</td>
</tr>
</tbody>
</table>
<p>For the above table, the camera device may skip reporting any state changes that happen
without application intervention (i.e. mode switch, trigger, locking). Any state that
can be skipped in that manner is called a transient state.</p>
<p>For example, for this AWB mode (AWB_MODE_AUTO), in addition to the state transitions
listed in above table, it is also legal for the camera device to skip one or more
transient states between two results. See below table for examples:</p>
<table>
<thead>
<tr>
<th align=\"center\">State</th>
<th align=\"center\">Transition Cause</th>
<th align=\"center\">New State</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">INACTIVE</td>
<td align=\"center\">Camera device finished AWB scan</td>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Values are already good, transient states are skipped by camera device.</td>
</tr>
<tr>
<td align=\"center\">LOCKED</td>
<td align=\"center\">{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} is OFF</td>
<td align=\"center\">CONVERGED</td>
<td align=\"center\">Values good after unlock, transient states are skipped by camera device.</td>
</tr>
</tbody>
</table>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_AWB_STATE_INACTIVE INACTIVE}</li>
  <li>{@link #CONTROL_AWB_STATE_SEARCHING SEARCHING}</li>
  <li>{@link #CONTROL_AWB_STATE_CONVERGED CONVERGED}</li>
  <li>{@link #CONTROL_AWB_STATE_LOCKED LOCKED}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AWB_LOCK
@see CaptureRequest#CONTROL_AWB_MODE
@see CaptureRequest#CONTROL_MODE
@see CaptureRequest#CONTROL_SCENE_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see #CONTROL_AWB_STATE_INACTIVE
@see #CONTROL_AWB_STATE_SEARCHING
@see #CONTROL_AWB_STATE_CONVERGED
@see #CONTROL_AWB_STATE_LOCKED

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15677495 // CONTROL_AWB_STATE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15677623 // CONTROL_EFFECT_MODE (<unidirectional association>)
	relation 15677623 --->
	  a role_name "CONTROL_EFFECT_MODE" init_value "
            new Key<Integer>(\"android.control.effectMode\", int.class)" class_relation const_relation public
	    comment "
<p>A special color effect to apply.</p>
<p>When this mode is set, a color effect will be applied
to images produced by the camera device. The interpretation
and implementation of these color effects is left to the
implementor of the camera device, and should not be
depended on to be consistent (or present) across all
devices.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_EFFECT_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_EFFECT_MODE_MONO MONO}</li>
  <li>{@link #CONTROL_EFFECT_MODE_NEGATIVE NEGATIVE}</li>
  <li>{@link #CONTROL_EFFECT_MODE_SOLARIZE SOLARIZE}</li>
  <li>{@link #CONTROL_EFFECT_MODE_SEPIA SEPIA}</li>
  <li>{@link #CONTROL_EFFECT_MODE_POSTERIZE POSTERIZE}</li>
  <li>{@link #CONTROL_EFFECT_MODE_WHITEBOARD WHITEBOARD}</li>
  <li>{@link #CONTROL_EFFECT_MODE_BLACKBOARD BLACKBOARD}</li>
  <li>{@link #CONTROL_EFFECT_MODE_AQUA AQUA}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AVAILABLE_EFFECTS android.control.availableEffects}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AVAILABLE_EFFECTS
@see #CONTROL_EFFECT_MODE_OFF
@see #CONTROL_EFFECT_MODE_MONO
@see #CONTROL_EFFECT_MODE_NEGATIVE
@see #CONTROL_EFFECT_MODE_SOLARIZE
@see #CONTROL_EFFECT_MODE_SEPIA
@see #CONTROL_EFFECT_MODE_POSTERIZE
@see #CONTROL_EFFECT_MODE_WHITEBOARD
@see #CONTROL_EFFECT_MODE_BLACKBOARD
@see #CONTROL_EFFECT_MODE_AQUA

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15677623 // CONTROL_EFFECT_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15677751 // CONTROL_MODE (<unidirectional association>)
	relation 15677751 --->
	  a role_name "CONTROL_MODE" init_value "
            new Key<Integer>(\"android.control.mode\", int.class)" class_relation const_relation public
	    comment "
<p>Overall mode of 3A (auto-exposure, auto-white-balance, auto-focus) control
routines.</p>
<p>This is a top-level 3A control switch. When set to OFF, all 3A control
by the camera device is disabled. The application must set the fields for
capture parameters itself.</p>
<p>When set to AUTO, the individual algorithm controls in
android.control.* are in effect, such as {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}.</p>
<p>When set to USE_SCENE_MODE, the individual controls in
android.control.* are mostly disabled, and the camera device implements
one of the scene mode settings (such as ACTION, SUNSET, or PARTY)
as it wishes. The camera device scene mode 3A settings are provided by
{@link android.hardware.camera2.CaptureResult capture results}.</p>
<p>When set to OFF_KEEP_STATE, it is similar to OFF mode, the only difference
is that this frame will not be used by camera device background 3A statistics
update, as if this frame is never captured. This mode can be used in the scenario
where the application doesn't want a 3A manual control capture to affect
the subsequent auto 3A capture results.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_MODE_AUTO AUTO}</li>
  <li>{@link #CONTROL_MODE_USE_SCENE_MODE USE_SCENE_MODE}</li>
  <li>{@link #CONTROL_MODE_OFF_KEEP_STATE OFF_KEEP_STATE}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AVAILABLE_MODES android.control.availableModes}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AF_MODE
@see CameraCharacteristics#CONTROL_AVAILABLE_MODES
@see #CONTROL_MODE_OFF
@see #CONTROL_MODE_AUTO
@see #CONTROL_MODE_USE_SCENE_MODE
@see #CONTROL_MODE_OFF_KEEP_STATE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15677751 // CONTROL_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15677879 // CONTROL_SCENE_MODE (<unidirectional association>)
	relation 15677879 --->
	  a role_name "CONTROL_SCENE_MODE" init_value "
            new Key<Integer>(\"android.control.sceneMode\", int.class)" class_relation const_relation public
	    comment "
<p>Control for which scene mode is currently active.</p>
<p>Scene modes are custom camera modes optimized for a certain set of conditions and
capture settings.</p>
<p>This is the mode that that is active when
<code>{@link CaptureRequest#CONTROL_MODE android.control.mode} == USE_SCENE_MODE</code>. Aside from FACE_PRIORITY, these modes will
disable {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}, {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, and {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}
while in use.</p>
<p>The interpretation and implementation of these scene modes is left
to the implementor of the camera device. Their behavior will not be
consistent across all devices, and any given device may only implement
a subset of these modes.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_SCENE_MODE_DISABLED DISABLED}</li>
  <li>{@link #CONTROL_SCENE_MODE_FACE_PRIORITY FACE_PRIORITY}</li>
  <li>{@link #CONTROL_SCENE_MODE_ACTION ACTION}</li>
  <li>{@link #CONTROL_SCENE_MODE_PORTRAIT PORTRAIT}</li>
  <li>{@link #CONTROL_SCENE_MODE_LANDSCAPE LANDSCAPE}</li>
  <li>{@link #CONTROL_SCENE_MODE_NIGHT NIGHT}</li>
  <li>{@link #CONTROL_SCENE_MODE_NIGHT_PORTRAIT NIGHT_PORTRAIT}</li>
  <li>{@link #CONTROL_SCENE_MODE_THEATRE THEATRE}</li>
  <li>{@link #CONTROL_SCENE_MODE_BEACH BEACH}</li>
  <li>{@link #CONTROL_SCENE_MODE_SNOW SNOW}</li>
  <li>{@link #CONTROL_SCENE_MODE_SUNSET SUNSET}</li>
  <li>{@link #CONTROL_SCENE_MODE_STEADYPHOTO STEADYPHOTO}</li>
  <li>{@link #CONTROL_SCENE_MODE_FIREWORKS FIREWORKS}</li>
  <li>{@link #CONTROL_SCENE_MODE_SPORTS SPORTS}</li>
  <li>{@link #CONTROL_SCENE_MODE_PARTY PARTY}</li>
  <li>{@link #CONTROL_SCENE_MODE_CANDLELIGHT CANDLELIGHT}</li>
  <li>{@link #CONTROL_SCENE_MODE_BARCODE BARCODE}</li>
  <li>{@link #CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO HIGH_SPEED_VIDEO}</li>
  <li>{@link #CONTROL_SCENE_MODE_HDR HDR}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES android.control.availableSceneModes}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AF_MODE
@see CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES
@see CaptureRequest#CONTROL_AWB_MODE
@see CaptureRequest#CONTROL_MODE
@see #CONTROL_SCENE_MODE_DISABLED
@see #CONTROL_SCENE_MODE_FACE_PRIORITY
@see #CONTROL_SCENE_MODE_ACTION
@see #CONTROL_SCENE_MODE_PORTRAIT
@see #CONTROL_SCENE_MODE_LANDSCAPE
@see #CONTROL_SCENE_MODE_NIGHT
@see #CONTROL_SCENE_MODE_NIGHT_PORTRAIT
@see #CONTROL_SCENE_MODE_THEATRE
@see #CONTROL_SCENE_MODE_BEACH
@see #CONTROL_SCENE_MODE_SNOW
@see #CONTROL_SCENE_MODE_SUNSET
@see #CONTROL_SCENE_MODE_STEADYPHOTO
@see #CONTROL_SCENE_MODE_FIREWORKS
@see #CONTROL_SCENE_MODE_SPORTS
@see #CONTROL_SCENE_MODE_PARTY
@see #CONTROL_SCENE_MODE_CANDLELIGHT
@see #CONTROL_SCENE_MODE_BARCODE
@see #CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO
@see #CONTROL_SCENE_MODE_HDR

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15677879 // CONTROL_SCENE_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15678007 // CONTROL_VIDEO_STABILIZATION_MODE (<unidirectional association>)
	relation 15678007 --->
	  a role_name "CONTROL_VIDEO_STABILIZATION_MODE" init_value "
            new Key<Integer>(\"android.control.videoStabilizationMode\", int.class)" class_relation const_relation public
	    comment "
<p>Whether video stabilization is
active.</p>
<p>Video stabilization automatically warps images from
the camera in order to stabilize motion between consecutive frames.</p>
<p>If enabled, video stabilization can modify the
{@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} to keep the video stream stabilized.</p>
<p>Switching between different video stabilization modes may take several
frames to initialize, the camera device will report the current mode
in capture result metadata. For example, When \"ON\" mode is requested,
the video stabilization modes in the first several capture results may
still be \"OFF\", and it will become \"ON\" when the initialization is
done.</p>
<p>In addition, not all recording sizes or frame rates may be supported for
stabilization by a device that reports stabilization support. It is guaranteed
that an output targeting a MediaRecorder or MediaCodec will be stabilized if
the recording resolution is less than or equal to 1920 x 1080 (width less than
or equal to 1920, height less than or equal to 1080), and the recording
frame rate is less than or equal to 30fps.  At other sizes, the CaptureResult
{@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode} field will return
OFF if the recording output is not stabilized, or if there are no output
Surface types that can be stabilized.</p>
<p>If a camera device supports both this mode and OIS
({@link CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode}), turning both modes on may
produce undesirable interaction, so it is recommended not to enable
both at the same time.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #CONTROL_VIDEO_STABILIZATION_MODE_OFF OFF}</li>
  <li>{@link #CONTROL_VIDEO_STABILIZATION_MODE_ON ON}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE
@see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE
@see CaptureRequest#SCALER_CROP_REGION
@see #CONTROL_VIDEO_STABILIZATION_MODE_OFF
@see #CONTROL_VIDEO_STABILIZATION_MODE_ON

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15678007 // CONTROL_VIDEO_STABILIZATION_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15678135 // CONTROL_POST_RAW_SENSITIVITY_BOOST (<unidirectional association>)
	relation 15678135 --->
	  a role_name "CONTROL_POST_RAW_SENSITIVITY_BOOST" init_value "
            new Key<Integer>(\"android.control.postRawSensitivityBoost\", int.class)" class_relation const_relation public
	    comment "
<p>The amount of additional sensitivity boost applied to output images
after RAW sensor data is captured.</p>
<p>Some camera devices support additional digital sensitivity boosting in the
camera processing pipeline after sensor RAW image is captured.
Such a boost will be applied to YUV/JPEG format output images but will not
have effect on RAW output formats like RAW_SENSOR, RAW10, RAW12 or RAW_OPAQUE.</p>
<p>This key will be <code>null</code> for devices that do not support any RAW format
outputs. For devices that do support RAW format outputs, this key will always
present, and if a device does not support post RAW sensitivity boost, it will
list <code>100</code> in this key.</p>
<p>If the camera device cannot apply the exact boost requested, it will reduce the
boost to the nearest supported value.
The final boost value used will be available in the output capture result.</p>
<p>For devices that support post RAW sensitivity boost, the YUV/JPEG output images
of such device will have the total sensitivity of
<code>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity} * {@link CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST android.control.postRawSensitivityBoost} / 100</code>
The sensitivity of RAW format images will always be <code>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</code></p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to
OFF; otherwise the auto-exposure algorithm will override this value.</p>
<p><b>Units</b>: ISO arithmetic units, the same as {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE android.control.postRawSensitivityBoostRange}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST
@see CameraCharacteristics#CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15678135 // CONTROL_POST_RAW_SENSITIVITY_BOOST (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15678263 // EDGE_MODE (<unidirectional association>)
	relation 15678263 --->
	  a role_name "EDGE_MODE" init_value "
            new Key<Integer>(\"android.edge.mode\", int.class)" class_relation const_relation public
	    comment "
<p>Operation mode for edge
enhancement.</p>
<p>Edge enhancement improves sharpness and details in the captured image. OFF means
no enhancement will be applied by the camera device.</p>
<p>FAST/HIGH_QUALITY both mean camera device determined enhancement
will be applied. HIGH_QUALITY mode indicates that the
camera device will use the highest-quality enhancement algorithms,
even if it slows down capture rate. FAST means the camera device will
not slow down capture rate when applying edge enhancement. FAST may be the same as OFF if
edge enhancement will slow down capture rate. Every output stream will have a similar
amount of enhancement applied.</p>
<p>ZERO_SHUTTER_LAG is meant to be used by applications that maintain a continuous circular
buffer of high-resolution images during preview and reprocess image(s) from that buffer
into a final capture when triggered by the user. In this mode, the camera device applies
edge enhancement to low-resolution streams (below maximum recording resolution) to
maximize preview quality, but does not apply edge enhancement to high-resolution streams,
since those will be reprocessed later if necessary.</p>
<p>For YUV_REPROCESSING, these FAST/HIGH_QUALITY modes both mean that the camera
device will apply FAST/HIGH_QUALITY YUV-domain edge enhancement, respectively.
The camera device may adjust its internal edge enhancement parameters for best
image quality based on the {@link CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor}, if it is set.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #EDGE_MODE_OFF OFF}</li>
  <li>{@link #EDGE_MODE_FAST FAST}</li>
  <li>{@link #EDGE_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
  <li>{@link #EDGE_MODE_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES android.edge.availableEdgeModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR
@see #EDGE_MODE_OFF
@see #EDGE_MODE_FAST
@see #EDGE_MODE_HIGH_QUALITY
@see #EDGE_MODE_ZERO_SHUTTER_LAG

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15678263 // EDGE_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15678391 // FLASH_MODE (<unidirectional association>)
	relation 15678391 --->
	  a role_name "FLASH_MODE" init_value "
            new Key<Integer>(\"android.flash.mode\", int.class)" class_relation const_relation public
	    comment "
<p>The desired mode for for the camera device's flash control.</p>
<p>This control is only effective when flash unit is available
(<code>{@link CameraCharacteristics#FLASH_INFO_AVAILABLE android.flash.info.available} == true</code>).</p>
<p>When this control is used, the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} must be set to ON or OFF.
Otherwise, the camera device auto-exposure related flash control (ON_AUTO_FLASH,
ON_ALWAYS_FLASH, or ON_AUTO_FLASH_REDEYE) will override this control.</p>
<p>When set to OFF, the camera device will not fire flash for this capture.</p>
<p>When set to SINGLE, the camera device will fire flash regardless of the camera
device's auto-exposure routine's result. When used in still capture case, this
control should be used along with auto-exposure (AE) precapture metering sequence
({@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}), otherwise, the image may be incorrectly exposed.</p>
<p>When set to TORCH, the flash will be on continuously. This mode can be used
for use cases such as preview, auto-focus assist, still capture, or video recording.</p>
<p>The flash status will be reported by {@link CaptureResult#FLASH_STATE android.flash.state} in the capture result metadata.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #FLASH_MODE_OFF OFF}</li>
  <li>{@link #FLASH_MODE_SINGLE SINGLE}</li>
  <li>{@link #FLASH_MODE_TORCH TORCH}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CameraCharacteristics#FLASH_INFO_AVAILABLE
@see CaptureResult#FLASH_STATE
@see #FLASH_MODE_OFF
@see #FLASH_MODE_SINGLE
@see #FLASH_MODE_TORCH

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15678391 // FLASH_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15678519 // FLASH_STATE (<unidirectional association>)
	relation 15678519 --->
	  a role_name "FLASH_STATE" init_value "
            new Key<Integer>(\"android.flash.state\", int.class)" class_relation const_relation public
	    comment "
<p>Current state of the flash
unit.</p>
<p>When the camera device doesn't have flash unit
(i.e. <code>{@link CameraCharacteristics#FLASH_INFO_AVAILABLE android.flash.info.available} == false</code>), this state will always be UNAVAILABLE.
Other states indicate the current flash status.</p>
<p>In certain conditions, this will be available on LEGACY devices:</p>
<ul>
<li>Flash-less cameras always return UNAVAILABLE.</li>
<li>Using {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} <code>==</code> ON_ALWAYS_FLASH
   will always return FIRED.</li>
<li>Using {@link CaptureRequest#FLASH_MODE android.flash.mode} <code>==</code> TORCH
   will always return FIRED.</li>
</ul>
<p>In all other conditions the state will not be available on
LEGACY devices (i.e. it will be <code>null</code>).</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #FLASH_STATE_UNAVAILABLE UNAVAILABLE}</li>
  <li>{@link #FLASH_STATE_CHARGING CHARGING}</li>
  <li>{@link #FLASH_STATE_READY READY}</li>
  <li>{@link #FLASH_STATE_FIRED FIRED}</li>
  <li>{@link #FLASH_STATE_PARTIAL PARTIAL}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CameraCharacteristics#FLASH_INFO_AVAILABLE
@see CaptureRequest#FLASH_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see #FLASH_STATE_UNAVAILABLE
@see #FLASH_STATE_CHARGING
@see #FLASH_STATE_READY
@see #FLASH_STATE_FIRED
@see #FLASH_STATE_PARTIAL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15678519 // FLASH_STATE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15678647 // HOT_PIXEL_MODE (<unidirectional association>)
	relation 15678647 --->
	  a role_name "HOT_PIXEL_MODE" init_value "
            new Key<Integer>(\"android.hotPixel.mode\", int.class)" class_relation const_relation public
	    comment "
<p>Operational mode for hot pixel correction.</p>
<p>Hotpixel correction interpolates out, or otherwise removes, pixels
that do not accurately measure the incoming light (i.e. pixels that
are stuck at an arbitrary value or are oversensitive).</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #HOT_PIXEL_MODE_OFF OFF}</li>
  <li>{@link #HOT_PIXEL_MODE_FAST FAST}</li>
  <li>{@link #HOT_PIXEL_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES android.hotPixel.availableHotPixelModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES
@see #HOT_PIXEL_MODE_OFF
@see #HOT_PIXEL_MODE_FAST
@see #HOT_PIXEL_MODE_HIGH_QUALITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15678647 // HOT_PIXEL_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15678775 // JPEG_GPS_LOCATION (<unidirectional association>)
	relation 15678775 --->
	  a role_name "JPEG_GPS_LOCATION" init_value "
            new Key<android.location.Location>(\"android.jpeg.gpsLocation\", android.location.Location.class)" class_relation const_relation public
	    comment "
<p>A location object to use when generating image GPS metadata.</p>
<p>Setting a location object in a request will include the GPS coordinates of the location
into any JPEG images captured based on the request. These coordinates can then be
viewed by anyone who receives the JPEG image.</p>
<p>This key is available on all devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.location.Location> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15678775 // JPEG_GPS_LOCATION (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15678903 // JPEG_GPS_COORDINATES (<unidirectional association>)
	relation 15678903 --->
	  a role_name "JPEG_GPS_COORDINATES" init_value "
            new Key<double[]>(\"android.jpeg.gpsCoordinates\", double[].class)" class_relation const_relation public
	    comment "
<p>GPS coordinates to include in output JPEG
EXIF.</p>
<p><b>Range of valid values:</b><br>
(-180 - 180], [-90,90], [-inf, inf]</p>
<p>This key is available on all devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<double[]> ${name}${value};
"
	    classrelation_ref 15678903 // JPEG_GPS_COORDINATES (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15679031 // JPEG_GPS_PROCESSING_METHOD (<unidirectional association>)
	relation 15679031 --->
	  a role_name "JPEG_GPS_PROCESSING_METHOD" init_value "
            new Key<String>(\"android.jpeg.gpsProcessingMethod\", String.class)" class_relation const_relation public
	    comment "
<p>32 characters describing GPS algorithm to
include in EXIF.</p>
<p><b>Units</b>: UTF-8 null-terminated string</p>
<p>This key is available on all devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<String> ${name}${value};
"
	    classrelation_ref 15679031 // JPEG_GPS_PROCESSING_METHOD (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15679159 // JPEG_GPS_TIMESTAMP (<unidirectional association>)
	relation 15679159 --->
	  a role_name "JPEG_GPS_TIMESTAMP" init_value "
            new Key<Long>(\"android.jpeg.gpsTimestamp\", long.class)" class_relation const_relation public
	    comment "
<p>Time GPS fix was made to include in
EXIF.</p>
<p><b>Units</b>: UTC in seconds since January 1, 1970</p>
<p>This key is available on all devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Long> ${name}${value};
"
	    classrelation_ref 15679159 // JPEG_GPS_TIMESTAMP (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15679287 // JPEG_ORIENTATION (<unidirectional association>)
	relation 15679287 --->
	  a role_name "JPEG_ORIENTATION" init_value "
            new Key<Integer>(\"android.jpeg.orientation\", int.class)" class_relation const_relation public
	    comment "
<p>The orientation for a JPEG image.</p>
<p>The clockwise rotation angle in degrees, relative to the orientation
to the camera, that the JPEG picture needs to be rotated by, to be viewed
upright.</p>
<p>Camera devices may either encode this value into the JPEG EXIF header, or
rotate the image data to match this orientation. When the image data is rotated,
the thumbnail data will also be rotated.</p>
<p>Note that this orientation is relative to the orientation of the camera sensor, given
by {@link CameraCharacteristics#SENSOR_ORIENTATION android.sensor.orientation}.</p>
<p>To translate from the device orientation given by the Android sensor APIs, the following
sample code may be used:</p>
<pre><code>private int getJpegOrientation(CameraCharacteristics c, int deviceOrientation) {
    if (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN) return 0;
    int sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION);

    // Round device orientation to a multiple of 90
    deviceOrientation = (deviceOrientation + 45) / 90 * 90;

    // Reverse device orientation for front-facing cameras
    boolean facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT;
    if (facingFront) deviceOrientation = -deviceOrientation;

    // Calculate desired JPEG orientation relative to camera orientation to make
    // the image upright relative to the device orientation
    int jpegOrientation = (sensorOrientation + deviceOrientation + 360) % 360;

    return jpegOrientation;
}
</code></pre>
<p><b>Units</b>: Degrees in multiples of 90</p>
<p><b>Range of valid values:</b><br>
0, 90, 180, 270</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#SENSOR_ORIENTATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15679287 // JPEG_ORIENTATION (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15679415 // JPEG_QUALITY (<unidirectional association>)
	relation 15679415 --->
	  a role_name "JPEG_QUALITY" init_value "
            new Key<Byte>(\"android.jpeg.quality\", byte.class)" class_relation const_relation public
	    comment "
<p>Compression quality of the final JPEG
image.</p>
<p>85-95 is typical usage range.</p>
<p><b>Range of valid values:</b><br>
1-100; larger is higher quality</p>
<p>This key is available on all devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Byte> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15679415 // JPEG_QUALITY (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15679543 // JPEG_THUMBNAIL_QUALITY (<unidirectional association>)
	relation 15679543 --->
	  a role_name "JPEG_THUMBNAIL_QUALITY" init_value "
            new Key<Byte>(\"android.jpeg.thumbnailQuality\", byte.class)" class_relation const_relation public
	    comment "
<p>Compression quality of JPEG
thumbnail.</p>
<p><b>Range of valid values:</b><br>
1-100; larger is higher quality</p>
<p>This key is available on all devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Byte> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15679543 // JPEG_THUMBNAIL_QUALITY (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15679671 // JPEG_THUMBNAIL_SIZE (<unidirectional association>)
	relation 15679671 --->
	  a role_name "JPEG_THUMBNAIL_SIZE" init_value "
            new Key<android.util.Size>(\"android.jpeg.thumbnailSize\", android.util.Size.class)" class_relation const_relation public
	    comment "
<p>Resolution of embedded JPEG thumbnail.</p>
<p>When set to (0, 0) value, the JPEG EXIF will not contain thumbnail,
but the captured JPEG will still be a valid image.</p>
<p>For best results, when issuing a request for a JPEG image, the thumbnail size selected
should have the same aspect ratio as the main JPEG output.</p>
<p>If the thumbnail image aspect ratio differs from the JPEG primary image aspect
ratio, the camera device creates the thumbnail by cropping it from the primary image.
For example, if the primary image has 4:3 aspect ratio, the thumbnail image has
16:9 aspect ratio, the primary image will be cropped vertically (letterbox) to
generate the thumbnail image. The thumbnail image will always have a smaller Field
Of View (FOV) than the primary image when aspect ratios differ.</p>
<p>When an {@link CaptureRequest#JPEG_ORIENTATION android.jpeg.orientation} of non-zero degree is requested,
the camera device will handle thumbnail rotation in one of the following ways:</p>
<ul>
<li>Set the {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}
  and keep jpeg and thumbnail image data unrotated.</li>
<li>Rotate the jpeg and thumbnail image data and not set
  {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}. In this
  case, LIMITED or FULL hardware level devices will report rotated thumnail size in
  capture result, so the width and height will be interchanged if 90 or 270 degree
  orientation is requested. LEGACY device will always report unrotated thumbnail
  size.</li>
</ul>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#JPEG_AVAILABLE_THUMBNAIL_SIZES android.jpeg.availableThumbnailSizes}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#JPEG_AVAILABLE_THUMBNAIL_SIZES
@see CaptureRequest#JPEG_ORIENTATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Size> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15679671 // JPEG_THUMBNAIL_SIZE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15679799 // LENS_APERTURE (<unidirectional association>)
	relation 15679799 --->
	  a role_name "LENS_APERTURE" init_value "
            new Key<Float>(\"android.lens.aperture\", float.class)" class_relation const_relation public
	    comment "
<p>The desired lens aperture size, as a ratio of lens focal length to the
effective aperture diameter.</p>
<p>Setting this value is only supported on the camera devices that have a variable
aperture lens.</p>
<p>When this is supported and {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is OFF,
this can be set along with {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},
{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, and {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}
to achieve manual exposure control.</p>
<p>The requested aperture value may take several frames to reach the
requested value; the camera device will report the current (intermediate)
aperture size in capture result metadata while the aperture is changing.
While the aperture is still changing, {@link CaptureResult#LENS_STATE android.lens.state} will be set to MOVING.</p>
<p>When this is supported and {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is one of
the ON modes, this will be overridden by the camera device
auto-exposure algorithm, the overridden values are then provided
back to the user in the corresponding result.</p>
<p><b>Units</b>: The f-number (f/N)</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES android.lens.info.availableApertures}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES
@see CaptureResult#LENS_STATE
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_FRAME_DURATION
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15679799 // LENS_APERTURE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15679927 // LENS_FILTER_DENSITY (<unidirectional association>)
	relation 15679927 --->
	  a role_name "LENS_FILTER_DENSITY" init_value "
            new Key<Float>(\"android.lens.filterDensity\", float.class)" class_relation const_relation public
	    comment "
<p>The desired setting for the lens neutral density filter(s).</p>
<p>This control will not be supported on most camera devices.</p>
<p>Lens filters are typically used to lower the amount of light the
sensor is exposed to (measured in steps of EV). As used here, an EV
step is the standard logarithmic representation, which are
non-negative, and inversely proportional to the amount of light
hitting the sensor.  For example, setting this to 0 would result
in no reduction of the incoming light, and setting this to 2 would
mean that the filter is set to reduce incoming light by two stops
(allowing 1/4 of the prior amount of light to the sensor).</p>
<p>It may take several frames before the lens filter density changes
to the requested value. While the filter density is still changing,
{@link CaptureResult#LENS_STATE android.lens.state} will be set to MOVING.</p>
<p><b>Units</b>: Exposure Value (EV)</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES android.lens.info.availableFilterDensities}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES
@see CaptureResult#LENS_STATE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15679927 // LENS_FILTER_DENSITY (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15680055 // LENS_FOCAL_LENGTH (<unidirectional association>)
	relation 15680055 --->
	  a role_name "LENS_FOCAL_LENGTH" init_value "
            new Key<Float>(\"android.lens.focalLength\", float.class)" class_relation const_relation public
	    comment "
<p>The desired lens focal length; used for optical zoom.</p>
<p>This setting controls the physical focal length of the camera
device's lens. Changing the focal length changes the field of
view of the camera device, and is usually used for optical zoom.</p>
<p>Like {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} and {@link CaptureRequest#LENS_APERTURE android.lens.aperture}, this
setting won't be applied instantaneously, and it may take several
frames before the lens can change to the requested focal length.
While the focal length is still changing, {@link CaptureResult#LENS_STATE android.lens.state} will
be set to MOVING.</p>
<p>Optical zoom will not be supported on most devices.</p>
<p><b>Units</b>: Millimeters</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS android.lens.info.availableFocalLengths}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#LENS_APERTURE
@see CaptureRequest#LENS_FOCUS_DISTANCE
@see CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS
@see CaptureResult#LENS_STATE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15680055 // LENS_FOCAL_LENGTH (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15680183 // LENS_FOCUS_DISTANCE (<unidirectional association>)
	relation 15680183 --->
	  a role_name "LENS_FOCUS_DISTANCE" init_value "
            new Key<Float>(\"android.lens.focusDistance\", float.class)" class_relation const_relation public
	    comment "
<p>Desired distance to plane of sharpest focus,
measured from frontmost surface of the lens.</p>
<p>Should be zero for fixed-focus cameras</p>
<p><b>Units</b>: See {@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration} for details</p>
<p><b>Range of valid values:</b><br>
&gt;= 0</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15680183 // LENS_FOCUS_DISTANCE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15680311 // LENS_FOCUS_RANGE (<unidirectional association>)
	relation 15680311 --->
	  a role_name "LENS_FOCUS_RANGE" init_value "
            new Key<android.util.Pair<Float,Float>>(\"android.lens.focusRange\", new TypeReference<android.util.Pair<Float,Float>>() {{ }})" class_relation const_relation public
	    comment "
<p>The range of scene distances that are in
sharp focus (depth of field).</p>
<p>If variable focus not supported, can still report
fixed depth of field range</p>
<p><b>Units</b>: A pair of focus distances in diopters: (near,
far); see {@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration} for details.</p>
<p><b>Range of valid values:</b><br>
&gt;=0</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Pair<Float,Float>> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15680311 // LENS_FOCUS_RANGE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15680439 // LENS_OPTICAL_STABILIZATION_MODE (<unidirectional association>)
	relation 15680439 --->
	  a role_name "LENS_OPTICAL_STABILIZATION_MODE" init_value "
            new Key<Integer>(\"android.lens.opticalStabilizationMode\", int.class)" class_relation const_relation public
	    comment "
<p>Sets whether the camera device uses optical image stabilization (OIS)
when capturing images.</p>
<p>OIS is used to compensate for motion blur due to small
movements of the camera during capture. Unlike digital image
stabilization ({@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode}), OIS
makes use of mechanical elements to stabilize the camera
sensor, and thus allows for longer exposure times before
camera shake becomes apparent.</p>
<p>Switching between different optical stabilization modes may take several
frames to initialize, the camera device will report the current mode in
capture result metadata. For example, When \"ON\" mode is requested, the
optical stabilization modes in the first several capture results may still
be \"OFF\", and it will become \"ON\" when the initialization is done.</p>
<p>If a camera device supports both OIS and digital image stabilization
({@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode}), turning both modes on may produce undesirable
interaction, so it is recommended not to enable both at the same time.</p>
<p>Not all devices will support OIS; see
{@link CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION android.lens.info.availableOpticalStabilization} for
available controls.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #LENS_OPTICAL_STABILIZATION_MODE_OFF OFF}</li>
  <li>{@link #LENS_OPTICAL_STABILIZATION_MODE_ON ON}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION android.lens.info.availableOpticalStabilization}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION
@see #LENS_OPTICAL_STABILIZATION_MODE_OFF
@see #LENS_OPTICAL_STABILIZATION_MODE_ON

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15680439 // LENS_OPTICAL_STABILIZATION_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15680567 // LENS_STATE (<unidirectional association>)
	relation 15680567 --->
	  a role_name "LENS_STATE" init_value "
            new Key<Integer>(\"android.lens.state\", int.class)" class_relation const_relation public
	    comment "
<p>Current lens status.</p>
<p>For lens parameters {@link CaptureRequest#LENS_FOCAL_LENGTH android.lens.focalLength}, {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance},
{@link CaptureRequest#LENS_FILTER_DENSITY android.lens.filterDensity} and {@link CaptureRequest#LENS_APERTURE android.lens.aperture}, when changes are requested,
they may take several frames to reach the requested values. This state indicates
the current status of the lens parameters.</p>
<p>When the state is STATIONARY, the lens parameters are not changing. This could be
either because the parameters are all fixed, or because the lens has had enough
time to reach the most recently-requested values.
If all these lens parameters are not changable for a camera device, as listed below:</p>
<ul>
<li>Fixed focus (<code>{@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance} == 0</code>), which means
{@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} parameter will always be 0.</li>
<li>Fixed focal length ({@link CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS android.lens.info.availableFocalLengths} contains single value),
which means the optical zoom is not supported.</li>
<li>No ND filter ({@link CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES android.lens.info.availableFilterDensities} contains only 0).</li>
<li>Fixed aperture ({@link CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES android.lens.info.availableApertures} contains single value).</li>
</ul>
<p>Then this state will always be STATIONARY.</p>
<p>When the state is MOVING, it indicates that at least one of the lens parameters
is changing.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #LENS_STATE_STATIONARY STATIONARY}</li>
  <li>{@link #LENS_STATE_MOVING MOVING}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#LENS_APERTURE
@see CaptureRequest#LENS_FILTER_DENSITY
@see CaptureRequest#LENS_FOCAL_LENGTH
@see CaptureRequest#LENS_FOCUS_DISTANCE
@see CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES
@see CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES
@see CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS
@see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE
@see #LENS_STATE_STATIONARY
@see #LENS_STATE_MOVING

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15680567 // LENS_STATE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15680695 // LENS_POSE_ROTATION (<unidirectional association>)
	relation 15680695 --->
	  a role_name "LENS_POSE_ROTATION" init_value "
            new Key<float[]>(\"android.lens.poseRotation\", float[].class)" class_relation const_relation public
	    comment "
<p>The orientation of the camera relative to the sensor
coordinate system.</p>
<p>The four coefficients that describe the quaternion
rotation from the Android sensor coordinate system to a
camera-aligned coordinate system where the X-axis is
aligned with the long side of the image sensor, the Y-axis
is aligned with the short side of the image sensor, and
the Z-axis is aligned with the optical axis of the sensor.</p>
<p>To convert from the quaternion coefficients <code>(x,y,z,w)</code>
to the axis of rotation <code>(a_x, a_y, a_z)</code> and rotation
amount <code>theta</code>, the following formulas can be used:</p>
<pre><code> theta = 2 * acos(w)
a_x = x / sin(theta/2)
a_y = y / sin(theta/2)
a_z = z / sin(theta/2)
</code></pre>
<p>To create a 3x3 rotation matrix that applies the rotation
defined by this quaternion, the following matrix can be
used:</p>
<pre><code>R = [ 1 - 2y^2 - 2z^2,       2xy - 2zw,       2xz + 2yw,
           2xy + 2zw, 1 - 2x^2 - 2z^2,       2yz - 2xw,
           2xz - 2yw,       2yz + 2xw, 1 - 2x^2 - 2y^2 ]
</code></pre>
<p>This matrix can then be used to apply the rotation to a
 column vector point with</p>
<p><code>p' = Rp</code></p>
<p>where <code>p</code> is in the device sensor coordinate system, and
 <code>p'</code> is in the camera-oriented coordinate system.</p>
<p><b>Units</b>:
Quaternion coefficients</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15680695 // LENS_POSE_ROTATION (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15680823 // LENS_POSE_TRANSLATION (<unidirectional association>)
	relation 15680823 --->
	  a role_name "LENS_POSE_TRANSLATION" init_value "
            new Key<float[]>(\"android.lens.poseTranslation\", float[].class)" class_relation const_relation public
	    comment "
<p>Position of the camera optical center.</p>
<p>The position of the camera device's lens optical center,
as a three-dimensional vector <code>(x,y,z)</code>, relative to the
optical center of the largest camera device facing in the
same direction as this camera, in the {@link android.hardware.SensorEvent Android sensor coordinate
axes}. Note that only the axis definitions are shared with
the sensor coordinate system, but not the origin.</p>
<p>If this device is the largest or only camera device with a
given facing, then this position will be <code>(0, 0, 0)</code>; a
camera device with a lens optical center located 3 cm from
the main sensor along the +X axis (to the right from the
user's perspective) will report <code>(0.03, 0, 0)</code>.</p>
<p>To transform a pixel coordinates between two cameras
facing the same direction, first the source camera
{@link CameraCharacteristics#LENS_RADIAL_DISTORTION android.lens.radialDistortion} must be corrected for.  Then
the source camera {@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration} needs
to be applied, followed by the {@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation}
of the source camera, the translation of the source camera
relative to the destination camera, the
{@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} of the destination camera, and
finally the inverse of {@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration}
of the destination camera. This obtains a
radial-distortion-free coordinate in the destination
camera pixel coordinates.</p>
<p>To compare this against a real image from the destination
camera, the destination camera image then needs to be
corrected for radial distortion before comparison or
sampling.</p>
<p><b>Units</b>: Meters</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#LENS_INTRINSIC_CALIBRATION
@see CameraCharacteristics#LENS_POSE_ROTATION
@see CameraCharacteristics#LENS_RADIAL_DISTORTION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15680823 // LENS_POSE_TRANSLATION (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15680951 // LENS_INTRINSIC_CALIBRATION (<unidirectional association>)
	relation 15680951 --->
	  a role_name "LENS_INTRINSIC_CALIBRATION" init_value "
            new Key<float[]>(\"android.lens.intrinsicCalibration\", float[].class)" class_relation const_relation public
	    comment "
<p>The parameters for this camera device's intrinsic
calibration.</p>
<p>The five calibration parameters that describe the
transform from camera-centric 3D coordinates to sensor
pixel coordinates:</p>
<pre><code>[f_x, f_y, c_x, c_y, s]
</code></pre>
<p>Where <code>f_x</code> and <code>f_y</code> are the horizontal and vertical
focal lengths, <code>[c_x, c_y]</code> is the position of the optical
axis, and <code>s</code> is a skew parameter for the sensor plane not
being aligned with the lens plane.</p>
<p>These are typically used within a transformation matrix K:</p>
<pre><code>K = [ f_x,   s, c_x,
       0, f_y, c_y,
       0    0,   1 ]
</code></pre>
<p>which can then be combined with the camera pose rotation
<code>R</code> and translation <code>t</code> ({@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} and
{@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}, respective) to calculate the
complete transform from world coordinates to pixel
coordinates:</p>
<pre><code>P = [ K 0   * [ R t
     0 1 ]     0 1 ]
</code></pre>
<p>and with <code>p_w</code> being a point in the world coordinate system
and <code>p_s</code> being a point in the camera active pixel array
coordinate system, and with the mapping including the
homogeneous division by z:</p>
<pre><code> p_h = (x_h, y_h, z_h) = P p_w
p_s = p_h / z_h
</code></pre>
<p>so <code>[x_s, y_s]</code> is the pixel coordinates of the world
point, <code>z_s = 1</code>, and <code>w_s</code> is a measurement of disparity
(depth) in pixel coordinates.</p>
<p>Note that the coordinate system for this transform is the
{@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} system,
where <code>(0,0)</code> is the top-left of the
preCorrectionActiveArraySize rectangle. Once the pose and
intrinsic calibration transforms have been applied to a
world point, then the {@link CameraCharacteristics#LENS_RADIAL_DISTORTION android.lens.radialDistortion}
transform needs to be applied, and the result adjusted to
be in the {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} coordinate
system (where <code>(0, 0)</code> is the top-left of the
activeArraySize rectangle), to determine the final pixel
coordinate of the world point for processed (non-RAW)
output buffers.</p>
<p><b>Units</b>:
Pixels in the
{@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}
coordinate system.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#LENS_POSE_ROTATION
@see CameraCharacteristics#LENS_POSE_TRANSLATION
@see CameraCharacteristics#LENS_RADIAL_DISTORTION
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE
@see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15680951 // LENS_INTRINSIC_CALIBRATION (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15681079 // LENS_RADIAL_DISTORTION (<unidirectional association>)
	relation 15681079 --->
	  a role_name "LENS_RADIAL_DISTORTION" init_value "
            new Key<float[]>(\"android.lens.radialDistortion\", float[].class)" class_relation const_relation public
	    comment "
<p>The correction coefficients to correct for this camera device's
radial and tangential lens distortion.</p>
<p>Four radial distortion coefficients <code>[kappa_0, kappa_1, kappa_2,
kappa_3]</code> and two tangential distortion coefficients
<code>[kappa_4, kappa_5]</code> that can be used to correct the
lens's geometric distortion with the mapping equations:</p>
<pre><code> x_c = x_i * ( kappa_0 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +
       kappa_4 * (2 * x_i * y_i) + kappa_5 * ( r^2 + 2 * x_i^2 )
 y_c = y_i * ( kappa_0 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +
       kappa_5 * (2 * x_i * y_i) + kappa_4 * ( r^2 + 2 * y_i^2 )
</code></pre>
<p>Here, <code>[x_c, y_c]</code> are the coordinates to sample in the
input image that correspond to the pixel values in the
corrected image at the coordinate <code>[x_i, y_i]</code>:</p>
<pre><code> correctedImage(x_i, y_i) = sample_at(x_c, y_c, inputImage)
</code></pre>
<p>The pixel coordinates are defined in a normalized
coordinate system related to the
{@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration} calibration fields.
Both <code>[x_i, y_i]</code> and <code>[x_c, y_c]</code> have <code>(0,0)</code> at the
lens optical center <code>[c_x, c_y]</code>. The maximum magnitudes
of both x and y coordinates are normalized to be 1 at the
edge further from the optical center, so the range
for both dimensions is <code>-1 &lt;= x &lt;= 1</code>.</p>
<p>Finally, <code>r</code> represents the radial distance from the
optical center, <code>r^2 = x_i^2 + y_i^2</code>, and its magnitude
is therefore no larger than <code>|r| &lt;= sqrt(2)</code>.</p>
<p>The distortion model used is the Brown-Conrady model.</p>
<p><b>Units</b>:
Unitless coefficients.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#LENS_INTRINSIC_CALIBRATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15681079 // LENS_RADIAL_DISTORTION (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15681207 // NOISE_REDUCTION_MODE (<unidirectional association>)
	relation 15681207 --->
	  a role_name "NOISE_REDUCTION_MODE" init_value "
            new Key<Integer>(\"android.noiseReduction.mode\", int.class)" class_relation const_relation public
	    comment "
<p>Mode of operation for the noise reduction algorithm.</p>
<p>The noise reduction algorithm attempts to improve image quality by removing
excessive noise added by the capture process, especially in dark conditions.</p>
<p>OFF means no noise reduction will be applied by the camera device, for both raw and
YUV domain.</p>
<p>MINIMAL means that only sensor raw domain basic noise reduction is enabled ,to remove
demosaicing or other processing artifacts. For YUV_REPROCESSING, MINIMAL is same as OFF.
This mode is optional, may not be support by all devices. The application should check
{@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes} before using it.</p>
<p>FAST/HIGH_QUALITY both mean camera device determined noise filtering
will be applied. HIGH_QUALITY mode indicates that the camera device
will use the highest-quality noise filtering algorithms,
even if it slows down capture rate. FAST means the camera device will not
slow down capture rate when applying noise filtering. FAST may be the same as MINIMAL if
MINIMAL is listed, or the same as OFF if any noise filtering will slow down capture rate.
Every output stream will have a similar amount of enhancement applied.</p>
<p>ZERO_SHUTTER_LAG is meant to be used by applications that maintain a continuous circular
buffer of high-resolution images during preview and reprocess image(s) from that buffer
into a final capture when triggered by the user. In this mode, the camera device applies
noise reduction to low-resolution streams (below maximum recording resolution) to maximize
preview quality, but does not apply noise reduction to high-resolution streams, since
those will be reprocessed later if necessary.</p>
<p>For YUV_REPROCESSING, these FAST/HIGH_QUALITY modes both mean that the camera device
will apply FAST/HIGH_QUALITY YUV domain noise reduction, respectively. The camera device
may adjust the noise reduction parameters for best image quality based on the
{@link CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor} if it is set.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #NOISE_REDUCTION_MODE_OFF OFF}</li>
  <li>{@link #NOISE_REDUCTION_MODE_FAST FAST}</li>
  <li>{@link #NOISE_REDUCTION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
  <li>{@link #NOISE_REDUCTION_MODE_MINIMAL MINIMAL}</li>
  <li>{@link #NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES
@see CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR
@see #NOISE_REDUCTION_MODE_OFF
@see #NOISE_REDUCTION_MODE_FAST
@see #NOISE_REDUCTION_MODE_HIGH_QUALITY
@see #NOISE_REDUCTION_MODE_MINIMAL
@see #NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15681207 // NOISE_REDUCTION_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15681335 // QUIRKS_PARTIAL_RESULT (<unidirectional association>)
	relation 15681335 --->
	  a role_name "QUIRKS_PARTIAL_RESULT" init_value "
            new Key<Boolean>(\"android.quirks.partialResult\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether a result given to the framework is the
final one for the capture, or only a partial that contains a
subset of the full set of dynamic metadata
values.</p>
<p>The entries in the result metadata buffers for a
single capture may not overlap, except for this entry. The
FINAL buffers must retain FIFO ordering relative to the
requests that generate them, so the FINAL buffer for frame 3 must
always be sent to the framework after the FINAL buffer for frame 2, and
before the FINAL buffer for frame 4. PARTIAL buffers may be returned
in any order relative to other frames, but all PARTIAL buffers for a given
capture must arrive before the FINAL buffer for that capture. This entry may
only be used by the camera device if quirks.usePartialResult is set to 1.</p>
<p><b>Range of valid values:</b><br>
Optional. Default value is FINAL.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@deprecated
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@Deprecated
"
	    classrelation_ref 15681335 // QUIRKS_PARTIAL_RESULT (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15681463 // REQUEST_FRAME_COUNT (<unidirectional association>)
	relation 15681463 --->
	  a role_name "REQUEST_FRAME_COUNT" init_value "
            new Key<Integer>(\"android.request.frameCount\", int.class)" class_relation const_relation public
	    comment "
<p>A frame counter set by the framework. This value monotonically
increases with every new result (that is, each new result has a unique
frameCount value).</p>
<p>Reset on release()</p>
<p><b>Units</b>: count of frames</p>
<p><b>Range of valid values:</b><br>
&gt; 0</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@deprecated
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@Deprecated
"
	    classrelation_ref 15681463 // REQUEST_FRAME_COUNT (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15681591 // REQUEST_ID (<unidirectional association>)
	relation 15681591 --->
	  a role_name "REQUEST_ID" init_value "
            new Key<Integer>(\"android.request.id\", int.class)" class_relation const_relation public
	    comment "
<p>An application-specified ID for the current
request. Must be maintained unchanged in output
frame</p>
<p><b>Units</b>: arbitrary integer assigned by application</p>
<p><b>Range of valid values:</b><br>
Any int</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    classrelation_ref 15681591 // REQUEST_ID (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15681719 // REQUEST_PIPELINE_DEPTH (<unidirectional association>)
	relation 15681719 --->
	  a role_name "REQUEST_PIPELINE_DEPTH" init_value "
            new Key<Byte>(\"android.request.pipelineDepth\", byte.class)" class_relation const_relation public
	    comment "
<p>Specifies the number of pipeline stages the frame went
through from when it was exposed to when the final completed result
was available to the framework.</p>
<p>Depending on what settings are used in the request, and
what streams are configured, the data may undergo less processing,
and some pipeline stages skipped.</p>
<p>See {@link CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH android.request.pipelineMaxDepth} for more details.</p>
<p><b>Range of valid values:</b><br>
&lt;= {@link CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH android.request.pipelineMaxDepth}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Byte> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15681719 // REQUEST_PIPELINE_DEPTH (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15681847 // SCALER_CROP_REGION (<unidirectional association>)
	relation 15681847 --->
	  a role_name "SCALER_CROP_REGION" init_value "
            new Key<android.graphics.Rect>(\"android.scaler.cropRegion\", android.graphics.Rect.class)" class_relation const_relation public
	    comment "
<p>The desired region of the sensor to read out for this capture.</p>
<p>This control can be used to implement digital zoom.</p>
<p>The crop region coordinate system is based off
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with <code>(0, 0)</code> being the
top-left corner of the sensor active array.</p>
<p>Output streams use this rectangle to produce their output,
cropping to a smaller region if necessary to maintain the
stream's aspect ratio, then scaling the sensor input to
match the output's configured resolution.</p>
<p>The crop region is applied after the RAW to other color
space (e.g. YUV) conversion. Since raw streams
(e.g. RAW16) don't have the conversion stage, they are not
croppable. The crop region will be ignored by raw streams.</p>
<p>For non-raw streams, any additional per-stream cropping will
be done to maximize the final pixel area of the stream.</p>
<p>For example, if the crop region is set to a 4:3 aspect
ratio, then 4:3 streams will use the exact crop
region. 16:9 streams will further crop vertically
(letterbox).</p>
<p>Conversely, if the crop region is set to a 16:9, then 4:3
outputs will crop horizontally (pillarbox), and 16:9
streams will match exactly. These additional crops will
be centered within the crop region.</p>
<p>The width and height of the crop region cannot
be set to be smaller than
<code>floor( activeArraySize.width / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code> and
<code>floor( activeArraySize.height / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code>, respectively.</p>
<p>The camera device may adjust the crop region to account
for rounding and other hardware requirements; the final
crop region used will be included in the output capture
result.</p>
<p><b>Units</b>: Pixel coordinates relative to
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.graphics.Rect> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15681847 // SCALER_CROP_REGION (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15681975 // SENSOR_EXPOSURE_TIME (<unidirectional association>)
	relation 15681975 --->
	  a role_name "SENSOR_EXPOSURE_TIME" init_value "
            new Key<Long>(\"android.sensor.exposureTime\", long.class)" class_relation const_relation public
	    comment "
<p>Duration each pixel is exposed to
light.</p>
<p>If the sensor can't expose this exact duration, it will shorten the
duration exposed to the nearest possible value (rather than expose longer).
The final exposure time used will be available in the output capture result.</p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to
OFF; otherwise the auto-exposure algorithm will override this value.</p>
<p><b>Units</b>: Nanoseconds</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Long> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15681975 // SENSOR_EXPOSURE_TIME (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15682103 // SENSOR_FRAME_DURATION (<unidirectional association>)
	relation 15682103 --->
	  a role_name "SENSOR_FRAME_DURATION" init_value "
            new Key<Long>(\"android.sensor.frameDuration\", long.class)" class_relation const_relation public
	    comment "
<p>Duration from start of frame exposure to
start of next frame exposure.</p>
<p>The maximum frame rate that can be supported by a camera subsystem is
a function of many factors:</p>
<ul>
<li>Requested resolutions of output image streams</li>
<li>Availability of binning / skipping modes on the imager</li>
<li>The bandwidth of the imager interface</li>
<li>The bandwidth of the various ISP processing blocks</li>
</ul>
<p>Since these factors can vary greatly between different ISPs and
sensors, the camera abstraction tries to represent the bandwidth
restrictions with as simple a model as possible.</p>
<p>The model presented has the following characteristics:</p>
<ul>
<li>The image sensor is always configured to output the smallest
resolution possible given the application's requested output stream
sizes.  The smallest resolution is defined as being at least as large
as the largest requested output stream size; the camera pipeline must
never digitally upsample sensor data when the crop region covers the
whole sensor. In general, this means that if only small output stream
resolutions are configured, the sensor can provide a higher frame
rate.</li>
<li>Since any request may use any or all the currently configured
output streams, the sensor and ISP must be configured to support
scaling a single capture to all the streams at the same time.  This
means the camera pipeline must be ready to produce the largest
requested output size without any delay.  Therefore, the overall
frame rate of a given configured stream set is governed only by the
largest requested stream resolution.</li>
<li>Using more than one output stream in a request does not affect the
frame duration.</li>
<li>Certain format-streams may need to do additional background processing
before data is consumed/produced by that stream. These processors
can run concurrently to the rest of the camera pipeline, but
cannot process more than 1 capture at a time.</li>
</ul>
<p>The necessary information for the application, given the model above,
is provided via the {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap} field using
{@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }.
These are used to determine the maximum frame rate / minimum frame
duration that is possible for a given stream configuration.</p>
<p>Specifically, the application can use the following rules to
determine the minimum frame duration it can request from the camera
device:</p>
<ol>
<li>Let the set of currently configured input/output streams
be called <code>S</code>.</li>
<li>Find the minimum frame durations for each stream in <code>S</code>, by looking
it up in {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap} using {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }
(with its respective size/format). Let this set of frame durations be
called <code>F</code>.</li>
<li>For any given request <code>R</code>, the minimum frame duration allowed
for <code>R</code> is the maximum out of all values in <code>F</code>. Let the streams
used in <code>R</code> be called <code>S_r</code>.</li>
</ol>
<p>If none of the streams in <code>S_r</code> have a stall time (listed in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration }
using its respective size/format), then the frame duration in <code>F</code>
determines the steady state frame rate that the application will get
if it uses <code>R</code> as a repeating request. Let this special kind of
request be called <code>Rsimple</code>.</p>
<p>A repeating request <code>Rsimple</code> can be <em>occasionally</em> interleaved
by a single capture of a new request <code>Rstall</code> (which has at least
one in-use stream with a non-0 stall time) and if <code>Rstall</code> has the
same minimum frame duration this will not cause a frame rate loss
if all buffers from the previous <code>Rstall</code> have already been
delivered.</p>
<p>For more details about stalling, see
{@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration }.</p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to
OFF; otherwise the auto-exposure algorithm will override this value.</p>
<p><b>Units</b>: Nanoseconds</p>
<p><b>Range of valid values:</b><br>
See {@link CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration},
{@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap}. The duration
is capped to <code>max(duration, exposureTime + overhead)</code>.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP
@see CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Long> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15682103 // SENSOR_FRAME_DURATION (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15682231 // SENSOR_SENSITIVITY (<unidirectional association>)
	relation 15682231 --->
	  a role_name "SENSOR_SENSITIVITY" init_value "
            new Key<Integer>(\"android.sensor.sensitivity\", int.class)" class_relation const_relation public
	    comment "
<p>The amount of gain applied to sensor data
before processing.</p>
<p>The sensitivity is the standard ISO sensitivity value,
as defined in ISO 12232:2006.</p>
<p>The sensitivity must be within {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}, and
if if it less than {@link CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY android.sensor.maxAnalogSensitivity}, the camera device
is guaranteed to use only analog amplification for applying the gain.</p>
<p>If the camera device cannot apply the exact sensitivity
requested, it will reduce the gain to the nearest supported
value. The final sensitivity used will be available in the
output capture result.</p>
<p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to
OFF; otherwise the auto-exposure algorithm will override this value.</p>
<p><b>Units</b>: ISO arithmetic units</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE
@see CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15682231 // SENSOR_SENSITIVITY (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15682359 // SENSOR_TIMESTAMP (<unidirectional association>)
	relation 15682359 --->
	  a role_name "SENSOR_TIMESTAMP" init_value "
            new Key<Long>(\"android.sensor.timestamp\", long.class)" class_relation const_relation public
	    comment "
<p>Time at start of exposure of first
row of the image sensor active array, in nanoseconds.</p>
<p>The timestamps are also included in all image
buffers produced for the same capture, and will be identical
on all the outputs.</p>
<p>When {@link CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE android.sensor.info.timestampSource} <code>==</code> UNKNOWN,
the timestamps measure time since an unspecified starting point,
and are monotonically increasing. They can be compared with the
timestamps for other captures from the same camera device, but are
not guaranteed to be comparable to any other time source.</p>
<p>When {@link CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE android.sensor.info.timestampSource} <code>==</code> REALTIME, the
timestamps measure time in the same timebase as {@link android.os.SystemClock#elapsedRealtimeNanos }, and they can
be compared to other timestamps from other subsystems that
are using that base.</p>
<p>For reprocessing, the timestamp will match the start of exposure of
the input image, i.e. {@link CaptureResult#SENSOR_TIMESTAMP the
timestamp} in the TotalCaptureResult that was used to create the
reprocess capture request.</p>
<p><b>Units</b>: Nanoseconds</p>
<p><b>Range of valid values:</b><br>
&gt; 0</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Long> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15682359 // SENSOR_TIMESTAMP (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15682487 // SENSOR_NEUTRAL_COLOR_POINT (<unidirectional association>)
	relation 15682487 --->
	  a role_name "SENSOR_NEUTRAL_COLOR_POINT" init_value "
            new Key<Rational[]>(\"android.sensor.neutralColorPoint\", Rational[].class)" class_relation const_relation public
	    comment "
<p>The estimated camera neutral color in the native sensor colorspace at
the time of capture.</p>
<p>This value gives the neutral color point encoded as an RGB value in the
native sensor color space.  The neutral color point indicates the
currently estimated white point of the scene illumination.  It can be
used to interpolate between the provided color transforms when
processing raw sensor data.</p>
<p>The order of the values is R, G, B; where R is in the lowest index.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Rational[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15682487 // SENSOR_NEUTRAL_COLOR_POINT (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15682615 // SENSOR_NOISE_PROFILE (<unidirectional association>)
	relation 15682615 --->
	  a role_name "SENSOR_NOISE_PROFILE" init_value "
            new Key<android.util.Pair<Double,Double>[]>(\"android.sensor.noiseProfile\", new TypeReference<android.util.Pair<Double,Double>[]>() {{ }})" class_relation const_relation public
	    comment "
<p>Noise model coefficients for each CFA mosaic channel.</p>
<p>This key contains two noise model coefficients for each CFA channel
corresponding to the sensor amplification (S) and sensor readout
noise (O).  These are given as pairs of coefficients for each channel
in the same order as channels listed for the CFA layout key
(see {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT android.sensor.info.colorFilterArrangement}).  This is
represented as an array of Pair&lt;Double, Double&gt;, where
the first member of the Pair at index n is the S coefficient and the
second member is the O coefficient for the nth color channel in the CFA.</p>
<p>These coefficients are used in a two parameter noise model to describe
the amount of noise present in the image for each CFA channel.  The
noise model used here is:</p>
<p>N(x) = sqrt(Sx + O)</p>
<p>Where x represents the recorded signal of a CFA channel normalized to
the range [0, 1], and S and O are the noise model coeffiecients for
that channel.</p>
<p>A more detailed description of the noise model can be found in the
Adobe DNG specification for the NoiseProfile tag.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Pair<Double,Double>[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15682615 // SENSOR_NOISE_PROFILE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15682743 // SENSOR_GREEN_SPLIT (<unidirectional association>)
	relation 15682743 --->
	  a role_name "SENSOR_GREEN_SPLIT" init_value "
            new Key<Float>(\"android.sensor.greenSplit\", float.class)" class_relation const_relation public
	    comment "
<p>The worst-case divergence between Bayer green channels.</p>
<p>This value is an estimate of the worst case split between the
Bayer green channels in the red and blue rows in the sensor color
filter array.</p>
<p>The green split is calculated as follows:</p>
<ol>
<li>A 5x5 pixel (or larger) window W within the active sensor array is
chosen. The term 'pixel' here is taken to mean a group of 4 Bayer
mosaic channels (R, Gr, Gb, B).  The location and size of the window
chosen is implementation defined, and should be chosen to provide a
green split estimate that is both representative of the entire image
for this camera sensor, and can be calculated quickly.</li>
<li>The arithmetic mean of the green channels from the red
rows (mean_Gr) within W is computed.</li>
<li>The arithmetic mean of the green channels from the blue
rows (mean_Gb) within W is computed.</li>
<li>The maximum ratio R of the two means is computed as follows:
<code>R = max((mean_Gr + 1)/(mean_Gb + 1), (mean_Gb + 1)/(mean_Gr + 1))</code></li>
</ol>
<p>The ratio R is the green split divergence reported for this property,
which represents how much the green channels differ in the mosaic
pattern.  This value is typically used to determine the treatment of
the green mosaic channels when demosaicing.</p>
<p>The green split value can be roughly interpreted as follows:</p>
<ul>
<li>R &lt; 1.03 is a negligible split (&lt;3% divergence).</li>
<li>1.20 &lt;= R &gt;= 1.03 will require some software
correction to avoid demosaic errors (3-20% divergence).</li>
<li>R &gt; 1.20 will require strong software correction to produce
a usuable image (&gt;20% divergence).</li>
</ul>
<p><b>Range of valid values:</b><br></p>
<p>&gt;= 0</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15682743 // SENSOR_GREEN_SPLIT (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15682871 // SENSOR_TEST_PATTERN_DATA (<unidirectional association>)
	relation 15682871 --->
	  a role_name "SENSOR_TEST_PATTERN_DATA" init_value "
            new Key<int[]>(\"android.sensor.testPatternData\", int[].class)" class_relation const_relation public
	    comment "
<p>A pixel <code>[R, G_even, G_odd, B]</code> that supplies the test pattern
when {@link CaptureRequest#SENSOR_TEST_PATTERN_MODE android.sensor.testPatternMode} is SOLID_COLOR.</p>
<p>Each color channel is treated as an unsigned 32-bit integer.
The camera device then uses the most significant X bits
that correspond to how many bits are in its Bayer raw sensor
output.</p>
<p>For example, a sensor with RAW10 Bayer output would use the
10 most significant bits from each color channel.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#SENSOR_TEST_PATTERN_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15682871 // SENSOR_TEST_PATTERN_DATA (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15682999 // SENSOR_TEST_PATTERN_MODE (<unidirectional association>)
	relation 15682999 --->
	  a role_name "SENSOR_TEST_PATTERN_MODE" init_value "
            new Key<Integer>(\"android.sensor.testPatternMode\", int.class)" class_relation const_relation public
	    comment "
<p>When enabled, the sensor sends a test pattern instead of
doing a real exposure from the camera.</p>
<p>When a test pattern is enabled, all manual sensor controls specified
by android.sensor.* will be ignored. All other controls should
work as normal.</p>
<p>For example, if manual flash is enabled, flash firing should still
occur (and that the test pattern remain unmodified, since the flash
would not actually affect it).</p>
<p>Defaults to OFF.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_OFF OFF}</li>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_SOLID_COLOR SOLID_COLOR}</li>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_COLOR_BARS COLOR_BARS}</li>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY COLOR_BARS_FADE_TO_GRAY}</li>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_PN9 PN9}</li>
  <li>{@link #SENSOR_TEST_PATTERN_MODE_CUSTOM1 CUSTOM1}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES android.sensor.availableTestPatternModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES
@see #SENSOR_TEST_PATTERN_MODE_OFF
@see #SENSOR_TEST_PATTERN_MODE_SOLID_COLOR
@see #SENSOR_TEST_PATTERN_MODE_COLOR_BARS
@see #SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY
@see #SENSOR_TEST_PATTERN_MODE_PN9
@see #SENSOR_TEST_PATTERN_MODE_CUSTOM1

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15682999 // SENSOR_TEST_PATTERN_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15683127 // SENSOR_ROLLING_SHUTTER_SKEW (<unidirectional association>)
	relation 15683127 --->
	  a role_name "SENSOR_ROLLING_SHUTTER_SKEW" init_value "
            new Key<Long>(\"android.sensor.rollingShutterSkew\", long.class)" class_relation const_relation public
	    comment "
<p>Duration between the start of first row exposure
and the start of last row exposure.</p>
<p>This is the exposure time skew between the first and last
row exposure start times. The first row and the last row are
the first and last rows inside of the
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.</p>
<p>For typical camera sensors that use rolling shutters, this is also equivalent
to the frame readout time.</p>
<p><b>Units</b>: Nanoseconds</p>
<p><b>Range of valid values:</b><br>
&gt;= 0 and &lt;
{@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Long> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15683127 // SENSOR_ROLLING_SHUTTER_SKEW (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15683255 // SENSOR_DYNAMIC_BLACK_LEVEL (<unidirectional association>)
	relation 15683255 --->
	  a role_name "SENSOR_DYNAMIC_BLACK_LEVEL" init_value "
            new Key<float[]>(\"android.sensor.dynamicBlackLevel\", float[].class)" class_relation const_relation public
	    comment "
<p>A per-frame dynamic black level offset for each of the color filter
arrangement (CFA) mosaic channels.</p>
<p>Camera sensor black levels may vary dramatically for different
capture settings (e.g. {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}). The fixed black
level reported by {@link CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern} may be too
inaccurate to represent the actual value on a per-frame basis. The
camera device internal pipeline relies on reliable black level values
to process the raw images appropriately. To get the best image
quality, the camera device may choose to estimate the per frame black
level values either based on optically shielded black regions
({@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions}) or its internal model.</p>
<p>This key reports the camera device estimated per-frame zero light
value for each of the CFA mosaic channels in the camera sensor. The
{@link CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern} may only represent a coarse
approximation of the actual black level values. This value is the
black level used in camera device internal image processing pipeline
and generally more accurate than the fixed black level values.
However, since they are estimated values by the camera device, they
may not be as accurate as the black level values calculated from the
optical black pixels reported by {@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions}.</p>
<p>The values are given in the same order as channels listed for the CFA
layout key (see {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT android.sensor.info.colorFilterArrangement}), i.e. the
nth value given corresponds to the black level offset for the nth
color channel listed in the CFA.</p>
<p>This key will be available if {@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions} is
available or the camera device advertises this key via
{@link android.hardware.camera2.CameraCharacteristics#getAvailableCaptureResultKeys }.</p>
<p><b>Range of valid values:</b><br>
&gt;= 0 for each.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN
@see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
@see CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15683255 // SENSOR_DYNAMIC_BLACK_LEVEL (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15683383 // SENSOR_DYNAMIC_WHITE_LEVEL (<unidirectional association>)
	relation 15683383 --->
	  a role_name "SENSOR_DYNAMIC_WHITE_LEVEL" init_value "
            new Key<Integer>(\"android.sensor.dynamicWhiteLevel\", int.class)" class_relation const_relation public
	    comment "
<p>Maximum raw value output by sensor for this frame.</p>
<p>Since the {@link CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern} may change for different
capture settings (e.g., {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}), the white
level will change accordingly. This key is similar to
{@link CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL android.sensor.info.whiteLevel}, but specifies the camera device
estimated white level for each frame.</p>
<p>This key will be available if {@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions} is
available or the camera device advertises this key via
{@link android.hardware.camera2.CameraCharacteristics#getAvailableCaptureRequestKeys }.</p>
<p><b>Range of valid values:</b><br>
&gt;= 0</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN
@see CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL
@see CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15683383 // SENSOR_DYNAMIC_WHITE_LEVEL (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15683511 // SHADING_MODE (<unidirectional association>)
	relation 15683511 --->
	  a role_name "SHADING_MODE" init_value "
            new Key<Integer>(\"android.shading.mode\", int.class)" class_relation const_relation public
	    comment "
<p>Quality of lens shading correction applied
to the image data.</p>
<p>When set to OFF mode, no lens shading correction will be applied by the
camera device, and an identity lens shading map data will be provided
if <code>{@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode} == ON</code>. For example, for lens
shading map with size of <code>[ 4, 3 ]</code>,
the output {@link CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP android.statistics.lensShadingCorrectionMap} for this case will be an identity
map shown below:</p>
<pre><code>[ 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0 ]
</code></pre>
<p>When set to other modes, lens shading correction will be applied by the camera
device. Applications can request lens shading map data by setting
{@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode} to ON, and then the camera device will provide lens
shading map data in {@link CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP android.statistics.lensShadingCorrectionMap}; the returned shading map
data will be the one applied by the camera device for this capture request.</p>
<p>The shading map data may depend on the auto-exposure (AE) and AWB statistics, therefore
the reliability of the map data may be affected by the AE and AWB algorithms. When AE and
AWB are in AUTO modes({@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} <code>!=</code> OFF and {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} <code>!=</code>
OFF), to get best results, it is recommended that the applications wait for the AE and AWB
to be converged before using the returned shading map data.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #SHADING_MODE_OFF OFF}</li>
  <li>{@link #SHADING_MODE_FAST FAST}</li>
  <li>{@link #SHADING_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#SHADING_AVAILABLE_MODES android.shading.availableModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AWB_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SHADING_AVAILABLE_MODES
@see CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP
@see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE
@see #SHADING_MODE_OFF
@see #SHADING_MODE_FAST
@see #SHADING_MODE_HIGH_QUALITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15683511 // SHADING_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15683639 // STATISTICS_FACE_DETECT_MODE (<unidirectional association>)
	relation 15683639 --->
	  a role_name "STATISTICS_FACE_DETECT_MODE" init_value "
            new Key<Integer>(\"android.statistics.faceDetectMode\", int.class)" class_relation const_relation public
	    comment "
<p>Operating mode for the face detector
unit.</p>
<p>Whether face detection is enabled, and whether it
should output just the basic fields or the full set of
fields.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #STATISTICS_FACE_DETECT_MODE_OFF OFF}</li>
  <li>{@link #STATISTICS_FACE_DETECT_MODE_SIMPLE SIMPLE}</li>
  <li>{@link #STATISTICS_FACE_DETECT_MODE_FULL FULL}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES android.statistics.info.availableFaceDetectModes}</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES
@see #STATISTICS_FACE_DETECT_MODE_OFF
@see #STATISTICS_FACE_DETECT_MODE_SIMPLE
@see #STATISTICS_FACE_DETECT_MODE_FULL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15683639 // STATISTICS_FACE_DETECT_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15683767 // STATISTICS_FACE_IDS (<unidirectional association>)
	relation 15683767 --->
	  a role_name "STATISTICS_FACE_IDS" init_value "
            new Key<int[]>(\"android.statistics.faceIds\", int[].class)" class_relation const_relation public
	    comment "
<p>List of unique IDs for detected faces.</p>
<p>Each detected face is given a unique ID that is valid for as long as the face is visible
to the camera device.  A face that leaves the field of view and later returns may be
assigned a new ID.</p>
<p>Only available if {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} == FULL
This key is available on all devices.</p>

@see CaptureRequest#STATISTICS_FACE_DETECT_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    classrelation_ref 15683767 // STATISTICS_FACE_IDS (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15683895 // STATISTICS_FACE_LANDMARKS (<unidirectional association>)
	relation 15683895 --->
	  a role_name "STATISTICS_FACE_LANDMARKS" init_value "
            new Key<int[]>(\"android.statistics.faceLandmarks\", int[].class)" class_relation const_relation public
	    comment "
<p>List of landmarks for detected
faces.</p>
<p>The coordinate system is that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with
<code>(0, 0)</code> being the top-left pixel of the active array.</p>
<p>Only available if {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} == FULL
This key is available on all devices.</p>

@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE
@see CaptureRequest#STATISTICS_FACE_DETECT_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    classrelation_ref 15683895 // STATISTICS_FACE_LANDMARKS (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15684023 // STATISTICS_FACE_RECTANGLES (<unidirectional association>)
	relation 15684023 --->
	  a role_name "STATISTICS_FACE_RECTANGLES" init_value "
            new Key<android.graphics.Rect[]>(\"android.statistics.faceRectangles\", android.graphics.Rect[].class)" class_relation const_relation public
	    comment "
<p>List of the bounding rectangles for detected
faces.</p>
<p>The coordinate system is that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with
<code>(0, 0)</code> being the top-left pixel of the active array.</p>
<p>Only available if {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} != OFF
This key is available on all devices.</p>

@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE
@see CaptureRequest#STATISTICS_FACE_DETECT_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.graphics.Rect[]> ${name}${value};
"
	    classrelation_ref 15684023 // STATISTICS_FACE_RECTANGLES (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15684151 // STATISTICS_FACE_SCORES (<unidirectional association>)
	relation 15684151 --->
	  a role_name "STATISTICS_FACE_SCORES" init_value "
            new Key<byte[]>(\"android.statistics.faceScores\", byte[].class)" class_relation const_relation public
	    comment "
<p>List of the face confidence scores for
detected faces</p>
<p>Only available if {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} != OFF.</p>
<p><b>Range of valid values:</b><br>
1-100</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#STATISTICS_FACE_DETECT_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<byte[]> ${name}${value};
"
	    classrelation_ref 15684151 // STATISTICS_FACE_SCORES (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15684279 // STATISTICS_FACES (<unidirectional association>)
	relation 15684279 --->
	  a role_name "STATISTICS_FACES" init_value "
            new Key<android.hardware.camera2.params.Face[]>(\"android.statistics.faces\", android.hardware.camera2.params.Face[].class)" class_relation const_relation public
	    comment "
<p>List of the faces detected through camera face detection
in this capture.</p>
<p>Only available if {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} <code>!=</code> OFF.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#STATISTICS_FACE_DETECT_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.Face[]> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15684279 // STATISTICS_FACES (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15684407 // STATISTICS_LENS_SHADING_CORRECTION_MAP (<unidirectional association>)
	relation 15684407 --->
	  a role_name "STATISTICS_LENS_SHADING_CORRECTION_MAP" init_value "
            new Key<android.hardware.camera2.params.LensShadingMap>(\"android.statistics.lensShadingCorrectionMap\", android.hardware.camera2.params.LensShadingMap.class)" class_relation const_relation public
	    comment "
<p>The shading map is a low-resolution floating-point map
that lists the coefficients used to correct for vignetting, for each
Bayer color channel.</p>
<p>The map provided here is the same map that is used by the camera device to
correct both color shading and vignetting for output non-RAW images.</p>
<p>When there is no lens shading correction applied to RAW
output images ({@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied} <code>==</code>
false), this map is the complete lens shading correction
map; when there is some lens shading correction applied to
the RAW output image ({@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied}<code>==</code> true), this map reports the remaining lens shading
correction map that needs to be applied to get shading
corrected images that match the camera device's output for
non-RAW formats.</p>
<p>For a complete shading correction map, the least shaded
section of the image will have a gain factor of 1; all
other sections will have gains above 1.</p>
<p>When {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} = TRANSFORM_MATRIX, the map
will take into account the colorCorrection settings.</p>
<p>The shading map is for the entire active pixel array, and is not
affected by the crop region specified in the request. Each shading map
entry is the value of the shading compensation map over a specific
pixel on the sensor.  Specifically, with a (N x M) resolution shading
map, and an active pixel array size (W x H), shading map entry
(x,y) ϵ (0 ... N-1, 0 ... M-1) is the value of the shading map at
pixel ( ((W-1)/(N-1)) * x, ((H-1)/(M-1)) * y) for the four color channels.
The map is assumed to be bilinearly interpolated between the sample points.</p>
<p>The channel order is [R, Geven, Godd, B], where Geven is the green
channel for the even rows of a Bayer pattern, and Godd is the odd rows.
The shading map is stored in a fully interleaved format.</p>
<p>The shading map will generally have on the order of 30-40 rows and columns,
and will be smaller than 64x64.</p>
<p>As an example, given a very small map defined as:</p>
<pre><code>width,height = [ 4, 3 ]
values =
[ 1.3, 1.2, 1.15, 1.2,  1.2, 1.2, 1.15, 1.2,
    1.1, 1.2, 1.2, 1.2,  1.3, 1.2, 1.3, 1.3,
  1.2, 1.2, 1.25, 1.1,  1.1, 1.1, 1.1, 1.0,
    1.0, 1.0, 1.0, 1.0,  1.2, 1.3, 1.25, 1.2,
  1.3, 1.2, 1.2, 1.3,   1.2, 1.15, 1.1, 1.2,
    1.2, 1.1, 1.0, 1.2,  1.3, 1.15, 1.2, 1.3 ]
</code></pre>
<p>The low-resolution scaling map images for each channel are
(displayed using nearest-neighbor interpolation):</p>
<p><img alt=\"Red lens shading map\" src=\"../../../../images/camera2/metadata/android.statistics.lensShadingMap/red_shading.png\" />
<img alt=\"Green (even rows) lens shading map\" src=\"../../../../images/camera2/metadata/android.statistics.lensShadingMap/green_e_shading.png\" />
<img alt=\"Green (odd rows) lens shading map\" src=\"../../../../images/camera2/metadata/android.statistics.lensShadingMap/green_o_shading.png\" />
<img alt=\"Blue lens shading map\" src=\"../../../../images/camera2/metadata/android.statistics.lensShadingMap/blue_shading.png\" /></p>
<p>As a visualization only, inverting the full-color map to recover an
image of a gray wall (using bicubic interpolation for visual quality) as captured by the sensor gives:</p>
<p><img alt=\"Image of a uniform white wall (inverse shading map)\" src=\"../../../../images/camera2/metadata/android.statistics.lensShadingMap/inv_shading.png\" /></p>
<p><b>Range of valid values:</b><br>
Each gain factor is &gt;= 1</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#COLOR_CORRECTION_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.LensShadingMap> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15684407 // STATISTICS_LENS_SHADING_CORRECTION_MAP (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15684535 // STATISTICS_LENS_SHADING_MAP (<unidirectional association>)
	relation 15684535 --->
	  a role_name "STATISTICS_LENS_SHADING_MAP" init_value "
            new Key<float[]>(\"android.statistics.lensShadingMap\", float[].class)" class_relation const_relation public
	    comment "
<p>The shading map is a low-resolution floating-point map
that lists the coefficients used to correct for vignetting and color shading,
for each Bayer color channel of RAW image data.</p>
<p>The map provided here is the same map that is used by the camera device to
correct both color shading and vignetting for output non-RAW images.</p>
<p>When there is no lens shading correction applied to RAW
output images ({@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied} <code>==</code>
false), this map is the complete lens shading correction
map; when there is some lens shading correction applied to
the RAW output image ({@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied}<code>==</code> true), this map reports the remaining lens shading
correction map that needs to be applied to get shading
corrected images that match the camera device's output for
non-RAW formats.</p>
<p>For a complete shading correction map, the least shaded
section of the image will have a gain factor of 1; all
other sections will have gains above 1.</p>
<p>When {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} = TRANSFORM_MATRIX, the map
will take into account the colorCorrection settings.</p>
<p>The shading map is for the entire active pixel array, and is not
affected by the crop region specified in the request. Each shading map
entry is the value of the shading compensation map over a specific
pixel on the sensor.  Specifically, with a (N x M) resolution shading
map, and an active pixel array size (W x H), shading map entry
(x,y) ϵ (0 ... N-1, 0 ... M-1) is the value of the shading map at
pixel ( ((W-1)/(N-1)) * x, ((H-1)/(M-1)) * y) for the four color channels.
The map is assumed to be bilinearly interpolated between the sample points.</p>
<p>The channel order is [R, Geven, Godd, B], where Geven is the green
channel for the even rows of a Bayer pattern, and Godd is the odd rows.
The shading map is stored in a fully interleaved format, and its size
is provided in the camera static metadata by android.lens.info.shadingMapSize.</p>
<p>The shading map will generally have on the order of 30-40 rows and columns,
and will be smaller than 64x64.</p>
<p>As an example, given a very small map defined as:</p>
<pre><code>android.lens.info.shadingMapSize = [ 4, 3 ]
android.statistics.lensShadingMap =
[ 1.3, 1.2, 1.15, 1.2,  1.2, 1.2, 1.15, 1.2,
    1.1, 1.2, 1.2, 1.2,  1.3, 1.2, 1.3, 1.3,
  1.2, 1.2, 1.25, 1.1,  1.1, 1.1, 1.1, 1.0,
    1.0, 1.0, 1.0, 1.0,  1.2, 1.3, 1.25, 1.2,
  1.3, 1.2, 1.2, 1.3,   1.2, 1.15, 1.1, 1.2,
    1.2, 1.1, 1.0, 1.2,  1.3, 1.15, 1.2, 1.3 ]
</code></pre>
<p>The low-resolution scaling map images for each channel are
(displayed using nearest-neighbor interpolation):</p>
<p><img alt=\"Red lens shading map\" src=\"../../../../images/camera2/metadata/android.statistics.lensShadingMap/red_shading.png\" />
<img alt=\"Green (even rows) lens shading map\" src=\"../../../../images/camera2/metadata/android.statistics.lensShadingMap/green_e_shading.png\" />
<img alt=\"Green (odd rows) lens shading map\" src=\"../../../../images/camera2/metadata/android.statistics.lensShadingMap/green_o_shading.png\" />
<img alt=\"Blue lens shading map\" src=\"../../../../images/camera2/metadata/android.statistics.lensShadingMap/blue_shading.png\" /></p>
<p>As a visualization only, inverting the full-color map to recover an
image of a gray wall (using bicubic interpolation for visual quality)
as captured by the sensor gives:</p>
<p><img alt=\"Image of a uniform white wall (inverse shading map)\" src=\"../../../../images/camera2/metadata/android.statistics.lensShadingMap/inv_shading.png\" /></p>
<p>Note that the RAW image data might be subject to lens shading
correction not reported on this map. Query
{@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied} to see if RAW image data has subject
to lens shading correction. If {@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied}
is TRUE, the RAW image data is subject to partial or full lens shading
correction. In the case full lens shading correction is applied to RAW
images, the gain factor map reported in this key will contain all 1.0 gains.
In other words, the map reported in this key is the remaining lens shading
that needs to be applied on the RAW image to get images without lens shading
artifacts. See {@link CameraCharacteristics#REQUEST_MAX_NUM_OUTPUT_RAW android.request.maxNumOutputRaw} for a list of RAW image
formats.</p>
<p><b>Range of valid values:</b><br>
Each gain factor is &gt;= 1</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#COLOR_CORRECTION_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#REQUEST_MAX_NUM_OUTPUT_RAW
@see CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    classrelation_ref 15684535 // STATISTICS_LENS_SHADING_MAP (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15684663 // STATISTICS_PREDICTED_COLOR_GAINS (<unidirectional association>)
	relation 15684663 --->
	  a role_name "STATISTICS_PREDICTED_COLOR_GAINS" init_value "
            new Key<float[]>(\"android.statistics.predictedColorGains\", float[].class)" class_relation const_relation public
	    comment "
<p>The best-fit color channel gains calculated
by the camera device's statistics units for the current output frame.</p>
<p>This may be different than the gains used for this frame,
since statistics processing on data from a new frame
typically completes after the transform has already been
applied to that frame.</p>
<p>The 4 channel gains are defined in Bayer domain,
see {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} for details.</p>
<p>This value should always be calculated by the auto-white balance (AWB) block,
regardless of the android.control.* current values.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@deprecated
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@Deprecated
"
	    classrelation_ref 15684663 // STATISTICS_PREDICTED_COLOR_GAINS (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15684791 // STATISTICS_PREDICTED_COLOR_TRANSFORM (<unidirectional association>)
	relation 15684791 --->
	  a role_name "STATISTICS_PREDICTED_COLOR_TRANSFORM" init_value "
            new Key<Rational[]>(\"android.statistics.predictedColorTransform\", Rational[].class)" class_relation const_relation public
	    comment "
<p>The best-fit color transform matrix estimate
calculated by the camera device's statistics units for the current
output frame.</p>
<p>The camera device will provide the estimate from its
statistics unit on the white balance transforms to use
for the next frame. These are the values the camera device believes
are the best fit for the current output frame. This may
be different than the transform used for this frame, since
statistics processing on data from a new frame typically
completes after the transform has already been applied to
that frame.</p>
<p>These estimates must be provided for all frames, even if
capture settings and color transforms are set by the application.</p>
<p>This value should always be calculated by the auto-white balance (AWB) block,
regardless of the android.control.* current values.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@deprecated
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Rational[]> ${name}${value};
"
	    java_annotation "@Deprecated
"
	    classrelation_ref 15684791 // STATISTICS_PREDICTED_COLOR_TRANSFORM (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15684919 // STATISTICS_SCENE_FLICKER (<unidirectional association>)
	relation 15684919 --->
	  a role_name "STATISTICS_SCENE_FLICKER" init_value "
            new Key<Integer>(\"android.statistics.sceneFlicker\", int.class)" class_relation const_relation public
	    comment "
<p>The camera device estimated scene illumination lighting
frequency.</p>
<p>Many light sources, such as most fluorescent lights, flicker at a rate
that depends on the local utility power standards. This flicker must be
accounted for by auto-exposure routines to avoid artifacts in captured images.
The camera device uses this entry to tell the application what the scene
illuminant frequency is.</p>
<p>When manual exposure control is enabled
(<code>{@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} == OFF</code> or <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} ==
OFF</code>), the {@link CaptureRequest#CONTROL_AE_ANTIBANDING_MODE android.control.aeAntibandingMode} doesn't perform
antibanding, and the application can ensure it selects
exposure times that do not cause banding issues by looking
into this metadata field. See
{@link CaptureRequest#CONTROL_AE_ANTIBANDING_MODE android.control.aeAntibandingMode} for more details.</p>
<p>Reports NONE if there doesn't appear to be flickering illumination.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #STATISTICS_SCENE_FLICKER_NONE NONE}</li>
  <li>{@link #STATISTICS_SCENE_FLICKER_50HZ 50HZ}</li>
  <li>{@link #STATISTICS_SCENE_FLICKER_60HZ 60HZ}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE
@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see #STATISTICS_SCENE_FLICKER_NONE
@see #STATISTICS_SCENE_FLICKER_50HZ
@see #STATISTICS_SCENE_FLICKER_60HZ

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15684919 // STATISTICS_SCENE_FLICKER (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15685047 // STATISTICS_HOT_PIXEL_MAP_MODE (<unidirectional association>)
	relation 15685047 --->
	  a role_name "STATISTICS_HOT_PIXEL_MAP_MODE" init_value "
            new Key<Boolean>(\"android.statistics.hotPixelMapMode\", boolean.class)" class_relation const_relation public
	    comment "
<p>Operating mode for hot pixel map generation.</p>
<p>If set to <code>true</code>, a hot pixel map is returned in {@link CaptureResult#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap}.
If set to <code>false</code>, no hot pixel map will be returned.</p>
<p><b>Range of valid values:</b><br>
{@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES android.statistics.info.availableHotPixelMapModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureResult#STATISTICS_HOT_PIXEL_MAP
@see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15685047 // STATISTICS_HOT_PIXEL_MAP_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15685175 // STATISTICS_HOT_PIXEL_MAP (<unidirectional association>)
	relation 15685175 --->
	  a role_name "STATISTICS_HOT_PIXEL_MAP" init_value "
            new Key<android.graphics.Point[]>(\"android.statistics.hotPixelMap\", android.graphics.Point[].class)" class_relation const_relation public
	    comment "
<p>List of <code>(x, y)</code> coordinates of hot/defective pixels on the sensor.</p>
<p>A coordinate <code>(x, y)</code> must lie between <code>(0, 0)</code>, and
<code>(width - 1, height - 1)</code> (inclusive), which are the top-left and
bottom-right of the pixel array, respectively. The width and
height dimensions are given in {@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}.
This may include hot pixels that lie outside of the active array
bounds given by {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.</p>
<p><b>Range of valid values:</b><br></p>
<p>n &lt;= number of pixels on the sensor.
The <code>(x, y)</code> coordinates must be bounded by
{@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE
@see CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.graphics.Point[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15685175 // STATISTICS_HOT_PIXEL_MAP (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15685303 // STATISTICS_LENS_SHADING_MAP_MODE (<unidirectional association>)
	relation 15685303 --->
	  a role_name "STATISTICS_LENS_SHADING_MAP_MODE" init_value "
            new Key<Integer>(\"android.statistics.lensShadingMapMode\", int.class)" class_relation const_relation public
	    comment "
<p>Whether the camera device will output the lens
shading map in output result metadata.</p>
<p>When set to ON,
android.statistics.lensShadingMap will be provided in
the output result metadata.</p>
<p>ON is always supported on devices with the RAW capability.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #STATISTICS_LENS_SHADING_MAP_MODE_OFF OFF}</li>
  <li>{@link #STATISTICS_LENS_SHADING_MAP_MODE_ON ON}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES android.statistics.info.availableLensShadingMapModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES
@see #STATISTICS_LENS_SHADING_MAP_MODE_OFF
@see #STATISTICS_LENS_SHADING_MAP_MODE_ON

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15685303 // STATISTICS_LENS_SHADING_MAP_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15685431 // TONEMAP_CURVE_BLUE (<unidirectional association>)
	relation 15685431 --->
	  a role_name "TONEMAP_CURVE_BLUE" init_value "
            new Key<float[]>(\"android.tonemap.curveBlue\", float[].class)" class_relation const_relation public
	    comment "
<p>Tonemapping / contrast / gamma curve for the blue
channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
CONTRAST_CURVE.</p>
<p>See android.tonemap.curveRed for more details.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#TONEMAP_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    classrelation_ref 15685431 // TONEMAP_CURVE_BLUE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15685559 // TONEMAP_CURVE_GREEN (<unidirectional association>)
	relation 15685559 --->
	  a role_name "TONEMAP_CURVE_GREEN" init_value "
            new Key<float[]>(\"android.tonemap.curveGreen\", float[].class)" class_relation const_relation public
	    comment "
<p>Tonemapping / contrast / gamma curve for the green
channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
CONTRAST_CURVE.</p>
<p>See android.tonemap.curveRed for more details.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#TONEMAP_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    classrelation_ref 15685559 // TONEMAP_CURVE_GREEN (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15685687 // TONEMAP_CURVE_RED (<unidirectional association>)
	relation 15685687 --->
	  a role_name "TONEMAP_CURVE_RED" init_value "
            new Key<float[]>(\"android.tonemap.curveRed\", float[].class)" class_relation const_relation public
	    comment "
<p>Tonemapping / contrast / gamma curve for the red
channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
CONTRAST_CURVE.</p>
<p>Each channel's curve is defined by an array of control points:</p>
<pre><code>android.tonemap.curveRed =
  [ P0in, P0out, P1in, P1out, P2in, P2out, P3in, P3out, ..., PNin, PNout ]
2 &lt;= N &lt;= {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}</code></pre>
<p>These are sorted in order of increasing <code>Pin</code>; it is
required that input values 0.0 and 1.0 are included in the list to
define a complete mapping. For input values between control points,
the camera device must linearly interpolate between the control
points.</p>
<p>Each curve can have an independent number of points, and the number
of points can be less than max (that is, the request doesn't have to
always provide a curve with number of points equivalent to
{@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}).</p>
<p>A few examples, and their corresponding graphical mappings; these
only specify the red channel and the precision is limited to 4
digits, for conciseness.</p>
<p>Linear mapping:</p>
<pre><code>android.tonemap.curveRed = [ 0, 0, 1.0, 1.0 ]
</code></pre>
<p><img alt=\"Linear mapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/linear_tonemap.png\" /></p>
<p>Invert mapping:</p>
<pre><code>android.tonemap.curveRed = [ 0, 1.0, 1.0, 0 ]
</code></pre>
<p><img alt=\"Inverting mapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/inverse_tonemap.png\" /></p>
<p>Gamma 1/2.2 mapping, with 16 control points:</p>
<pre><code>android.tonemap.curveRed = [
  0.0000, 0.0000, 0.0667, 0.2920, 0.1333, 0.4002, 0.2000, 0.4812,
  0.2667, 0.5484, 0.3333, 0.6069, 0.4000, 0.6594, 0.4667, 0.7072,
  0.5333, 0.7515, 0.6000, 0.7928, 0.6667, 0.8317, 0.7333, 0.8685,
  0.8000, 0.9035, 0.8667, 0.9370, 0.9333, 0.9691, 1.0000, 1.0000 ]
</code></pre>
<p><img alt=\"Gamma = 1/2.2 tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/gamma_tonemap.png\" /></p>
<p>Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:</p>
<pre><code>android.tonemap.curveRed = [
  0.0000, 0.0000, 0.0667, 0.2864, 0.1333, 0.4007, 0.2000, 0.4845,
  0.2667, 0.5532, 0.3333, 0.6125, 0.4000, 0.6652, 0.4667, 0.7130,
  0.5333, 0.7569, 0.6000, 0.7977, 0.6667, 0.8360, 0.7333, 0.8721,
  0.8000, 0.9063, 0.8667, 0.9389, 0.9333, 0.9701, 1.0000, 1.0000 ]
</code></pre>
<p><img alt=\"sRGB tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>
<p><b>Range of valid values:</b><br>
0-1 on both input and output coordinates, normalized
as a floating-point value such that 0 == black and 1 == white.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS
@see CaptureRequest#TONEMAP_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    classrelation_ref 15685687 // TONEMAP_CURVE_RED (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15685815 // TONEMAP_CURVE (<unidirectional association>)
	relation 15685815 --->
	  a role_name "TONEMAP_CURVE" init_value "
            new Key<android.hardware.camera2.params.TonemapCurve>(\"android.tonemap.curve\", android.hardware.camera2.params.TonemapCurve.class)" class_relation const_relation public
	    comment "
<p>Tonemapping / contrast / gamma curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode}
is CONTRAST_CURVE.</p>
<p>The tonemapCurve consist of three curves for each of red, green, and blue
channels respectively. The following example uses the red channel as an
example. The same logic applies to green and blue channel.
Each channel's curve is defined by an array of control points:</p>
<pre><code>curveRed =
  [ P0(in, out), P1(in, out), P2(in, out), P3(in, out), ..., PN(in, out) ]
2 &lt;= N &lt;= {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}</code></pre>
<p>These are sorted in order of increasing <code>Pin</code>; it is always
guaranteed that input values 0.0 and 1.0 are included in the list to
define a complete mapping. For input values between control points,
the camera device must linearly interpolate between the control
points.</p>
<p>Each curve can have an independent number of points, and the number
of points can be less than max (that is, the request doesn't have to
always provide a curve with number of points equivalent to
{@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}).</p>
<p>A few examples, and their corresponding graphical mappings; these
only specify the red channel and the precision is limited to 4
digits, for conciseness.</p>
<p>Linear mapping:</p>
<pre><code>curveRed = [ (0, 0), (1.0, 1.0) ]
</code></pre>
<p><img alt=\"Linear mapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/linear_tonemap.png\" /></p>
<p>Invert mapping:</p>
<pre><code>curveRed = [ (0, 1.0), (1.0, 0) ]
</code></pre>
<p><img alt=\"Inverting mapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/inverse_tonemap.png\" /></p>
<p>Gamma 1/2.2 mapping, with 16 control points:</p>
<pre><code>curveRed = [
  (0.0000, 0.0000), (0.0667, 0.2920), (0.1333, 0.4002), (0.2000, 0.4812),
  (0.2667, 0.5484), (0.3333, 0.6069), (0.4000, 0.6594), (0.4667, 0.7072),
  (0.5333, 0.7515), (0.6000, 0.7928), (0.6667, 0.8317), (0.7333, 0.8685),
  (0.8000, 0.9035), (0.8667, 0.9370), (0.9333, 0.9691), (1.0000, 1.0000) ]
</code></pre>
<p><img alt=\"Gamma = 1/2.2 tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/gamma_tonemap.png\" /></p>
<p>Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:</p>
<pre><code>curveRed = [
  (0.0000, 0.0000), (0.0667, 0.2864), (0.1333, 0.4007), (0.2000, 0.4845),
  (0.2667, 0.5532), (0.3333, 0.6125), (0.4000, 0.6652), (0.4667, 0.7130),
  (0.5333, 0.7569), (0.6000, 0.7977), (0.6667, 0.8360), (0.7333, 0.8721),
  (0.8000, 0.9063), (0.8667, 0.9389), (0.9333, 0.9701), (1.0000, 1.0000) ]
</code></pre>
<p><img alt=\"sRGB tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS
@see CaptureRequest#TONEMAP_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.TonemapCurve> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15685815 // TONEMAP_CURVE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15685943 // TONEMAP_MODE (<unidirectional association>)
	relation 15685943 --->
	  a role_name "TONEMAP_MODE" init_value "
            new Key<Integer>(\"android.tonemap.mode\", int.class)" class_relation const_relation public
	    comment "
<p>High-level global contrast/gamma/tonemapping control.</p>
<p>When switching to an application-defined contrast curve by setting
{@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} to CONTRAST_CURVE, the curve is defined
per-channel with a set of <code>(in, out)</code> points that specify the
mapping from input high-bit-depth pixel value to the output
low-bit-depth value.  Since the actual pixel ranges of both input
and output may change depending on the camera pipeline, the values
are specified by normalized floating-point numbers.</p>
<p>More-complex color mapping operations such as 3D color look-up
tables, selective chroma enhancement, or other non-linear color
transforms will be disabled when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
CONTRAST_CURVE.</p>
<p>When using either FAST or HIGH_QUALITY, the camera device will
emit its own tonemap curve in {@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}.
These values are always available, and as close as possible to the
actually used nonlinear/nonglobal transforms.</p>
<p>If a request is sent with CONTRAST_CURVE with the camera device's
provided curve in FAST or HIGH_QUALITY, the image's tonemap will be
roughly the same.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #TONEMAP_MODE_CONTRAST_CURVE CONTRAST_CURVE}</li>
  <li>{@link #TONEMAP_MODE_FAST FAST}</li>
  <li>{@link #TONEMAP_MODE_HIGH_QUALITY HIGH_QUALITY}</li>
  <li>{@link #TONEMAP_MODE_GAMMA_VALUE GAMMA_VALUE}</li>
  <li>{@link #TONEMAP_MODE_PRESET_CURVE PRESET_CURVE}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
{@link CameraCharacteristics#TONEMAP_AVAILABLE_TONE_MAP_MODES android.tonemap.availableToneMapModes}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#TONEMAP_AVAILABLE_TONE_MAP_MODES
@see CaptureRequest#TONEMAP_CURVE
@see CaptureRequest#TONEMAP_MODE
@see #TONEMAP_MODE_CONTRAST_CURVE
@see #TONEMAP_MODE_FAST
@see #TONEMAP_MODE_HIGH_QUALITY
@see #TONEMAP_MODE_GAMMA_VALUE
@see #TONEMAP_MODE_PRESET_CURVE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15685943 // TONEMAP_MODE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15686071 // TONEMAP_GAMMA (<unidirectional association>)
	relation 15686071 --->
	  a role_name "TONEMAP_GAMMA" init_value "
            new Key<Float>(\"android.tonemap.gamma\", float.class)" class_relation const_relation public
	    comment "
<p>Tonemapping curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
GAMMA_VALUE</p>
<p>The tonemap curve will be defined the following formula:
* OUT = pow(IN, 1.0 / gamma)
where IN and OUT is the input pixel value scaled to range [0.0, 1.0],
pow is the power function and gamma is the gamma value specified by this
key.</p>
<p>The same curve will be applied to all color channels. The camera device
may clip the input gamma value to its supported range. The actual applied
value will be returned in capture result.</p>
<p>The valid range of gamma value varies on different devices, but values
within [1.0, 5.0] are guaranteed not to be clipped.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#TONEMAP_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15686071 // TONEMAP_GAMMA (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15686199 // TONEMAP_PRESET_CURVE (<unidirectional association>)
	relation 15686199 --->
	  a role_name "TONEMAP_PRESET_CURVE" init_value "
            new Key<Integer>(\"android.tonemap.presetCurve\", int.class)" class_relation const_relation public
	    comment "
<p>Tonemapping curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is
PRESET_CURVE</p>
<p>The tonemap curve will be defined by specified standard.</p>
<p>sRGB (approximated by 16 control points):</p>
<p><img alt=\"sRGB tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>
<p>Rec. 709 (approximated by 16 control points):</p>
<p><img alt=\"Rec. 709 tonemapping curve\" src=\"../../../../images/camera2/metadata/android.tonemap.curveRed/rec709_tonemap.png\" /></p>
<p>Note that above figures show a 16 control points approximation of preset
curves. Camera devices may apply a different approximation to the curve.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #TONEMAP_PRESET_CURVE_SRGB SRGB}</li>
  <li>{@link #TONEMAP_PRESET_CURVE_REC709 REC709}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#TONEMAP_MODE
@see #TONEMAP_PRESET_CURVE_SRGB
@see #TONEMAP_PRESET_CURVE_REC709

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15686199 // TONEMAP_PRESET_CURVE (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15686327 // LED_TRANSMIT (<unidirectional association>)
	relation 15686327 --->
	  a role_name "LED_TRANSMIT" init_value "
            new Key<Boolean>(\"android.led.transmit\", boolean.class)" class_relation const_relation public
	    comment "
<p>This LED is nominally used to indicate to the user
that the camera is powered on and may be streaming images back to the
Application Processor. In certain rare circumstances, the OS may
disable this when video is processed locally and not transmitted to
any untrusted applications.</p>
<p>In particular, the LED <em>must</em> always be on when the data could be
transmitted off the device. The LED <em>should</em> always be on whenever
data is stored locally on the device.</p>
<p>The LED <em>may</em> be off if a trusted application is using the data that
doesn't violate the above rules.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    classrelation_ref 15686327 // LED_TRANSMIT (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15686455 // BLACK_LEVEL_LOCK (<unidirectional association>)
	relation 15686455 --->
	  a role_name "BLACK_LEVEL_LOCK" init_value "
            new Key<Boolean>(\"android.blackLevel.lock\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether black-level compensation is locked
to its current values, or is free to vary.</p>
<p>Whether the black level offset was locked for this frame.  Should be
ON if {@link CaptureRequest#BLACK_LEVEL_LOCK android.blackLevel.lock} was ON in the capture request, unless
a change in other capture settings forced the camera device to
perform a black level reset.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#BLACK_LEVEL_LOCK
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15686455 // BLACK_LEVEL_LOCK (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15686583 // SYNC_FRAME_NUMBER (<unidirectional association>)
	relation 15686583 --->
	  a role_name "SYNC_FRAME_NUMBER" init_value "
            new Key<Long>(\"android.sync.frameNumber\", long.class)" class_relation const_relation public
	    comment "
<p>The frame number corresponding to the last request
with which the output result (metadata + buffers) has been fully
synchronized.</p>
<p>When a request is submitted to the camera device, there is usually a
delay of several frames before the controls get applied. A camera
device may either choose to account for this delay by implementing a
pipeline and carefully submit well-timed atomic control updates, or
it may start streaming control changes that span over several frame
boundaries.</p>
<p>In the latter case, whenever a request's settings change relative to
the previous submitted request, the full set of changes may take
multiple frame durations to fully take effect. Some settings may
take effect sooner (in less frame durations) than others.</p>
<p>While a set of control changes are being propagated, this value
will be CONVERGING.</p>
<p>Once it is fully known that a set of control changes have been
finished propagating, and the resulting updated control settings
have been read back by the camera device, this value will be set
to a non-negative frame number (corresponding to the request to
which the results have synchronized to).</p>
<p>Older camera device implementations may not have a way to detect
when all camera controls have been applied, and will always set this
value to UNKNOWN.</p>
<p>FULL capability devices will always have this value set to the
frame number of the request corresponding to this result.</p>
<p><em>Further details</em>:</p>
<ul>
<li>Whenever a request differs from the last request, any future
results not yet returned may have this value set to CONVERGING (this
could include any in-progress captures not yet returned by the camera
device, for more details see pipeline considerations below).</li>
<li>Submitting a series of multiple requests that differ from the
previous request (e.g. r1, r2, r3 s.t. r1 != r2 != r3)
moves the new synchronization frame to the last non-repeating
request (using the smallest frame number from the contiguous list of
repeating requests).</li>
<li>Submitting the same request repeatedly will not change this value
to CONVERGING, if it was already a non-negative value.</li>
<li>When this value changes to non-negative, that means that all of the
metadata controls from the request have been applied, all of the
metadata controls from the camera device have been read to the
updated values (into the result), and all of the graphics buffers
corresponding to this result are also synchronized to the request.</li>
</ul>
<p><em>Pipeline considerations</em>:</p>
<p>Submitting a request with updated controls relative to the previously
submitted requests may also invalidate the synchronization state
of all the results corresponding to currently in-flight requests.</p>
<p>In other words, results for this current request and up to
{@link CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH android.request.pipelineMaxDepth} prior requests may have their
android.sync.frameNumber change to CONVERGING.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #SYNC_FRAME_NUMBER_CONVERGING CONVERGING}</li>
  <li>{@link #SYNC_FRAME_NUMBER_UNKNOWN UNKNOWN}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
Either a non-negative value corresponding to a
<code>frame_number</code>, or one of the two enums (CONVERGING / UNKNOWN).</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH
@see #SYNC_FRAME_NUMBER_CONVERGING
@see #SYNC_FRAME_NUMBER_UNKNOWN
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Long> ${name}${value};
"
	    classrelation_ref 15686583 // SYNC_FRAME_NUMBER (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      classrelation 15686711 // REPROCESS_EFFECTIVE_EXPOSURE_FACTOR (<unidirectional association>)
	relation 15686711 --->
	  a role_name "REPROCESS_EFFECTIVE_EXPOSURE_FACTOR" init_value "
            new Key<Float>(\"android.reprocess.effectiveExposureFactor\", float.class)" class_relation const_relation public
	    comment "
<p>The amount of exposure time increase factor applied to the original output
frame by the application processing before sending for reprocessing.</p>
<p>This is optional, and will be supported if the camera device supports YUV_REPROCESSING
capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains YUV_REPROCESSING).</p>
<p>For some YUV reprocessing use cases, the application may choose to filter the original
output frames to effectively reduce the noise to the same level as a frame that was
captured with longer exposure time. To be more specific, assuming the original captured
images were captured with a sensitivity of S and an exposure time of T, the model in
the camera device is that the amount of noise in the image would be approximately what
would be expected if the original capture parameters had been a sensitivity of
S/effectiveExposureFactor and an exposure time of T*effectiveExposureFactor, rather
than S and T respectively. If the captured images were processed by the application
before being sent for reprocessing, then the application may have used image processing
algorithms and/or multi-frame image fusion to reduce the noise in the
application-processed images (input images). By using the effectiveExposureFactor
control, the application can communicate to the camera device the actual noise level
improvement in the application-processed image. With this information, the camera
device can select appropriate noise reduction and edge enhancement parameters to avoid
excessive noise reduction ({@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode}) and insufficient edge
enhancement ({@link CaptureRequest#EDGE_MODE android.edge.mode}) being applied to the reprocessed frames.</p>
<p>For example, for multi-frame image fusion use case, the application may fuse
multiple output frames together to a final frame for reprocessing. When N image are
fused into 1 image for reprocessing, the exposure time increase factor could be up to
square root of N (based on a simple photon shot noise model). The camera device will
adjust the reprocessing noise reduction and edge enhancement parameters accordingly to
produce the best quality images.</p>
<p>This is relative factor, 1.0 indicates the application hasn't processed the input
buffer in a way that affects its effective exposure time.</p>
<p>This control is only effective for YUV reprocessing capture request. For noise
reduction reprocessing, it is only effective when <code>{@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode} != OFF</code>.
Similarly, for edge enhancement reprocessing, it is only effective when
<code>{@link CaptureRequest#EDGE_MODE android.edge.mode} != OFF</code>.</p>
<p><b>Units</b>: Relative exposure time increase factor.</p>
<p><b>Range of valid values:</b><br>
&gt;= 1.0</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#EDGE_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#NOISE_REDUCTION_MODE
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15686711 // REPROCESS_EFFECTIVE_EXPOSURE_FACTOR (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end
    end

    class 7148471 "TotalCaptureResult"
      visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      final java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "<p>The total assembled results of a single image capture from the image sensor.</p>

<p>Contains the final configuration for the capture hardware (sensor, lens,
flash), the processing pipeline, the control algorithms, and the output
buffers.</p>

<p>A {@code TotalCaptureResult} is produced by a {@link CameraDevice} after processing a
{@link CaptureRequest}. All properties listed for capture requests can also
be queried on the capture result, to determine the final values used for
capture. The result also includes additional metadata about the state of the
camera device during the capture.</p>

<p>All properties returned by {@link CameraCharacteristics#getAvailableCaptureResultKeys()}
are available (that is {@link CaptureResult#get} will return non-{@code null}, if and only if
that key that was enabled by the request. A few keys such as
{@link CaptureResult#STATISTICS_FACES} are disabled by default unless enabled with a switch (such
as {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE}). Refer to each key documentation on
a case-by-case basis.</p>

<p>{@link TotalCaptureResult} objects are immutable.</p>

@see CameraDevice.CaptureCallback#onCaptureCompleted
"
      classrelation 15687863 // <generalisation>
	relation 15687863 ---|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 15687863 // <generalisation>
	  b parent class_ref 7148343 // CaptureResult
      end

      classrelation 15687991 // mPartialResults (<unidirectional association>)
	relation 15687991 --->
	  stereotype "List"
	  a role_name "mPartialResults" const_relation private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${stereotype}<${type}> ${name}${value};
"
	    classrelation_ref 15687991 // mPartialResults (<unidirectional association>)
	  b parent class_ref 7148343 // CaptureResult
      end

      attribute 24804151 "mSessionId"
	const_attribute private explicit_type "int"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 79343159 "TotalCaptureResult"
	public explicit_return_type ""
	nparams 5
	  param inout name "results" type class_ref 7149239 // CameraMetadataNative
	  param inout name "parent" type class_ref 7147831 // CaptureRequest
	  param inout name "extras" type class_ref 7153207 // CaptureResultExtras
	  param inout name "partials" explicit_type "List<CaptureResult>"
	  param in name "sessionId" explicit_type "int"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Takes ownership of the passed-in camera metadata and the partial results

@param partials a list of partial results; {@code null} will be substituted for an empty list
@hide
"
      end

      operation 79343287 "TotalCaptureResult"
	public explicit_return_type ""
	nparams 2
	  param inout name "results" type class_ref 7149239 // CameraMetadataNative
	  param in name "sequenceId" explicit_type "int"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a request-less result.

<p><strong>For testing only.</strong></p>
@hide
"
      end

      operation 79343415 "getPartialResults"
	public return_type class_ref 7148343 // CaptureResult
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}List<${type}> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Get the read-only list of partial results that compose this total result.

<p>The list is returned is unmodifiable; attempting to modify it will result in a
{@code UnsupportedOperationException} being thrown.</p>

<p>The list size will be inclusive between {@code 0} and
{@link CameraCharacteristics#REQUEST_PARTIAL_RESULT_COUNT}, with elements in ascending order
of when {@link CameraCaptureSession.CaptureCallback#onCaptureProgressed} was invoked.</p>

@return unmodifiable list of partial results
"
      end

      operation 79343543 "getSessionId"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Get the ID of the session where the capture request of this result was submitted.

@return The session ID
@hide
"
      end
    end

    class 7148599 "CaptureFailure"
      visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A report of failed capture for a single image capture from the image sensor.

<p>CaptureFailures are produced by a {@link CameraDevice} if processing a
{@link CaptureRequest} fails, either partially or fully. Use {@link #getReason}
to determine the specific nature of the failed capture.</p>

<p>Receiving a CaptureFailure means that the metadata associated with that frame number
has been dropped -- no {@link CaptureResult} with the same frame number will be
produced.</p>
"
      attribute 24801591 "REASON_ERROR"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "The {@link CaptureResult} has been dropped this frame only due to an error
in the framework.

@see #getReason()

"
      end

      attribute 24801719 "REASON_FLUSHED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "The capture has failed due to a {@link CameraCaptureSession#abortCaptures} call from the
application.

@see #getReason()

"
      end

      class 7152695 "FailureReason"
	visibility public stereotype "@interface"
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	java_decl "${comment}${@}${visibility}${static}@interface ${name}${extends} {
${members}}
"
	java_annotation "@Retention(RetentionPolicy.SOURCE)
@IntDef(
         {REASON_ERROR,
          REASON_FLUSHED })
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
      end

      classrelation 15665335 // mRequest (<unidirectional association>)
	relation 15665335 --->
	  a role_name "mRequest" const_relation private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 15665335 // mRequest (<unidirectional association>)
	  b parent class_ref 7147831 // CaptureRequest
      end

      attribute 24801847 "mReason"
	const_attribute private explicit_type "int"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24801975 "mDropped"
	const_attribute private explicit_type "boolean"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24802103 "mSequenceId"
	const_attribute private explicit_type "int"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24802231 "mFrameNumber"
	const_attribute private explicit_type "long"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 79331895 "CaptureFailure"
	public explicit_return_type ""
	nparams 5
	  param inout name "request" type class_ref 7147831 // CaptureRequest
	  param in name "reason" explicit_type "int"
	  param inout name "dropped" explicit_type "boolean"
	  param in name "sequenceId" explicit_type "int"
	  param in name "frameNumber" explicit_type "long"
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@hide
"
      end

      operation 79332023 "getRequest"
	public return_type class_ref 7147831 // CaptureRequest
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Get the request associated with this failed capture.

<p>Whenever a request is unsuccessfully captured, with
{@link CameraCaptureSession.CaptureCallback#onCaptureFailed},
the {@code failed capture}'s {@code getRequest()} will return that {@code request}.
</p>

<p>In particular,
<code><pre>cameraDevice.capture(someRequest, new CaptureCallback() {
    {@literal @}Override
    void onCaptureFailed(CaptureRequest myRequest, CaptureFailure myFailure) {
        assert(myFailure.getRequest.equals(myRequest) == true);
    }
};
</code></pre>
</p>

@return The request associated with this failed capture. Never {@code null}.
"
      end

      operation 79332151 "getFrameNumber"
	public explicit_return_type "long"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Get the frame number associated with this failed capture.

<p>Whenever a request has been processed, regardless of failed capture or success,
it gets a unique frame number assigned to its future result/failed capture.</p>

<p>This value monotonically increments, starting with 0,
for every new result or failure; and the scope is the lifetime of the
{@link CameraDevice}.</p>

@return long frame number
"
      end

      operation 79332279 "getReason"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@FailureReason
"
	
	
	
	comment "Determine why the request was dropped, whether due to an error or to a user
action.

@return int One of {@code REASON_*} integer constants.

@see #REASON_ERROR
@see #REASON_FLUSHED
"
      end

      operation 79332407 "wasImageCaptured"
	public explicit_return_type "boolean"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Determine if the image was captured from the camera.

<p>If the image was not captured, no image buffers will be available.
If the image was captured, then image buffers may be available.</p>

@return boolean True if the image was captured, false otherwise.
"
      end

      operation 79332535 "getSequenceId"
	public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "The sequence ID for this failed capture that was returned by the
{@link CameraCaptureSession#capture} family of functions.

<p>The sequence ID is a unique monotonically increasing value starting from 0,
incremented every time a new group of requests is submitted to the CameraDevice.</p>

@return int The ID for the sequence of requests that this capture failure is the result of

@see CameraDevice.CaptureCallback#onCaptureSequenceCompleted
"
      end
    end

    class 7148855 "CameraCharacteristics"
      visibility public 
      nactuals 1
      actual class class_ref 7148983 // CameraMetadata
        rank 0 explicit_value ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      final java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "<p>The properties describing a
{@link CameraDevice CameraDevice}.</p>

<p>These properties are fixed for a given CameraDevice, and can be queried
through the {@link CameraManager CameraManager}
interface with {@link CameraManager#getCameraCharacteristics}.</p>

<p>{@link CameraCharacteristics} objects are immutable.</p>

@see CameraDevice
@see CameraManager
"
      classrelation 15649335 // <realization>
	relation 15649335 -_-|>
	  stereotype "bind"
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 15649335 // <realization>
	  b parent class_ref 7148983 // CameraMetadata
      end

      class 7149111 "Key"
	visibility public 
	nformals 1
	formal name "T" type "" explicit_default_value ""
	  explicit_extends ""
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 15649463 // mKey (<unidirectional association>)
	  relation 15649463 --->
	    a role_name "mKey" const_relation private
	      cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<T> ${name}${value};
"
	      classrelation_ref 15649463 // mKey (<unidirectional association>)
	    b parent class_ref 7149367 // Key
	end

	operation 79322423 "Key"
	  cpp_inline public explicit_return_type ""
	  nparams 2
	    param inout name "name" explicit_type "String"
	    param inout name "type" explicit_type "Class"
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1}<T> ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Visible for testing and vendor extensions only.

@hide
"
	end

	operation 79322551 "Key"
	  cpp_inline public explicit_return_type ""
	  nparams 2
	    param inout name "name" explicit_type "String"
	    param inout name "typeReference" type class_ref 7149495 // TypeReference
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1}<T> ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Visible for testing and vendor extensions only.

@hide
"
	end

	operation 79322679 "getName"
	  cpp_inline public explicit_return_type "String"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@NonNull
"
	  
	  
	  
	  comment "Return a camelCase, period separated name formatted like:
{@code \"root.section[.subsections].name\"}.

<p>Built-in keys exposed by the Android SDK are always prefixed with {@code \"android.\"};
keys that are device/platform-specific are prefixed with {@code \"com.\"}.</p>

<p>For example, {@code CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP} would
have a name of {@code \"android.scaler.streamConfigurationMap\"}; whereas a device
specific key might look like {@code \"com.google.nexus.data.private\"}.</p>

@return String representation of the key name
"
	end

	operation 79322807 "hashCode"
	  cpp_inline public explicit_return_type "int"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@Override
"
	  
	  
	  
	  comment "{@inheritDoc}
"
	end

	operation 79322935 "equals"
	  cpp_inline public explicit_return_type "boolean"
	  nparams 1
	    param inout name "o" explicit_type "Object"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@SuppressWarnings(\"unchecked\")
@Override
"
	  
	  
	  
	  comment "{@inheritDoc}
"
	end

	operation 79323063 "toString"
	  cpp_inline public explicit_return_type "String"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@NonNull
@Override
"
	  
	  
	  
	  comment "Return this {@link Key} as a string representation.

<p>{@code \"CameraCharacteristics.Key(%s)\"}, where {@code %s} represents
the name of this key as returned by {@link #getName}.</p>

@return string representation of {@link Key}
"
	end

	operation 79323191 "getNativeKey"
	  cpp_inline public return_type class_ref 7149367 // Key
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<T> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Visible for CameraMetadataNative implementation only; do not use.

TODO: Make this private or remove it altogether.

@hide
"
	end

	operation 79323319 "Key"
	  cpp_inline private explicit_return_type ""
	  nparams 1
	    param inout name "nativeKey" type class_ref 7149367 // Key
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0}<?> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@SuppressWarnings({
                \"unused\", \"unchecked\"
        })
"
	  
	  
	  
	end
      end

      classrelation 15649591 // mProperties (<unidirectional association>)
	relation 15649591 --->
	  a role_name "mProperties" const_relation private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 15649591 // mProperties (<unidirectional association>)
	  b parent class_ref 7149239 // CameraMetadataNative
      end

      classrelation 15649719 // mKeys (<unidirectional association>)
	relation 15649719 --->
	  stereotype "List"
	  a role_name "mKeys" private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${stereotype}<${type}<?>> ${name}${value};
"
	    classrelation_ref 15649719 // mKeys (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15649847 // mAvailableRequestKeys (<unidirectional association>)
	relation 15649847 --->
	  stereotype "List"
	  a role_name "mAvailableRequestKeys" private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${stereotype}<${type}<?>> ${name}${value};
"
	    classrelation_ref 15649847 // mAvailableRequestKeys (<unidirectional association>)
	  b parent class_ref 7149623 // Key
      end

      classrelation 15649975 // mAvailableResultKeys (<unidirectional association>)
	relation 15649975 --->
	  stereotype "List"
	  a role_name "mAvailableResultKeys" private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${stereotype}<${type}<?>> ${name}${value};
"
	    classrelation_ref 15649975 // mAvailableResultKeys (<unidirectional association>)
	  b parent class_ref 7149751 // Key
      end

      operation 79323447 "CameraCharacteristics"
	public explicit_return_type ""
	nparams 1
	  param inout name "properties" type class_ref 7149239 // CameraMetadataNative
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Takes ownership of the passed-in properties object
@hide
"
      end

      operation 79323575 "getNativeCopy"
	public return_type class_ref 7149239 // CameraMetadataNative
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a copy of the underlying {@link CameraMetadataNative}.
@hide
"
      end

      operation 79323703 "get"
	public explicit_return_type "T"
	nparams 1
	  param inout name "key" type class_ref 7149111 // Key
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Nullable
"
	
	
	
	comment "Get a camera characteristics field value.

<p>The field definitions can be
found in {@link CameraCharacteristics}.</p>

<p>Querying the value for the same key more than once will return a value
which is equal to the previous queried value.</p>

@throws IllegalArgumentException if the key was not valid

@param key The characteristics field to read.
@return The value of that key, or {@code null} if the field is not set.
"
      end

      operation 79323831 "getProtected"
	protected explicit_return_type "T"
	nparams 1
	  param inout name "key" type class_ref 7149111 // Key
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<?> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings(\"unchecked\")
@Override
"
	
	
	
	comment "{@inheritDoc}
@hide
"
      end

      operation 79323959 "getKeyClass"
	protected explicit_return_type "Class"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Key<?>> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings(\"unchecked\")
@Override
"
	
	
	
	comment "{@inheritDoc}
@hide
"
      end

      operation 79324087 "getKeys"
	public return_type class_ref 7149111 // Key
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}List<${type}<?>> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
@Override
"
	
	
	
	comment "{@inheritDoc}
"
      end

      operation 79324215 "getAvailableCaptureRequestKeys"
	public return_type class_ref 7149623 // Key
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}List<${type}<?>> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings({\"unchecked\"})
@NonNull
"
	
	
	
	comment "Returns the list of keys supported by this {@link CameraDevice} for querying
with a {@link CaptureRequest}.

<p>The list returned is not modifiable, so any attempts to modify it will throw
a {@code UnsupportedOperationException}.</p>

<p>Each key is only listed once in the list. The order of the keys is undefined.</p>

<p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
{@link #getKeys()} instead.</p>

@return List of keys supported by this CameraDevice for CaptureRequests.
"
      end

      operation 79324343 "getAvailableCaptureResultKeys"
	public return_type class_ref 7149751 // Key
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}List<${type}<?>> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings({\"unchecked\"})
@NonNull
"
	
	
	
	comment "Returns the list of keys supported by this {@link CameraDevice} for querying
with a {@link CaptureResult}.

<p>The list returned is not modifiable, so any attempts to modify it will throw
a {@code UnsupportedOperationException}.</p>

<p>Each key is only listed once in the list. The order of the keys is undefined.</p>

<p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
{@link #getKeys()} instead.</p>

@return List of keys supported by this CameraDevice for CaptureResults.
"
      end

      operation 79324471 "getAvailableKeyList"
	private explicit_return_type "List<TKey>"
	nparams 3
	  param inout name "metadataClass" explicit_type "Class"
	  param inout name "keyClass" explicit_type "Class"
	  param inout name "filterTags" explicit_type "int"
	multiplicity "[]"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<TKey> ${type} ${name}${(}${t0}<?> ${p0}, ${t1}<TKey> ${p1}, ${t2}[] ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the list of keys supported by this {@link CameraDevice} by metadataClass.

<p>The list returned is not modifiable, so any attempts to modify it will throw
a {@code UnsupportedOperationException}.</p>

<p>Each key is only listed once in the list. The order of the keys is undefined.</p>

@param metadataClass The subclass of CameraMetadata that you want to get the keys for.
@param keyClass The class of the metadata key, e.g. CaptureRequest.Key.class

@return List of keys supported by this CameraDevice for metadataClass.

@throws IllegalArgumentException if metadataClass is not a subclass of CameraMetadata
"
      end

      classrelation 15650103 // COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES (<unidirectional association>)
	relation 15650103 --->
	  a role_name "COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES" init_value "
            new Key<int[]>(\"android.colorCorrection.availableAberrationModes\", int[].class)" class_relation const_relation public
	    comment "@O~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~
The key entries below this point are generated from metadata
definitions in /system/media/camera/docs. Do not modify by hand or
modify the comment blocks at the start or end.
~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~

<p>List of aberration correction modes for {@link CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE android.colorCorrection.aberrationMode} that are
supported by this camera device.</p>
<p>This key lists the valid modes for {@link CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE android.colorCorrection.aberrationMode}.  If no
aberration correction modes are available for a device, this list will solely include
OFF mode. All camera devices will support either OFF or FAST mode.</p>
<p>Camera devices that support the MANUAL_POST_PROCESSING capability will always list
OFF mode. This includes all FULL level devices.</p>
<p>LEGACY devices will always only support FAST mode.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE android.colorCorrection.aberrationMode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15650103 // COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15650231 // CONTROL_AE_AVAILABLE_ANTIBANDING_MODES (<unidirectional association>)
	relation 15650231 --->
	  a role_name "CONTROL_AE_AVAILABLE_ANTIBANDING_MODES" init_value "
            new Key<int[]>(\"android.control.aeAvailableAntibandingModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of auto-exposure antibanding modes for {@link CaptureRequest#CONTROL_AE_ANTIBANDING_MODE android.control.aeAntibandingMode} that are
supported by this camera device.</p>
<p>Not all of the auto-exposure anti-banding modes may be
supported by a given camera device. This field lists the
valid anti-banding modes that the application may request
for this camera device with the
{@link CaptureRequest#CONTROL_AE_ANTIBANDING_MODE android.control.aeAntibandingMode} control.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#CONTROL_AE_ANTIBANDING_MODE android.control.aeAntibandingMode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15650231 // CONTROL_AE_AVAILABLE_ANTIBANDING_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15650359 // CONTROL_AE_AVAILABLE_MODES (<unidirectional association>)
	relation 15650359 --->
	  a role_name "CONTROL_AE_AVAILABLE_MODES" init_value "
            new Key<int[]>(\"android.control.aeAvailableModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of auto-exposure modes for {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} that are supported by this camera
device.</p>
<p>Not all the auto-exposure modes may be supported by a
given camera device, especially if no flash unit is
available. This entry lists the valid modes for
{@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} for this camera device.</p>
<p>All camera devices support ON, and all camera devices with flash
units support ON_AUTO_FLASH and ON_ALWAYS_FLASH.</p>
<p>FULL mode camera devices always support OFF mode,
which enables application control of camera exposure time,
sensitivity, and frame duration.</p>
<p>LEGACY mode camera devices never support OFF mode.
LIMITED mode devices support OFF if they support the MANUAL_SENSOR
capability.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15650359 // CONTROL_AE_AVAILABLE_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15650487 // CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES (<unidirectional association>)
	relation 15650487 --->
	  a role_name "CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES" init_value "
            new Key<android.util.Range<Integer>[]>(\"android.control.aeAvailableTargetFpsRanges\", new TypeReference<android.util.Range<Integer>[]>() {{ }})" class_relation const_relation public
	    comment "
<p>List of frame rate ranges for {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange} supported by
this camera device.</p>
<p>For devices at the LEGACY level or above:</p>
<ul>
<li>
<p>For constant-framerate recording, for each normal
{@link android.media.CamcorderProfile CamcorderProfile}, that is, a
{@link android.media.CamcorderProfile CamcorderProfile} that has
{@link android.media.CamcorderProfile#quality quality} in
the range [{@link android.media.CamcorderProfile#QUALITY_LOW QUALITY_LOW},
{@link android.media.CamcorderProfile#QUALITY_2160P QUALITY_2160P}], if the profile is
supported by the device and has
{@link android.media.CamcorderProfile#videoFrameRate videoFrameRate} <code>x</code>, this list will
always include (<code>x</code>,<code>x</code>).</p>
</li>
<li>
<p>Also, a camera device must either not support any
{@link android.media.CamcorderProfile CamcorderProfile},
or support at least one
normal {@link android.media.CamcorderProfile CamcorderProfile} that has
{@link android.media.CamcorderProfile#videoFrameRate videoFrameRate} <code>x</code> &gt;= 24.</p>
</li>
</ul>
<p>For devices at the LIMITED level or above:</p>
<ul>
<li>For YUV_420_888 burst capture use case, this list will always include (<code>min</code>, <code>max</code>)
and (<code>max</code>, <code>max</code>) where <code>min</code> &lt;= 15 and <code>max</code> = the maximum output frame rate of the
maximum YUV_420_888 output size.</li>
</ul>
<p><b>Units</b>: Frames per second (FPS)</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Range<Integer>[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15650487 // CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15650615 // CONTROL_AE_COMPENSATION_RANGE (<unidirectional association>)
	relation 15650615 --->
	  a role_name "CONTROL_AE_COMPENSATION_RANGE" init_value "
            new Key<android.util.Range<Integer>>(\"android.control.aeCompensationRange\", new TypeReference<android.util.Range<Integer>>() {{ }})" class_relation const_relation public
	    comment "
<p>Maximum and minimum exposure compensation values for
{@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation}, in counts of {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP android.control.aeCompensationStep},
that are supported by this camera device.</p>
<p><b>Range of valid values:</b><br></p>
<p>Range [0,0] indicates that exposure compensation is not supported.</p>
<p>For LIMITED and FULL devices, range must follow below requirements if exposure
compensation is supported (<code>range != [0, 0]</code>):</p>
<p><code>Min.exposure compensation * {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP android.control.aeCompensationStep} &lt;= -2 EV</code></p>
<p><code>Max.exposure compensation * {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP android.control.aeCompensationStep} &gt;= 2 EV</code></p>
<p>LEGACY devices may support a smaller range than this.</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP
@see CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Range<Integer>> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15650615 // CONTROL_AE_COMPENSATION_RANGE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15650743 // CONTROL_AE_COMPENSATION_STEP (<unidirectional association>)
	relation 15650743 --->
	  a role_name "CONTROL_AE_COMPENSATION_STEP" init_value "
            new Key<Rational>(\"android.control.aeCompensationStep\", Rational.class)" class_relation const_relation public
	    comment "
<p>Smallest step by which the exposure compensation
can be changed.</p>
<p>This is the unit for {@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation}. For example, if this key has
a value of <code>1/2</code>, then a setting of <code>-2</code> for {@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation} means
that the target EV offset for the auto-exposure routine is -1 EV.</p>
<p>One unit of EV compensation changes the brightness of the captured image by a factor
of two. +1 EV doubles the image brightness, while -1 EV halves the image brightness.</p>
<p><b>Units</b>: Exposure Value (EV)</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Rational> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15650743 // CONTROL_AE_COMPENSATION_STEP (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15650871 // CONTROL_AF_AVAILABLE_MODES (<unidirectional association>)
	relation 15650871 --->
	  a role_name "CONTROL_AF_AVAILABLE_MODES" init_value "
            new Key<int[]>(\"android.control.afAvailableModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of auto-focus (AF) modes for {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode} that are
supported by this camera device.</p>
<p>Not all the auto-focus modes may be supported by a
given camera device. This entry lists the valid modes for
{@link CaptureRequest#CONTROL_AF_MODE android.control.afMode} for this camera device.</p>
<p>All LIMITED and FULL mode camera devices will support OFF mode, and all
camera devices with adjustable focuser units
(<code>{@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance} &gt; 0</code>) will support AUTO mode.</p>
<p>LEGACY devices will support OFF mode only if they support
focusing to infinity (by also setting {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} to
<code>0.0f</code>).</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AF_MODE
@see CaptureRequest#LENS_FOCUS_DISTANCE
@see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15650871 // CONTROL_AF_AVAILABLE_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15650999 // CONTROL_AVAILABLE_EFFECTS (<unidirectional association>)
	relation 15650999 --->
	  a role_name "CONTROL_AVAILABLE_EFFECTS" init_value "
            new Key<int[]>(\"android.control.availableEffects\", int[].class)" class_relation const_relation public
	    comment "
<p>List of color effects for {@link CaptureRequest#CONTROL_EFFECT_MODE android.control.effectMode} that are supported by this camera
device.</p>
<p>This list contains the color effect modes that can be applied to
images produced by the camera device.
Implementations are not expected to be consistent across all devices.
If no color effect modes are available for a device, this will only list
OFF.</p>
<p>A color effect will only be applied if
{@link CaptureRequest#CONTROL_MODE android.control.mode} != OFF.  OFF is always included in this list.</p>
<p>This control has no effect on the operation of other control routines such
as auto-exposure, white balance, or focus.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#CONTROL_EFFECT_MODE android.control.effectMode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_EFFECT_MODE
@see CaptureRequest#CONTROL_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15650999 // CONTROL_AVAILABLE_EFFECTS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15651127 // CONTROL_AVAILABLE_SCENE_MODES (<unidirectional association>)
	relation 15651127 --->
	  a role_name "CONTROL_AVAILABLE_SCENE_MODES" init_value "
            new Key<int[]>(\"android.control.availableSceneModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of scene modes for {@link CaptureRequest#CONTROL_SCENE_MODE android.control.sceneMode} that are supported by this camera
device.</p>
<p>This list contains scene modes that can be set for the camera device.
Only scene modes that have been fully implemented for the
camera device may be included here. Implementations are not expected
to be consistent across all devices.</p>
<p>If no scene modes are supported by the camera device, this
will be set to DISABLED. Otherwise DISABLED will not be listed.</p>
<p>FACE_PRIORITY is always listed if face detection is
supported (i.e.<code>{@link CameraCharacteristics#STATISTICS_INFO_MAX_FACE_COUNT android.statistics.info.maxFaceCount} &gt;
0</code>).</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#CONTROL_SCENE_MODE android.control.sceneMode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_SCENE_MODE
@see CameraCharacteristics#STATISTICS_INFO_MAX_FACE_COUNT

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15651127 // CONTROL_AVAILABLE_SCENE_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15651255 // CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES (<unidirectional association>)
	relation 15651255 --->
	  a role_name "CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES" init_value "
            new Key<int[]>(\"android.control.availableVideoStabilizationModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of video stabilization modes for {@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode}
that are supported by this camera device.</p>
<p>OFF will always be listed.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15651255 // CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15651383 // CONTROL_AWB_AVAILABLE_MODES (<unidirectional association>)
	relation 15651383 --->
	  a role_name "CONTROL_AWB_AVAILABLE_MODES" init_value "
            new Key<int[]>(\"android.control.awbAvailableModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of auto-white-balance modes for {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} that are supported by this
camera device.</p>
<p>Not all the auto-white-balance modes may be supported by a
given camera device. This entry lists the valid modes for
{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} for this camera device.</p>
<p>All camera devices will support ON mode.</p>
<p>Camera devices that support the MANUAL_POST_PROCESSING capability will always support OFF
mode, which enables application control of white balance, by using
{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains}({@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} must be set to TRANSFORM_MATRIX). This includes all FULL
mode camera devices.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_MODE
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15651383 // CONTROL_AWB_AVAILABLE_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15651511 // CONTROL_MAX_REGIONS (<unidirectional association>)
	relation 15651511 --->
	  a role_name "CONTROL_MAX_REGIONS" init_value "
            new Key<int[]>(\"android.control.maxRegions\", int[].class)" class_relation const_relation public
	    comment "
<p>List of the maximum number of regions that can be used for metering in
auto-exposure (AE), auto-white balance (AWB), and auto-focus (AF);
this corresponds to the the maximum number of elements in
{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}, {@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions},
and {@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}.</p>
<p><b>Range of valid values:</b><br></p>
<p>Value must be &gt;= 0 for each element. For full-capability devices
this value must be &gt;= 1 for AE and AF. The order of the elements is:
<code>(AE, AWB, AF)</code>.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_REGIONS
@see CaptureRequest#CONTROL_AF_REGIONS
@see CaptureRequest#CONTROL_AWB_REGIONS
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    classrelation_ref 15651511 // CONTROL_MAX_REGIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15651639 // CONTROL_MAX_REGIONS_AE (<unidirectional association>)
	relation 15651639 --->
	  a role_name "CONTROL_MAX_REGIONS_AE" init_value "
            new Key<Integer>(\"android.control.maxRegionsAe\", int.class)" class_relation const_relation public
	    comment "
<p>The maximum number of metering regions that can be used by the auto-exposure (AE)
routine.</p>
<p>This corresponds to the the maximum allowed number of elements in
{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}.</p>
<p><b>Range of valid values:</b><br>
Value will be &gt;= 0. For FULL-capability devices, this
value will be &gt;= 1.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_REGIONS

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15651639 // CONTROL_MAX_REGIONS_AE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15651767 // CONTROL_MAX_REGIONS_AWB (<unidirectional association>)
	relation 15651767 --->
	  a role_name "CONTROL_MAX_REGIONS_AWB" init_value "
            new Key<Integer>(\"android.control.maxRegionsAwb\", int.class)" class_relation const_relation public
	    comment "
<p>The maximum number of metering regions that can be used by the auto-white balance (AWB)
routine.</p>
<p>This corresponds to the the maximum allowed number of elements in
{@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions}.</p>
<p><b>Range of valid values:</b><br>
Value will be &gt;= 0.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AWB_REGIONS

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15651767 // CONTROL_MAX_REGIONS_AWB (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15651895 // CONTROL_MAX_REGIONS_AF (<unidirectional association>)
	relation 15651895 --->
	  a role_name "CONTROL_MAX_REGIONS_AF" init_value "
            new Key<Integer>(\"android.control.maxRegionsAf\", int.class)" class_relation const_relation public
	    comment "
<p>The maximum number of metering regions that can be used by the auto-focus (AF) routine.</p>
<p>This corresponds to the the maximum allowed number of elements in
{@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}.</p>
<p><b>Range of valid values:</b><br>
Value will be &gt;= 0. For FULL-capability devices, this
value will be &gt;= 1.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AF_REGIONS

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15651895 // CONTROL_MAX_REGIONS_AF (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15652023 // CONTROL_AVAILABLE_HIGH_SPEED_VIDEO_CONFIGURATIONS (<unidirectional association>)
	relation 15652023 --->
	  a role_name "CONTROL_AVAILABLE_HIGH_SPEED_VIDEO_CONFIGURATIONS" init_value "
            new Key<android.hardware.camera2.params.HighSpeedVideoConfiguration[]>(\"android.control.availableHighSpeedVideoConfigurations\", android.hardware.camera2.params.HighSpeedVideoConfiguration[].class)" class_relation const_relation public
	    comment "
<p>List of available high speed video size, fps range and max batch size configurations
supported by the camera device, in the format of (width, height, fps_min, fps_max, batch_size_max).</p>
<p>When CONSTRAINED_HIGH_SPEED_VIDEO is supported in {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities},
this metadata will list the supported high speed video size, fps range and max batch size
configurations. All the sizes listed in this configuration will be a subset of the sizes
reported by {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes }
for processed non-stalling formats.</p>
<p>For the high speed video use case, the application must
select the video size and fps range from this metadata to configure the recording and
preview streams and setup the recording requests. For example, if the application intends
to do high speed recording, it can select the maximum size reported by this metadata to
configure output streams. Once the size is selected, application can filter this metadata
by selected size and get the supported fps ranges, and use these fps ranges to setup the
recording requests. Note that for the use case of multiple output streams, application
must select one unique size from this metadata to use (e.g., preview and recording streams
must have the same size). Otherwise, the high speed capture session creation will fail.</p>
<p>The min and max fps will be multiple times of 30fps.</p>
<p>High speed video streaming extends significant performance pressue to camera hardware,
to achieve efficient high speed streaming, the camera device may have to aggregate
multiple frames together and send to camera device for processing where the request
controls are same for all the frames in this batch. Max batch size indicates
the max possible number of frames the camera device will group together for this high
speed stream configuration. This max batch size will be used to generate a high speed
recording request list by
{@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList }.
The max batch size for each configuration will satisfy below conditions:</p>
<ul>
<li>Each max batch size will be a divisor of its corresponding fps_max / 30. For example,
if max_fps is 300, max batch size will only be 1, 2, 5, or 10.</li>
<li>The camera device may choose smaller internal batch size for each configuration, but
the actual batch size will be a divisor of max batch size. For example, if the max batch
size is 8, the actual batch size used by camera device will only be 1, 2, 4, or 8.</li>
<li>The max batch size in each configuration entry must be no larger than 32.</li>
</ul>
<p>The camera device doesn't have to support batch mode to achieve high speed video recording,
in such case, batch_size_max will be reported as 1 in each configuration entry.</p>
<p>This fps ranges in this configuration list can only be used to create requests
that are submitted to a high speed camera capture session created by
{@link android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession }.
The fps ranges reported in this metadata must not be used to setup capture requests for
normal capture session, or it will cause request error.</p>
<p><b>Range of valid values:</b><br></p>
<p>For each configuration, the fps_max &gt;= 120fps.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.HighSpeedVideoConfiguration[]> ${name}${value};
"
	    classrelation_ref 15652023 // CONTROL_AVAILABLE_HIGH_SPEED_VIDEO_CONFIGURATIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15652151 // CONTROL_AE_LOCK_AVAILABLE (<unidirectional association>)
	relation 15652151 --->
	  a role_name "CONTROL_AE_LOCK_AVAILABLE" init_value "
            new Key<Boolean>(\"android.control.aeLockAvailable\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether the camera device supports {@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock}</p>
<p>Devices with MANUAL_SENSOR capability or BURST_CAPTURE capability will always
list <code>true</code>. This includes FULL devices.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AE_LOCK

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15652151 // CONTROL_AE_LOCK_AVAILABLE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15652279 // CONTROL_AWB_LOCK_AVAILABLE (<unidirectional association>)
	relation 15652279 --->
	  a role_name "CONTROL_AWB_LOCK_AVAILABLE" init_value "
            new Key<Boolean>(\"android.control.awbLockAvailable\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether the camera device supports {@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock}</p>
<p>Devices with MANUAL_POST_PROCESSING capability or BURST_CAPTURE capability will
always list <code>true</code>. This includes FULL devices.</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_AWB_LOCK

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15652279 // CONTROL_AWB_LOCK_AVAILABLE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15652407 // CONTROL_AVAILABLE_MODES (<unidirectional association>)
	relation 15652407 --->
	  a role_name "CONTROL_AVAILABLE_MODES" init_value "
            new Key<int[]>(\"android.control.availableModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of control modes for {@link CaptureRequest#CONTROL_MODE android.control.mode} that are supported by this camera
device.</p>
<p>This list contains control modes that can be set for the camera device.
LEGACY mode devices will always support AUTO mode. LIMITED and FULL
devices will always support OFF, AUTO modes.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#CONTROL_MODE android.control.mode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#CONTROL_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15652407 // CONTROL_AVAILABLE_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15652535 // CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE (<unidirectional association>)
	relation 15652535 --->
	  a role_name "CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE" init_value "
            new Key<android.util.Range<Integer>>(\"android.control.postRawSensitivityBoostRange\", new TypeReference<android.util.Range<Integer>>() {{ }})" class_relation const_relation public
	    comment "
<p>Range of boosts for {@link CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST android.control.postRawSensitivityBoost} supported
by this camera device.</p>
<p>Devices support post RAW sensitivity boost  will advertise
{@link CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST android.control.postRawSensitivityBoost} key for controling
post RAW sensitivity boost.</p>
<p>This key will be <code>null</code> for devices that do not support any RAW format
outputs. For devices that do support RAW format outputs, this key will always
present, and if a device does not support post RAW sensitivity boost, it will
list <code>(100, 100)</code> in this key.</p>
<p><b>Units</b>: ISO arithmetic units, the same as {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Range<Integer>> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15652535 // CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15652663 // EDGE_AVAILABLE_EDGE_MODES (<unidirectional association>)
	relation 15652663 --->
	  a role_name "EDGE_AVAILABLE_EDGE_MODES" init_value "
            new Key<int[]>(\"android.edge.availableEdgeModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of edge enhancement modes for {@link CaptureRequest#EDGE_MODE android.edge.mode} that are supported by this camera
device.</p>
<p>Full-capability camera devices must always support OFF; camera devices that support
YUV_REPROCESSING or PRIVATE_REPROCESSING will list ZERO_SHUTTER_LAG; all devices will
list FAST.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#EDGE_MODE android.edge.mode}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CaptureRequest#EDGE_MODE
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15652663 // EDGE_AVAILABLE_EDGE_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15652791 // FLASH_INFO_AVAILABLE (<unidirectional association>)
	relation 15652791 --->
	  a role_name "FLASH_INFO_AVAILABLE" init_value "
            new Key<Boolean>(\"android.flash.info.available\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether this camera device has a
flash unit.</p>
<p>Will be <code>false</code> if no flash is available.</p>
<p>If there is no flash unit, none of the flash controls do
anything.
This key is available on all devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15652791 // FLASH_INFO_AVAILABLE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15652919 // HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES (<unidirectional association>)
	relation 15652919 --->
	  a role_name "HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES" init_value "
            new Key<int[]>(\"android.hotPixel.availableHotPixelModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of hot pixel correction modes for {@link CaptureRequest#HOT_PIXEL_MODE android.hotPixel.mode} that are supported by this
camera device.</p>
<p>FULL mode camera devices will always support FAST.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#HOT_PIXEL_MODE android.hotPixel.mode}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#HOT_PIXEL_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15652919 // HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15653047 // JPEG_AVAILABLE_THUMBNAIL_SIZES (<unidirectional association>)
	relation 15653047 --->
	  a role_name "JPEG_AVAILABLE_THUMBNAIL_SIZES" init_value "
            new Key<android.util.Size[]>(\"android.jpeg.availableThumbnailSizes\", android.util.Size[].class)" class_relation const_relation public
	    comment "
<p>List of JPEG thumbnail sizes for {@link CaptureRequest#JPEG_THUMBNAIL_SIZE android.jpeg.thumbnailSize} supported by this
camera device.</p>
<p>This list will include at least one non-zero resolution, plus <code>(0,0)</code> for indicating no
thumbnail should be generated.</p>
<p>Below condiditions will be satisfied for this size list:</p>
<ul>
<li>The sizes will be sorted by increasing pixel area (width x height).
If several resolutions have the same area, they will be sorted by increasing width.</li>
<li>The aspect ratio of the largest thumbnail size will be same as the
aspect ratio of largest JPEG output size in android.scaler.availableStreamConfigurations.
The largest size is defined as the size that has the largest pixel area
in a given size list.</li>
<li>Each output JPEG size in android.scaler.availableStreamConfigurations will have at least
one corresponding size that has the same aspect ratio in availableThumbnailSizes,
and vice versa.</li>
<li>All non-<code>(0, 0)</code> sizes will have non-zero widths and heights.
This key is available on all devices.</li>
</ul>

@see CaptureRequest#JPEG_THUMBNAIL_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Size[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15653047 // JPEG_AVAILABLE_THUMBNAIL_SIZES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15653175 // LENS_INFO_AVAILABLE_APERTURES (<unidirectional association>)
	relation 15653175 --->
	  a role_name "LENS_INFO_AVAILABLE_APERTURES" init_value "
            new Key<float[]>(\"android.lens.info.availableApertures\", float[].class)" class_relation const_relation public
	    comment "
<p>List of aperture size values for {@link CaptureRequest#LENS_APERTURE android.lens.aperture} that are
supported by this camera device.</p>
<p>If the camera device doesn't support a variable lens aperture,
this list will contain only one value, which is the fixed aperture size.</p>
<p>If the camera device supports a variable aperture, the aperture values
in this list will be sorted in ascending order.</p>
<p><b>Units</b>: The aperture f-number</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#LENS_APERTURE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15653175 // LENS_INFO_AVAILABLE_APERTURES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15653303 // LENS_INFO_AVAILABLE_FILTER_DENSITIES (<unidirectional association>)
	relation 15653303 --->
	  a role_name "LENS_INFO_AVAILABLE_FILTER_DENSITIES" init_value "
            new Key<float[]>(\"android.lens.info.availableFilterDensities\", float[].class)" class_relation const_relation public
	    comment "
<p>List of neutral density filter values for
{@link CaptureRequest#LENS_FILTER_DENSITY android.lens.filterDensity} that are supported by this camera device.</p>
<p>If a neutral density filter is not supported by this camera device,
this list will contain only 0. Otherwise, this list will include every
filter density supported by the camera device, in ascending order.</p>
<p><b>Units</b>: Exposure value (EV)</p>
<p><b>Range of valid values:</b><br></p>
<p>Values are &gt;= 0</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#LENS_FILTER_DENSITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15653303 // LENS_INFO_AVAILABLE_FILTER_DENSITIES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15653431 // LENS_INFO_AVAILABLE_FOCAL_LENGTHS (<unidirectional association>)
	relation 15653431 --->
	  a role_name "LENS_INFO_AVAILABLE_FOCAL_LENGTHS" init_value "
            new Key<float[]>(\"android.lens.info.availableFocalLengths\", float[].class)" class_relation const_relation public
	    comment "
<p>List of focal lengths for {@link CaptureRequest#LENS_FOCAL_LENGTH android.lens.focalLength} that are supported by this camera
device.</p>
<p>If optical zoom is not supported, this list will only contain
a single value corresponding to the fixed focal length of the
device. Otherwise, this list will include every focal length supported
by the camera device, in ascending order.</p>
<p><b>Units</b>: Millimeters</p>
<p><b>Range of valid values:</b><br></p>
<p>Values are &gt; 0</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#LENS_FOCAL_LENGTH

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15653431 // LENS_INFO_AVAILABLE_FOCAL_LENGTHS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15653559 // LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION (<unidirectional association>)
	relation 15653559 --->
	  a role_name "LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION" init_value "
            new Key<int[]>(\"android.lens.info.availableOpticalStabilization\", int[].class)" class_relation const_relation public
	    comment "
<p>List of optical image stabilization (OIS) modes for
{@link CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode} that are supported by this camera device.</p>
<p>If OIS is not supported by a given camera device, this list will
contain only OFF.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15653559 // LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15653687 // LENS_INFO_HYPERFOCAL_DISTANCE (<unidirectional association>)
	relation 15653687 --->
	  a role_name "LENS_INFO_HYPERFOCAL_DISTANCE" init_value "
            new Key<Float>(\"android.lens.info.hyperfocalDistance\", float.class)" class_relation const_relation public
	    comment "
<p>Hyperfocal distance for this lens.</p>
<p>If the lens is not fixed focus, the camera device will report this
field when {@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration} is APPROXIMATE or CALIBRATED.</p>
<p><b>Units</b>: See {@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration} for details</p>
<p><b>Range of valid values:</b><br>
If lens is fixed focus, &gt;= 0. If lens has focuser unit, the value is
within <code>(0.0f, {@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance}]</code></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION
@see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15653687 // LENS_INFO_HYPERFOCAL_DISTANCE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15653815 // LENS_INFO_MINIMUM_FOCUS_DISTANCE (<unidirectional association>)
	relation 15653815 --->
	  a role_name "LENS_INFO_MINIMUM_FOCUS_DISTANCE" init_value "
            new Key<Float>(\"android.lens.info.minimumFocusDistance\", float.class)" class_relation const_relation public
	    comment "
<p>Shortest distance from frontmost surface
of the lens that can be brought into sharp focus.</p>
<p>If the lens is fixed-focus, this will be
0.</p>
<p><b>Units</b>: See {@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration} for details</p>
<p><b>Range of valid values:</b><br>
&gt;= 0</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15653815 // LENS_INFO_MINIMUM_FOCUS_DISTANCE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15653943 // LENS_INFO_SHADING_MAP_SIZE (<unidirectional association>)
	relation 15653943 --->
	  a role_name "LENS_INFO_SHADING_MAP_SIZE" init_value "
            new Key<android.util.Size>(\"android.lens.info.shadingMapSize\", android.util.Size.class)" class_relation const_relation public
	    comment "
<p>Dimensions of lens shading map.</p>
<p>The map should be on the order of 30-40 rows and columns, and
must be smaller than 64x64.</p>
<p><b>Range of valid values:</b><br>
Both values &gt;= 1</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Size> ${name}${value};
"
	    classrelation_ref 15653943 // LENS_INFO_SHADING_MAP_SIZE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15654071 // LENS_INFO_FOCUS_DISTANCE_CALIBRATION (<unidirectional association>)
	relation 15654071 --->
	  a role_name "LENS_INFO_FOCUS_DISTANCE_CALIBRATION" init_value "
            new Key<Integer>(\"android.lens.info.focusDistanceCalibration\", int.class)" class_relation const_relation public
	    comment "
<p>The lens focus distance calibration quality.</p>
<p>The lens focus distance calibration quality determines the reliability of
focus related metadata entries, i.e. {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance},
{@link CaptureResult#LENS_FOCUS_RANGE android.lens.focusRange}, {@link CameraCharacteristics#LENS_INFO_HYPERFOCAL_DISTANCE android.lens.info.hyperfocalDistance}, and
{@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance}.</p>
<p>APPROXIMATE and CALIBRATED devices report the focus metadata in
units of diopters (1/meter), so <code>0.0f</code> represents focusing at infinity,
and increasing positive numbers represent focusing closer and closer
to the camera device. The focus distance control also uses diopters
on these devices.</p>
<p>UNCALIBRATED devices do not use units that are directly comparable
to any real physical measurement, but <code>0.0f</code> still represents farthest
focus, and {@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance} represents the
nearest focus the device can achieve.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED UNCALIBRATED}</li>
  <li>{@link #LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE APPROXIMATE}</li>
  <li>{@link #LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED CALIBRATED}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#LENS_FOCUS_DISTANCE
@see CaptureResult#LENS_FOCUS_RANGE
@see CameraCharacteristics#LENS_INFO_HYPERFOCAL_DISTANCE
@see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE
@see #LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED
@see #LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE
@see #LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15654071 // LENS_INFO_FOCUS_DISTANCE_CALIBRATION (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15654199 // LENS_FACING (<unidirectional association>)
	relation 15654199 --->
	  a role_name "LENS_FACING" init_value "
            new Key<Integer>(\"android.lens.facing\", int.class)" class_relation const_relation public
	    comment "
<p>Direction the camera faces relative to
device screen.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #LENS_FACING_FRONT FRONT}</li>
  <li>{@link #LENS_FACING_BACK BACK}</li>
  <li>{@link #LENS_FACING_EXTERNAL EXTERNAL}</li>
</ul></p>
<p>This key is available on all devices.</p>
@see #LENS_FACING_FRONT
@see #LENS_FACING_BACK
@see #LENS_FACING_EXTERNAL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15654199 // LENS_FACING (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15654327 // LENS_POSE_ROTATION (<unidirectional association>)
	relation 15654327 --->
	  a role_name "LENS_POSE_ROTATION" init_value "
            new Key<float[]>(\"android.lens.poseRotation\", float[].class)" class_relation const_relation public
	    comment "
<p>The orientation of the camera relative to the sensor
coordinate system.</p>
<p>The four coefficients that describe the quaternion
rotation from the Android sensor coordinate system to a
camera-aligned coordinate system where the X-axis is
aligned with the long side of the image sensor, the Y-axis
is aligned with the short side of the image sensor, and
the Z-axis is aligned with the optical axis of the sensor.</p>
<p>To convert from the quaternion coefficients <code>(x,y,z,w)</code>
to the axis of rotation <code>(a_x, a_y, a_z)</code> and rotation
amount <code>theta</code>, the following formulas can be used:</p>
<pre><code> theta = 2 * acos(w)
a_x = x / sin(theta/2)
a_y = y / sin(theta/2)
a_z = z / sin(theta/2)
</code></pre>
<p>To create a 3x3 rotation matrix that applies the rotation
defined by this quaternion, the following matrix can be
used:</p>
<pre><code>R = [ 1 - 2y^2 - 2z^2,       2xy - 2zw,       2xz + 2yw,
           2xy + 2zw, 1 - 2x^2 - 2z^2,       2yz - 2xw,
           2xz - 2yw,       2yz + 2xw, 1 - 2x^2 - 2y^2 ]
</code></pre>
<p>This matrix can then be used to apply the rotation to a
 column vector point with</p>
<p><code>p' = Rp</code></p>
<p>where <code>p</code> is in the device sensor coordinate system, and
 <code>p'</code> is in the camera-oriented coordinate system.</p>
<p><b>Units</b>:
Quaternion coefficients</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15654327 // LENS_POSE_ROTATION (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15654455 // LENS_POSE_TRANSLATION (<unidirectional association>)
	relation 15654455 --->
	  a role_name "LENS_POSE_TRANSLATION" init_value "
            new Key<float[]>(\"android.lens.poseTranslation\", float[].class)" class_relation const_relation public
	    comment "
<p>Position of the camera optical center.</p>
<p>The position of the camera device's lens optical center,
as a three-dimensional vector <code>(x,y,z)</code>, relative to the
optical center of the largest camera device facing in the
same direction as this camera, in the {@link android.hardware.SensorEvent Android sensor coordinate
axes}. Note that only the axis definitions are shared with
the sensor coordinate system, but not the origin.</p>
<p>If this device is the largest or only camera device with a
given facing, then this position will be <code>(0, 0, 0)</code>; a
camera device with a lens optical center located 3 cm from
the main sensor along the +X axis (to the right from the
user's perspective) will report <code>(0.03, 0, 0)</code>.</p>
<p>To transform a pixel coordinates between two cameras
facing the same direction, first the source camera
{@link CameraCharacteristics#LENS_RADIAL_DISTORTION android.lens.radialDistortion} must be corrected for.  Then
the source camera {@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration} needs
to be applied, followed by the {@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation}
of the source camera, the translation of the source camera
relative to the destination camera, the
{@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} of the destination camera, and
finally the inverse of {@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration}
of the destination camera. This obtains a
radial-distortion-free coordinate in the destination
camera pixel coordinates.</p>
<p>To compare this against a real image from the destination
camera, the destination camera image then needs to be
corrected for radial distortion before comparison or
sampling.</p>
<p><b>Units</b>: Meters</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#LENS_INTRINSIC_CALIBRATION
@see CameraCharacteristics#LENS_POSE_ROTATION
@see CameraCharacteristics#LENS_RADIAL_DISTORTION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15654455 // LENS_POSE_TRANSLATION (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15654583 // LENS_INTRINSIC_CALIBRATION (<unidirectional association>)
	relation 15654583 --->
	  a role_name "LENS_INTRINSIC_CALIBRATION" init_value "
            new Key<float[]>(\"android.lens.intrinsicCalibration\", float[].class)" class_relation const_relation public
	    comment "
<p>The parameters for this camera device's intrinsic
calibration.</p>
<p>The five calibration parameters that describe the
transform from camera-centric 3D coordinates to sensor
pixel coordinates:</p>
<pre><code>[f_x, f_y, c_x, c_y, s]
</code></pre>
<p>Where <code>f_x</code> and <code>f_y</code> are the horizontal and vertical
focal lengths, <code>[c_x, c_y]</code> is the position of the optical
axis, and <code>s</code> is a skew parameter for the sensor plane not
being aligned with the lens plane.</p>
<p>These are typically used within a transformation matrix K:</p>
<pre><code>K = [ f_x,   s, c_x,
       0, f_y, c_y,
       0    0,   1 ]
</code></pre>
<p>which can then be combined with the camera pose rotation
<code>R</code> and translation <code>t</code> ({@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} and
{@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}, respective) to calculate the
complete transform from world coordinates to pixel
coordinates:</p>
<pre><code>P = [ K 0   * [ R t
     0 1 ]     0 1 ]
</code></pre>
<p>and with <code>p_w</code> being a point in the world coordinate system
and <code>p_s</code> being a point in the camera active pixel array
coordinate system, and with the mapping including the
homogeneous division by z:</p>
<pre><code> p_h = (x_h, y_h, z_h) = P p_w
p_s = p_h / z_h
</code></pre>
<p>so <code>[x_s, y_s]</code> is the pixel coordinates of the world
point, <code>z_s = 1</code>, and <code>w_s</code> is a measurement of disparity
(depth) in pixel coordinates.</p>
<p>Note that the coordinate system for this transform is the
{@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} system,
where <code>(0,0)</code> is the top-left of the
preCorrectionActiveArraySize rectangle. Once the pose and
intrinsic calibration transforms have been applied to a
world point, then the {@link CameraCharacteristics#LENS_RADIAL_DISTORTION android.lens.radialDistortion}
transform needs to be applied, and the result adjusted to
be in the {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} coordinate
system (where <code>(0, 0)</code> is the top-left of the
activeArraySize rectangle), to determine the final pixel
coordinate of the world point for processed (non-RAW)
output buffers.</p>
<p><b>Units</b>:
Pixels in the
{@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}
coordinate system.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#LENS_POSE_ROTATION
@see CameraCharacteristics#LENS_POSE_TRANSLATION
@see CameraCharacteristics#LENS_RADIAL_DISTORTION
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE
@see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15654583 // LENS_INTRINSIC_CALIBRATION (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15654711 // LENS_RADIAL_DISTORTION (<unidirectional association>)
	relation 15654711 --->
	  a role_name "LENS_RADIAL_DISTORTION" init_value "
            new Key<float[]>(\"android.lens.radialDistortion\", float[].class)" class_relation const_relation public
	    comment "
<p>The correction coefficients to correct for this camera device's
radial and tangential lens distortion.</p>
<p>Four radial distortion coefficients <code>[kappa_0, kappa_1, kappa_2,
kappa_3]</code> and two tangential distortion coefficients
<code>[kappa_4, kappa_5]</code> that can be used to correct the
lens's geometric distortion with the mapping equations:</p>
<pre><code> x_c = x_i * ( kappa_0 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +
       kappa_4 * (2 * x_i * y_i) + kappa_5 * ( r^2 + 2 * x_i^2 )
 y_c = y_i * ( kappa_0 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +
       kappa_5 * (2 * x_i * y_i) + kappa_4 * ( r^2 + 2 * y_i^2 )
</code></pre>
<p>Here, <code>[x_c, y_c]</code> are the coordinates to sample in the
input image that correspond to the pixel values in the
corrected image at the coordinate <code>[x_i, y_i]</code>:</p>
<pre><code> correctedImage(x_i, y_i) = sample_at(x_c, y_c, inputImage)
</code></pre>
<p>The pixel coordinates are defined in a normalized
coordinate system related to the
{@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration} calibration fields.
Both <code>[x_i, y_i]</code> and <code>[x_c, y_c]</code> have <code>(0,0)</code> at the
lens optical center <code>[c_x, c_y]</code>. The maximum magnitudes
of both x and y coordinates are normalized to be 1 at the
edge further from the optical center, so the range
for both dimensions is <code>-1 &lt;= x &lt;= 1</code>.</p>
<p>Finally, <code>r</code> represents the radial distance from the
optical center, <code>r^2 = x_i^2 + y_i^2</code>, and its magnitude
is therefore no larger than <code>|r| &lt;= sqrt(2)</code>.</p>
<p>The distortion model used is the Brown-Conrady model.</p>
<p><b>Units</b>:
Unitless coefficients.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#LENS_INTRINSIC_CALIBRATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<float[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15654711 // LENS_RADIAL_DISTORTION (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15654839 // NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES (<unidirectional association>)
	relation 15654839 --->
	  a role_name "NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES" init_value "
            new Key<int[]>(\"android.noiseReduction.availableNoiseReductionModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of noise reduction modes for {@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode} that are supported
by this camera device.</p>
<p>Full-capability camera devices will always support OFF and FAST.</p>
<p>Camera devices that support YUV_REPROCESSING or PRIVATE_REPROCESSING will support
ZERO_SHUTTER_LAG.</p>
<p>Legacy-capability camera devices will only support FAST mode.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#NOISE_REDUCTION_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15654839 // NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15654967 // QUIRKS_USE_PARTIAL_RESULT (<unidirectional association>)
	relation 15654967 --->
	  a role_name "QUIRKS_USE_PARTIAL_RESULT" init_value "
            new Key<Byte>(\"android.quirks.usePartialResult\", byte.class)" class_relation const_relation public
	    comment "
<p>If set to 1, the HAL will always split result
metadata for a single capture into multiple buffers,
returned using multiple process_capture_result calls.</p>
<p>Does not need to be listed in static
metadata. Support for partial results will be reworked in
future versions of camera service. This quirk will stop
working at that point; DO NOT USE without careful
consideration of future support.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@deprecated
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Byte> ${name}${value};
"
	    java_annotation "@Deprecated
"
	    classrelation_ref 15654967 // QUIRKS_USE_PARTIAL_RESULT (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15655095 // REQUEST_MAX_NUM_OUTPUT_STREAMS (<unidirectional association>)
	relation 15655095 --->
	  a role_name "REQUEST_MAX_NUM_OUTPUT_STREAMS" init_value "
            new Key<int[]>(\"android.request.maxNumOutputStreams\", int[].class)" class_relation const_relation public
	    comment "
<p>The maximum numbers of different types of output streams
that can be configured and used simultaneously by a camera device.</p>
<p>This is a 3 element tuple that contains the max number of output simultaneous
streams for raw sensor, processed (but not stalling), and processed (and stalling)
formats respectively. For example, assuming that JPEG is typically a processed and
stalling stream, if max raw sensor format output stream number is 1, max YUV streams
number is 3, and max JPEG stream number is 2, then this tuple should be <code>(1, 3, 2)</code>.</p>
<p>This lists the upper bound of the number of output streams supported by
the camera device. Using more streams simultaneously may require more hardware and
CPU resources that will consume more power. The image format for an output stream can
be any supported format provided by android.scaler.availableStreamConfigurations.
The formats defined in android.scaler.availableStreamConfigurations can be catergorized
into the 3 stream types as below:</p>
<ul>
<li>Processed (but stalling): any non-RAW format with a stallDurations &gt; 0.
  Typically {@link android.graphics.ImageFormat#JPEG JPEG format}.</li>
<li>Raw formats: {@link android.graphics.ImageFormat#RAW_SENSOR RAW_SENSOR}, {@link android.graphics.ImageFormat#RAW10 RAW10}, or {@link android.graphics.ImageFormat#RAW12 RAW12}.</li>
<li>Processed (but not-stalling): any non-RAW format without a stall duration.
  Typically {@link android.graphics.ImageFormat#YUV_420_888 YUV_420_888},
  {@link android.graphics.ImageFormat#NV21 NV21}, or
  {@link android.graphics.ImageFormat#YV12 YV12}.</li>
</ul>
<p><b>Range of valid values:</b><br></p>
<p>For processed (and stalling) format streams, &gt;= 1.</p>
<p>For Raw format (either stalling or non-stalling) streams, &gt;= 0.</p>
<p>For processed (but not stalling) format streams, &gt;= 3
for FULL mode devices (<code>{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} == FULL</code>);
&gt;= 2 for LIMITED mode devices (<code>{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} == LIMITED</code>).</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    classrelation_ref 15655095 // REQUEST_MAX_NUM_OUTPUT_STREAMS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15655223 // REQUEST_MAX_NUM_OUTPUT_RAW (<unidirectional association>)
	relation 15655223 --->
	  a role_name "REQUEST_MAX_NUM_OUTPUT_RAW" init_value "
            new Key<Integer>(\"android.request.maxNumOutputRaw\", int.class)" class_relation const_relation public
	    comment "
<p>The maximum numbers of different types of output streams
that can be configured and used simultaneously by a camera device
for any <code>RAW</code> formats.</p>
<p>This value contains the max number of output simultaneous
streams from the raw sensor.</p>
<p>This lists the upper bound of the number of output streams supported by
the camera device. Using more streams simultaneously may require more hardware and
CPU resources that will consume more power. The image format for this kind of an output stream can
be any <code>RAW</code> and supported format provided by {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap}.</p>
<p>In particular, a <code>RAW</code> format is typically one of:</p>
<ul>
<li>{@link android.graphics.ImageFormat#RAW_SENSOR RAW_SENSOR}</li>
<li>{@link android.graphics.ImageFormat#RAW10 RAW10}</li>
<li>{@link android.graphics.ImageFormat#RAW12 RAW12}</li>
</ul>
<p>LEGACY mode devices ({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} <code>==</code> LEGACY)
never support raw streams.</p>
<p><b>Range of valid values:</b><br></p>
<p>&gt;= 0</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15655223 // REQUEST_MAX_NUM_OUTPUT_RAW (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15655351 // REQUEST_MAX_NUM_OUTPUT_PROC (<unidirectional association>)
	relation 15655351 --->
	  a role_name "REQUEST_MAX_NUM_OUTPUT_PROC" init_value "
            new Key<Integer>(\"android.request.maxNumOutputProc\", int.class)" class_relation const_relation public
	    comment "
<p>The maximum numbers of different types of output streams
that can be configured and used simultaneously by a camera device
for any processed (but not-stalling) formats.</p>
<p>This value contains the max number of output simultaneous
streams for any processed (but not-stalling) formats.</p>
<p>This lists the upper bound of the number of output streams supported by
the camera device. Using more streams simultaneously may require more hardware and
CPU resources that will consume more power. The image format for this kind of an output stream can
be any non-<code>RAW</code> and supported format provided by {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap}.</p>
<p>Processed (but not-stalling) is defined as any non-RAW format without a stall duration.
Typically:</p>
<ul>
<li>{@link android.graphics.ImageFormat#YUV_420_888 YUV_420_888}</li>
<li>{@link android.graphics.ImageFormat#NV21 NV21}</li>
<li>{@link android.graphics.ImageFormat#YV12 YV12}</li>
<li>Implementation-defined formats, i.e. {@link android.hardware.camera2.params.StreamConfigurationMap#isOutputSupportedFor(Class) }</li>
</ul>
<p>For full guarantees, query {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration } with a
processed format -- it will return 0 for a non-stalling stream.</p>
<p>LEGACY devices will support at least 2 processing/non-stalling streams.</p>
<p><b>Range of valid values:</b><br></p>
<p>&gt;= 3
for FULL mode devices (<code>{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} == FULL</code>);
&gt;= 2 for LIMITED mode devices (<code>{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} == LIMITED</code>).</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15655351 // REQUEST_MAX_NUM_OUTPUT_PROC (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15655479 // REQUEST_MAX_NUM_OUTPUT_PROC_STALLING (<unidirectional association>)
	relation 15655479 --->
	  a role_name "REQUEST_MAX_NUM_OUTPUT_PROC_STALLING" init_value "
            new Key<Integer>(\"android.request.maxNumOutputProcStalling\", int.class)" class_relation const_relation public
	    comment "
<p>The maximum numbers of different types of output streams
that can be configured and used simultaneously by a camera device
for any processed (and stalling) formats.</p>
<p>This value contains the max number of output simultaneous
streams for any processed (but not-stalling) formats.</p>
<p>This lists the upper bound of the number of output streams supported by
the camera device. Using more streams simultaneously may require more hardware and
CPU resources that will consume more power. The image format for this kind of an output stream can
be any non-<code>RAW</code> and supported format provided by {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap}.</p>
<p>A processed and stalling format is defined as any non-RAW format with a stallDurations
&gt; 0.  Typically only the {@link android.graphics.ImageFormat#JPEG JPEG format} is a
stalling format.</p>
<p>For full guarantees, query {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration } with a
processed format -- it will return a non-0 value for a stalling stream.</p>
<p>LEGACY devices will support up to 1 processing/stalling stream.</p>
<p><b>Range of valid values:</b><br></p>
<p>&gt;= 1</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15655479 // REQUEST_MAX_NUM_OUTPUT_PROC_STALLING (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15655607 // REQUEST_MAX_NUM_INPUT_STREAMS (<unidirectional association>)
	relation 15655607 --->
	  a role_name "REQUEST_MAX_NUM_INPUT_STREAMS" init_value "
            new Key<Integer>(\"android.request.maxNumInputStreams\", int.class)" class_relation const_relation public
	    comment "
<p>The maximum numbers of any type of input streams
that can be configured and used simultaneously by a camera device.</p>
<p>When set to 0, it means no input stream is supported.</p>
<p>The image format for a input stream can be any supported format returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats }. When using an
input stream, there must be at least one output stream configured to to receive the
reprocessed images.</p>
<p>When an input stream and some output streams are used in a reprocessing request,
only the input buffer will be used to produce these output stream buffers, and a
new sensor image will not be captured.</p>
<p>For example, for Zero Shutter Lag (ZSL) still capture use case, the input
stream image format will be PRIVATE, the associated output stream image format
should be JPEG.</p>
<p><b>Range of valid values:</b><br></p>
<p>0 or 1.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15655607 // REQUEST_MAX_NUM_INPUT_STREAMS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15655735 // REQUEST_PIPELINE_MAX_DEPTH (<unidirectional association>)
	relation 15655735 --->
	  a role_name "REQUEST_PIPELINE_MAX_DEPTH" init_value "
            new Key<Byte>(\"android.request.pipelineMaxDepth\", byte.class)" class_relation const_relation public
	    comment "
<p>Specifies the number of maximum pipeline stages a frame
has to go through from when it's exposed to when it's available
to the framework.</p>
<p>A typical minimum value for this is 2 (one stage to expose,
one stage to readout) from the sensor. The ISP then usually adds
its own stages to do custom HW processing. Further stages may be
added by SW processing.</p>
<p>Depending on what settings are used (e.g. YUV, JPEG) and what
processing is enabled (e.g. face detection), the actual pipeline
depth (specified by {@link CaptureResult#REQUEST_PIPELINE_DEPTH android.request.pipelineDepth}) may be less than
the max pipeline depth.</p>
<p>A pipeline depth of X stages is equivalent to a pipeline latency of
X frame intervals.</p>
<p>This value will normally be 8 or less, however, for high speed capture session,
the max pipeline depth will be up to 8 x size of high speed capture request list.</p>
<p>This key is available on all devices.</p>

@see CaptureResult#REQUEST_PIPELINE_DEPTH

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Byte> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15655735 // REQUEST_PIPELINE_MAX_DEPTH (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15655863 // REQUEST_PARTIAL_RESULT_COUNT (<unidirectional association>)
	relation 15655863 --->
	  a role_name "REQUEST_PARTIAL_RESULT_COUNT" init_value "
            new Key<Integer>(\"android.request.partialResultCount\", int.class)" class_relation const_relation public
	    comment "
<p>Defines how many sub-components
a result will be composed of.</p>
<p>In order to combat the pipeline latency, partial results
may be delivered to the application layer from the camera device as
soon as they are available.</p>
<p>Optional; defaults to 1. A value of 1 means that partial
results are not supported, and only the final TotalCaptureResult will
be produced by the camera device.</p>
<p>A typical use case for this might be: after requesting an
auto-focus (AF) lock the new AF state might be available 50%
of the way through the pipeline.  The camera device could
then immediately dispatch this state via a partial result to
the application, and the rest of the metadata via later
partial results.</p>
<p><b>Range of valid values:</b><br>
&gt;= 1</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15655863 // REQUEST_PARTIAL_RESULT_COUNT (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15655991 // REQUEST_AVAILABLE_CAPABILITIES (<unidirectional association>)
	relation 15655991 --->
	  a role_name "REQUEST_AVAILABLE_CAPABILITIES" init_value "
            new Key<int[]>(\"android.request.availableCapabilities\", int[].class)" class_relation const_relation public
	    comment "
<p>List of capabilities that this camera device
advertises as fully supporting.</p>
<p>A capability is a contract that the camera device makes in order
to be able to satisfy one or more use cases.</p>
<p>Listing a capability guarantees that the whole set of features
required to support a common use will all be available.</p>
<p>Using a subset of the functionality provided by an unsupported
capability may be possible on a specific camera device implementation;
to do this query each of android.request.availableRequestKeys,
android.request.availableResultKeys,
android.request.availableCharacteristicsKeys.</p>
<p>The following capabilities are guaranteed to be available on
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} <code>==</code> FULL devices:</p>
<ul>
<li>MANUAL_SENSOR</li>
<li>MANUAL_POST_PROCESSING</li>
</ul>
<p>Other capabilities may be available on either FULL or LIMITED
devices, but the application should query this key to be sure.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE BACKWARD_COMPATIBLE}</li>
  <li>{@link #REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR MANUAL_SENSOR}</li>
  <li>{@link #REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING MANUAL_POST_PROCESSING}</li>
  <li>{@link #REQUEST_AVAILABLE_CAPABILITIES_RAW RAW}</li>
  <li>{@link #REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING PRIVATE_REPROCESSING}</li>
  <li>{@link #REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS READ_SENSOR_SETTINGS}</li>
  <li>{@link #REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE BURST_CAPTURE}</li>
  <li>{@link #REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING YUV_REPROCESSING}</li>
  <li>{@link #REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT DEPTH_OUTPUT}</li>
  <li>{@link #REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO CONSTRAINED_HIGH_SPEED_VIDEO}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see #REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE
@see #REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR
@see #REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING
@see #REQUEST_AVAILABLE_CAPABILITIES_RAW
@see #REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING
@see #REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS
@see #REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE
@see #REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING
@see #REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT
@see #REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15655991 // REQUEST_AVAILABLE_CAPABILITIES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15656119 // REQUEST_AVAILABLE_REQUEST_KEYS (<unidirectional association>)
	relation 15656119 --->
	  a role_name "REQUEST_AVAILABLE_REQUEST_KEYS" init_value "
            new Key<int[]>(\"android.request.availableRequestKeys\", int[].class)" class_relation const_relation public
	    comment "
<p>A list of all keys that the camera device has available
to use with {@link android.hardware.camera2.CaptureRequest }.</p>
<p>Attempting to set a key into a CaptureRequest that is not
listed here will result in an invalid request and will be rejected
by the camera device.</p>
<p>This field can be used to query the feature set of a camera device
at a more granular level than capabilities. This is especially
important for optional keys that are not listed under any capability
in {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities}.</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    classrelation_ref 15656119 // REQUEST_AVAILABLE_REQUEST_KEYS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15656247 // REQUEST_AVAILABLE_RESULT_KEYS (<unidirectional association>)
	relation 15656247 --->
	  a role_name "REQUEST_AVAILABLE_RESULT_KEYS" init_value "
            new Key<int[]>(\"android.request.availableResultKeys\", int[].class)" class_relation const_relation public
	    comment "
<p>A list of all keys that the camera device has available
to use with {@link android.hardware.camera2.CaptureResult }.</p>
<p>Attempting to get a key from a CaptureResult that is not
listed here will always return a <code>null</code> value. Getting a key from
a CaptureResult that is listed here will generally never return a <code>null</code>
value.</p>
<p>The following keys may return <code>null</code> unless they are enabled:</p>
<ul>
<li>android.statistics.lensShadingMap (non-null iff {@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode} == ON)</li>
</ul>
<p>(Those sometimes-null keys will nevertheless be listed here
if they are available.)</p>
<p>This field can be used to query the feature set of a camera device
at a more granular level than capabilities. This is especially
important for optional keys that are not listed under any capability
in {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities}.</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    classrelation_ref 15656247 // REQUEST_AVAILABLE_RESULT_KEYS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15656375 // REQUEST_AVAILABLE_CHARACTERISTICS_KEYS (<unidirectional association>)
	relation 15656375 --->
	  a role_name "REQUEST_AVAILABLE_CHARACTERISTICS_KEYS" init_value "
            new Key<int[]>(\"android.request.availableCharacteristicsKeys\", int[].class)" class_relation const_relation public
	    comment "
<p>A list of all keys that the camera device has available
to use with {@link android.hardware.camera2.CameraCharacteristics }.</p>
<p>This entry follows the same rules as
android.request.availableResultKeys (except that it applies for
CameraCharacteristics instead of CaptureResult). See above for more
details.</p>
<p>This key is available on all devices.</p>
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    classrelation_ref 15656375 // REQUEST_AVAILABLE_CHARACTERISTICS_KEYS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15656503 // SCALER_AVAILABLE_FORMATS (<unidirectional association>)
	relation 15656503 --->
	  a role_name "SCALER_AVAILABLE_FORMATS" init_value "
            new Key<int[]>(\"android.scaler.availableFormats\", int[].class)" class_relation const_relation public
	    comment "
<p>The list of image formats that are supported by this
camera device for output streams.</p>
<p>All camera devices will support JPEG and YUV_420_888 formats.</p>
<p>When set to YUV_420_888, application can access the YUV420 data directly.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@deprecated
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@Deprecated
"
	    classrelation_ref 15656503 // SCALER_AVAILABLE_FORMATS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15656631 // SCALER_AVAILABLE_JPEG_MIN_DURATIONS (<unidirectional association>)
	relation 15656631 --->
	  a role_name "SCALER_AVAILABLE_JPEG_MIN_DURATIONS" init_value "
            new Key<long[]>(\"android.scaler.availableJpegMinDurations\", long[].class)" class_relation const_relation public
	    comment "
<p>The minimum frame duration that is supported
for each resolution in android.scaler.availableJpegSizes.</p>
<p>This corresponds to the minimum steady-state frame duration when only
that JPEG stream is active and captured in a burst, with all
processing (typically in android.*.mode) set to FAST.</p>
<p>When multiple streams are configured, the minimum
frame duration will be &gt;= max(individual stream min
durations)</p>
<p><b>Units</b>: Nanoseconds</p>
<p><b>Range of valid values:</b><br>
TODO: Remove property.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@deprecated
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<long[]> ${name}${value};
"
	    java_annotation "@Deprecated
"
	    classrelation_ref 15656631 // SCALER_AVAILABLE_JPEG_MIN_DURATIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15656759 // SCALER_AVAILABLE_JPEG_SIZES (<unidirectional association>)
	relation 15656759 --->
	  a role_name "SCALER_AVAILABLE_JPEG_SIZES" init_value "
            new Key<android.util.Size[]>(\"android.scaler.availableJpegSizes\", android.util.Size[].class)" class_relation const_relation public
	    comment "
<p>The JPEG resolutions that are supported by this camera device.</p>
<p>The resolutions are listed as <code>(width, height)</code> pairs. All camera devices will support
sensor maximum resolution (defined by {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}).</p>
<p><b>Range of valid values:</b><br>
TODO: Remove property.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE
@deprecated
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Size[]> ${name}${value};
"
	    java_annotation "@Deprecated
"
	    classrelation_ref 15656759 // SCALER_AVAILABLE_JPEG_SIZES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15656887 // SCALER_AVAILABLE_MAX_DIGITAL_ZOOM (<unidirectional association>)
	relation 15656887 --->
	  a role_name "SCALER_AVAILABLE_MAX_DIGITAL_ZOOM" init_value "
            new Key<Float>(\"android.scaler.availableMaxDigitalZoom\", float.class)" class_relation const_relation public
	    comment "
<p>The maximum ratio between both active area width
and crop region width, and active area height and
crop region height, for {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}.</p>
<p>This represents the maximum amount of zooming possible by
the camera device, or equivalently, the minimum cropping
window size.</p>
<p>Crop regions that have a width or height that is smaller
than this ratio allows will be rounded up to the minimum
allowed size by the camera device.</p>
<p><b>Units</b>: Zoom scale factor</p>
<p><b>Range of valid values:</b><br>
&gt;=1</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#SCALER_CROP_REGION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Float> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15656887 // SCALER_AVAILABLE_MAX_DIGITAL_ZOOM (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15657015 // SCALER_AVAILABLE_PROCESSED_MIN_DURATIONS (<unidirectional association>)
	relation 15657015 --->
	  a role_name "SCALER_AVAILABLE_PROCESSED_MIN_DURATIONS" init_value "
            new Key<long[]>(\"android.scaler.availableProcessedMinDurations\", long[].class)" class_relation const_relation public
	    comment "
<p>For each available processed output size (defined in
android.scaler.availableProcessedSizes), this property lists the
minimum supportable frame duration for that size.</p>
<p>This should correspond to the frame duration when only that processed
stream is active, with all processing (typically in android.*.mode)
set to FAST.</p>
<p>When multiple streams are configured, the minimum frame duration will
be &gt;= max(individual stream min durations).</p>
<p><b>Units</b>: Nanoseconds</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@deprecated
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<long[]> ${name}${value};
"
	    java_annotation "@Deprecated
"
	    classrelation_ref 15657015 // SCALER_AVAILABLE_PROCESSED_MIN_DURATIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15657143 // SCALER_AVAILABLE_PROCESSED_SIZES (<unidirectional association>)
	relation 15657143 --->
	  a role_name "SCALER_AVAILABLE_PROCESSED_SIZES" init_value "
            new Key<android.util.Size[]>(\"android.scaler.availableProcessedSizes\", android.util.Size[].class)" class_relation const_relation public
	    comment "
<p>The resolutions available for use with
processed output streams, such as YV12, NV12, and
platform opaque YUV/RGB streams to the GPU or video
encoders.</p>
<p>The resolutions are listed as <code>(width, height)</code> pairs.</p>
<p>For a given use case, the actual maximum supported resolution
may be lower than what is listed here, depending on the destination
Surface for the image data. For example, for recording video,
the video encoder chosen may have a maximum size limit (e.g. 1080p)
smaller than what the camera (e.g. maximum resolution is 3264x2448)
can provide.</p>
<p>Please reference the documentation for the image data destination to
check if it limits the maximum size for image data.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@deprecated
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Size[]> ${name}${value};
"
	    java_annotation "@Deprecated
"
	    classrelation_ref 15657143 // SCALER_AVAILABLE_PROCESSED_SIZES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15657271 // SCALER_AVAILABLE_INPUT_OUTPUT_FORMATS_MAP (<unidirectional association>)
	relation 15657271 --->
	  a role_name "SCALER_AVAILABLE_INPUT_OUTPUT_FORMATS_MAP" init_value "
            new Key<android.hardware.camera2.params.ReprocessFormatsMap>(\"android.scaler.availableInputOutputFormatsMap\", android.hardware.camera2.params.ReprocessFormatsMap.class)" class_relation const_relation public
	    comment "
<p>The mapping of image formats that are supported by this
camera device for input streams, to their corresponding output formats.</p>
<p>All camera devices with at least 1
{@link CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS android.request.maxNumInputStreams} will have at least one
available input format.</p>
<p>The camera device will support the following map of formats,
if its dependent capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities}) is supported:</p>
<table>
<thead>
<tr>
<th align=\"left\">Input Format</th>
<th align=\"left\">Output Format</th>
<th align=\"left\">Capability</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"left\">{@link android.graphics.ImageFormat#PRIVATE }</td>
<td align=\"left\">{@link android.graphics.ImageFormat#JPEG }</td>
<td align=\"left\">PRIVATE_REPROCESSING</td>
</tr>
<tr>
<td align=\"left\">{@link android.graphics.ImageFormat#PRIVATE }</td>
<td align=\"left\">{@link android.graphics.ImageFormat#YUV_420_888 }</td>
<td align=\"left\">PRIVATE_REPROCESSING</td>
</tr>
<tr>
<td align=\"left\">{@link android.graphics.ImageFormat#YUV_420_888 }</td>
<td align=\"left\">{@link android.graphics.ImageFormat#JPEG }</td>
<td align=\"left\">YUV_REPROCESSING</td>
</tr>
<tr>
<td align=\"left\">{@link android.graphics.ImageFormat#YUV_420_888 }</td>
<td align=\"left\">{@link android.graphics.ImageFormat#YUV_420_888 }</td>
<td align=\"left\">YUV_REPROCESSING</td>
</tr>
</tbody>
</table>
<p>PRIVATE refers to a device-internal format that is not directly application-visible.  A
PRIVATE input surface can be acquired by {@link android.media.ImageReader#newInstance }
with {@link android.graphics.ImageFormat#PRIVATE } as the format.</p>
<p>For a PRIVATE_REPROCESSING-capable camera device, using the PRIVATE format as either input
or output will never hurt maximum frame rate (i.e.  {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration getOutputStallDuration(ImageFormat.PRIVATE, size)} is always 0),</p>
<p>Attempting to configure an input stream with output streams not
listed as available in this map is not valid.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.ReprocessFormatsMap> ${name}${value};
"
	    classrelation_ref 15657271 // SCALER_AVAILABLE_INPUT_OUTPUT_FORMATS_MAP (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15657399 // SCALER_AVAILABLE_STREAM_CONFIGURATIONS (<unidirectional association>)
	relation 15657399 --->
	  a role_name "SCALER_AVAILABLE_STREAM_CONFIGURATIONS" init_value "
            new Key<android.hardware.camera2.params.StreamConfiguration[]>(\"android.scaler.availableStreamConfigurations\", android.hardware.camera2.params.StreamConfiguration[].class)" class_relation const_relation public
	    comment "
<p>The available stream configurations that this
camera device supports
(i.e. format, width, height, output/input stream).</p>
<p>The configurations are listed as <code>(format, width, height, input?)</code>
tuples.</p>
<p>For a given use case, the actual maximum supported resolution
may be lower than what is listed here, depending on the destination
Surface for the image data. For example, for recording video,
the video encoder chosen may have a maximum size limit (e.g. 1080p)
smaller than what the camera (e.g. maximum resolution is 3264x2448)
can provide.</p>
<p>Please reference the documentation for the image data destination to
check if it limits the maximum size for image data.</p>
<p>Not all output formats may be supported in a configuration with
an input stream of a particular format. For more details, see
android.scaler.availableInputOutputFormatsMap.</p>
<p>The following table describes the minimum required output stream
configurations based on the hardware level
({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel}):</p>
<table>
<thead>
<tr>
<th align=\"center\">Format</th>
<th align=\"center\">Size</th>
<th align=\"center\">Hardware Level</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">JPEG</td>
<td align=\"center\">{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}</td>
<td align=\"center\">Any</td>
<td align=\"center\"></td>
</tr>
<tr>
<td align=\"center\">JPEG</td>
<td align=\"center\">1920x1080 (1080p)</td>
<td align=\"center\">Any</td>
<td align=\"center\">if 1080p &lt;= activeArraySize</td>
</tr>
<tr>
<td align=\"center\">JPEG</td>
<td align=\"center\">1280x720 (720)</td>
<td align=\"center\">Any</td>
<td align=\"center\">if 720p &lt;= activeArraySize</td>
</tr>
<tr>
<td align=\"center\">JPEG</td>
<td align=\"center\">640x480 (480p)</td>
<td align=\"center\">Any</td>
<td align=\"center\">if 480p &lt;= activeArraySize</td>
</tr>
<tr>
<td align=\"center\">JPEG</td>
<td align=\"center\">320x240 (240p)</td>
<td align=\"center\">Any</td>
<td align=\"center\">if 240p &lt;= activeArraySize</td>
</tr>
<tr>
<td align=\"center\">YUV_420_888</td>
<td align=\"center\">all output sizes available for JPEG</td>
<td align=\"center\">FULL</td>
<td align=\"center\"></td>
</tr>
<tr>
<td align=\"center\">YUV_420_888</td>
<td align=\"center\">all output sizes available for JPEG, up to the maximum video size</td>
<td align=\"center\">LIMITED</td>
<td align=\"center\"></td>
</tr>
<tr>
<td align=\"center\">IMPLEMENTATION_DEFINED</td>
<td align=\"center\">same as YUV_420_888</td>
<td align=\"center\">Any</td>
<td align=\"center\"></td>
</tr>
</tbody>
</table>
<p>Refer to {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} for additional
mandatory stream configurations on a per-capability basis.</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.StreamConfiguration[]> ${name}${value};
"
	    classrelation_ref 15657399 // SCALER_AVAILABLE_STREAM_CONFIGURATIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15657527 // SCALER_AVAILABLE_MIN_FRAME_DURATIONS (<unidirectional association>)
	relation 15657527 --->
	  a role_name "SCALER_AVAILABLE_MIN_FRAME_DURATIONS" init_value "
            new Key<android.hardware.camera2.params.StreamConfigurationDuration[]>(\"android.scaler.availableMinFrameDurations\", android.hardware.camera2.params.StreamConfigurationDuration[].class)" class_relation const_relation public
	    comment "
<p>This lists the minimum frame duration for each
format/size combination.</p>
<p>This should correspond to the frame duration when only that
stream is active, with all processing (typically in android.*.mode)
set to either OFF or FAST.</p>
<p>When multiple streams are used in a request, the minimum frame
duration will be max(individual stream min durations).</p>
<p>The minimum frame duration of a stream (of a particular format, size)
is the same regardless of whether the stream is input or output.</p>
<p>See {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration} and
android.scaler.availableStallDurations for more details about
calculating the max frame rate.</p>
<p>(Keep in sync with
{@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration })</p>
<p><b>Units</b>: (format, width, height, ns) x n</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#SENSOR_FRAME_DURATION
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.StreamConfigurationDuration[]> ${name}${value};
"
	    classrelation_ref 15657527 // SCALER_AVAILABLE_MIN_FRAME_DURATIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15657655 // SCALER_AVAILABLE_STALL_DURATIONS (<unidirectional association>)
	relation 15657655 --->
	  a role_name "SCALER_AVAILABLE_STALL_DURATIONS" init_value "
            new Key<android.hardware.camera2.params.StreamConfigurationDuration[]>(\"android.scaler.availableStallDurations\", android.hardware.camera2.params.StreamConfigurationDuration[].class)" class_relation const_relation public
	    comment "
<p>This lists the maximum stall duration for each
output format/size combination.</p>
<p>A stall duration is how much extra time would get added
to the normal minimum frame duration for a repeating request
that has streams with non-zero stall.</p>
<p>For example, consider JPEG captures which have the following
characteristics:</p>
<ul>
<li>JPEG streams act like processed YUV streams in requests for which
they are not included; in requests in which they are directly
referenced, they act as JPEG streams. This is because supporting a
JPEG stream requires the underlying YUV data to always be ready for
use by a JPEG encoder, but the encoder will only be used (and impact
frame duration) on requests that actually reference a JPEG stream.</li>
<li>The JPEG processor can run concurrently to the rest of the camera
pipeline, but cannot process more than 1 capture at a time.</li>
</ul>
<p>In other words, using a repeating YUV request would result
in a steady frame rate (let's say it's 30 FPS). If a single
JPEG request is submitted periodically, the frame rate will stay
at 30 FPS (as long as we wait for the previous JPEG to return each
time). If we try to submit a repeating YUV + JPEG request, then
the frame rate will drop from 30 FPS.</p>
<p>In general, submitting a new request with a non-0 stall time
stream will <em>not</em> cause a frame rate drop unless there are still
outstanding buffers for that stream from previous requests.</p>
<p>Submitting a repeating request with streams (call this <code>S</code>)
is the same as setting the minimum frame duration from
the normal minimum frame duration corresponding to <code>S</code>, added with
the maximum stall duration for <code>S</code>.</p>
<p>If interleaving requests with and without a stall duration,
a request will stall by the maximum of the remaining times
for each can-stall stream with outstanding buffers.</p>
<p>This means that a stalling request will not have an exposure start
until the stall has completed.</p>
<p>This should correspond to the stall duration when only that stream is
active, with all processing (typically in android.*.mode) set to FAST
or OFF. Setting any of the processing modes to HIGH_QUALITY
effectively results in an indeterminate stall duration for all
streams in a request (the regular stall calculation rules are
ignored).</p>
<p>The following formats may always have a stall duration:</p>
<ul>
<li>{@link android.graphics.ImageFormat#JPEG }</li>
<li>{@link android.graphics.ImageFormat#RAW_SENSOR }</li>
</ul>
<p>The following formats will never have a stall duration:</p>
<ul>
<li>{@link android.graphics.ImageFormat#YUV_420_888 }</li>
<li>{@link android.graphics.ImageFormat#RAW10 }</li>
</ul>
<p>All other formats may or may not have an allowed stall duration on
a per-capability basis; refer to {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities}
for more details.</p>
<p>See {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration} for more information about
calculating the max frame rate (absent stalls).</p>
<p>(Keep up to date with
{@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration } )</p>
<p><b>Units</b>: (format, width, height, ns) x n</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CaptureRequest#SENSOR_FRAME_DURATION
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.StreamConfigurationDuration[]> ${name}${value};
"
	    classrelation_ref 15657655 // SCALER_AVAILABLE_STALL_DURATIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15657783 // SCALER_STREAM_CONFIGURATION_MAP (<unidirectional association>)
	relation 15657783 --->
	  a role_name "SCALER_STREAM_CONFIGURATION_MAP" init_value "
            new Key<android.hardware.camera2.params.StreamConfigurationMap>(\"android.scaler.streamConfigurationMap\", android.hardware.camera2.params.StreamConfigurationMap.class)" class_relation const_relation public
	    comment "
<p>The available stream configurations that this
camera device supports; also includes the minimum frame durations
and the stall durations for each format/size combination.</p>
<p>All camera devices will support sensor maximum resolution (defined by
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}) for the JPEG format.</p>
<p>For a given use case, the actual maximum supported resolution
may be lower than what is listed here, depending on the destination
Surface for the image data. For example, for recording video,
the video encoder chosen may have a maximum size limit (e.g. 1080p)
smaller than what the camera (e.g. maximum resolution is 3264x2448)
can provide.</p>
<p>Please reference the documentation for the image data destination to
check if it limits the maximum size for image data.</p>
<p>The following table describes the minimum required output stream
configurations based on the hardware level
({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel}):</p>
<table>
<thead>
<tr>
<th align=\"center\">Format</th>
<th align=\"center\">Size</th>
<th align=\"center\">Hardware Level</th>
<th align=\"center\">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align=\"center\">{@link android.graphics.ImageFormat#JPEG }</td>
<td align=\"center\">{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} (*1)</td>
<td align=\"center\">Any</td>
<td align=\"center\"></td>
</tr>
<tr>
<td align=\"center\">{@link android.graphics.ImageFormat#JPEG }</td>
<td align=\"center\">1920x1080 (1080p)</td>
<td align=\"center\">Any</td>
<td align=\"center\">if 1080p &lt;= activeArraySize</td>
</tr>
<tr>
<td align=\"center\">{@link android.graphics.ImageFormat#JPEG }</td>
<td align=\"center\">1280x720 (720p)</td>
<td align=\"center\">Any</td>
<td align=\"center\">if 720p &lt;= activeArraySize</td>
</tr>
<tr>
<td align=\"center\">{@link android.graphics.ImageFormat#JPEG }</td>
<td align=\"center\">640x480 (480p)</td>
<td align=\"center\">Any</td>
<td align=\"center\">if 480p &lt;= activeArraySize</td>
</tr>
<tr>
<td align=\"center\">{@link android.graphics.ImageFormat#JPEG }</td>
<td align=\"center\">320x240 (240p)</td>
<td align=\"center\">Any</td>
<td align=\"center\">if 240p &lt;= activeArraySize</td>
</tr>
<tr>
<td align=\"center\">{@link android.graphics.ImageFormat#YUV_420_888 }</td>
<td align=\"center\">all output sizes available for JPEG</td>
<td align=\"center\">FULL</td>
<td align=\"center\"></td>
</tr>
<tr>
<td align=\"center\">{@link android.graphics.ImageFormat#YUV_420_888 }</td>
<td align=\"center\">all output sizes available for JPEG, up to the maximum video size</td>
<td align=\"center\">LIMITED</td>
<td align=\"center\"></td>
</tr>
<tr>
<td align=\"center\">{@link android.graphics.ImageFormat#PRIVATE }</td>
<td align=\"center\">same as YUV_420_888</td>
<td align=\"center\">Any</td>
<td align=\"center\"></td>
</tr>
</tbody>
</table>
<p>Refer to {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} and {@link android.hardware.camera2.CameraDevice#createCaptureSession } for additional mandatory
stream configurations on a per-capability basis.</p>
<p>*1: For JPEG format, the sizes may be restricted by below conditions:</p>
<ul>
<li>The HAL may choose the aspect ratio of each Jpeg size to be one of well known ones
(e.g. 4:3, 16:9, 3:2 etc.). If the sensor maximum resolution
(defined by {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}) has an aspect ratio other than these,
it does not have to be included in the supported JPEG sizes.</li>
<li>Some hardware JPEG encoders may have pixel boundary alignment requirements, such as
the dimensions being a multiple of 16.
Therefore, the maximum JPEG size may be smaller than sensor maximum resolution.
However, the largest JPEG size will be as close as possible to the sensor maximum
resolution given above constraints. It is required that after aspect ratio adjustments,
additional size reduction due to other issues must be less than 3% in area. For example,
if the sensor maximum resolution is 3280x2464, if the maximum JPEG size has aspect
ratio 4:3, and the JPEG encoder alignment requirement is 16, the maximum JPEG size will be
3264x2448.</li>
</ul>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.StreamConfigurationMap> ${name}${value};
"
	    java_annotation "@PublicKey
@SyntheticKey
"
	    classrelation_ref 15657783 // SCALER_STREAM_CONFIGURATION_MAP (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15657911 // SCALER_CROPPING_TYPE (<unidirectional association>)
	relation 15657911 --->
	  a role_name "SCALER_CROPPING_TYPE" init_value "
            new Key<Integer>(\"android.scaler.croppingType\", int.class)" class_relation const_relation public
	    comment "
<p>The crop type that this camera device supports.</p>
<p>When passing a non-centered crop region ({@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}) to a camera
device that only supports CENTER_ONLY cropping, the camera device will move the
crop region to the center of the sensor active array ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize})
and keep the crop region width and height unchanged. The camera device will return the
final used crop region in metadata result {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}.</p>
<p>Camera devices that support FREEFORM cropping will support any crop region that
is inside of the active array. The camera device will apply the same crop region and
return the final used crop region in capture result metadata {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}.</p>
<p>LEGACY capability devices will only support CENTER_ONLY cropping.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #SCALER_CROPPING_TYPE_CENTER_ONLY CENTER_ONLY}</li>
  <li>{@link #SCALER_CROPPING_TYPE_FREEFORM FREEFORM}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CaptureRequest#SCALER_CROP_REGION
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE
@see #SCALER_CROPPING_TYPE_CENTER_ONLY
@see #SCALER_CROPPING_TYPE_FREEFORM

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15657911 // SCALER_CROPPING_TYPE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15658039 // SENSOR_INFO_ACTIVE_ARRAY_SIZE (<unidirectional association>)
	relation 15658039 --->
	  a role_name "SENSOR_INFO_ACTIVE_ARRAY_SIZE" init_value "
            new Key<android.graphics.Rect>(\"android.sensor.info.activeArraySize\", android.graphics.Rect.class)" class_relation const_relation public
	    comment "
<p>The area of the image sensor which corresponds to active pixels after any geometric
distortion correction has been applied.</p>
<p>This is the rectangle representing the size of the active region of the sensor (i.e.
the region that actually receives light from the scene) after any geometric correction
has been applied, and should be treated as the maximum size in pixels of any of the
image output formats aside from the raw formats.</p>
<p>This rectangle is defined relative to the full pixel array; (0,0) is the top-left of
the full pixel array, and the size of the full pixel array is given by
{@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}.</p>
<p>The coordinate system for most other keys that list pixel coordinates, including
{@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}, is defined relative to the active array rectangle given in
this field, with <code>(0, 0)</code> being the top-left of this rectangle.</p>
<p>The active array may be smaller than the full pixel array, since the full array may
include black calibration pixels or other inactive regions, and geometric correction
resulting in scaling or cropping may have been applied.</p>
<p><b>Units</b>: Pixel coordinates on the image sensor</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#SCALER_CROP_REGION
@see CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.graphics.Rect> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15658039 // SENSOR_INFO_ACTIVE_ARRAY_SIZE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15658167 // SENSOR_INFO_SENSITIVITY_RANGE (<unidirectional association>)
	relation 15658167 --->
	  a role_name "SENSOR_INFO_SENSITIVITY_RANGE" init_value "
            new Key<android.util.Range<Integer>>(\"android.sensor.info.sensitivityRange\", new TypeReference<android.util.Range<Integer>>() {{ }})" class_relation const_relation public
	    comment "
<p>Range of sensitivities for {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity} supported by this
camera device.</p>
<p>The values are the standard ISO sensitivity values,
as defined in ISO 12232:2006.</p>
<p><b>Range of valid values:</b><br>
Min &lt;= 100, Max &gt;= 800</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Range<Integer>> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15658167 // SENSOR_INFO_SENSITIVITY_RANGE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15658295 // SENSOR_INFO_COLOR_FILTER_ARRANGEMENT (<unidirectional association>)
	relation 15658295 --->
	  a role_name "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT" init_value "
            new Key<Integer>(\"android.sensor.info.colorFilterArrangement\", int.class)" class_relation const_relation public
	    comment "
<p>The arrangement of color filters on sensor;
represents the colors in the top-left 2x2 section of
the sensor, in reading order.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB RGGB}</li>
  <li>{@link #SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG GRBG}</li>
  <li>{@link #SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG GBRG}</li>
  <li>{@link #SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR BGGR}</li>
  <li>{@link #SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB RGB}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see #SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB
@see #SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG
@see #SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG
@see #SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR
@see #SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15658295 // SENSOR_INFO_COLOR_FILTER_ARRANGEMENT (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15658423 // SENSOR_INFO_EXPOSURE_TIME_RANGE (<unidirectional association>)
	relation 15658423 --->
	  a role_name "SENSOR_INFO_EXPOSURE_TIME_RANGE" init_value "
            new Key<android.util.Range<Long>>(\"android.sensor.info.exposureTimeRange\", new TypeReference<android.util.Range<Long>>() {{ }})" class_relation const_relation public
	    comment "
<p>The range of image exposure times for {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime} supported
by this camera device.</p>
<p><b>Units</b>: Nanoseconds</p>
<p><b>Range of valid values:</b><br>
The minimum exposure time will be less than 100 us. For FULL
capability devices ({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} == FULL),
the maximum exposure time will be greater than 100ms.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#SENSOR_EXPOSURE_TIME

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Range<Long>> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15658423 // SENSOR_INFO_EXPOSURE_TIME_RANGE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15658551 // SENSOR_INFO_MAX_FRAME_DURATION (<unidirectional association>)
	relation 15658551 --->
	  a role_name "SENSOR_INFO_MAX_FRAME_DURATION" init_value "
            new Key<Long>(\"android.sensor.info.maxFrameDuration\", long.class)" class_relation const_relation public
	    comment "
<p>The maximum possible frame duration (minimum frame rate) for
{@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration} that is supported this camera device.</p>
<p>Attempting to use frame durations beyond the maximum will result in the frame
duration being clipped to the maximum. See that control for a full definition of frame
durations.</p>
<p>Refer to {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }
for the minimum frame duration values.</p>
<p><b>Units</b>: Nanoseconds</p>
<p><b>Range of valid values:</b><br>
For FULL capability devices
({@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} == FULL), at least 100ms.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#SENSOR_FRAME_DURATION

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Long> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15658551 // SENSOR_INFO_MAX_FRAME_DURATION (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15658679 // SENSOR_INFO_PHYSICAL_SIZE (<unidirectional association>)
	relation 15658679 --->
	  a role_name "SENSOR_INFO_PHYSICAL_SIZE" init_value "
            new Key<android.util.SizeF>(\"android.sensor.info.physicalSize\", android.util.SizeF.class)" class_relation const_relation public
	    comment "
<p>The physical dimensions of the full pixel
array.</p>
<p>This is the physical size of the sensor pixel
array defined by {@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}.</p>
<p><b>Units</b>: Millimeters</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.SizeF> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15658679 // SENSOR_INFO_PHYSICAL_SIZE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15658807 // SENSOR_INFO_PIXEL_ARRAY_SIZE (<unidirectional association>)
	relation 15658807 --->
	  a role_name "SENSOR_INFO_PIXEL_ARRAY_SIZE" init_value "
            new Key<android.util.Size>(\"android.sensor.info.pixelArraySize\", android.util.Size.class)" class_relation const_relation public
	    comment "
<p>Dimensions of the full pixel array, possibly
including black calibration pixels.</p>
<p>The pixel count of the full pixel array of the image sensor, which covers
{@link CameraCharacteristics#SENSOR_INFO_PHYSICAL_SIZE android.sensor.info.physicalSize} area.  This represents the full pixel dimensions of
the raw buffers produced by this sensor.</p>
<p>If a camera device supports raw sensor formats, either this or
{@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} is the maximum dimensions for the raw
output formats listed in {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap} (this depends on
whether or not the image sensor returns buffers containing pixels that are not
part of the active array region for blacklevel calibration or other purposes).</p>
<p>Some parts of the full pixel array may not receive light from the scene,
or be otherwise inactive.  The {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} key
defines the rectangle of active pixels that will be included in processed image
formats.</p>
<p><b>Units</b>: Pixels</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP
@see CameraCharacteristics#SENSOR_INFO_PHYSICAL_SIZE
@see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.util.Size> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15658807 // SENSOR_INFO_PIXEL_ARRAY_SIZE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15658935 // SENSOR_INFO_WHITE_LEVEL (<unidirectional association>)
	relation 15658935 --->
	  a role_name "SENSOR_INFO_WHITE_LEVEL" init_value "
            new Key<Integer>(\"android.sensor.info.whiteLevel\", int.class)" class_relation const_relation public
	    comment "
<p>Maximum raw value output by sensor.</p>
<p>This specifies the fully-saturated encoding level for the raw
sample values from the sensor.  This is typically caused by the
sensor becoming highly non-linear or clipping. The minimum for
each channel is specified by the offset in the
{@link CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern} key.</p>
<p>The white level is typically determined either by sensor bit depth
(8-14 bits is expected), or by the point where the sensor response
becomes too non-linear to be useful.  The default value for this is
maximum representable value for a 16-bit raw sample (2^16 - 1).</p>
<p>The white level values of captured images may vary for different
capture settings (e.g., {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}). This key
represents a coarse approximation for such case. It is recommended
to use {@link CaptureResult#SENSOR_DYNAMIC_WHITE_LEVEL android.sensor.dynamicWhiteLevel} for captures when supported
by the camera device, which provides more accurate white level values.</p>
<p><b>Range of valid values:</b><br>
&gt; 255 (8-bit output)</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN
@see CaptureResult#SENSOR_DYNAMIC_WHITE_LEVEL
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15658935 // SENSOR_INFO_WHITE_LEVEL (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15659063 // SENSOR_INFO_TIMESTAMP_SOURCE (<unidirectional association>)
	relation 15659063 --->
	  a role_name "SENSOR_INFO_TIMESTAMP_SOURCE" init_value "
            new Key<Integer>(\"android.sensor.info.timestampSource\", int.class)" class_relation const_relation public
	    comment "
<p>The time base source for sensor capture start timestamps.</p>
<p>The timestamps provided for captures are always in nanoseconds and monotonic, but
may not based on a time source that can be compared to other system time sources.</p>
<p>This characteristic defines the source for the timestamps, and therefore whether they
can be compared against other system time sources/timestamps.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN UNKNOWN}</li>
  <li>{@link #SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME REALTIME}</li>
</ul></p>
<p>This key is available on all devices.</p>
@see #SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN
@see #SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15659063 // SENSOR_INFO_TIMESTAMP_SOURCE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15659191 // SENSOR_INFO_LENS_SHADING_APPLIED (<unidirectional association>)
	relation 15659191 --->
	  a role_name "SENSOR_INFO_LENS_SHADING_APPLIED" init_value "
            new Key<Boolean>(\"android.sensor.info.lensShadingApplied\", boolean.class)" class_relation const_relation public
	    comment "
<p>Whether the RAW images output from this camera device are subject to
lens shading correction.</p>
<p>If TRUE, all images produced by the camera device in the RAW image formats will
have lens shading correction already applied to it. If FALSE, the images will
not be adjusted for lens shading correction.
See {@link CameraCharacteristics#REQUEST_MAX_NUM_OUTPUT_RAW android.request.maxNumOutputRaw} for a list of RAW image formats.</p>
<p>This key will be <code>null</code> for all devices do not report this information.
Devices with RAW capability will always report this information in this key.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#REQUEST_MAX_NUM_OUTPUT_RAW

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15659191 // SENSOR_INFO_LENS_SHADING_APPLIED (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15659319 // SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE (<unidirectional association>)
	relation 15659319 --->
	  a role_name "SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE" init_value "
            new Key<android.graphics.Rect>(\"android.sensor.info.preCorrectionActiveArraySize\", android.graphics.Rect.class)" class_relation const_relation public
	    comment "
<p>The area of the image sensor which corresponds to active pixels prior to the
application of any geometric distortion correction.</p>
<p>This is the rectangle representing the size of the active region of the sensor (i.e.
the region that actually receives light from the scene) before any geometric correction
has been applied, and should be treated as the active region rectangle for any of the
raw formats.  All metadata associated with raw processing (e.g. the lens shading
correction map, and radial distortion fields) treats the top, left of this rectangle as
the origin, (0,0).</p>
<p>The size of this region determines the maximum field of view and the maximum number of
pixels that an image from this sensor can contain, prior to the application of
geometric distortion correction. The effective maximum pixel dimensions of a
post-distortion-corrected image is given by the {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}
field, and the effective maximum field of view for a post-distortion-corrected image
can be calculated by applying the geometric distortion correction fields to this
rectangle, and cropping to the rectangle given in {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.</p>
<p>E.g. to calculate position of a pixel, (x,y), in a processed YUV output image with the
dimensions in {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} given the position of a pixel,
(x', y'), in the raw pixel array with dimensions give in
{@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}:</p>
<ol>
<li>Choose a pixel (x', y') within the active array region of the raw buffer given in
{@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, otherwise this pixel is considered
to be outside of the FOV, and will not be shown in the processed output image.</li>
<li>Apply geometric distortion correction to get the post-distortion pixel coordinate,
(x_i, y_i). When applying geometric correction metadata, note that metadata for raw
buffers is defined relative to the top, left of the
{@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} rectangle.</li>
<li>If the resulting corrected pixel coordinate is within the region given in
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, then the position of this pixel in the
processed output image buffer is <code>(x_i - activeArray.left, y_i - activeArray.top)</code>,
when the top, left coordinate of that buffer is treated as (0, 0).</li>
</ol>
<p>Thus, for pixel x',y' = (25, 25) on a sensor where {@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}
is (100,100), {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} is (10, 10, 100, 100),
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} is (20, 20, 80, 80), and the geometric distortion
correction doesn't change the pixel coordinate, the resulting pixel selected in
pixel coordinates would be x,y = (25, 25) relative to the top,left of the raw buffer
with dimensions given in {@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}, and would be (5, 5)
relative to the top,left of post-processed YUV output buffer with dimensions given in
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.</p>
<p>The currently supported fields that correct for geometric distortion are:</p>
<ol>
<li>{@link CameraCharacteristics#LENS_RADIAL_DISTORTION android.lens.radialDistortion}.</li>
</ol>
<p>If all of the geometric distortion fields are no-ops, this rectangle will be the same
as the post-distortion-corrected rectangle given in
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.</p>
<p>This rectangle is defined relative to the full pixel array; (0,0) is the top-left of
the full pixel array, and the size of the full pixel array is given by
{@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}.</p>
<p>The pre-correction active array may be smaller than the full pixel array, since the
full array may include black calibration pixels or other inactive regions.</p>
<p><b>Units</b>: Pixel coordinates on the image sensor</p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#LENS_RADIAL_DISTORTION
@see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE
@see CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE
@see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.graphics.Rect> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15659319 // SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15659447 // SENSOR_REFERENCE_ILLUMINANT1 (<unidirectional association>)
	relation 15659447 --->
	  a role_name "SENSOR_REFERENCE_ILLUMINANT1" init_value "
            new Key<Integer>(\"android.sensor.referenceIlluminant1\", int.class)" class_relation const_relation public
	    comment "
<p>The standard reference illuminant used as the scene light source when
calculating the {@link CameraCharacteristics#SENSOR_COLOR_TRANSFORM1 android.sensor.colorTransform1},
{@link CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM1 android.sensor.calibrationTransform1}, and
{@link CameraCharacteristics#SENSOR_FORWARD_MATRIX1 android.sensor.forwardMatrix1} matrices.</p>
<p>The values in this key correspond to the values defined for the
EXIF LightSource tag. These illuminants are standard light sources
that are often used calibrating camera devices.</p>
<p>If this key is present, then {@link CameraCharacteristics#SENSOR_COLOR_TRANSFORM1 android.sensor.colorTransform1},
{@link CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM1 android.sensor.calibrationTransform1}, and
{@link CameraCharacteristics#SENSOR_FORWARD_MATRIX1 android.sensor.forwardMatrix1} will also be present.</p>
<p>Some devices may choose to provide a second set of calibration
information for improved quality, including
{@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2 android.sensor.referenceIlluminant2} and its corresponding matrices.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT DAYLIGHT}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT FLUORESCENT}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN TUNGSTEN}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_FLASH FLASH}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER FINE_WEATHER}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER CLOUDY_WEATHER}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_SHADE SHADE}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT DAYLIGHT_FLUORESCENT}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT DAY_WHITE_FLUORESCENT}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT COOL_WHITE_FLUORESCENT}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT WHITE_FLUORESCENT}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A STANDARD_A}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B STANDARD_B}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C STANDARD_C}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_D55 D55}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_D65 D65}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_D75 D75}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_D50 D50}</li>
  <li>{@link #SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN ISO_STUDIO_TUNGSTEN}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM1
@see CameraCharacteristics#SENSOR_COLOR_TRANSFORM1
@see CameraCharacteristics#SENSOR_FORWARD_MATRIX1
@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2
@see #SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT
@see #SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT
@see #SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN
@see #SENSOR_REFERENCE_ILLUMINANT1_FLASH
@see #SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER
@see #SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER
@see #SENSOR_REFERENCE_ILLUMINANT1_SHADE
@see #SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT
@see #SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT
@see #SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT
@see #SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT
@see #SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A
@see #SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B
@see #SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C
@see #SENSOR_REFERENCE_ILLUMINANT1_D55
@see #SENSOR_REFERENCE_ILLUMINANT1_D65
@see #SENSOR_REFERENCE_ILLUMINANT1_D75
@see #SENSOR_REFERENCE_ILLUMINANT1_D50
@see #SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15659447 // SENSOR_REFERENCE_ILLUMINANT1 (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15659575 // SENSOR_REFERENCE_ILLUMINANT2 (<unidirectional association>)
	relation 15659575 --->
	  a role_name "SENSOR_REFERENCE_ILLUMINANT2" init_value "
            new Key<Byte>(\"android.sensor.referenceIlluminant2\", byte.class)" class_relation const_relation public
	    comment "
<p>The standard reference illuminant used as the scene light source when
calculating the {@link CameraCharacteristics#SENSOR_COLOR_TRANSFORM2 android.sensor.colorTransform2},
{@link CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM2 android.sensor.calibrationTransform2}, and
{@link CameraCharacteristics#SENSOR_FORWARD_MATRIX2 android.sensor.forwardMatrix2} matrices.</p>
<p>See {@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1} for more details.</p>
<p>If this key is present, then {@link CameraCharacteristics#SENSOR_COLOR_TRANSFORM2 android.sensor.colorTransform2},
{@link CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM2 android.sensor.calibrationTransform2}, and
{@link CameraCharacteristics#SENSOR_FORWARD_MATRIX2 android.sensor.forwardMatrix2} will also be present.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM2
@see CameraCharacteristics#SENSOR_COLOR_TRANSFORM2
@see CameraCharacteristics#SENSOR_FORWARD_MATRIX2
@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Byte> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15659575 // SENSOR_REFERENCE_ILLUMINANT2 (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15659703 // SENSOR_CALIBRATION_TRANSFORM1 (<unidirectional association>)
	relation 15659703 --->
	  a role_name "SENSOR_CALIBRATION_TRANSFORM1" init_value "
            new Key<android.hardware.camera2.params.ColorSpaceTransform>(\"android.sensor.calibrationTransform1\", android.hardware.camera2.params.ColorSpaceTransform.class)" class_relation const_relation public
	    comment "
<p>A per-device calibration transform matrix that maps from the
reference sensor colorspace to the actual device sensor colorspace.</p>
<p>This matrix is used to correct for per-device variations in the
sensor colorspace, and is used for processing raw buffer data.</p>
<p>The matrix is expressed as a 3x3 matrix in row-major-order, and
contains a per-device calibration transform that maps colors
from reference sensor color space (i.e. the \"golden module\"
colorspace) into this camera device's native sensor color
space under the first reference illuminant
({@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1}).</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.ColorSpaceTransform> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15659703 // SENSOR_CALIBRATION_TRANSFORM1 (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15659831 // SENSOR_CALIBRATION_TRANSFORM2 (<unidirectional association>)
	relation 15659831 --->
	  a role_name "SENSOR_CALIBRATION_TRANSFORM2" init_value "
            new Key<android.hardware.camera2.params.ColorSpaceTransform>(\"android.sensor.calibrationTransform2\", android.hardware.camera2.params.ColorSpaceTransform.class)" class_relation const_relation public
	    comment "
<p>A per-device calibration transform matrix that maps from the
reference sensor colorspace to the actual device sensor colorspace
(this is the colorspace of the raw buffer data).</p>
<p>This matrix is used to correct for per-device variations in the
sensor colorspace, and is used for processing raw buffer data.</p>
<p>The matrix is expressed as a 3x3 matrix in row-major-order, and
contains a per-device calibration transform that maps colors
from reference sensor color space (i.e. the \"golden module\"
colorspace) into this camera device's native sensor color
space under the second reference illuminant
({@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2 android.sensor.referenceIlluminant2}).</p>
<p>This matrix will only be present if the second reference
illuminant is present.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.ColorSpaceTransform> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15659831 // SENSOR_CALIBRATION_TRANSFORM2 (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15659959 // SENSOR_COLOR_TRANSFORM1 (<unidirectional association>)
	relation 15659959 --->
	  a role_name "SENSOR_COLOR_TRANSFORM1" init_value "
            new Key<android.hardware.camera2.params.ColorSpaceTransform>(\"android.sensor.colorTransform1\", android.hardware.camera2.params.ColorSpaceTransform.class)" class_relation const_relation public
	    comment "
<p>A matrix that transforms color values from CIE XYZ color space to
reference sensor color space.</p>
<p>This matrix is used to convert from the standard CIE XYZ color
space to the reference sensor colorspace, and is used when processing
raw buffer data.</p>
<p>The matrix is expressed as a 3x3 matrix in row-major-order, and
contains a color transform matrix that maps colors from the CIE
XYZ color space to the reference sensor color space (i.e. the
\"golden module\" colorspace) under the first reference illuminant
({@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1}).</p>
<p>The white points chosen in both the reference sensor color space
and the CIE XYZ colorspace when calculating this transform will
match the standard white point for the first reference illuminant
(i.e. no chromatic adaptation will be applied by this transform).</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.ColorSpaceTransform> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15659959 // SENSOR_COLOR_TRANSFORM1 (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15660087 // SENSOR_COLOR_TRANSFORM2 (<unidirectional association>)
	relation 15660087 --->
	  a role_name "SENSOR_COLOR_TRANSFORM2" init_value "
            new Key<android.hardware.camera2.params.ColorSpaceTransform>(\"android.sensor.colorTransform2\", android.hardware.camera2.params.ColorSpaceTransform.class)" class_relation const_relation public
	    comment "
<p>A matrix that transforms color values from CIE XYZ color space to
reference sensor color space.</p>
<p>This matrix is used to convert from the standard CIE XYZ color
space to the reference sensor colorspace, and is used when processing
raw buffer data.</p>
<p>The matrix is expressed as a 3x3 matrix in row-major-order, and
contains a color transform matrix that maps colors from the CIE
XYZ color space to the reference sensor color space (i.e. the
\"golden module\" colorspace) under the second reference illuminant
({@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2 android.sensor.referenceIlluminant2}).</p>
<p>The white points chosen in both the reference sensor color space
and the CIE XYZ colorspace when calculating this transform will
match the standard white point for the second reference illuminant
(i.e. no chromatic adaptation will be applied by this transform).</p>
<p>This matrix will only be present if the second reference
illuminant is present.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.ColorSpaceTransform> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15660087 // SENSOR_COLOR_TRANSFORM2 (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15660215 // SENSOR_FORWARD_MATRIX1 (<unidirectional association>)
	relation 15660215 --->
	  a role_name "SENSOR_FORWARD_MATRIX1" init_value "
            new Key<android.hardware.camera2.params.ColorSpaceTransform>(\"android.sensor.forwardMatrix1\", android.hardware.camera2.params.ColorSpaceTransform.class)" class_relation const_relation public
	    comment "
<p>A matrix that transforms white balanced camera colors from the reference
sensor colorspace to the CIE XYZ colorspace with a D50 whitepoint.</p>
<p>This matrix is used to convert to the standard CIE XYZ colorspace, and
is used when processing raw buffer data.</p>
<p>This matrix is expressed as a 3x3 matrix in row-major-order, and contains
a color transform matrix that maps white balanced colors from the
reference sensor color space to the CIE XYZ color space with a D50 white
point.</p>
<p>Under the first reference illuminant ({@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1})
this matrix is chosen so that the standard white point for this reference
illuminant in the reference sensor colorspace is mapped to D50 in the
CIE XYZ colorspace.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.ColorSpaceTransform> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15660215 // SENSOR_FORWARD_MATRIX1 (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15660343 // SENSOR_FORWARD_MATRIX2 (<unidirectional association>)
	relation 15660343 --->
	  a role_name "SENSOR_FORWARD_MATRIX2" init_value "
            new Key<android.hardware.camera2.params.ColorSpaceTransform>(\"android.sensor.forwardMatrix2\", android.hardware.camera2.params.ColorSpaceTransform.class)" class_relation const_relation public
	    comment "
<p>A matrix that transforms white balanced camera colors from the reference
sensor colorspace to the CIE XYZ colorspace with a D50 whitepoint.</p>
<p>This matrix is used to convert to the standard CIE XYZ colorspace, and
is used when processing raw buffer data.</p>
<p>This matrix is expressed as a 3x3 matrix in row-major-order, and contains
a color transform matrix that maps white balanced colors from the
reference sensor color space to the CIE XYZ color space with a D50 white
point.</p>
<p>Under the second reference illuminant ({@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2 android.sensor.referenceIlluminant2})
this matrix is chosen so that the standard white point for this reference
illuminant in the reference sensor colorspace is mapped to D50 in the
CIE XYZ colorspace.</p>
<p>This matrix will only be present if the second reference
illuminant is present.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.ColorSpaceTransform> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15660343 // SENSOR_FORWARD_MATRIX2 (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15660471 // SENSOR_BLACK_LEVEL_PATTERN (<unidirectional association>)
	relation 15660471 --->
	  a role_name "SENSOR_BLACK_LEVEL_PATTERN" init_value "
            new Key<android.hardware.camera2.params.BlackLevelPattern>(\"android.sensor.blackLevelPattern\", android.hardware.camera2.params.BlackLevelPattern.class)" class_relation const_relation public
	    comment "
<p>A fixed black level offset for each of the color filter arrangement
(CFA) mosaic channels.</p>
<p>This key specifies the zero light value for each of the CFA mosaic
channels in the camera sensor.  The maximal value output by the
sensor is represented by the value in {@link CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL android.sensor.info.whiteLevel}.</p>
<p>The values are given in the same order as channels listed for the CFA
layout key (see {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT android.sensor.info.colorFilterArrangement}), i.e. the
nth value given corresponds to the black level offset for the nth
color channel listed in the CFA.</p>
<p>The black level values of captured images may vary for different
capture settings (e.g., {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}). This key
represents a coarse approximation for such case. It is recommended to
use {@link CaptureResult#SENSOR_DYNAMIC_BLACK_LEVEL android.sensor.dynamicBlackLevel} or use pixels from
{@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions} directly for captures when
supported by the camera device, which provides more accurate black
level values. For raw capture in particular, it is recommended to use
pixels from {@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions} to calculate black
level values for each frame.</p>
<p><b>Range of valid values:</b><br>
&gt;= 0 for each.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureResult#SENSOR_DYNAMIC_BLACK_LEVEL
@see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT
@see CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL
@see CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.BlackLevelPattern> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15660471 // SENSOR_BLACK_LEVEL_PATTERN (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15660599 // SENSOR_MAX_ANALOG_SENSITIVITY (<unidirectional association>)
	relation 15660599 --->
	  a role_name "SENSOR_MAX_ANALOG_SENSITIVITY" init_value "
            new Key<Integer>(\"android.sensor.maxAnalogSensitivity\", int.class)" class_relation const_relation public
	    comment "
<p>Maximum sensitivity that is implemented
purely through analog gain.</p>
<p>For {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity} values less than or
equal to this, all applied gain must be analog. For
values above this, the gain applied can be a mix of analog and
digital.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#SENSOR_SENSITIVITY

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15660599 // SENSOR_MAX_ANALOG_SENSITIVITY (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15660727 // SENSOR_ORIENTATION (<unidirectional association>)
	relation 15660727 --->
	  a role_name "SENSOR_ORIENTATION" init_value "
            new Key<Integer>(\"android.sensor.orientation\", int.class)" class_relation const_relation public
	    comment "
<p>Clockwise angle through which the output image needs to be rotated to be
upright on the device screen in its native orientation.</p>
<p>Also defines the direction of rolling shutter readout, which is from top to bottom in
the sensor's coordinate system.</p>
<p><b>Units</b>: Degrees of clockwise rotation; always a multiple of
90</p>
<p><b>Range of valid values:</b><br>
0, 90, 180, 270</p>
<p>This key is available on all devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15660727 // SENSOR_ORIENTATION (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15660855 // SENSOR_AVAILABLE_TEST_PATTERN_MODES (<unidirectional association>)
	relation 15660855 --->
	  a role_name "SENSOR_AVAILABLE_TEST_PATTERN_MODES" init_value "
            new Key<int[]>(\"android.sensor.availableTestPatternModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of sensor test pattern modes for {@link CaptureRequest#SENSOR_TEST_PATTERN_MODE android.sensor.testPatternMode}
supported by this camera device.</p>
<p>Defaults to OFF, and always includes OFF if defined.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#SENSOR_TEST_PATTERN_MODE android.sensor.testPatternMode}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#SENSOR_TEST_PATTERN_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15660855 // SENSOR_AVAILABLE_TEST_PATTERN_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15660983 // SENSOR_OPTICAL_BLACK_REGIONS (<unidirectional association>)
	relation 15660983 --->
	  a role_name "SENSOR_OPTICAL_BLACK_REGIONS" init_value "
            new Key<android.graphics.Rect[]>(\"android.sensor.opticalBlackRegions\", android.graphics.Rect[].class)" class_relation const_relation public
	    comment "
<p>List of disjoint rectangles indicating the sensor
optically shielded black pixel regions.</p>
<p>In most camera sensors, the active array is surrounded by some
optically shielded pixel areas. By blocking light, these pixels
provides a reliable black reference for black level compensation
in active array region.</p>
<p>This key provides a list of disjoint rectangles specifying the
regions of optically shielded (with metal shield) black pixel
regions if the camera device is capable of reading out these black
pixels in the output raw images. In comparison to the fixed black
level values reported by {@link CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern}, this key
may provide a more accurate way for the application to calculate
black level of each captured raw images.</p>
<p>When this key is reported, the {@link CaptureResult#SENSOR_DYNAMIC_BLACK_LEVEL android.sensor.dynamicBlackLevel} and
{@link CaptureResult#SENSOR_DYNAMIC_WHITE_LEVEL android.sensor.dynamicWhiteLevel} will also be reported.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN
@see CaptureResult#SENSOR_DYNAMIC_BLACK_LEVEL
@see CaptureResult#SENSOR_DYNAMIC_WHITE_LEVEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.graphics.Rect[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15660983 // SENSOR_OPTICAL_BLACK_REGIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15661111 // SHADING_AVAILABLE_MODES (<unidirectional association>)
	relation 15661111 --->
	  a role_name "SHADING_AVAILABLE_MODES" init_value "
            new Key<int[]>(\"android.shading.availableModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of lens shading modes for {@link CaptureRequest#SHADING_MODE android.shading.mode} that are supported by this camera device.</p>
<p>This list contains lens shading modes that can be set for the camera device.
Camera devices that support the MANUAL_POST_PROCESSING capability will always
list OFF and FAST mode. This includes all FULL level devices.
LEGACY devices will always only support FAST mode.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#SHADING_MODE android.shading.mode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#SHADING_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15661111 // SHADING_AVAILABLE_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15661239 // STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES (<unidirectional association>)
	relation 15661239 --->
	  a role_name "STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES" init_value "
            new Key<int[]>(\"android.statistics.info.availableFaceDetectModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of face detection modes for {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} that are
supported by this camera device.</p>
<p>OFF is always supported.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode}</p>
<p>This key is available on all devices.</p>

@see CaptureRequest#STATISTICS_FACE_DETECT_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15661239 // STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15661367 // STATISTICS_INFO_MAX_FACE_COUNT (<unidirectional association>)
	relation 15661367 --->
	  a role_name "STATISTICS_INFO_MAX_FACE_COUNT" init_value "
            new Key<Integer>(\"android.statistics.info.maxFaceCount\", int.class)" class_relation const_relation public
	    comment "
<p>The maximum number of simultaneously detectable
faces.</p>
<p><b>Range of valid values:</b><br>
0 for cameras without available face detection; otherwise:
<code>&gt;=4</code> for LIMITED or FULL hwlevel devices or
<code>&gt;0</code> for LEGACY devices.</p>
<p>This key is available on all devices.</p>

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15661367 // STATISTICS_INFO_MAX_FACE_COUNT (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15661495 // STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES (<unidirectional association>)
	relation 15661495 --->
	  a role_name "STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES" init_value "
            new Key<boolean[]>(\"android.statistics.info.availableHotPixelMapModes\", boolean[].class)" class_relation const_relation public
	    comment "
<p>List of hot pixel map output modes for {@link CaptureRequest#STATISTICS_HOT_PIXEL_MAP_MODE android.statistics.hotPixelMapMode} that are
supported by this camera device.</p>
<p>If no hotpixel map output is available for this camera device, this will contain only
<code>false</code>.</p>
<p>ON is always supported on devices with the RAW capability.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#STATISTICS_HOT_PIXEL_MAP_MODE android.statistics.hotPixelMapMode}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#STATISTICS_HOT_PIXEL_MAP_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<boolean[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15661495 // STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15661623 // STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES (<unidirectional association>)
	relation 15661623 --->
	  a role_name "STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES" init_value "
            new Key<int[]>(\"android.statistics.info.availableLensShadingMapModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of lens shading map output modes for {@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode} that
are supported by this camera device.</p>
<p>If no lens shading map output is available for this camera device, this key will
contain only OFF.</p>
<p>ON is always supported on devices with the RAW capability.
LEGACY mode devices will always only support OFF.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>

@see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15661623 // STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15661751 // TONEMAP_MAX_CURVE_POINTS (<unidirectional association>)
	relation 15661751 --->
	  a role_name "TONEMAP_MAX_CURVE_POINTS" init_value "
            new Key<Integer>(\"android.tonemap.maxCurvePoints\", int.class)" class_relation const_relation public
	    comment "
<p>Maximum number of supported points in the
tonemap curve that can be used for {@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}.</p>
<p>If the actual number of points provided by the application (in {@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}*) is
less than this maximum, the camera device will resample the curve to its internal
representation, using linear interpolation.</p>
<p>The output curves in the result metadata may have a different number
of points than the input curves, and will represent the actual
hardware curves used as closely as possible when linearly interpolated.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#TONEMAP_CURVE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15661751 // TONEMAP_MAX_CURVE_POINTS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15661879 // TONEMAP_AVAILABLE_TONE_MAP_MODES (<unidirectional association>)
	relation 15661879 --->
	  a role_name "TONEMAP_AVAILABLE_TONE_MAP_MODES" init_value "
            new Key<int[]>(\"android.tonemap.availableToneMapModes\", int[].class)" class_relation const_relation public
	    comment "
<p>List of tonemapping modes for {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} that are supported by this camera
device.</p>
<p>Camera devices that support the MANUAL_POST_PROCESSING capability will always contain
at least one of below mode combinations:</p>
<ul>
<li>CONTRAST_CURVE, FAST and HIGH_QUALITY</li>
<li>GAMMA_VALUE, PRESET_CURVE, FAST and HIGH_QUALITY</li>
</ul>
<p>This includes all FULL level devices.</p>
<p><b>Range of valid values:</b><br>
Any value listed in {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode}</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Full capability</b> -
Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#TONEMAP_MODE

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15661879 // TONEMAP_AVAILABLE_TONE_MAP_MODES (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15662007 // LED_AVAILABLE_LEDS (<unidirectional association>)
	relation 15662007 --->
	  a role_name "LED_AVAILABLE_LEDS" init_value "
            new Key<int[]>(\"android.led.availableLeds\", int[].class)" class_relation const_relation public
	    comment "
<p>A list of camera LEDs that are available on this system.</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #LED_AVAILABLE_LEDS_TRANSMIT TRANSMIT}</li>
</ul></p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
@see #LED_AVAILABLE_LEDS_TRANSMIT
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<int[]> ${name}${value};
"
	    classrelation_ref 15662007 // LED_AVAILABLE_LEDS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15662135 // INFO_SUPPORTED_HARDWARE_LEVEL (<unidirectional association>)
	relation 15662135 --->
	  a role_name "INFO_SUPPORTED_HARDWARE_LEVEL" init_value "
            new Key<Integer>(\"android.info.supportedHardwareLevel\", int.class)" class_relation const_relation public
	    comment "
<p>Generally classifies the overall set of the camera device functionality.</p>
<p>The supported hardware level is a high-level description of the camera device's
capabilities, summarizing several capabilities into one field.  Each level adds additional
features to the previous one, and is always a strict superset of the previous level.
The ordering is <code>LEGACY &lt; LIMITED &lt; FULL &lt; LEVEL_3</code>.</p>
<p>Starting from <code>LEVEL_3</code>, the level enumerations are guaranteed to be in increasing
numerical value as well. To check if a given device is at least at a given hardware level,
the following code snippet can be used:</p>
<pre><code>// Returns true if the device supports the required hardware level, or better.
boolean isHardwareLevelSupported(CameraCharacteristics c, int requiredLevel) {
    int deviceLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);
    if (deviceLevel == CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY) {
        return requiredLevel == deviceLevel;
    }
    // deviceLevel is not LEGACY, can use numerical sort
    return requiredLevel &lt;= deviceLevel;
}
</code></pre>
<p>At a high level, the levels are:</p>
<ul>
<li><code>LEGACY</code> devices operate in a backwards-compatibility mode for older
  Android devices, and have very limited capabilities.</li>
<li><code>LIMITED</code> devices represent the
  baseline feature set, and may also include additional capabilities that are
  subsets of <code>FULL</code>.</li>
<li><code>FULL</code> devices additionally support per-frame manual control of sensor, flash, lens and
  post-processing settings, and image capture at a high rate.</li>
<li><code>LEVEL_3</code> devices additionally support YUV reprocessing and RAW image capture, along
  with additional output stream configurations.</li>
</ul>
<p>See the individual level enums for full descriptions of the supported capabilities.  The
{@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} entry describes the device's capabilities at a
finer-grain level, if needed. In addition, many controls have their available settings or
ranges defined in individual {@link android.hardware.camera2.CameraCharacteristics } entries.</p>
<p>Some features are not part of any particular hardware level or capability and must be
queried separately. These include:</p>
<ul>
<li>Calibrated timestamps ({@link CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE android.sensor.info.timestampSource} <code>==</code> REALTIME)</li>
<li>Precision lens control ({@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration} <code>==</code> CALIBRATED)</li>
<li>Face detection ({@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES android.statistics.info.availableFaceDetectModes})</li>
<li>Optical or electrical image stabilization
  ({@link CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION android.lens.info.availableOpticalStabilization},
   {@link CameraCharacteristics#CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES android.control.availableVideoStabilizationModes})</li>
</ul>
<p><b>Possible values:</b>
<ul>
  <li>{@link #INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED LIMITED}</li>
  <li>{@link #INFO_SUPPORTED_HARDWARE_LEVEL_FULL FULL}</li>
  <li>{@link #INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY LEGACY}</li>
  <li>{@link #INFO_SUPPORTED_HARDWARE_LEVEL_3 3}</li>
</ul></p>
<p>This key is available on all devices.</p>

@see CameraCharacteristics#CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES
@see CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION
@see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE
@see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES
@see #INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED
@see #INFO_SUPPORTED_HARDWARE_LEVEL_FULL
@see #INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY
@see #INFO_SUPPORTED_HARDWARE_LEVEL_3

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15662135 // INFO_SUPPORTED_HARDWARE_LEVEL (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15662263 // SYNC_MAX_LATENCY (<unidirectional association>)
	relation 15662263 --->
	  a role_name "SYNC_MAX_LATENCY" init_value "
            new Key<Integer>(\"android.sync.maxLatency\", int.class)" class_relation const_relation public
	    comment "
<p>The maximum number of frames that can occur after a request
(different than the previous) has been submitted, and before the
result's state becomes synchronized.</p>
<p>This defines the maximum distance (in number of metadata results),
between the frame number of the request that has new controls to apply
and the frame number of the result that has all the controls applied.</p>
<p>In other words this acts as an upper boundary for how many frames
must occur before the camera device knows for a fact that the new
submitted camera settings have been applied in outgoing frames.</p>
<p><b>Units</b>: Frame counts</p>
<p><b>Possible values:</b>
<ul>
  <li>{@link #SYNC_MAX_LATENCY_PER_FRAME_CONTROL PER_FRAME_CONTROL}</li>
  <li>{@link #SYNC_MAX_LATENCY_UNKNOWN UNKNOWN}</li>
</ul></p>
<p><b>Available values for this device:</b><br>
A positive value, PER_FRAME_CONTROL, or UNKNOWN.</p>
<p>This key is available on all devices.</p>
@see #SYNC_MAX_LATENCY_PER_FRAME_CONTROL
@see #SYNC_MAX_LATENCY_UNKNOWN

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15662263 // SYNC_MAX_LATENCY (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15662391 // REPROCESS_MAX_CAPTURE_STALL (<unidirectional association>)
	relation 15662391 --->
	  a role_name "REPROCESS_MAX_CAPTURE_STALL" init_value "
            new Key<Integer>(\"android.reprocess.maxCaptureStall\", int.class)" class_relation const_relation public
	    comment "
<p>The maximal camera capture pipeline stall (in unit of frame count) introduced by a
reprocess capture request.</p>
<p>The key describes the maximal interference that one reprocess (input) request
can introduce to the camera simultaneous streaming of regular (output) capture
requests, including repeating requests.</p>
<p>When a reprocessing capture request is submitted while a camera output repeating request
(e.g. preview) is being served by the camera device, it may preempt the camera capture
pipeline for at least one frame duration so that the camera device is unable to process
the following capture request in time for the next sensor start of exposure boundary.
When this happens, the application may observe a capture time gap (longer than one frame
duration) between adjacent capture output frames, which usually exhibits as preview
glitch if the repeating request output targets include a preview surface. This key gives
the worst-case number of frame stall introduced by one reprocess request with any kind of
formats/sizes combination.</p>
<p>If this key reports 0, it means a reprocess request doesn't introduce any glitch to the
ongoing camera repeating request outputs, as if this reprocess request is never issued.</p>
<p>This key is supported if the camera device supports PRIVATE or YUV reprocessing (
i.e. {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains PRIVATE_REPROCESSING or
YUV_REPROCESSING).</p>
<p><b>Units</b>: Number of frames.</p>
<p><b>Range of valid values:</b><br>
&lt;= 4</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Integer> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15662391 // REPROCESS_MAX_CAPTURE_STALL (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15662519 // DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS (<unidirectional association>)
	relation 15662519 --->
	  a role_name "DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS" init_value "
            new Key<android.hardware.camera2.params.StreamConfiguration[]>(\"android.depth.availableDepthStreamConfigurations\", android.hardware.camera2.params.StreamConfiguration[].class)" class_relation const_relation public
	    comment "
<p>The available depth dataspace stream
configurations that this camera device supports
(i.e. format, width, height, output/input stream).</p>
<p>These are output stream configurations for use with
dataSpace HAL_DATASPACE_DEPTH. The configurations are
listed as <code>(format, width, height, input?)</code> tuples.</p>
<p>Only devices that support depth output for at least
the HAL_PIXEL_FORMAT_Y16 dense depth map may include
this entry.</p>
<p>A device that also supports the HAL_PIXEL_FORMAT_BLOB
sparse depth point cloud must report a single entry for
the format in this list as <code>(HAL_PIXEL_FORMAT_BLOB,
android.depth.maxDepthSamples, 1, OUTPUT)</code> in addition to
the entries for HAL_PIXEL_FORMAT_Y16.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.StreamConfiguration[]> ${name}${value};
"
	    classrelation_ref 15662519 // DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15662647 // DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS (<unidirectional association>)
	relation 15662647 --->
	  a role_name "DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS" init_value "
            new Key<android.hardware.camera2.params.StreamConfigurationDuration[]>(\"android.depth.availableDepthMinFrameDurations\", android.hardware.camera2.params.StreamConfigurationDuration[].class)" class_relation const_relation public
	    comment "
<p>This lists the minimum frame duration for each
format/size combination for depth output formats.</p>
<p>This should correspond to the frame duration when only that
stream is active, with all processing (typically in android.*.mode)
set to either OFF or FAST.</p>
<p>When multiple streams are used in a request, the minimum frame
duration will be max(individual stream min durations).</p>
<p>The minimum frame duration of a stream (of a particular format, size)
is the same regardless of whether the stream is input or output.</p>
<p>See {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration} and
android.scaler.availableStallDurations for more details about
calculating the max frame rate.</p>
<p>(Keep in sync with {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration })</p>
<p><b>Units</b>: (format, width, height, ns) x n</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CaptureRequest#SENSOR_FRAME_DURATION
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.StreamConfigurationDuration[]> ${name}${value};
"
	    classrelation_ref 15662647 // DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15662775 // DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS (<unidirectional association>)
	relation 15662775 --->
	  a role_name "DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS" init_value "
            new Key<android.hardware.camera2.params.StreamConfigurationDuration[]>(\"android.depth.availableDepthStallDurations\", android.hardware.camera2.params.StreamConfigurationDuration[].class)" class_relation const_relation public
	    comment "
<p>This lists the maximum stall duration for each
output format/size combination for depth streams.</p>
<p>A stall duration is how much extra time would get added
to the normal minimum frame duration for a repeating request
that has streams with non-zero stall.</p>
<p>This functions similarly to
android.scaler.availableStallDurations for depth
streams.</p>
<p>All depth output stream formats may have a nonzero stall
duration.</p>
<p><b>Units</b>: (format, width, height, ns) x n</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@hide

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<android.hardware.camera2.params.StreamConfigurationDuration[]> ${name}${value};
"
	    classrelation_ref 15662775 // DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end

      classrelation 15662903 // DEPTH_DEPTH_IS_EXCLUSIVE (<unidirectional association>)
	relation 15662903 --->
	  a role_name "DEPTH_DEPTH_IS_EXCLUSIVE" init_value "
            new Key<Boolean>(\"android.depth.depthIsExclusive\", boolean.class)" class_relation const_relation public
	    comment "
<p>Indicates whether a capture request may target both a
DEPTH16 / DEPTH_POINT_CLOUD output, and normal color outputs (such as
YUV_420_888, JPEG, or RAW) simultaneously.</p>
<p>If TRUE, including both depth and color outputs in a single
capture request is not supported. An application must interleave color
and depth requests.  If FALSE, a single request can target both types
of output.</p>
<p>Typically, this restriction exists on camera devices that
need to emit a specific pattern or wavelength of light to
measure depth values, which causes the color image to be
corrupted during depth measurement.</p>
<p><b>Optional</b> - This value may be {@code null} on some devices.</p>
<p><b>Limited capability</b> -
Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the
{@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<Boolean> ${name}${value};
"
	    java_annotation "@PublicKey
"
	    classrelation_ref 15662903 // DEPTH_DEPTH_IS_EXCLUSIVE (<unidirectional association>)
	  b parent class_ref 7149111 // Key
      end
    end

    class 7148983 "CameraMetadata"
      abstract visibility public 
      nformals 1
      formal name "TKey" type "" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "The base class for camera controls and information.

<p>
This class defines the basic key/value map used for querying for camera
characteristics or capture results, and for setting camera request
parameters.
</p>

<p>
All instances of CameraMetadata are immutable. The list of keys with {@link #getKeys()}
never changes, nor do the values returned by any key with {@code #get} throughout
the lifetime of the object.
</p>

@see CameraDevice
@see CameraManager
@see CameraCharacteristics
"
      attribute 24773559 "DEBUG"
	class_attribute const_attribute private explicit_type "boolean"
	init_value " false"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 79321655 "CameraMetadata"
	cpp_inline protected explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Set a camera metadata field to a value. The field definitions can be
found in {@link CameraCharacteristics}, {@link CaptureResult}, and
{@link CaptureRequest}.

@param key The metadata field to write.
@param value The value to set the field to, which must be of a matching
type to the key.

@hide
"
      end

      operation 79321783 "getProtected"
	abstract cpp_inline protected explicit_return_type "T"
	nparams 1
	  param inout name "key" explicit_type "TKey"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Get a camera metadata field value.

<p>The field definitions can be
found in {@link CameraCharacteristics}, {@link CaptureResult}, and
{@link CaptureRequest}.</p>

<p>Querying the value for the same key more than once will return a value
which is equal to the previous queried value.</p>

@throws IllegalArgumentException if the key was not valid

@param key The metadata field to read.
@return The value of that key, or {@code null} if the field is not set.

@hide
"
      end

      operation 79321911 "getKeyClass"
	abstract cpp_inline protected explicit_return_type "Class"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<TKey> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@hide
"
      end

      operation 79322039 "getKeys"
	cpp_inline public explicit_return_type "List<TKey>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings(\"unchecked\")
@NonNull
"
	
	
	
	comment "Returns a list of the keys contained in this map.

<p>The list returned is not modifiable, so any attempts to modify it will throw
a {@code UnsupportedOperationException}.</p>

<p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
non-{@code null}. Each key is only listed once in the list. The order of the keys
is undefined.</p>

@return List of the keys contained in this map.
"
      end

      operation 79322167 "getKeysStatic"
	class_operation cpp_inline package explicit_return_type "ArrayList<TKey>"
	nparams 4
	  param inout name "type" explicit_type "Class"
	  param inout name "keyClass" explicit_type "Class"
	  param inout name "instance" type class_ref 7148983 // CameraMetadata
	  param inout name "filterTags" explicit_type "int"
	multiplicity "[]"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<TKey> ${type} ${name}${(}${t0}<?> ${p0}, ${t1}<TKey> ${p1}, ${t2}<TKey> ${p2}, ${t3}[] ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings(\"unchecked\")
"
	
	
	
	comment "Return a list of all the Key<?> that are declared as a field inside of the class
{@code type}.

<p>
Optionally, if {@code instance} is not null, then filter out any keys with null values.
</p>

<p>
Optionally, if {@code filterTags} is not {@code null}, then filter out any keys
whose native {@code tag} is not in {@code filterTags}. The {@code filterTags} array will be
sorted as a side effect.
</p>

package"
      end

      operation 79322295 "shouldKeyBeAdded"
	class_operation cpp_inline private explicit_return_type "boolean"
	nparams 3
	  param inout name "key" explicit_type "TKey"
	  param inout name "field" explicit_type "Field"
	  param inout name "filterTags" explicit_type "int"
	multiplicity "[]"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<TKey> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2}[] ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@SuppressWarnings(\"rawtypes\")
"
	
	
	
      end

      attribute 24773687 "LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@O~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~
The enum values below this point are generated from metadata
definitions in /system/media/camera/docs. Do not modify by hand or
modify the comment blocks at the start or end.
~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~

 Enumeration values for CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION


<p>The lens focus distance is not accurate, and the units used for
{@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} do not correspond to any physical units.</p>
<p>Setting the lens to the same focus distance on separate occasions may
result in a different real focus distance, depending on factors such
as the orientation of the device, the age of the focusing mechanism,
and the device temperature. The focus distance value will still be
in the range of <code>[0, {@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance}]</code>, where 0
represents the farthest focus.</p>

@see CaptureRequest#LENS_FOCUS_DISTANCE
@see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE
@see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION

"
      end

      attribute 24773815 "LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The lens focus distance is measured in diopters.</p>
<p>However, setting the lens to the same focus distance
on separate occasions may result in a different real
focus distance, depending on factors such as the
orientation of the device, the age of the focusing
mechanism, and the device temperature.</p>
@see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION

"
      end

      attribute 24773943 "LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The lens focus distance is measured in diopters, and
is calibrated.</p>
<p>The lens mechanism is calibrated so that setting the
same focus distance is repeatable on multiple
occasions with good accuracy, and the focus distance
corresponds to the real physical distance to the plane
of best focus.</p>
@see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION

"
      end

      attribute 24774071 "LENS_FACING_FRONT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CameraCharacteristics#LENS_FACING


<p>The camera device faces the same direction as the device's screen.</p>
@see CameraCharacteristics#LENS_FACING

"
      end

      attribute 24774199 "LENS_FACING_BACK"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device faces the opposite direction as the device's screen.</p>
@see CameraCharacteristics#LENS_FACING

"
      end

      attribute 24774327 "LENS_FACING_EXTERNAL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device is an external camera, and has no fixed facing relative to the
device's screen.</p>
@see CameraCharacteristics#LENS_FACING

"
      end

      attribute 24774455 "REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES


<p>The minimal set of capabilities that every camera
device (regardless of {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel})
supports.</p>
<p>This capability is listed by all normal devices, and
indicates that the camera device has a feature set
that's comparable to the baseline requirements for the
older android.hardware.Camera API.</p>
<p>Devices with the DEPTH_OUTPUT capability might not list this
capability, indicating that they support only depth measurement,
not standard color output.</p>

@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
      end

      attribute 24774583 "REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device can be manually controlled (3A algorithms such
as auto-exposure, and auto-focus can be bypassed).
The camera device supports basic manual control of the sensor image
acquisition related stages. This means the following controls are
guaranteed to be supported:</p>
<ul>
<li>Manual frame duration control<ul>
<li>{@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}</li>
<li>{@link CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration}</li>
</ul>
</li>
<li>Manual exposure control<ul>
<li>{@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime}</li>
<li>{@link CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange}</li>
</ul>
</li>
<li>Manual sensitivity control<ul>
<li>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</li>
<li>{@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}</li>
</ul>
</li>
<li>Manual lens control (if the lens is adjustable)<ul>
<li>android.lens.*</li>
</ul>
</li>
<li>Manual flash control (if a flash unit is present)<ul>
<li>android.flash.*</li>
</ul>
</li>
<li>Manual black level locking<ul>
<li>{@link CaptureRequest#BLACK_LEVEL_LOCK android.blackLevel.lock}</li>
</ul>
</li>
<li>Auto exposure lock<ul>
<li>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock}</li>
</ul>
</li>
</ul>
<p>If any of the above 3A algorithms are enabled, then the camera
device will accurately report the values applied by 3A in the
result.</p>
<p>A given camera device may also support additional manual sensor controls,
but this capability only covers the above list of controls.</p>
<p>If this is supported, {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap} will
additionally return a min frame duration that is greater than
zero for each supported size-format combination.</p>

@see CaptureRequest#BLACK_LEVEL_LOCK
@see CaptureRequest#CONTROL_AE_LOCK
@see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_FRAME_DURATION
@see CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE
@see CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION
@see CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE
@see CaptureRequest#SENSOR_SENSITIVITY
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
      end

      attribute 24774711 "REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device post-processing stages can be manually controlled.
The camera device supports basic manual control of the image post-processing
stages. This means the following controls are guaranteed to be supported:</p>
<ul>
<li>
<p>Manual tonemap control</p>
<ul>
<li>{@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}</li>
<li>{@link CaptureRequest#TONEMAP_MODE android.tonemap.mode}</li>
<li>{@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}</li>
<li>{@link CaptureRequest#TONEMAP_GAMMA android.tonemap.gamma}</li>
<li>{@link CaptureRequest#TONEMAP_PRESET_CURVE android.tonemap.presetCurve}</li>
</ul>
</li>
<li>
<p>Manual white balance control</p>
<ul>
<li>{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}</li>
<li>{@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains}</li>
</ul>
</li>
<li>Manual lens shading map control<ul>
<li>{@link CaptureRequest#SHADING_MODE android.shading.mode}</li>
<li>{@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode}</li>
<li>android.statistics.lensShadingMap</li>
<li>android.lens.info.shadingMapSize</li>
</ul>
</li>
<li>Manual aberration correction control (if aberration correction is supported)<ul>
<li>{@link CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE android.colorCorrection.aberrationMode}</li>
<li>{@link CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES android.colorCorrection.availableAberrationModes}</li>
</ul>
</li>
<li>Auto white balance lock<ul>
<li>{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock}</li>
</ul>
</li>
</ul>
<p>If auto white balance is enabled, then the camera device
will accurately report the values applied by AWB in the result.</p>
<p>A given camera device may also support additional post-processing
controls, but this capability only covers the above list of controls.</p>

@see CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE
@see CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES
@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_LOCK
@see CaptureRequest#SHADING_MODE
@see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE
@see CaptureRequest#TONEMAP_CURVE
@see CaptureRequest#TONEMAP_GAMMA
@see CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS
@see CaptureRequest#TONEMAP_MODE
@see CaptureRequest#TONEMAP_PRESET_CURVE
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
      end

      attribute 24774839 "REQUEST_AVAILABLE_CAPABILITIES_RAW"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device supports outputting RAW buffers and
metadata for interpreting them.</p>
<p>Devices supporting the RAW capability allow both for
saving DNG files, and for direct application processing of
raw sensor images.</p>
<ul>
<li>RAW_SENSOR is supported as an output format.</li>
<li>The maximum available resolution for RAW_SENSOR streams
  will match either the value in
  {@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize} or
  {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.</li>
<li>All DNG-related optional metadata entries are provided
  by the camera device.</li>
</ul>

@see CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE
@see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
      end

      attribute 24774967 "REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device supports the Zero Shutter Lag reprocessing use case.</p>
<ul>
<li>One input stream is supported, that is, <code>{@link CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS android.request.maxNumInputStreams} == 1</code>.</li>
<li>{@link android.graphics.ImageFormat#PRIVATE } is supported as an output/input format,
  that is, {@link android.graphics.ImageFormat#PRIVATE } is included in the lists of
  formats returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats } and {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputFormats }.</li>
<li>{@link android.hardware.camera2.params.StreamConfigurationMap#getValidOutputFormatsForInput }
  returns non empty int[] for each supported input format returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats }.</li>
<li>Each size returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputSizes getInputSizes(ImageFormat.PRIVATE)} is also included in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes getOutputSizes(ImageFormat.PRIVATE)}</li>
<li>Using {@link android.graphics.ImageFormat#PRIVATE } does not cause a frame rate drop
  relative to the sensor's maximum capture rate (at that resolution).</li>
<li>{@link android.graphics.ImageFormat#PRIVATE } will be reprocessable into both
  {@link android.graphics.ImageFormat#YUV_420_888 } and
  {@link android.graphics.ImageFormat#JPEG } formats.</li>
<li>The maximum available resolution for PRIVATE streams
  (both input/output) will match the maximum available
  resolution of JPEG streams.</li>
<li>Static metadata {@link CameraCharacteristics#REPROCESS_MAX_CAPTURE_STALL android.reprocess.maxCaptureStall}.</li>
<li>Only below controls are effective for reprocessing requests and
  will be present in capture results, other controls in reprocess
  requests will be ignored by the camera device.<ul>
<li>android.jpeg.*</li>
<li>{@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode}</li>
<li>{@link CaptureRequest#EDGE_MODE android.edge.mode}</li>
</ul>
</li>
<li>{@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes} and
  {@link CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES android.edge.availableEdgeModes} will both list ZERO_SHUTTER_LAG as a supported mode.</li>
</ul>

@see CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES
@see CaptureRequest#EDGE_MODE
@see CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES
@see CaptureRequest#NOISE_REDUCTION_MODE
@see CameraCharacteristics#REPROCESS_MAX_CAPTURE_STALL
@see CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
      end

      attribute 24775095 "REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS"
	class_attribute const_attribute public explicit_type "int"
	init_value " 5"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device supports accurately reporting the sensor settings for many of
the sensor controls while the built-in 3A algorithm is running.  This allows
reporting of sensor settings even when these settings cannot be manually changed.</p>
<p>The values reported for the following controls are guaranteed to be available
in the CaptureResult, including when 3A is enabled:</p>
<ul>
<li>Exposure control<ul>
<li>{@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime}</li>
</ul>
</li>
<li>Sensitivity control<ul>
<li>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</li>
</ul>
</li>
<li>Lens controls (if the lens is adjustable)<ul>
<li>{@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance}</li>
<li>{@link CaptureRequest#LENS_APERTURE android.lens.aperture}</li>
</ul>
</li>
</ul>
<p>This capability is a subset of the MANUAL_SENSOR control capability, and will
always be included if the MANUAL_SENSOR capability is available.</p>

@see CaptureRequest#LENS_APERTURE
@see CaptureRequest#LENS_FOCUS_DISTANCE
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_SENSITIVITY
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
      end

      attribute 24775223 "REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 6"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device supports capturing high-resolution images at &gt;= 20 frames per
second, in at least the uncompressed YUV format, when post-processing settings are set
to FAST. Additionally, maximum-resolution images can be captured at &gt;= 10 frames
per second.  Here, 'high resolution' means at least 8 megapixels, or the maximum
resolution of the device, whichever is smaller.</p>
<p>More specifically, this means that a size matching the camera device's active array
size is listed as a supported size for the {@link android.graphics.ImageFormat#YUV_420_888 } format in either {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes } or {@link android.hardware.camera2.params.StreamConfigurationMap#getHighResolutionOutputSizes },
with a minimum frame duration for that format and size of either &lt;= 1/20 s, or
&lt;= 1/10 s, respectively; and the {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges} entry
lists at least one FPS range where the minimum FPS is &gt;= 1 / minimumFrameDuration
for the maximum-size YUV_420_888 format.  If that maximum size is listed in {@link android.hardware.camera2.params.StreamConfigurationMap#getHighResolutionOutputSizes },
then the list of resolutions for YUV_420_888 from {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes } contains at
least one resolution &gt;= 8 megapixels, with a minimum frame duration of &lt;= 1/20
s.</p>
<p>If the device supports the {@link android.graphics.ImageFormat#RAW10 }, {@link android.graphics.ImageFormat#RAW12 }, then those can also be captured at the same rate
as the maximum-size YUV_420_888 resolution is.</p>
<p>If the device supports the PRIVATE_REPROCESSING capability, then the same guarantees
as for the YUV_420_888 format also apply to the {@link android.graphics.ImageFormat#PRIVATE } format.</p>
<p>In addition, the {@link CameraCharacteristics#SYNC_MAX_LATENCY android.sync.maxLatency} field is guaranted to have a value between 0
and 4, inclusive. {@link CameraCharacteristics#CONTROL_AE_LOCK_AVAILABLE android.control.aeLockAvailable} and {@link CameraCharacteristics#CONTROL_AWB_LOCK_AVAILABLE android.control.awbLockAvailable}
are also guaranteed to be <code>true</code> so burst capture with these two locks ON yields
consistent image output.</p>

@see CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES
@see CameraCharacteristics#CONTROL_AE_LOCK_AVAILABLE
@see CameraCharacteristics#CONTROL_AWB_LOCK_AVAILABLE
@see CameraCharacteristics#SYNC_MAX_LATENCY
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
      end

      attribute 24775351 "REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING"
	class_attribute const_attribute public explicit_type "int"
	init_value " 7"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device supports the YUV_420_888 reprocessing use case, similar as
PRIVATE_REPROCESSING, This capability requires the camera device to support the
following:</p>
<ul>
<li>One input stream is supported, that is, <code>{@link CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS android.request.maxNumInputStreams} == 1</code>.</li>
<li>{@link android.graphics.ImageFormat#YUV_420_888 } is supported as an output/input format, that is,
  YUV_420_888 is included in the lists of formats returned by
  {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats } and
  {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputFormats }.</li>
<li>{@link android.hardware.camera2.params.StreamConfigurationMap#getValidOutputFormatsForInput }
  returns non-empty int[] for each supported input format returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats }.</li>
<li>Each size returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputSizes getInputSizes(YUV_420_888)} is also included in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes getOutputSizes(YUV_420_888)}</li>
<li>Using {@link android.graphics.ImageFormat#YUV_420_888 } does not cause a frame rate drop
  relative to the sensor's maximum capture rate (at that resolution).</li>
<li>{@link android.graphics.ImageFormat#YUV_420_888 } will be reprocessable into both
  {@link android.graphics.ImageFormat#YUV_420_888 } and {@link android.graphics.ImageFormat#JPEG } formats.</li>
<li>The maximum available resolution for {@link android.graphics.ImageFormat#YUV_420_888 } streams (both input/output) will match the
  maximum available resolution of {@link android.graphics.ImageFormat#JPEG } streams.</li>
<li>Static metadata {@link CameraCharacteristics#REPROCESS_MAX_CAPTURE_STALL android.reprocess.maxCaptureStall}.</li>
<li>Only the below controls are effective for reprocessing requests and will be present
  in capture results. The reprocess requests are from the original capture results that
  are associated with the intermediate {@link android.graphics.ImageFormat#YUV_420_888 }
  output buffers.  All other controls in the reprocess requests will be ignored by the
  camera device.<ul>
<li>android.jpeg.*</li>
<li>{@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode}</li>
<li>{@link CaptureRequest#EDGE_MODE android.edge.mode}</li>
<li>{@link CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor}</li>
</ul>
</li>
<li>{@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes} and
  {@link CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES android.edge.availableEdgeModes} will both list ZERO_SHUTTER_LAG as a supported mode.</li>
</ul>

@see CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES
@see CaptureRequest#EDGE_MODE
@see CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES
@see CaptureRequest#NOISE_REDUCTION_MODE
@see CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR
@see CameraCharacteristics#REPROCESS_MAX_CAPTURE_STALL
@see CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
      end

      attribute 24775479 "REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 8"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device can produce depth measurements from its field of view.</p>
<p>This capability requires the camera device to support the following:</p>
<ul>
<li>{@link android.graphics.ImageFormat#DEPTH16 } is supported as an output format.</li>
<li>{@link android.graphics.ImageFormat#DEPTH_POINT_CLOUD } is optionally supported as an
  output format.</li>
<li>This camera device, and all camera devices with the same {@link CameraCharacteristics#LENS_FACING android.lens.facing},
  will list the following calibration entries in both
  {@link android.hardware.camera2.CameraCharacteristics } and
  {@link android.hardware.camera2.CaptureResult }:<ul>
<li>{@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}</li>
<li>{@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation}</li>
<li>{@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration}</li>
<li>{@link CameraCharacteristics#LENS_RADIAL_DISTORTION android.lens.radialDistortion}</li>
</ul>
</li>
<li>The {@link CameraCharacteristics#DEPTH_DEPTH_IS_EXCLUSIVE android.depth.depthIsExclusive} entry is listed by this device.</li>
<li>A LIMITED camera with only the DEPTH_OUTPUT capability does not have to support
  normal YUV_420_888, JPEG, and PRIV-format outputs. It only has to support the DEPTH16
  format.</li>
</ul>
<p>Generally, depth output operates at a slower frame rate than standard color capture,
so the DEPTH16 and DEPTH_POINT_CLOUD formats will commonly have a stall duration that
should be accounted for (see
{@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration }).
On a device that supports both depth and color-based output, to enable smooth preview,
using a repeating burst is recommended, where a depth-output target is only included
once every N frames, where N is the ratio between preview output rate and depth output
rate, including depth stall time.</p>

@see CameraCharacteristics#DEPTH_DEPTH_IS_EXCLUSIVE
@see CameraCharacteristics#LENS_FACING
@see CameraCharacteristics#LENS_INTRINSIC_CALIBRATION
@see CameraCharacteristics#LENS_POSE_ROTATION
@see CameraCharacteristics#LENS_POSE_TRANSLATION
@see CameraCharacteristics#LENS_RADIAL_DISTORTION
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
      end

      attribute 24775607 "REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO"
	class_attribute const_attribute public explicit_type "int"
	init_value " 9"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The device supports constrained high speed video recording (frame rate &gt;=120fps)
use case. The camera device will support high speed capture session created by
{@link android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession }, which
only accepts high speed request lists created by
{@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList }.</p>
<p>A camera device can still support high speed video streaming by advertising the high speed
FPS ranges in {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges}. For this case, all normal
capture request per frame control and synchronization requirements will apply to
the high speed fps ranges, the same as all other fps ranges. This capability describes
the capability of a specialized operating mode with many limitations (see below), which
is only targeted at high speed video recording.</p>
<p>The supported high speed video sizes and fps ranges are specified in
{@link android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoFpsRanges }.
To get desired output frame rates, the application is only allowed to select video size
and FPS range combinations provided by
{@link android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoSizes }.
The fps range can be controlled via {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange}.</p>
<p>In this capability, the camera device will override aeMode, awbMode, and afMode to
ON, AUTO, and CONTINUOUS_VIDEO, respectively. All post-processing block mode
controls will be overridden to be FAST. Therefore, no manual control of capture
and post-processing parameters is possible. All other controls operate the
same as when {@link CaptureRequest#CONTROL_MODE android.control.mode} == AUTO. This means that all other
android.control.* fields continue to work, such as</p>
<ul>
<li>{@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange}</li>
<li>{@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation}</li>
<li>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock}</li>
<li>{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock}</li>
<li>{@link CaptureRequest#CONTROL_EFFECT_MODE android.control.effectMode}</li>
<li>{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}</li>
<li>{@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}</li>
<li>{@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions}</li>
<li>{@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}</li>
<li>{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}</li>
</ul>
<p>Outside of android.control.*, the following controls will work:</p>
<ul>
<li>{@link CaptureRequest#FLASH_MODE android.flash.mode} (TORCH mode only, automatic flash for still capture will not
work since aeMode is ON)</li>
<li>{@link CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode} (if it is supported)</li>
<li>{@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}</li>
<li>{@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} (if it is supported)</li>
</ul>
<p>For high speed recording use case, the actual maximum supported frame rate may
be lower than what camera can output, depending on the destination Surfaces for
the image data. For example, if the destination surface is from video encoder,
the application need check if the video encoder is capable of supporting the
high frame rate for a given video size, or it will end up with lower recording
frame rate. If the destination surface is from preview window, the actual preview frame
rate will be bounded by the screen refresh rate.</p>
<p>The camera device will only support up to 2 high speed simultaneous output surfaces
(preview and recording surfaces)
in this mode. Above controls will be effective only if all of below conditions are true:</p>
<ul>
<li>The application creates a camera capture session with no more than 2 surfaces via
{@link android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession }. The
targeted surfaces must be preview surface (either from
{@link android.view.SurfaceView } or {@link android.graphics.SurfaceTexture }) or
recording surface(either from {@link android.media.MediaRecorder#getSurface } or
{@link android.media.MediaCodec#createInputSurface }).</li>
<li>The stream sizes are selected from the sizes reported by
{@link android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoSizes }.</li>
<li>The FPS ranges are selected from
{@link android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoFpsRanges }.</li>
</ul>
<p>When above conditions are NOT satistied,
{@link android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession }
will fail.</p>
<p>Switching to a FPS range that has different maximum FPS may trigger some camera device
reconfigurations, which may introduce extra latency. It is recommended that
the application avoids unnecessary maximum target FPS changes as much as possible
during high speed streaming.</p>

@see CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES
@see CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION
@see CaptureRequest#CONTROL_AE_LOCK
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureRequest#CONTROL_AE_REGIONS
@see CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE
@see CaptureRequest#CONTROL_AF_REGIONS
@see CaptureRequest#CONTROL_AF_TRIGGER
@see CaptureRequest#CONTROL_AWB_LOCK
@see CaptureRequest#CONTROL_AWB_REGIONS
@see CaptureRequest#CONTROL_EFFECT_MODE
@see CaptureRequest#CONTROL_MODE
@see CaptureRequest#FLASH_MODE
@see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE
@see CaptureRequest#SCALER_CROP_REGION
@see CaptureRequest#STATISTICS_FACE_DETECT_MODE
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES

"
      end

      attribute 24775735 "SCALER_CROPPING_TYPE_CENTER_ONLY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CameraCharacteristics#SCALER_CROPPING_TYPE


<p>The camera device only supports centered crop regions.</p>
@see CameraCharacteristics#SCALER_CROPPING_TYPE

"
      end

      attribute 24775863 "SCALER_CROPPING_TYPE_FREEFORM"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device supports arbitrarily chosen crop regions.</p>
@see CameraCharacteristics#SCALER_CROPPING_TYPE

"
      end

      attribute 24775991 "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT


@see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT

"
      end

      attribute 24776119 "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT

"
      end

      attribute 24776247 "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT

"
      end

      attribute 24776375 "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT

"
      end

      attribute 24776503 "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Sensor is not Bayer; output has 3 16-bit
values for each pixel, instead of just 1 16-bit value
per pixel.</p>
@see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT

"
      end

      attribute 24776631 "SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE


<p>Timestamps from {@link CaptureResult#SENSOR_TIMESTAMP android.sensor.timestamp} are in nanoseconds and monotonic,
but can not be compared to timestamps from other subsystems
(e.g. accelerometer, gyro etc.), or other instances of the same or different
camera devices in the same system. Timestamps between streams and results for
a single camera instance are comparable, and the timestamps for all buffers
and the result metadata generated by a single capture are identical.</p>

@see CaptureResult#SENSOR_TIMESTAMP
@see CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE

"
      end

      attribute 24776759 "SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Timestamps from {@link CaptureResult#SENSOR_TIMESTAMP android.sensor.timestamp} are in the same timebase as
{@link android.os.SystemClock#elapsedRealtimeNanos },
and they can be compared to other timestamps using that base.</p>

@see CaptureResult#SENSOR_TIMESTAMP
@see CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE

"
      end

      attribute 24776887 "SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1


@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24777015 "SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24777143 "SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Incandescent light</p>
@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24777271 "SENSOR_REFERENCE_ILLUMINANT1_FLASH"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24777399 "SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER"
	class_attribute const_attribute public explicit_type "int"
	init_value " 9"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24777527 "SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER"
	class_attribute const_attribute public explicit_type "int"
	init_value " 10"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24777655 "SENSOR_REFERENCE_ILLUMINANT1_SHADE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 11"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24777783 "SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 12"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>D 5700 - 7100K</p>
@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24777911 "SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 13"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>N 4600 - 5400K</p>
@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24778039 "SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 14"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>W 3900 - 4500K</p>
@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24778167 "SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 15"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>WW 3200 - 3700K</p>
@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24778295 "SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A"
	class_attribute const_attribute public explicit_type "int"
	init_value " 17"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24778423 "SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B"
	class_attribute const_attribute public explicit_type "int"
	init_value " 18"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24778551 "SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C"
	class_attribute const_attribute public explicit_type "int"
	init_value " 19"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24778679 "SENSOR_REFERENCE_ILLUMINANT1_D55"
	class_attribute const_attribute public explicit_type "int"
	init_value " 20"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24778807 "SENSOR_REFERENCE_ILLUMINANT1_D65"
	class_attribute const_attribute public explicit_type "int"
	init_value " 21"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24778935 "SENSOR_REFERENCE_ILLUMINANT1_D75"
	class_attribute const_attribute public explicit_type "int"
	init_value " 22"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24779063 "SENSOR_REFERENCE_ILLUMINANT1_D50"
	class_attribute const_attribute public explicit_type "int"
	init_value " 23"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24779191 "SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN"
	class_attribute const_attribute public explicit_type "int"
	init_value " 24"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "@see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1

"
      end

      attribute 24779319 "LED_AVAILABLE_LEDS_TRANSMIT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CameraCharacteristics#LED_AVAILABLE_LEDS


<p>android.led.transmit control is used.</p>
@see CameraCharacteristics#LED_AVAILABLE_LEDS
@hide

"
      end

      attribute 24779447 "INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL


<p>This camera device does not have enough capabilities to qualify as a <code>FULL</code> device or
better.</p>
<p>Only the stream configurations listed in the <code>LEGACY</code> and <code>LIMITED</code> tables in the
{@link android.hardware.camera2.CameraDevice#createCaptureSession createCaptureSession} documentation are guaranteed to be supported.</p>
<p>All <code>LIMITED</code> devices support the <code>BACKWARDS_COMPATIBLE</code> capability, indicating basic
support for color image capture. The only exception is that the device may
alternatively support only the <code>DEPTH_OUTPUT</code> capability, if it can only output depth
measurements and not color images.</p>
<p><code>LIMITED</code> devices and above require the use of {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}
to lock exposure metering (and calculate flash power, for cameras with flash) before
capturing a high-quality still image.</p>
<p>A <code>LIMITED</code> device that only lists the <code>BACKWARDS_COMPATIBLE</code> capability is only
required to support full-automatic operation and post-processing (<code>OFF</code> is not
supported for {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}, {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}, or
{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode})</p>
<p>Additional capabilities may optionally be supported by a <code>LIMITED</code>-level device, and
can be checked for in {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities}.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureRequest#CONTROL_AF_MODE
@see CaptureRequest#CONTROL_AWB_MODE
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
      end

      attribute 24779575 "INFO_SUPPORTED_HARDWARE_LEVEL_FULL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>This camera device is capable of supporting advanced imaging applications.</p>
<p>The stream configurations listed in the <code>FULL</code>, <code>LEGACY</code> and <code>LIMITED</code> tables in the
{@link android.hardware.camera2.CameraDevice#createCaptureSession createCaptureSession} documentation are guaranteed to be supported.</p>
<p>A <code>FULL</code> device will support below capabilities:</p>
<ul>
<li><code>BURST_CAPTURE</code> capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains
  <code>BURST_CAPTURE</code>)</li>
<li>Per frame control ({@link CameraCharacteristics#SYNC_MAX_LATENCY android.sync.maxLatency} <code>==</code> PER_FRAME_CONTROL)</li>
<li>Manual sensor control ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains <code>MANUAL_SENSOR</code>)</li>
<li>Manual post-processing control ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains
  <code>MANUAL_POST_PROCESSING</code>)</li>
<li>The required exposure time range defined in {@link CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange}</li>
<li>The required maxFrameDuration defined in {@link CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration}</li>
</ul>
<p>Note:
Pre-API level 23, FULL devices also supported arbitrary cropping region
({@link CameraCharacteristics#SCALER_CROPPING_TYPE android.scaler.croppingType} <code>== FREEFORM</code>); this requirement was relaxed in API level
23, and <code>FULL</code> devices may only support <code>CENTERED</code> cropping.</p>

@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CameraCharacteristics#SCALER_CROPPING_TYPE
@see CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE
@see CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION
@see CameraCharacteristics#SYNC_MAX_LATENCY
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
      end

      attribute 24779703 "INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>This camera device is running in backward compatibility mode.</p>
<p>Only the stream configurations listed in the <code>LEGACY</code> table in the {@link android.hardware.camera2.CameraDevice#createCaptureSession createCaptureSession}
documentation are supported.</p>
<p>A <code>LEGACY</code> device does not support per-frame control, manual sensor control, manual
post-processing, arbitrary cropping regions, and has relaxed performance constraints.
No additional capabilities beyond <code>BACKWARD_COMPATIBLE</code> will ever be listed by a
<code>LEGACY</code> device in {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities}.</p>
<p>In addition, the {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is not functional on <code>LEGACY</code>
devices. Instead, every request that includes a JPEG-format output target is treated
as triggering a still capture, internally executing a precapture trigger.  This may
fire the flash for flash power metering during precapture, and then fire the flash
for the final capture, if a flash is available on the device and the AE mode is set to
enable the flash.</p>

@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
      end

      attribute 24779831 "INFO_SUPPORTED_HARDWARE_LEVEL_3"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>This camera device is capable of YUV reprocessing and RAW data capture, in addition to
FULL-level capabilities.</p>
<p>The stream configurations listed in the <code>LEVEL_3</code>, <code>RAW</code>, <code>FULL</code>, <code>LEGACY</code> and
<code>LIMITED</code> tables in the {@link android.hardware.camera2.CameraDevice#createCaptureSession createCaptureSession}
documentation are guaranteed to be supported.</p>
<p>The following additional capabilities are guaranteed to be supported:</p>
<ul>
<li><code>YUV_REPROCESSING</code> capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains
  <code>YUV_REPROCESSING</code>)</li>
<li><code>RAW</code> capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains
  <code>RAW</code>)</li>
</ul>

@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL

"
      end

      attribute 24779959 "SYNC_MAX_LATENCY_PER_FRAME_CONTROL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CameraCharacteristics#SYNC_MAX_LATENCY


<p>Every frame has the requests immediately applied.</p>
<p>Changing controls over multiple requests one after another will
produce results that have those controls applied atomically
each frame.</p>
<p>All FULL capability devices will have this as their maxLatency.</p>
@see CameraCharacteristics#SYNC_MAX_LATENCY

"
      end

      attribute 24780087 "SYNC_MAX_LATENCY_UNKNOWN"
	class_attribute const_attribute public explicit_type "int"
	init_value " -1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Each new frame has some subset (potentially the entire set)
of the past requests applied to the camera settings.</p>
<p>By submitting a series of identical requests, the camera device
will eventually have the camera settings applied, but it is
unknown when that exact point will be.</p>
<p>All LEGACY capability devices will have this as their maxLatency.</p>
@see CameraCharacteristics#SYNC_MAX_LATENCY

"
      end

      attribute 24780215 "COLOR_CORRECTION_MODE_TRANSFORM_MATRIX"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#COLOR_CORRECTION_MODE


<p>Use the {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} matrix
and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} to do color conversion.</p>
<p>All advanced white balance adjustments (not specified
by our white balance pipeline) must be disabled.</p>
<p>If AWB is enabled with <code>{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} != OFF</code>, then
TRANSFORM_MATRIX is ignored. The camera device will override
this value to either FAST or HIGH_QUALITY.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE
@see CaptureRequest#COLOR_CORRECTION_MODE

"
      end

      attribute 24780343 "COLOR_CORRECTION_MODE_FAST"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Color correction processing must not slow down
capture rate relative to sensor raw output.</p>
<p>Advanced white balance adjustments above and beyond
the specified white balance pipeline may be applied.</p>
<p>If AWB is enabled with <code>{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} != OFF</code>, then
the camera device uses the last frame's AWB values
(or defaults if AWB has never been run).</p>

@see CaptureRequest#CONTROL_AWB_MODE
@see CaptureRequest#COLOR_CORRECTION_MODE

"
      end

      attribute 24780471 "COLOR_CORRECTION_MODE_HIGH_QUALITY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Color correction processing operates at improved
quality but the capture rate might be reduced (relative to sensor
raw output rate)</p>
<p>Advanced white balance adjustments above and beyond
the specified white balance pipeline may be applied.</p>
<p>If AWB is enabled with <code>{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} != OFF</code>, then
the camera device uses the last frame's AWB values
(or defaults if AWB has never been run).</p>

@see CaptureRequest#CONTROL_AWB_MODE
@see CaptureRequest#COLOR_CORRECTION_MODE

"
      end

      attribute 24780599 "COLOR_CORRECTION_ABERRATION_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE


<p>No aberration correction is applied.</p>
@see CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE

"
      end

      attribute 24780727 "COLOR_CORRECTION_ABERRATION_MODE_FAST"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Aberration correction will not slow down capture rate
relative to sensor raw output.</p>
@see CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE

"
      end

      attribute 24780855 "COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Aberration correction operates at improved quality but the capture rate might be
reduced (relative to sensor raw output rate)</p>
@see CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE

"
      end

      attribute 24780983 "CONTROL_AE_ANTIBANDING_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_AE_ANTIBANDING_MODE


<p>The camera device will not adjust exposure duration to
avoid banding problems.</p>
@see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE

"
      end

      attribute 24781111 "CONTROL_AE_ANTIBANDING_MODE_50HZ"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device will adjust exposure duration to
avoid banding problems with 50Hz illumination sources.</p>
@see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE

"
      end

      attribute 24781239 "CONTROL_AE_ANTIBANDING_MODE_60HZ"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device will adjust exposure duration to
avoid banding problems with 60Hz illumination
sources.</p>
@see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE

"
      end

      attribute 24781367 "CONTROL_AE_ANTIBANDING_MODE_AUTO"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device will automatically adapt its
antibanding routine to the current illumination
condition. This is the default mode if AUTO is
available on given camera device.</p>
@see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE

"
      end

      attribute 24781495 "CONTROL_AE_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_AE_MODE


<p>The camera device's autoexposure routine is disabled.</p>
<p>The application-selected {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},
{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity} and
{@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration} are used by the camera
device, along with android.flash.* fields, if there's
a flash unit for this camera device.</p>
<p>Note that auto-white balance (AWB) and auto-focus (AF)
behavior is device dependent when AE is in OFF mode.
To have consistent behavior across different devices,
it is recommended to either set AWB and AF to OFF mode
or lock AWB and AF before setting AE to OFF.
See {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode},
{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock}, and {@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}
for more details.</p>
<p>LEGACY devices do not support the OFF mode and will
override attempts to use this value to ON.</p>

@see CaptureRequest#CONTROL_AF_MODE
@see CaptureRequest#CONTROL_AF_TRIGGER
@see CaptureRequest#CONTROL_AWB_LOCK
@see CaptureRequest#CONTROL_AWB_MODE
@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_FRAME_DURATION
@see CaptureRequest#SENSOR_SENSITIVITY
@see CaptureRequest#CONTROL_AE_MODE

"
      end

      attribute 24781623 "CONTROL_AE_MODE_ON"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device's autoexposure routine is active,
with no flash control.</p>
<p>The application's values for
{@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},
{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, and
{@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration} are ignored. The
application has control over the various
android.flash.* fields.</p>

@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_FRAME_DURATION
@see CaptureRequest#SENSOR_SENSITIVITY
@see CaptureRequest#CONTROL_AE_MODE

"
      end

      attribute 24781751 "CONTROL_AE_MODE_ON_AUTO_FLASH"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Like ON, except that the camera device also controls
the camera's flash unit, firing it in low-light
conditions.</p>
<p>The flash may be fired during a precapture sequence
(triggered by {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}) and
may be fired for captures for which the
{@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} field is set to
STILL_CAPTURE</p>

@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureRequest#CONTROL_CAPTURE_INTENT
@see CaptureRequest#CONTROL_AE_MODE

"
      end

      attribute 24781879 "CONTROL_AE_MODE_ON_ALWAYS_FLASH"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Like ON, except that the camera device also controls
the camera's flash unit, always firing it for still
captures.</p>
<p>The flash may be fired during a precapture sequence
(triggered by {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}) and
will always be fired for captures for which the
{@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} field is set to
STILL_CAPTURE</p>

@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureRequest#CONTROL_CAPTURE_INTENT
@see CaptureRequest#CONTROL_AE_MODE

"
      end

      attribute 24782007 "CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Like ON_AUTO_FLASH, but with automatic red eye
reduction.</p>
<p>If deemed necessary by the camera device, a red eye
reduction flash will fire during the precapture
sequence.</p>
@see CaptureRequest#CONTROL_AE_MODE

"
      end

      attribute 24782135 "CONTROL_AE_PRECAPTURE_TRIGGER_IDLE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER


<p>The trigger is idle.</p>
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER

"
      end

      attribute 24782263 "CONTROL_AE_PRECAPTURE_TRIGGER_START"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The precapture metering sequence will be started
by the camera device.</p>
<p>The exact effect of the precapture trigger depends on
the current AE mode and state.</p>
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER

"
      end

      attribute 24782391 "CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device will cancel any currently active or completed
precapture metering sequence, the auto-exposure routine will return to its
initial state.</p>
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER

"
      end

      attribute 24782519 "CONTROL_AF_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_AF_MODE


<p>The auto-focus routine does not control the lens;
{@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} is controlled by the
application.</p>

@see CaptureRequest#LENS_FOCUS_DISTANCE
@see CaptureRequest#CONTROL_AF_MODE

"
      end

      attribute 24782647 "CONTROL_AF_MODE_AUTO"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Basic automatic focus mode.</p>
<p>In this mode, the lens does not move unless
the autofocus trigger action is called. When that trigger
is activated, AF will transition to ACTIVE_SCAN, then to
the outcome of the scan (FOCUSED or NOT_FOCUSED).</p>
<p>Always supported if lens is not fixed focus.</p>
<p>Use {@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance} to determine if lens
is fixed-focus.</p>
<p>Triggering AF_CANCEL resets the lens position to default,
and sets the AF state to INACTIVE.</p>

@see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE
@see CaptureRequest#CONTROL_AF_MODE

"
      end

      attribute 24782775 "CONTROL_AF_MODE_MACRO"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Close-up focusing mode.</p>
<p>In this mode, the lens does not move unless the
autofocus trigger action is called. When that trigger is
activated, AF will transition to ACTIVE_SCAN, then to
the outcome of the scan (FOCUSED or NOT_FOCUSED). This
mode is optimized for focusing on objects very close to
the camera.</p>
<p>When that trigger is activated, AF will transition to
ACTIVE_SCAN, then to the outcome of the scan (FOCUSED or
NOT_FOCUSED). Triggering cancel AF resets the lens
position to default, and sets the AF state to
INACTIVE.</p>
@see CaptureRequest#CONTROL_AF_MODE

"
      end

      attribute 24782903 "CONTROL_AF_MODE_CONTINUOUS_VIDEO"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>In this mode, the AF algorithm modifies the lens
position continually to attempt to provide a
constantly-in-focus image stream.</p>
<p>The focusing behavior should be suitable for good quality
video recording; typically this means slower focus
movement and no overshoots. When the AF trigger is not
involved, the AF algorithm should start in INACTIVE state,
and then transition into PASSIVE_SCAN and PASSIVE_FOCUSED
states as appropriate. When the AF trigger is activated,
the algorithm should immediately transition into
AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the
lens position until a cancel AF trigger is received.</p>
<p>Once cancel is received, the algorithm should transition
back to INACTIVE and resume passive scan. Note that this
behavior is not identical to CONTINUOUS_PICTURE, since an
ongoing PASSIVE_SCAN must immediately be
canceled.</p>
@see CaptureRequest#CONTROL_AF_MODE

"
      end

      attribute 24783031 "CONTROL_AF_MODE_CONTINUOUS_PICTURE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>In this mode, the AF algorithm modifies the lens
position continually to attempt to provide a
constantly-in-focus image stream.</p>
<p>The focusing behavior should be suitable for still image
capture; typically this means focusing as fast as
possible. When the AF trigger is not involved, the AF
algorithm should start in INACTIVE state, and then
transition into PASSIVE_SCAN and PASSIVE_FOCUSED states as
appropriate as it attempts to maintain focus. When the AF
trigger is activated, the algorithm should finish its
PASSIVE_SCAN if active, and then transition into
AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the
lens position until a cancel AF trigger is received.</p>
<p>When the AF cancel trigger is activated, the algorithm
should transition back to INACTIVE and then act as if it
has just been started.</p>
@see CaptureRequest#CONTROL_AF_MODE

"
      end

      attribute 24783159 "CONTROL_AF_MODE_EDOF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 5"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Extended depth of field (digital focus) mode.</p>
<p>The camera device will produce images with an extended
depth of field automatically; no special focusing
operations need to be done before taking a picture.</p>
<p>AF triggers are ignored, and the AF state will always be
INACTIVE.</p>
@see CaptureRequest#CONTROL_AF_MODE

"
      end

      attribute 24783287 "CONTROL_AF_TRIGGER_IDLE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_AF_TRIGGER


<p>The trigger is idle.</p>
@see CaptureRequest#CONTROL_AF_TRIGGER

"
      end

      attribute 24783415 "CONTROL_AF_TRIGGER_START"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Autofocus will trigger now.</p>
@see CaptureRequest#CONTROL_AF_TRIGGER

"
      end

      attribute 24783543 "CONTROL_AF_TRIGGER_CANCEL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Autofocus will return to its initial
state, and cancel any currently active trigger.</p>
@see CaptureRequest#CONTROL_AF_TRIGGER

"
      end

      attribute 24783671 "CONTROL_AWB_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_AWB_MODE


<p>The camera device's auto-white balance routine is disabled.</p>
<p>The application-selected color transform matrix
({@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}) and gains
({@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains}) are used by the camera
device for manual white balance control.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE

"
      end

      attribute 24783799 "CONTROL_AWB_MODE_AUTO"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device's auto-white balance routine is active.</p>
<p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}
and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.
For devices that support the MANUAL_POST_PROCESSING capability, the
values used by the camera device for the transform and gains
will be available in the capture result for this request.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE

"
      end

      attribute 24783927 "CONTROL_AWB_MODE_INCANDESCENT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device's auto-white balance routine is disabled;
the camera device uses incandescent light as the assumed scene
illumination for white balance.</p>
<p>While the exact white balance transforms are up to the
camera device, they will approximately match the CIE
standard illuminant A.</p>
<p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}
and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.
For devices that support the MANUAL_POST_PROCESSING capability, the
values used by the camera device for the transform and gains
will be available in the capture result for this request.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE

"
      end

      attribute 24784055 "CONTROL_AWB_MODE_FLUORESCENT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device's auto-white balance routine is disabled;
the camera device uses fluorescent light as the assumed scene
illumination for white balance.</p>
<p>While the exact white balance transforms are up to the
camera device, they will approximately match the CIE
standard illuminant F2.</p>
<p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}
and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.
For devices that support the MANUAL_POST_PROCESSING capability, the
values used by the camera device for the transform and gains
will be available in the capture result for this request.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE

"
      end

      attribute 24784183 "CONTROL_AWB_MODE_WARM_FLUORESCENT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device's auto-white balance routine is disabled;
the camera device uses warm fluorescent light as the assumed scene
illumination for white balance.</p>
<p>While the exact white balance transforms are up to the
camera device, they will approximately match the CIE
standard illuminant F4.</p>
<p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}
and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.
For devices that support the MANUAL_POST_PROCESSING capability, the
values used by the camera device for the transform and gains
will be available in the capture result for this request.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE

"
      end

      attribute 24784311 "CONTROL_AWB_MODE_DAYLIGHT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 5"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device's auto-white balance routine is disabled;
the camera device uses daylight light as the assumed scene
illumination for white balance.</p>
<p>While the exact white balance transforms are up to the
camera device, they will approximately match the CIE
standard illuminant D65.</p>
<p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}
and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.
For devices that support the MANUAL_POST_PROCESSING capability, the
values used by the camera device for the transform and gains
will be available in the capture result for this request.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE

"
      end

      attribute 24784439 "CONTROL_AWB_MODE_CLOUDY_DAYLIGHT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 6"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device's auto-white balance routine is disabled;
the camera device uses cloudy daylight light as the assumed scene
illumination for white balance.</p>
<p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}
and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.
For devices that support the MANUAL_POST_PROCESSING capability, the
values used by the camera device for the transform and gains
will be available in the capture result for this request.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE

"
      end

      attribute 24784567 "CONTROL_AWB_MODE_TWILIGHT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 7"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device's auto-white balance routine is disabled;
the camera device uses twilight light as the assumed scene
illumination for white balance.</p>
<p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}
and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.
For devices that support the MANUAL_POST_PROCESSING capability, the
values used by the camera device for the transform and gains
will be available in the capture result for this request.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE

"
      end

      attribute 24784695 "CONTROL_AWB_MODE_SHADE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 8"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device's auto-white balance routine is disabled;
the camera device uses shade light as the assumed scene
illumination for white balance.</p>
<p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}
and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.
For devices that support the MANUAL_POST_PROCESSING capability, the
values used by the camera device for the transform and gains
will be available in the capture result for this request.</p>

@see CaptureRequest#COLOR_CORRECTION_GAINS
@see CaptureRequest#COLOR_CORRECTION_TRANSFORM
@see CaptureRequest#CONTROL_AWB_MODE

"
      end

      attribute 24784823 "CONTROL_CAPTURE_INTENT_CUSTOM"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_CAPTURE_INTENT


<p>The goal of this request doesn't fall into the other
categories. The camera device will default to preview-like
behavior.</p>
@see CaptureRequest#CONTROL_CAPTURE_INTENT

"
      end

      attribute 24784951 "CONTROL_CAPTURE_INTENT_PREVIEW"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>This request is for a preview-like use case.</p>
<p>The precapture trigger may be used to start off a metering
w/flash sequence.</p>
@see CaptureRequest#CONTROL_CAPTURE_INTENT

"
      end

      attribute 24785079 "CONTROL_CAPTURE_INTENT_STILL_CAPTURE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>This request is for a still capture-type
use case.</p>
<p>If the flash unit is under automatic control, it may fire as needed.</p>
@see CaptureRequest#CONTROL_CAPTURE_INTENT

"
      end

      attribute 24785207 "CONTROL_CAPTURE_INTENT_VIDEO_RECORD"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>This request is for a video recording
use case.</p>
@see CaptureRequest#CONTROL_CAPTURE_INTENT

"
      end

      attribute 24785335 "CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>This request is for a video snapshot (still
image while recording video) use case.</p>
<p>The camera device should take the highest-quality image
possible (given the other settings) without disrupting the
frame rate of video recording.  </p>
@see CaptureRequest#CONTROL_CAPTURE_INTENT

"
      end

      attribute 24785463 "CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG"
	class_attribute const_attribute public explicit_type "int"
	init_value " 5"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>This request is for a ZSL usecase; the
application will stream full-resolution images and
reprocess one or several later for a final
capture.</p>
@see CaptureRequest#CONTROL_CAPTURE_INTENT

"
      end

      attribute 24785591 "CONTROL_CAPTURE_INTENT_MANUAL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 6"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>This request is for manual capture use case where
the applications want to directly control the capture parameters.</p>
<p>For example, the application may wish to manually control
{@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime}, {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, etc.</p>

@see CaptureRequest#SENSOR_EXPOSURE_TIME
@see CaptureRequest#SENSOR_SENSITIVITY
@see CaptureRequest#CONTROL_CAPTURE_INTENT

"
      end

      attribute 24785719 "CONTROL_EFFECT_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_EFFECT_MODE


<p>No color effect will be applied.</p>
@see CaptureRequest#CONTROL_EFFECT_MODE

"
      end

      attribute 24785847 "CONTROL_EFFECT_MODE_MONO"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>A \"monocolor\" effect where the image is mapped into
a single color.</p>
<p>This will typically be grayscale.</p>
@see CaptureRequest#CONTROL_EFFECT_MODE

"
      end

      attribute 24785975 "CONTROL_EFFECT_MODE_NEGATIVE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>A \"photo-negative\" effect where the image's colors
are inverted.</p>
@see CaptureRequest#CONTROL_EFFECT_MODE

"
      end

      attribute 24786103 "CONTROL_EFFECT_MODE_SOLARIZE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>A \"solarisation\" effect (Sabattier effect) where the
image is wholly or partially reversed in
tone.</p>
@see CaptureRequest#CONTROL_EFFECT_MODE

"
      end

      attribute 24786231 "CONTROL_EFFECT_MODE_SEPIA"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>A \"sepia\" effect where the image is mapped into warm
gray, red, and brown tones.</p>
@see CaptureRequest#CONTROL_EFFECT_MODE

"
      end

      attribute 24786359 "CONTROL_EFFECT_MODE_POSTERIZE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 5"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>A \"posterization\" effect where the image uses
discrete regions of tone rather than a continuous
gradient of tones.</p>
@see CaptureRequest#CONTROL_EFFECT_MODE

"
      end

      attribute 24786487 "CONTROL_EFFECT_MODE_WHITEBOARD"
	class_attribute const_attribute public explicit_type "int"
	init_value " 6"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>A \"whiteboard\" effect where the image is typically displayed
as regions of white, with black or grey details.</p>
@see CaptureRequest#CONTROL_EFFECT_MODE

"
      end

      attribute 24786615 "CONTROL_EFFECT_MODE_BLACKBOARD"
	class_attribute const_attribute public explicit_type "int"
	init_value " 7"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>A \"blackboard\" effect where the image is typically displayed
as regions of black, with white or grey details.</p>
@see CaptureRequest#CONTROL_EFFECT_MODE

"
      end

      attribute 24786743 "CONTROL_EFFECT_MODE_AQUA"
	class_attribute const_attribute public explicit_type "int"
	init_value " 8"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>An \"aqua\" effect where a blue hue is added to the image.</p>
@see CaptureRequest#CONTROL_EFFECT_MODE

"
      end

      attribute 24786871 "CONTROL_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_MODE


<p>Full application control of pipeline.</p>
<p>All control by the device's metering and focusing (3A)
routines is disabled, and no other settings in
android.control.* have any effect, except that
{@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} may be used by the camera
device to select post-processing values for processing
blocks that do not allow for manual control, or are not
exposed by the camera API.</p>
<p>However, the camera device's 3A routines may continue to
collect statistics and update their internal state so that
when control is switched to AUTO mode, good control values
can be immediately applied.</p>

@see CaptureRequest#CONTROL_CAPTURE_INTENT
@see CaptureRequest#CONTROL_MODE

"
      end

      attribute 24786999 "CONTROL_MODE_AUTO"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Use settings for each individual 3A routine.</p>
<p>Manual control of capture parameters is disabled. All
controls in android.control.* besides sceneMode take
effect.</p>
@see CaptureRequest#CONTROL_MODE

"
      end

      attribute 24787127 "CONTROL_MODE_USE_SCENE_MODE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Use a specific scene mode.</p>
<p>Enabling this disables control.aeMode, control.awbMode and
control.afMode controls; the camera device will ignore
those settings while USE_SCENE_MODE is active (except for
FACE_PRIORITY scene mode). Other control entries are still active.
This setting can only be used if scene mode is supported (i.e.
{@link CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES android.control.availableSceneModes}
contain some modes other than DISABLED).</p>

@see CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES
@see CaptureRequest#CONTROL_MODE

"
      end

      attribute 24787255 "CONTROL_MODE_OFF_KEEP_STATE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Same as OFF mode, except that this capture will not be
used by camera device background auto-exposure, auto-white balance and
auto-focus algorithms (3A) to update their statistics.</p>
<p>Specifically, the 3A routines are locked to the last
values set from a request with AUTO, OFF, or
USE_SCENE_MODE, and any statistics or state updates
collected from manual captures with OFF_KEEP_STATE will be
discarded by the camera device.</p>
@see CaptureRequest#CONTROL_MODE

"
      end

      attribute 24787383 "CONTROL_SCENE_MODE_DISABLED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_SCENE_MODE


<p>Indicates that no scene modes are set for a given capture request.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24787511 "CONTROL_SCENE_MODE_FACE_PRIORITY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>If face detection support exists, use face
detection data for auto-focus, auto-white balance, and
auto-exposure routines.</p>
<p>If face detection statistics are disabled
(i.e. {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} is set to OFF),
this should still operate correctly (but will not return
face detection statistics to the framework).</p>
<p>Unlike the other scene modes, {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode},
{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, and {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}
remain active when FACE_PRIORITY is set.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AF_MODE
@see CaptureRequest#CONTROL_AWB_MODE
@see CaptureRequest#STATISTICS_FACE_DETECT_MODE
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24787639 "CONTROL_SCENE_MODE_ACTION"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for photos of quickly moving objects.</p>
<p>Similar to SPORTS.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24787767 "CONTROL_SCENE_MODE_PORTRAIT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for still photos of people.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24787895 "CONTROL_SCENE_MODE_LANDSCAPE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for photos of distant macroscopic objects.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24788023 "CONTROL_SCENE_MODE_NIGHT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 5"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for low-light settings.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24788151 "CONTROL_SCENE_MODE_NIGHT_PORTRAIT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 6"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for still photos of people in low-light
settings.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24788279 "CONTROL_SCENE_MODE_THEATRE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 7"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for dim, indoor settings where flash must
remain off.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24788407 "CONTROL_SCENE_MODE_BEACH"
	class_attribute const_attribute public explicit_type "int"
	init_value " 8"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for bright, outdoor beach settings.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24788535 "CONTROL_SCENE_MODE_SNOW"
	class_attribute const_attribute public explicit_type "int"
	init_value " 9"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for bright, outdoor settings containing snow.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24788663 "CONTROL_SCENE_MODE_SUNSET"
	class_attribute const_attribute public explicit_type "int"
	init_value " 10"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for scenes of the setting sun.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24788791 "CONTROL_SCENE_MODE_STEADYPHOTO"
	class_attribute const_attribute public explicit_type "int"
	init_value " 11"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized to avoid blurry photos due to small amounts of
device motion (for example: due to hand shake).</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24788919 "CONTROL_SCENE_MODE_FIREWORKS"
	class_attribute const_attribute public explicit_type "int"
	init_value " 12"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for nighttime photos of fireworks.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24789047 "CONTROL_SCENE_MODE_SPORTS"
	class_attribute const_attribute public explicit_type "int"
	init_value " 13"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for photos of quickly moving people.</p>
<p>Similar to ACTION.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24789175 "CONTROL_SCENE_MODE_PARTY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 14"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for dim, indoor settings with multiple moving
people.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24789303 "CONTROL_SCENE_MODE_CANDLELIGHT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 15"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for dim settings where the main light source
is a flame.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24789431 "CONTROL_SCENE_MODE_BARCODE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 16"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optimized for accurately capturing a photo of barcode
for use by camera applications that wish to read the
barcode value.</p>
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24789559 "CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO"
	class_attribute const_attribute public explicit_type "int"
	init_value " 17"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>This is deprecated, please use {@link android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession }
and {@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList }
for high speed video recording.</p>
<p>Optimized for high speed video recording (frame rate &gt;=60fps) use case.</p>
<p>The supported high speed video sizes and fps ranges are specified in
android.control.availableHighSpeedVideoConfigurations. To get desired
output frame rates, the application is only allowed to select video size
and fps range combinations listed in this static metadata. The fps range
can be control via {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange}.</p>
<p>In this mode, the camera device will override aeMode, awbMode, and afMode to
ON, ON, and CONTINUOUS_VIDEO, respectively. All post-processing block mode
controls will be overridden to be FAST. Therefore, no manual control of capture
and post-processing parameters is possible. All other controls operate the
same as when {@link CaptureRequest#CONTROL_MODE android.control.mode} == AUTO. This means that all other
android.control.* fields continue to work, such as</p>
<ul>
<li>{@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange}</li>
<li>{@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation}</li>
<li>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock}</li>
<li>{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock}</li>
<li>{@link CaptureRequest#CONTROL_EFFECT_MODE android.control.effectMode}</li>
<li>{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}</li>
<li>{@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}</li>
<li>{@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions}</li>
<li>{@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}</li>
<li>{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}</li>
</ul>
<p>Outside of android.control.*, the following controls will work:</p>
<ul>
<li>{@link CaptureRequest#FLASH_MODE android.flash.mode} (automatic flash for still capture will not work since aeMode is ON)</li>
<li>{@link CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode} (if it is supported)</li>
<li>{@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}</li>
<li>{@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode}</li>
</ul>
<p>For high speed recording use case, the actual maximum supported frame rate may
be lower than what camera can output, depending on the destination Surfaces for
the image data. For example, if the destination surface is from video encoder,
the application need check if the video encoder is capable of supporting the
high frame rate for a given video size, or it will end up with lower recording
frame rate. If the destination surface is from preview window, the preview frame
rate will be bounded by the screen refresh rate.</p>
<p>The camera device will only support up to 2 output high speed streams
(processed non-stalling format defined in android.request.maxNumOutputStreams)
in this mode. This control will be effective only if all of below conditions are true:</p>
<ul>
<li>The application created no more than maxNumHighSpeedStreams processed non-stalling
format output streams, where maxNumHighSpeedStreams is calculated as
min(2, android.request.maxNumOutputStreams[Processed (but not-stalling)]).</li>
<li>The stream sizes are selected from the sizes reported by
android.control.availableHighSpeedVideoConfigurations.</li>
<li>No processed non-stalling or raw streams are configured.</li>
</ul>
<p>When above conditions are NOT satistied, the controls of this mode and
{@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange} will be ignored by the camera device,
the camera device will fall back to {@link CaptureRequest#CONTROL_MODE android.control.mode} <code>==</code> AUTO,
and the returned capture result metadata will give the fps range choosen
by the camera device.</p>
<p>Switching into or out of this mode may trigger some camera ISP/sensor
reconfigurations, which may introduce extra latency. It is recommended that
the application avoids unnecessary scene mode switch as much as possible.</p>

@see CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION
@see CaptureRequest#CONTROL_AE_LOCK
@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureRequest#CONTROL_AE_REGIONS
@see CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE
@see CaptureRequest#CONTROL_AF_REGIONS
@see CaptureRequest#CONTROL_AF_TRIGGER
@see CaptureRequest#CONTROL_AWB_LOCK
@see CaptureRequest#CONTROL_AWB_REGIONS
@see CaptureRequest#CONTROL_EFFECT_MODE
@see CaptureRequest#CONTROL_MODE
@see CaptureRequest#FLASH_MODE
@see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE
@see CaptureRequest#SCALER_CROP_REGION
@see CaptureRequest#STATISTICS_FACE_DETECT_MODE
@see CaptureRequest#CONTROL_SCENE_MODE
@deprecated Please refer to this API documentation to find the alternatives

"
      end

      attribute 24789687 "CONTROL_SCENE_MODE_HDR"
	class_attribute const_attribute public explicit_type "int"
	init_value " 18"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Turn on a device-specific high dynamic range (HDR) mode.</p>
<p>In this scene mode, the camera device captures images
that keep a larger range of scene illumination levels
visible in the final image. For example, when taking a
picture of a object in front of a bright window, both
the object and the scene through the window may be
visible when using HDR mode, while in normal AUTO mode,
one or the other may be poorly exposed. As a tradeoff,
HDR mode generally takes much longer to capture a single
image, has no user control, and may have other artifacts
depending on the HDR method used.</p>
<p>Therefore, HDR captures operate at a much slower rate
than regular captures.</p>
<p>In this mode, on LIMITED or FULL devices, when a request
is made with a {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} of
STILL_CAPTURE, the camera device will capture an image
using a high dynamic range capture technique.  On LEGACY
devices, captures that target a JPEG-format output will
be captured with HDR, and the capture intent is not
relevant.</p>
<p>The HDR capture may involve the device capturing a burst
of images internally and combining them into one, or it
may involve the device using specialized high dynamic
range capture hardware. In all cases, a single image is
produced in response to a capture request submitted
while in HDR mode.</p>
<p>Since substantial post-processing is generally needed to
produce an HDR image, only YUV, PRIVATE, and JPEG
outputs are supported for LIMITED/FULL device HDR
captures, and only JPEG outputs are supported for LEGACY
HDR captures. Using a RAW output for HDR capture is not
supported.</p>
<p>Some devices may also support always-on HDR, which
applies HDR processing at full frame rate.  For these
devices, intents other than STILL_CAPTURE will also
produce an HDR output with no frame rate impact compared
to normal operation, though the quality may be lower
than for STILL_CAPTURE intents.</p>
<p>If SCENE_MODE_HDR is used with unsupported output types
or capture intents, the images captured will be as if
the SCENE_MODE was not enabled at all.</p>

@see CaptureRequest#CONTROL_CAPTURE_INTENT
@see CaptureRequest#CONTROL_SCENE_MODE

"
      end

      attribute 24789815 "CONTROL_SCENE_MODE_FACE_PRIORITY_LOW_LIGHT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 19"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Same as FACE_PRIORITY scene mode, except that the camera
device will choose higher sensitivity values ({@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity})
under low light conditions.</p>
<p>The camera device may be tuned to expose the images in a reduced
sensitivity range to produce the best quality images. For example,
if the {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange} gives range of [100, 1600],
the camera device auto-exposure routine tuning process may limit the actual
exposure sensitivity range to [100, 1200] to ensure that the noise level isn't
exessive in order to preserve the image quality. Under this situation, the image under
low light may be under-exposed when the sensor max exposure time (bounded by the
{@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange} when {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is one of the
ON_* modes) and effective max sensitivity are reached. This scene mode allows the
camera device auto-exposure routine to increase the sensitivity up to the max
sensitivity specified by {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange} when the scene is too
dark and the max exposure time is reached. The captured images may be noisier
compared with the images captured in normal FACE_PRIORITY mode; therefore, it is
recommended that the application only use this scene mode when it is capable of
reducing the noise level of the captured images.</p>
<p>Unlike the other scene modes, {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode},
{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, and {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}
remain active when FACE_PRIORITY_LOW_LIGHT is set.</p>

@see CaptureRequest#CONTROL_AE_MODE
@see CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE
@see CaptureRequest#CONTROL_AF_MODE
@see CaptureRequest#CONTROL_AWB_MODE
@see CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE
@see CaptureRequest#SENSOR_SENSITIVITY
@see CaptureRequest#CONTROL_SCENE_MODE
@hide

"
      end

      attribute 24789943 "CONTROL_SCENE_MODE_DEVICE_CUSTOM_START"
	class_attribute const_attribute public explicit_type "int"
	init_value " 100"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Scene mode values within the range of
<code>[DEVICE_CUSTOM_START, DEVICE_CUSTOM_END]</code> are reserved for device specific
customized scene modes.</p>
@see CaptureRequest#CONTROL_SCENE_MODE
@hide

"
      end

      attribute 24790071 "CONTROL_SCENE_MODE_DEVICE_CUSTOM_END"
	class_attribute const_attribute public explicit_type "int"
	init_value " 127"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Scene mode values within the range of
<code>[DEVICE_CUSTOM_START, DEVICE_CUSTOM_END]</code> are reserved for device specific
customized scene modes.</p>
@see CaptureRequest#CONTROL_SCENE_MODE
@hide

"
      end

      attribute 24790199 "CONTROL_VIDEO_STABILIZATION_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE


<p>Video stabilization is disabled.</p>
@see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE

"
      end

      attribute 24790327 "CONTROL_VIDEO_STABILIZATION_MODE_ON"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Video stabilization is enabled.</p>
@see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE

"
      end

      attribute 24790455 "EDGE_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#EDGE_MODE


<p>No edge enhancement is applied.</p>
@see CaptureRequest#EDGE_MODE

"
      end

      attribute 24790583 "EDGE_MODE_FAST"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Apply edge enhancement at a quality level that does not slow down frame rate
relative to sensor output. It may be the same as OFF if edge enhancement will
slow down frame rate relative to sensor.</p>
@see CaptureRequest#EDGE_MODE

"
      end

      attribute 24790711 "EDGE_MODE_HIGH_QUALITY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Apply high-quality edge enhancement, at a cost of possibly reduced output frame rate.</p>
@see CaptureRequest#EDGE_MODE

"
      end

      attribute 24790839 "EDGE_MODE_ZERO_SHUTTER_LAG"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Edge enhancement is applied at different levels for different output streams,
based on resolution. Streams at maximum recording resolution (see {@link android.hardware.camera2.CameraDevice#createCaptureSession }) or below have
edge enhancement applied, while higher-resolution streams have no edge enhancement
applied. The level of edge enhancement for low-resolution streams is tuned so that
frame rate is not impacted, and the quality is equal to or better than FAST (since it
is only applied to lower-resolution outputs, quality may improve from FAST).</p>
<p>This mode is intended to be used by applications operating in a zero-shutter-lag mode
with YUV or PRIVATE reprocessing, where the application continuously captures
high-resolution intermediate buffers into a circular buffer, from which a final image is
produced via reprocessing when a user takes a picture.  For such a use case, the
high-resolution buffers must not have edge enhancement applied to maximize efficiency of
preview and to avoid double-applying enhancement when reprocessed, while low-resolution
buffers (used for recording or preview, generally) need edge enhancement applied for
reasonable preview quality.</p>
<p>This mode is guaranteed to be supported by devices that support either the
YUV_REPROCESSING or PRIVATE_REPROCESSING capabilities
({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} lists either of those capabilities) and it will
be the default mode for CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.</p>

@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CaptureRequest#EDGE_MODE

"
      end

      attribute 24790967 "FLASH_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#FLASH_MODE


<p>Do not fire the flash for this capture.</p>
@see CaptureRequest#FLASH_MODE

"
      end

      attribute 24791095 "FLASH_MODE_SINGLE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>If the flash is available and charged, fire flash
for this capture.</p>
@see CaptureRequest#FLASH_MODE

"
      end

      attribute 24791223 "FLASH_MODE_TORCH"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Transition flash to continuously on.</p>
@see CaptureRequest#FLASH_MODE

"
      end

      attribute 24791351 "HOT_PIXEL_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#HOT_PIXEL_MODE


<p>No hot pixel correction is applied.</p>
<p>The frame rate must not be reduced relative to sensor raw output
for this option.</p>
<p>The hotpixel map may be returned in {@link CaptureResult#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap}.</p>

@see CaptureResult#STATISTICS_HOT_PIXEL_MAP
@see CaptureRequest#HOT_PIXEL_MODE

"
      end

      attribute 24791479 "HOT_PIXEL_MODE_FAST"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Hot pixel correction is applied, without reducing frame
rate relative to sensor raw output.</p>
<p>The hotpixel map may be returned in {@link CaptureResult#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap}.</p>

@see CaptureResult#STATISTICS_HOT_PIXEL_MAP
@see CaptureRequest#HOT_PIXEL_MODE

"
      end

      attribute 24791607 "HOT_PIXEL_MODE_HIGH_QUALITY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>High-quality hot pixel correction is applied, at a cost
of possibly reduced frame rate relative to sensor raw output.</p>
<p>The hotpixel map may be returned in {@link CaptureResult#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap}.</p>

@see CaptureResult#STATISTICS_HOT_PIXEL_MAP
@see CaptureRequest#HOT_PIXEL_MODE

"
      end

      attribute 24791735 "LENS_OPTICAL_STABILIZATION_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE


<p>Optical stabilization is unavailable.</p>
@see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE

"
      end

      attribute 24791863 "LENS_OPTICAL_STABILIZATION_MODE_ON"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Optical stabilization is enabled.</p>
@see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE

"
      end

      attribute 24791991 "NOISE_REDUCTION_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#NOISE_REDUCTION_MODE


<p>No noise reduction is applied.</p>
@see CaptureRequest#NOISE_REDUCTION_MODE

"
      end

      attribute 24792119 "NOISE_REDUCTION_MODE_FAST"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Noise reduction is applied without reducing frame rate relative to sensor
output. It may be the same as OFF if noise reduction will reduce frame rate
relative to sensor.</p>
@see CaptureRequest#NOISE_REDUCTION_MODE

"
      end

      attribute 24792247 "NOISE_REDUCTION_MODE_HIGH_QUALITY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>High-quality noise reduction is applied, at the cost of possibly reduced frame
rate relative to sensor output.</p>
@see CaptureRequest#NOISE_REDUCTION_MODE

"
      end

      attribute 24792375 "NOISE_REDUCTION_MODE_MINIMAL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>MINIMAL noise reduction is applied without reducing frame rate relative to
sensor output. </p>
@see CaptureRequest#NOISE_REDUCTION_MODE

"
      end

      attribute 24792503 "NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Noise reduction is applied at different levels for different output streams,
based on resolution. Streams at maximum recording resolution (see {@link android.hardware.camera2.CameraDevice#createCaptureSession }) or below have noise
reduction applied, while higher-resolution streams have MINIMAL (if supported) or no
noise reduction applied (if MINIMAL is not supported.) The degree of noise reduction
for low-resolution streams is tuned so that frame rate is not impacted, and the quality
is equal to or better than FAST (since it is only applied to lower-resolution outputs,
quality may improve from FAST).</p>
<p>This mode is intended to be used by applications operating in a zero-shutter-lag mode
with YUV or PRIVATE reprocessing, where the application continuously captures
high-resolution intermediate buffers into a circular buffer, from which a final image is
produced via reprocessing when a user takes a picture.  For such a use case, the
high-resolution buffers must not have noise reduction applied to maximize efficiency of
preview and to avoid over-applying noise filtering when reprocessing, while
low-resolution buffers (used for recording or preview, generally) need noise reduction
applied for reasonable preview quality.</p>
<p>This mode is guaranteed to be supported by devices that support either the
YUV_REPROCESSING or PRIVATE_REPROCESSING capabilities
({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} lists either of those capabilities) and it will
be the default mode for CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.</p>

@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CaptureRequest#NOISE_REDUCTION_MODE

"
      end

      attribute 24792631 "SENSOR_TEST_PATTERN_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#SENSOR_TEST_PATTERN_MODE


<p>No test pattern mode is used, and the camera
device returns captures from the image sensor.</p>
<p>This is the default if the key is not set.</p>
@see CaptureRequest#SENSOR_TEST_PATTERN_MODE

"
      end

      attribute 24792759 "SENSOR_TEST_PATTERN_MODE_SOLID_COLOR"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Each pixel in <code>[R, G_even, G_odd, B]</code> is replaced by its
respective color channel provided in
{@link CaptureRequest#SENSOR_TEST_PATTERN_DATA android.sensor.testPatternData}.</p>
<p>For example:</p>
<pre><code>android.testPatternData = [0, 0xFFFFFFFF, 0xFFFFFFFF, 0]
</code></pre>
<p>All green pixels are 100% green. All red/blue pixels are black.</p>
<pre><code>android.testPatternData = [0xFFFFFFFF, 0, 0xFFFFFFFF, 0]
</code></pre>
<p>All red pixels are 100% red. Only the odd green pixels
are 100% green. All blue pixels are 100% black.</p>

@see CaptureRequest#SENSOR_TEST_PATTERN_DATA
@see CaptureRequest#SENSOR_TEST_PATTERN_MODE

"
      end

      attribute 24792887 "SENSOR_TEST_PATTERN_MODE_COLOR_BARS"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>All pixel data is replaced with an 8-bar color pattern.</p>
<p>The vertical bars (left-to-right) are as follows:</p>
<ul>
<li>100% white</li>
<li>yellow</li>
<li>cyan</li>
<li>green</li>
<li>magenta</li>
<li>red</li>
<li>blue</li>
<li>black</li>
</ul>
<p>In general the image would look like the following:</p>
<pre><code>W Y C G M R B K
W Y C G M R B K
W Y C G M R B K
W Y C G M R B K
W Y C G M R B K
. . . . . . . .
. . . . . . . .
. . . . . . . .

(B = Blue, K = Black)
</code></pre>
<p>Each bar should take up 1/8 of the sensor pixel array width.
When this is not possible, the bar size should be rounded
down to the nearest integer and the pattern can repeat
on the right side.</p>
<p>Each bar's height must always take up the full sensor
pixel array height.</p>
<p>Each pixel in this test pattern must be set to either
0% intensity or 100% intensity.</p>
@see CaptureRequest#SENSOR_TEST_PATTERN_MODE

"
      end

      attribute 24793015 "SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The test pattern is similar to COLOR_BARS, except that
each bar should start at its specified color at the top,
and fade to gray at the bottom.</p>
<p>Furthermore each bar is further subdivided into a left and
right half. The left half should have a smooth gradient,
and the right half should have a quantized gradient.</p>
<p>In particular, the right half's should consist of blocks of the
same color for 1/16th active sensor pixel array width.</p>
<p>The least significant bits in the quantized gradient should
be copied from the most significant bits of the smooth gradient.</p>
<p>The height of each bar should always be a multiple of 128.
When this is not the case, the pattern should repeat at the bottom
of the image.</p>
@see CaptureRequest#SENSOR_TEST_PATTERN_MODE

"
      end

      attribute 24793143 "SENSOR_TEST_PATTERN_MODE_PN9"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>All pixel data is replaced by a pseudo-random sequence
generated from a PN9 512-bit sequence (typically implemented
in hardware with a linear feedback shift register).</p>
<p>The generator should be reset at the beginning of each frame,
and thus each subsequent raw frame with this test pattern should
be exactly the same as the last.</p>
@see CaptureRequest#SENSOR_TEST_PATTERN_MODE

"
      end

      attribute 24793271 "SENSOR_TEST_PATTERN_MODE_CUSTOM1"
	class_attribute const_attribute public explicit_type "int"
	init_value " 256"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The first custom test pattern. All custom patterns that are
available only on this camera device are at least this numeric
value.</p>
<p>All of the custom test patterns will be static
(that is the raw image must not vary from frame to frame).</p>
@see CaptureRequest#SENSOR_TEST_PATTERN_MODE

"
      end

      attribute 24793399 "SHADING_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#SHADING_MODE


<p>No lens shading correction is applied.</p>
@see CaptureRequest#SHADING_MODE

"
      end

      attribute 24793527 "SHADING_MODE_FAST"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Apply lens shading corrections, without slowing
frame rate relative to sensor raw output</p>
@see CaptureRequest#SHADING_MODE

"
      end

      attribute 24793655 "SHADING_MODE_HIGH_QUALITY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Apply high-quality lens shading correction, at the
cost of possibly reduced frame rate.</p>
@see CaptureRequest#SHADING_MODE

"
      end

      attribute 24793783 "STATISTICS_FACE_DETECT_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#STATISTICS_FACE_DETECT_MODE


<p>Do not include face detection statistics in capture
results.</p>
@see CaptureRequest#STATISTICS_FACE_DETECT_MODE

"
      end

      attribute 24793911 "STATISTICS_FACE_DETECT_MODE_SIMPLE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Return face rectangle and confidence values only.</p>
@see CaptureRequest#STATISTICS_FACE_DETECT_MODE

"
      end

      attribute 24794039 "STATISTICS_FACE_DETECT_MODE_FULL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Return all face
metadata.</p>
<p>In this mode, face rectangles, scores, landmarks, and face IDs are all valid.</p>
@see CaptureRequest#STATISTICS_FACE_DETECT_MODE

"
      end

      attribute 24794167 "STATISTICS_LENS_SHADING_MAP_MODE_OFF"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE


<p>Do not include a lens shading map in the capture result.</p>
@see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE

"
      end

      attribute 24794295 "STATISTICS_LENS_SHADING_MAP_MODE_ON"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Include a lens shading map in the capture result.</p>
@see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE

"
      end

      attribute 24794423 "TONEMAP_MODE_CONTRAST_CURVE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#TONEMAP_MODE


<p>Use the tone mapping curve specified in
the {@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}* entries.</p>
<p>All color enhancement and tonemapping must be disabled, except
for applying the tonemapping curve specified by
{@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}.</p>
<p>Must not slow down frame rate relative to raw
sensor output.</p>

@see CaptureRequest#TONEMAP_CURVE
@see CaptureRequest#TONEMAP_MODE

"
      end

      attribute 24794551 "TONEMAP_MODE_FAST"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Advanced gamma mapping and color enhancement may be applied, without
reducing frame rate compared to raw sensor output.</p>
@see CaptureRequest#TONEMAP_MODE

"
      end

      attribute 24794679 "TONEMAP_MODE_HIGH_QUALITY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>High-quality gamma mapping and color enhancement will be applied, at
the cost of possibly reduced frame rate compared to raw sensor output.</p>
@see CaptureRequest#TONEMAP_MODE

"
      end

      attribute 24794807 "TONEMAP_MODE_GAMMA_VALUE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Use the gamma value specified in {@link CaptureRequest#TONEMAP_GAMMA android.tonemap.gamma} to peform
tonemapping.</p>
<p>All color enhancement and tonemapping must be disabled, except
for applying the tonemapping curve specified by {@link CaptureRequest#TONEMAP_GAMMA android.tonemap.gamma}.</p>
<p>Must not slow down frame rate relative to raw sensor output.</p>

@see CaptureRequest#TONEMAP_GAMMA
@see CaptureRequest#TONEMAP_MODE

"
      end

      attribute 24794935 "TONEMAP_MODE_PRESET_CURVE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Use the preset tonemapping curve specified in
{@link CaptureRequest#TONEMAP_PRESET_CURVE android.tonemap.presetCurve} to peform tonemapping.</p>
<p>All color enhancement and tonemapping must be disabled, except
for applying the tonemapping curve specified by
{@link CaptureRequest#TONEMAP_PRESET_CURVE android.tonemap.presetCurve}.</p>
<p>Must not slow down frame rate relative to raw sensor output.</p>

@see CaptureRequest#TONEMAP_PRESET_CURVE
@see CaptureRequest#TONEMAP_MODE

"
      end

      attribute 24795063 "TONEMAP_PRESET_CURVE_SRGB"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureRequest#TONEMAP_PRESET_CURVE


<p>Tonemapping curve is defined by sRGB</p>
@see CaptureRequest#TONEMAP_PRESET_CURVE

"
      end

      attribute 24795191 "TONEMAP_PRESET_CURVE_REC709"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Tonemapping curve is defined by ITU-R BT.709</p>
@see CaptureRequest#TONEMAP_PRESET_CURVE

"
      end

      attribute 24795319 "CONTROL_AE_STATE_INACTIVE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureResult#CONTROL_AE_STATE


<p>AE is off or recently reset.</p>
<p>When a camera device is opened, it starts in
this state. This is a transient state, the camera device may skip reporting
this state in capture result.</p>
@see CaptureResult#CONTROL_AE_STATE

"
      end

      attribute 24795447 "CONTROL_AE_STATE_SEARCHING"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AE doesn't yet have a good set of control values
for the current scene.</p>
<p>This is a transient state, the camera device may skip
reporting this state in capture result.</p>
@see CaptureResult#CONTROL_AE_STATE

"
      end

      attribute 24795575 "CONTROL_AE_STATE_CONVERGED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AE has a good set of control values for the
current scene.</p>
@see CaptureResult#CONTROL_AE_STATE

"
      end

      attribute 24795703 "CONTROL_AE_STATE_LOCKED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AE has been locked.</p>
@see CaptureResult#CONTROL_AE_STATE

"
      end

      attribute 24795831 "CONTROL_AE_STATE_FLASH_REQUIRED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AE has a good set of control values, but flash
needs to be fired for good quality still
capture.</p>
@see CaptureResult#CONTROL_AE_STATE

"
      end

      attribute 24795959 "CONTROL_AE_STATE_PRECAPTURE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 5"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AE has been asked to do a precapture sequence
and is currently executing it.</p>
<p>Precapture can be triggered through setting
{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} to START. Currently
active and completed (if it causes camera device internal AE lock) precapture
metering sequence can be canceled through setting
{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} to CANCEL.</p>
<p>Once PRECAPTURE completes, AE will transition to CONVERGED
or FLASH_REQUIRED as appropriate. This is a transient
state, the camera device may skip reporting this state in
capture result.</p>

@see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER
@see CaptureResult#CONTROL_AE_STATE

"
      end

      attribute 24796087 "CONTROL_AF_STATE_INACTIVE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureResult#CONTROL_AF_STATE


<p>AF is off or has not yet tried to scan/been asked
to scan.</p>
<p>When a camera device is opened, it starts in this
state. This is a transient state, the camera device may
skip reporting this state in capture
result.</p>
@see CaptureResult#CONTROL_AF_STATE

"
      end

      attribute 24796215 "CONTROL_AF_STATE_PASSIVE_SCAN"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AF is currently performing an AF scan initiated the
camera device in a continuous autofocus mode.</p>
<p>Only used by CONTINUOUS_* AF modes. This is a transient
state, the camera device may skip reporting this state in
capture result.</p>
@see CaptureResult#CONTROL_AF_STATE

"
      end

      attribute 24796343 "CONTROL_AF_STATE_PASSIVE_FOCUSED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AF currently believes it is in focus, but may
restart scanning at any time.</p>
<p>Only used by CONTINUOUS_* AF modes. This is a transient
state, the camera device may skip reporting this state in
capture result.</p>
@see CaptureResult#CONTROL_AF_STATE

"
      end

      attribute 24796471 "CONTROL_AF_STATE_ACTIVE_SCAN"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AF is performing an AF scan because it was
triggered by AF trigger.</p>
<p>Only used by AUTO or MACRO AF modes. This is a transient
state, the camera device may skip reporting this state in
capture result.</p>
@see CaptureResult#CONTROL_AF_STATE

"
      end

      attribute 24796599 "CONTROL_AF_STATE_FOCUSED_LOCKED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AF believes it is focused correctly and has locked
focus.</p>
<p>This state is reached only after an explicit START AF trigger has been
sent ({@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}), when good focus has been obtained.</p>
<p>The lens will remain stationary until the AF mode ({@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}) is changed or
a new AF trigger is sent to the camera device ({@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}).</p>

@see CaptureRequest#CONTROL_AF_MODE
@see CaptureRequest#CONTROL_AF_TRIGGER
@see CaptureResult#CONTROL_AF_STATE

"
      end

      attribute 24796727 "CONTROL_AF_STATE_NOT_FOCUSED_LOCKED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 5"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AF has failed to focus successfully and has locked
focus.</p>
<p>This state is reached only after an explicit START AF trigger has been
sent ({@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}), when good focus cannot be obtained.</p>
<p>The lens will remain stationary until the AF mode ({@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}) is changed or
a new AF trigger is sent to the camera device ({@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}).</p>

@see CaptureRequest#CONTROL_AF_MODE
@see CaptureRequest#CONTROL_AF_TRIGGER
@see CaptureResult#CONTROL_AF_STATE

"
      end

      attribute 24796855 "CONTROL_AF_STATE_PASSIVE_UNFOCUSED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 6"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AF finished a passive scan without finding focus,
and may restart scanning at any time.</p>
<p>Only used by CONTINUOUS_* AF modes. This is a transient state, the camera
device may skip reporting this state in capture result.</p>
<p>LEGACY camera devices do not support this state. When a passive
scan has finished, it will always go to PASSIVE_FOCUSED.</p>
@see CaptureResult#CONTROL_AF_STATE

"
      end

      attribute 24796983 "CONTROL_AWB_STATE_INACTIVE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureResult#CONTROL_AWB_STATE


<p>AWB is not in auto mode, or has not yet started metering.</p>
<p>When a camera device is opened, it starts in this
state. This is a transient state, the camera device may
skip reporting this state in capture
result.</p>
@see CaptureResult#CONTROL_AWB_STATE

"
      end

      attribute 24797111 "CONTROL_AWB_STATE_SEARCHING"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AWB doesn't yet have a good set of control
values for the current scene.</p>
<p>This is a transient state, the camera device
may skip reporting this state in capture result.</p>
@see CaptureResult#CONTROL_AWB_STATE

"
      end

      attribute 24797239 "CONTROL_AWB_STATE_CONVERGED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AWB has a good set of control values for the
current scene.</p>
@see CaptureResult#CONTROL_AWB_STATE

"
      end

      attribute 24797367 "CONTROL_AWB_STATE_LOCKED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>AWB has been locked.</p>
@see CaptureResult#CONTROL_AWB_STATE

"
      end

      attribute 24797495 "FLASH_STATE_UNAVAILABLE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureResult#FLASH_STATE


<p>No flash on camera.</p>
@see CaptureResult#FLASH_STATE

"
      end

      attribute 24797623 "FLASH_STATE_CHARGING"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Flash is charging and cannot be fired.</p>
@see CaptureResult#FLASH_STATE

"
      end

      attribute 24797751 "FLASH_STATE_READY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Flash is ready to fire.</p>
@see CaptureResult#FLASH_STATE

"
      end

      attribute 24797879 "FLASH_STATE_FIRED"
	class_attribute const_attribute public explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Flash fired for this capture.</p>
@see CaptureResult#FLASH_STATE

"
      end

      attribute 24798007 "FLASH_STATE_PARTIAL"
	class_attribute const_attribute public explicit_type "int"
	init_value " 4"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>Flash partially illuminated this frame.</p>
<p>This is usually due to the next or previous frame having
the flash fire, and the flash spilling into this capture
due to hardware limitations.</p>
@see CaptureResult#FLASH_STATE

"
      end

      attribute 24798135 "LENS_STATE_STATIONARY"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureResult#LENS_STATE


<p>The lens parameters ({@link CaptureRequest#LENS_FOCAL_LENGTH android.lens.focalLength}, {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance},
{@link CaptureRequest#LENS_FILTER_DENSITY android.lens.filterDensity} and {@link CaptureRequest#LENS_APERTURE android.lens.aperture}) are not changing.</p>

@see CaptureRequest#LENS_APERTURE
@see CaptureRequest#LENS_FILTER_DENSITY
@see CaptureRequest#LENS_FOCAL_LENGTH
@see CaptureRequest#LENS_FOCUS_DISTANCE
@see CaptureResult#LENS_STATE

"
      end

      attribute 24798263 "LENS_STATE_MOVING"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>One or several of the lens parameters
({@link CaptureRequest#LENS_FOCAL_LENGTH android.lens.focalLength}, {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance},
{@link CaptureRequest#LENS_FILTER_DENSITY android.lens.filterDensity} or {@link CaptureRequest#LENS_APERTURE android.lens.aperture}) is
currently changing.</p>

@see CaptureRequest#LENS_APERTURE
@see CaptureRequest#LENS_FILTER_DENSITY
@see CaptureRequest#LENS_FOCAL_LENGTH
@see CaptureRequest#LENS_FOCUS_DISTANCE
@see CaptureResult#LENS_STATE

"
      end

      attribute 24798391 "STATISTICS_SCENE_FLICKER_NONE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureResult#STATISTICS_SCENE_FLICKER


<p>The camera device does not detect any flickering illumination
in the current scene.</p>
@see CaptureResult#STATISTICS_SCENE_FLICKER

"
      end

      attribute 24798519 "STATISTICS_SCENE_FLICKER_50HZ"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device detects illumination flickering at 50Hz
in the current scene.</p>
@see CaptureResult#STATISTICS_SCENE_FLICKER

"
      end

      attribute 24798647 "STATISTICS_SCENE_FLICKER_60HZ"
	class_attribute const_attribute public explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The camera device detects illumination flickering at 60Hz
in the current scene.</p>
@see CaptureResult#STATISTICS_SCENE_FLICKER

"
      end

      attribute 24798775 "SYNC_FRAME_NUMBER_CONVERGING"
	class_attribute const_attribute public explicit_type "int"
	init_value " -1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Enumeration values for CaptureResult#SYNC_FRAME_NUMBER


<p>The current result is not yet fully synchronized to any request.</p>
<p>Synchronization is in progress, and reading metadata from this
result may include a mix of data that have taken effect since the
last synchronization time.</p>
<p>In some future result, within {@link CameraCharacteristics#SYNC_MAX_LATENCY android.sync.maxLatency} frames,
this value will update to the actual frame number frame number
the result is guaranteed to be synchronized to (as long as the
request settings remain constant).</p>

@see CameraCharacteristics#SYNC_MAX_LATENCY
@see CaptureResult#SYNC_FRAME_NUMBER
@hide

"
      end

      attribute 24798903 "SYNC_FRAME_NUMBER_UNKNOWN"
	class_attribute const_attribute public explicit_type "int"
	init_value " -2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "<p>The current result's synchronization status is unknown.</p>
<p>The result may have already converged, or it may be in
progress.  Reading from this result may include some mix
of settings from past requests.</p>
<p>After a settings change, the new settings will eventually all
take effect for the output buffers and results. However, this
value will not change when that happens. Altering settings
rapidly may provide outcomes using mixes of settings from recent
requests.</p>
<p>This value is intended primarily for backwards compatibility with
the older camera implementations (for android.hardware.Camera).</p>
@see CaptureResult#SYNC_FRAME_NUMBER
@hide

"
      end
    end

    class 7151159 "CameraConstrainedHighSpeedCaptureSession"
      abstract visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A constrained high speed capture session for a {@link CameraDevice}, used for capturing high
speed images from the {@link CameraDevice} for high speed video recording use case.
<p>
A CameraHighSpeedCaptureSession is created by providing a set of target output surfaces to
{@link CameraDevice#createConstrainedHighSpeedCaptureSession}, Once created, the session is
active until a new session is created by the camera device, or the camera device is closed.
</p>
<p>
An active high speed capture session is a specialized capture session that is only targeted at
high speed video recording (>=120fps) use case if the camera device supports high speed video
capability (i.e., {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES} contains
{@link CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO}). It only
accepts request lists created via {@link #createHighSpeedRequestList}, and the request list can
only be submitted to this session via {@link CameraCaptureSession#captureBurst captureBurst}, or
{@link CameraCaptureSession#setRepeatingBurst setRepeatingBurst}. See
{@link CameraDevice#createConstrainedHighSpeedCaptureSession} for more details of the
limitations.
</p>
<p>
Creating a session is an expensive operation and can take several hundred milliseconds, since it
requires configuring the camera device's internal pipelines and allocating memory buffers for
sending images to the desired targets. Therefore the setup is done asynchronously, and
{@link CameraDevice#createConstrainedHighSpeedCaptureSession} will send the ready-to-use
CameraCaptureSession to the provided listener's
{@link CameraCaptureSession.StateCallback#onConfigured} callback. If configuration cannot be
completed, then the {@link CameraCaptureSession.StateCallback#onConfigureFailed} is called, and
the session will not become active.
</p>
<!--
<p>
Any capture requests (repeating or non-repeating) submitted before the session is ready will be
queued up and will begin capture once the session becomes ready. In case the session cannot be
configured and {@link CameraCaptureSession.StateCallback#onConfigureFailed onConfigureFailed} is
called, all queued capture requests are discarded.  </p>
-->
<p>
If a new session is created by the camera device, then the previous session is closed, and its
associated {@link CameraCaptureSession.StateCallback#onClosed onClosed} callback will be
invoked. All of the session methods will throw an IllegalStateException if called once the
session is closed.
</p>
<p>
A closed session clears any repeating requests (as if {@link #stopRepeating} had been called),
but will still complete all of its in-progress capture requests as normal, before a newly created
session takes over and reconfigures the camera device.
</p>
"
      classrelation 15663031 // <generalisation>
	relation 15663031 ---|>
	  a public
	    cpp default "${type}"
	    java "${type}"
	    classrelation_ref 15663031 // <generalisation>
	  b parent class_ref 7147575 // CameraCaptureSession
      end

      operation 79324599 "createHighSpeedRequestList"
	abstract public return_type class_ref 7147831 // CaptureRequest
	nparams 1
	  param inout name "request" type class_ref 7147831 // CaptureRequest
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}List<${type}> ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "<p>Create a unmodifiable list of requests that is suitable for constrained high speed capture
session streaming.</p>

<p>High speed video streaming creates significant performance pressure on the camera device,
so to achieve efficient high speed streaming, the camera device may have to aggregate
multiple frames together. This means requests must be sent in batched groups, with all
requests sharing the same settings. This method takes the list of output target
Surfaces (subject to the output Surface requirements specified by the constrained high speed
session) and a {@link CaptureRequest request}, and generates a request list that has the same
controls for each request. The input {@link CaptureRequest request} must contain the target
output Surfaces and target high speed FPS range that is one of the
{@link StreamConfigurationMap#getHighSpeedVideoFpsRangesFor} for the Surface size.</p>

<p>If both preview and recording Surfaces are specified in the {@code request}, the
{@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE target FPS range} in the input
{@link CaptureRequest request} must be a fixed frame rate FPS range, where the
{@link android.util.Range#getLower minimal FPS} ==
{@link android.util.Range#getUpper() maximum FPS}. The created request list will contain
a interleaved request pattern such that the preview output FPS is at least 30fps, the
recording output FPS is {@link android.util.Range#getUpper() maximum FPS} of the requested
FPS range. The application can submit this request list directly to an active high speed
capture session to achieve high speed video recording. When only preview or recording
Surface is specified, this method will return a list of request that have the same controls
and output targets for all requests.</p>

<p>Submitting a request list created by this method to a normal capture session will result
in an {@link IllegalArgumentException} if the high speed
{@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE FPS range} is not supported by
{@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES}.</p>

@param request The high speed capture request that will be used to generate the high speed
               request list.
@return A unmodifiable CaptureRequest list that is suitable for constrained high speed
        capture.

@throws IllegalArgumentException if the set of output Surfaces in the request do not meet the
                                 high speed video capability requirements, or the camera
                                 device doesn't support high speed video capability, or the
                                 request doesn't meet the high speed video capability
                                 requirements, or the request doesn't contain the required
                                 controls for high speed capture.
@throws CameraAccessException if the camera device is no longer connected or has
                              encountered a fatal error
@throws IllegalStateException if the camera device has been closed

@see CameraDevice#createConstrainedHighSpeedCaptureSession
@see CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE
@see android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoSizes
@see android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoFpsRangesFor
@see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES
@see CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO
"
      end
    end

    class 7152055 "CameraManager"
      visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      final java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "<p>A system service manager for detecting, characterizing, and connecting to
{@link CameraDevice CameraDevices}.</p>

<p>You can get an instance of this class by calling
{@link android.content.Context#getSystemService(String) Context.getSystemService()}.</p>

<pre>CameraManager manager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);</pre>

<p>For more details about communicating with camera devices, read the Camera
developer guide or the {@link android.hardware.camera2 camera2}
package documentation.</p>
"
      attribute 24800439 "DEBUG"
	const_attribute private explicit_type "boolean"
	init_value " false"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24800567 "USE_CALLING_UID"
	class_attribute const_attribute private explicit_type "int"
	init_value " -1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24800695 "API_VERSION_1"
	class_attribute const_attribute private explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	java_annotation "@SuppressWarnings(\"unused\")
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24800823 "API_VERSION_2"
	class_attribute const_attribute private explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24800951 "CAMERA_TYPE_BACKWARD_COMPATIBLE"
	class_attribute const_attribute private explicit_type "int"
	init_value " 0"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24801079 "CAMERA_TYPE_ALL"
	class_attribute const_attribute private explicit_type "int"
	init_value " 1"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      classrelation 15663671 // mContext (<unidirectional association>)
	relation 15663671 --->
	  a role_name "mContext" const_relation private
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 15663671 // mContext (<unidirectional association>)
	  b parent class_ref 6923703 // Context
      end

      operation 79326519 "CameraManager"
	public explicit_return_type ""
	nparams 1
	  param inout name "context" type class_ref 6923703 // Context
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@hide
"
      end

      operation 79326647 "getCameraIdList"
	public explicit_return_type "String"
	nparams 0
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}[] ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Return the list of currently connected camera devices by identifier, including
cameras that may be in use by other camera API clients.

<p>Non-removable cameras use integers starting at 0 for their
identifiers, while removable cameras have a unique identifier for each
individual device, even if they are the same model.</p>

@return The list of currently connected camera devices.
"
      end

      operation 79326775 "registerAvailabilityCallback"
	public explicit_return_type "void"
	nparams 2
	  param inout name "callback" type class_ref 7152183 // AvailabilityCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @Nullable ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Register a callback to be notified about camera device availability.

<p>Registering the same callback again will replace the handler with the
new one provided.</p>

<p>The first time a callback is registered, it is immediately called
with the availability status of all currently known camera devices.</p>

<p>{@link AvailabilityCallback#onCameraUnavailable(String)} will be called whenever a camera
device is opened by any camera API client. As of API level 23, other camera API clients may
still be able to open such a camera device, evicting the existing client if they have higher
priority than the existing client of a camera device. See open() for more details.</p>

<p>Since this callback will be registered with the camera service, remember to unregister it
once it is no longer needed; otherwise the callback will continue to receive events
indefinitely and it may prevent other resources from being released. Specifically, the
callbacks will be invoked independently of the general activity lifecycle and independently
of the state of individual CameraManager instances.</p>

@param callback the new callback to send camera availability notices to
@param handler The handler on which the callback should be invoked, or {@code null} to use
            the current thread's {@link android.os.Looper looper}.

@throws IllegalArgumentException if the handler is {@code null} but the current thread has
            no looper.
"
      end

      class 7152183 "AvailabilityCallback"
	abstract visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	operation 79327799 "onCameraAvailable"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "cameraId" explicit_type "String"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "A new camera has become available to use.

<p>The default implementation of this method does nothing.</p>

@param cameraId The unique identifier of the new camera.
"
	end

	operation 79327927 "onCameraUnavailable"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "cameraId" explicit_type "String"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "A previously-available camera has become unavailable for use.

<p>If an application had an active CameraDevice instance for the
now-disconnected camera, that application will receive a
{@link CameraDevice.StateCallback#onDisconnected disconnection error}.</p>

<p>The default implementation of this method does nothing.</p>

@param cameraId The unique identifier of the disconnected camera.
"
	end
      end

      operation 79326903 "unregisterAvailabilityCallback"
	public explicit_return_type "void"
	nparams 1
	  param inout name "callback" type class_ref 7152183 // AvailabilityCallback
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Remove a previously-added callback; the callback will no longer receive connection and
disconnection callbacks.

<p>Removing a callback that isn't registered has no effect.</p>

@param callback The callback to remove from the notification list
"
      end

      operation 79327031 "registerTorchCallback"
	public explicit_return_type "void"
	nparams 2
	  param inout name "callback" type class_ref 7152311 // TorchCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @Nullable ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Register a callback to be notified about torch mode status.

<p>Registering the same callback again will replace the handler with the
new one provided.</p>

<p>The first time a callback is registered, it is immediately called
with the torch mode status of all currently known camera devices with a flash unit.</p>

<p>Since this callback will be registered with the camera service, remember to unregister it
once it is no longer needed; otherwise the callback will continue to receive events
indefinitely and it may prevent other resources from being released. Specifically, the
callbacks will be invoked independently of the general activity lifecycle and independently
of the state of individual CameraManager instances.</p>

@param callback The new callback to send torch mode status to
@param handler The handler on which the callback should be invoked, or {@code null} to use
            the current thread's {@link android.os.Looper looper}.

@throws IllegalArgumentException if the handler is {@code null} but the current thread has
            no looper.
"
      end

      class 7152311 "TorchCallback"
	abstract visibility public 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	operation 79328055 "onTorchModeUnavailable"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "cameraId" explicit_type "String"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "A camera's torch mode has become unavailable to set via {@link #setTorchMode}.

<p>If torch mode was previously turned on by calling {@link #setTorchMode}, it will be
turned off before {@link CameraManager.TorchCallback#onTorchModeUnavailable} is
invoked. {@link #setTorchMode} will fail until the torch mode has entered a disabled or
enabled state again.</p>

<p>The default implementation of this method does nothing.</p>

@param cameraId The unique identifier of the camera whose torch mode has become
                unavailable.
"
	end

	operation 79328183 "onTorchModeChanged"
	  public explicit_return_type "void"
	  nparams 2
	    param inout name "cameraId" explicit_type "String"
	    param inout name "enabled" explicit_type "boolean"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "A camera's torch mode has become enabled or disabled and can be changed via
{@link #setTorchMode}.

<p>The default implementation of this method does nothing.</p>

@param cameraId The unique identifier of the camera whose torch mode has been changed.

@param enabled The state that the torch mode of the camera has been changed to.
               {@code true} when the torch mode has become on and available to be turned
               off. {@code false} when the torch mode has becomes off and available to
               be turned on.
"
	end
      end

      operation 79327159 "unregisterTorchCallback"
	public explicit_return_type "void"
	nparams 1
	  param inout name "callback" type class_ref 7152311 // TorchCallback
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Remove a previously-added callback; the callback will no longer receive torch mode status
callbacks.

<p>Removing a callback that isn't registered has no effect.</p>

@param callback The callback to remove from the notification list
"
      end

      operation 79327287 "getCameraCharacteristics"
	public return_type class_ref 7148855 // CameraCharacteristics
	nparams 1
	  param inout name "cameraId" explicit_type "String"
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "<p>Query the capabilities of a camera device. These capabilities are
immutable for a given camera.</p>

@param cameraId The id of the camera device to query
@return The properties of the given camera

@throws IllegalArgumentException if the cameraId does not match any
        known camera device.
@throws CameraAccessException if the camera device has been disconnected.

@see #getCameraIdList
@see android.app.admin.DevicePolicyManager#setCameraDisabled
"
      end

      operation 79327415 "openCameraDeviceUserAsync"
	private return_type class_ref 7147703 // CameraDevice
	nparams 3
	  param inout name "cameraId" explicit_type "String"
	  param inout name "callback" type class_ref 7151671 // StateCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Helper for opening a connection to a camera with the given ID.

@param cameraId The unique identifier of the camera device to open
@param callback The callback for the camera. Must not be null.
@param handler  The handler to invoke the callback on. Must not be null.

@throws CameraAccessException if the camera is disabled by device policy,
too many camera devices are already open, or the cameraId does not match
any currently available camera device.

@throws SecurityException if the application does not have permission to
access the camera
@throws IllegalArgumentException if callback or handler is null.
@return A handle to the newly-created camera device.

@see #getCameraIdList
@see android.app.admin.DevicePolicyManager#setCameraDisabled
"
      end

      operation 79327543 "openCamera"
	public explicit_return_type "void"
	nparams 3
	  param inout name "cameraId" explicit_type "String"
	  param in name "callback" type class_ref 7151671 // StateCallback
	  param inout name "handler" type class_ref 6926391 // Handler
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull final ${t1} ${p1}, @Nullable ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@RequiresPermission(android.Manifest.permission.CAMERA)
"
	
	
	
	comment "Open a connection to a camera with the given ID.

<p>Use {@link #getCameraIdList} to get the list of available camera
devices. Note that even if an id is listed, open may fail if the device
is disconnected between the calls to {@link #getCameraIdList} and
{@link #openCamera}, or if a higher-priority camera API client begins using the
camera device.</p>

<p>As of API level 23, devices for which the
{@link AvailabilityCallback#onCameraUnavailable(String)} callback has been called due to the
device being in use by a lower-priority, background camera API client can still potentially
be opened by calling this method when the calling camera API client has a higher priority
than the current camera API client using this device.  In general, if the top, foreground
activity is running within your application process, your process will be given the highest
priority when accessing the camera, and this method will succeed even if the camera device is
in use by another camera API client. Any lower-priority application that loses control of the
camera in this way will receive an
{@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback.</p>

<p>Once the camera is successfully opened, {@link CameraDevice.StateCallback#onOpened} will
be invoked with the newly opened {@link CameraDevice}. The camera device can then be set up
for operation by calling {@link CameraDevice#createCaptureSession} and
{@link CameraDevice#createCaptureRequest}</p>

<!--
<p>Since the camera device will be opened asynchronously, any asynchronous operations done
on the returned CameraDevice instance will be queued up until the device startup has
completed and the callback's {@link CameraDevice.StateCallback#onOpened onOpened} method is
called. The pending operations are then processed in order.</p>
-->
<p>If the camera becomes disconnected during initialization
after this function call returns,
{@link CameraDevice.StateCallback#onDisconnected} with a
{@link CameraDevice} in the disconnected state (and
{@link CameraDevice.StateCallback#onOpened} will be skipped).</p>

<p>If opening the camera device fails, then the device callback's
{@link CameraDevice.StateCallback#onError onError} method will be called, and subsequent
calls on the camera device will throw a {@link CameraAccessException}.</p>

@param cameraId
            The unique identifier of the camera device to open
@param callback
            The callback which is invoked once the camera is opened
@param handler
            The handler on which the callback should be invoked, or
            {@code null} to use the current thread's {@link android.os.Looper looper}.

@throws CameraAccessException if the camera is disabled by device policy,
has been disconnected, or is being used by a higher-priority camera API client.

@throws IllegalArgumentException if cameraId or the callback was null,
or the cameraId does not match any currently or previously available
camera device.

@throws SecurityException if the application does not have permission to
access the camera

@see #getCameraIdList
@see android.app.admin.DevicePolicyManager#setCameraDisabled
"
      end

      operation 79327671 "setTorchMode"
	public explicit_return_type "void"
	nparams 2
	  param inout name "cameraId" explicit_type "String"
	  param inout name "enabled" explicit_type "boolean"
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Set the flash unit's torch mode of the camera of the given ID without opening the camera
device.

<p>Use {@link #getCameraIdList} to get the list of available camera devices and use
{@link #getCameraCharacteristics} to check whether the camera device has a flash unit.
Note that even if a camera device has a flash unit, turning on the torch mode may fail
if the camera device or other camera resources needed to turn on the torch mode are in use.
</p>

<p> If {@link #setTorchMode} is called to turn on or off the torch mode successfully,
{@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked.
However, even if turning on the torch mode is successful, the application does not have the
exclusive ownership of the flash unit or the camera device. The torch mode will be turned
off and becomes unavailable when the camera device that the flash unit belongs to becomes
unavailable or when other camera resources to keep the torch on become unavailable (
{@link CameraManager.TorchCallback#onTorchModeUnavailable} will be invoked). Also,
other applications are free to call {@link #setTorchMode} to turn off the torch mode (
{@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked). If the latest
application that turned on the torch mode exits, the torch mode will be turned off.

@param cameraId
            The unique identifier of the camera device that the flash unit belongs to.
@param enabled
            The desired state of the torch mode for the target camera device. Set to
            {@code true} to turn on the torch mode. Set to {@code false} to turn off the
            torch mode.

@throws CameraAccessException if it failed to access the flash unit.
            {@link CameraAccessException#CAMERA_IN_USE} will be thrown if the camera device
            is in use. {@link CameraAccessException#MAX_CAMERAS_IN_USE} will be thrown if
            other camera resources needed to turn on the torch mode are in use.
            {@link CameraAccessException#CAMERA_DISCONNECTED} will be thrown if camera
            service is not available.

@throws IllegalArgumentException if cameraId was null, cameraId doesn't match any currently
            or previously available camera device, or the camera device doesn't have a
            flash unit.
"
      end

      operation 79328311 "throwAsPublicException"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "t" explicit_type "Throwable"
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convert ServiceSpecificExceptions and Binder RemoteExceptions from camera binder interfaces
into the correct public exceptions.

@hide
"
      end

      operation 79328439 "getOrCreateDeviceIdListLocked"
	private explicit_return_type "String"
	nparams 0
	nexceptions 1
	  exception class_ref 7147319 // CameraAccessException
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}ArrayList<${type}> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Return or create the list of currently connected camera devices.

<p>In case of errors connecting to the camera service, will return an empty list.</p>
"
      end

      operation 79328567 "supportsCamera2ApiLocked"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "cameraId" explicit_type "String"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the camera service if it supports the camera2 api directly, or needs a shim.

@param cameraId a non-{@code null} camera identifier
@return {@code false} if the legacy shim needs to be used, {@code true} otherwise.
"
      end

      operation 79328695 "supportsCameraApiLocked"
	private explicit_return_type "boolean"
	nparams 2
	  param inout name "cameraId" explicit_type "String"
	  param in name "apiVersion" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the camera service if it supports a camera api directly, or needs a shim.

@param cameraId a non-{@code null} camera identifier
@param apiVersion the version, i.e. {@code API_VERSION_1} or {@code API_VERSION_2}
@return {@code true} if connecting will work for that device version.
"
      end

      class 7152439 "CameraManagerGlobal"
	visibility private 
	cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 15664055 // <realization>
	  relation 15664055 -_-|>
	    a public
	      cpp default "${type}"
	      java "${type}"
	      classrelation_ref 15664055 // <realization>
	    b parent class_ref 6932023 // DeathRecipient
	end

	attribute 24801207 "DEBUG"
	  const_attribute private explicit_type "boolean"
	  init_value " false"
	  cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	attribute 24801335 "CAMERA_SERVICE_RECONNECT_DELAY_MS"
	  const_attribute private explicit_type "int"
	  init_value " 1000"
	  cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	classrelation 15664311 // gCameraManager (<unidirectional association>)
	  relation 15664311 --->
	    a role_name "gCameraManager" init_value "
            new CameraManagerGlobal()" class_relation const_relation private
	      comment " Singleton instance
"
	      cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 15664311 // gCameraManager (<unidirectional association>)
	    b parent class_ref 7152439 // CameraManagerGlobal
	end

	classrelation 15664567 // mDeviceStatus (<unidirectional association>)
	  relation 15664567 --->
	    a role_name "mDeviceStatus" init_value " new ArrayMap<String, Integer>()" const_relation private
	      comment " Camera ID -> Status map
"
	      cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<String, Integer> ${name}${value};
"
	      classrelation_ref 15664567 // mDeviceStatus (<unidirectional association>)
	    b parent class_ref 6930743 // ArrayMap
	end

	classrelation 15664695 // mCallbackMap (<unidirectional association>)
	  relation 15664695 --->
	    a role_name "mCallbackMap" init_value "
            new ArrayMap<AvailabilityCallback, Handler>()" const_relation private
	      comment " Registered availablility callbacks and their handlers
"
	      cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<AvailabilityCallback, Handler> ${name}${value};
"
	      classrelation_ref 15664695 // mCallbackMap (<unidirectional association>)
	    b parent class_ref 6930743 // ArrayMap
	end

	classrelation 15664823 // mTorchClientBinder (<unidirectional association>)
	  relation 15664823 --->
	    a role_name "mTorchClientBinder" init_value " new Binder()" private
	      comment " torch client binder to set the torch mode with.
"
	      cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 15664823 // mTorchClientBinder (<unidirectional association>)
	    b parent class_ref 6931511 // Binder
	end

	classrelation 15664951 // mTorchStatus (<unidirectional association>)
	  relation 15664951 --->
	    a role_name "mTorchStatus" init_value " new ArrayMap<String, Integer>()" const_relation private
	      comment " Camera ID -> Torch status map
"
	      cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<String, Integer> ${name}${value};
"
	      classrelation_ref 15664951 // mTorchStatus (<unidirectional association>)
	    b parent class_ref 6930743 // ArrayMap
	end

	classrelation 15665079 // mTorchCallbackMap (<unidirectional association>)
	  relation 15665079 --->
	    a role_name "mTorchCallbackMap" init_value "
                new ArrayMap<TorchCallback, Handler>()" const_relation private
	      comment " Registered torch callbacks and their handlers
"
	      cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} * ${name}${value};
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<TorchCallback, Handler> ${name}${value};
"
	      classrelation_ref 15665079 // mTorchCallbackMap (<unidirectional association>)
	    b parent class_ref 6930743 // ArrayMap
	end

	attribute 24801463 "mCameraService"
	  private explicit_type "ICameraService"
	  cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " Access only through getCameraService to deal with binder death
"
	end

	operation 79328823 "CameraManagerGlobal"
	  private explicit_return_type ""
	  nparams 0
	  cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	  cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Singleton, don't allow construction"
	end

	operation 79328951 "get"
	  class_operation public return_type class_ref 7152439 // CameraManagerGlobal
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79329079 "asBinder"
	  public return_type class_ref 6927031 // IBinder
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@Override
"
	  
	  
	  
	end

	operation 79329207 "getCameraService"
	  public explicit_return_type "ICameraService"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Return a best-effort ICameraService.

<p>This will be null if the camera service is not currently available. If the camera
service has died since the last use of the camera service, will try to reconnect to the
service.</p>
"
	end

	operation 79329335 "connectCameraServiceLocked"
	  private explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Connect to the camera service if it's available, and set up listeners.
If the service is already connected, do nothing.

<p>Sets mCameraService to a valid pointer or null if the connection does not succeed.</p>
"
	end

	operation 79329463 "setTorchMode"
	  public explicit_return_type "void"
	  nparams 2
	    param inout name "cameraId" explicit_type "String"
	    param inout name "enabled" explicit_type "boolean"
	  nexceptions 1
	    exception class_ref 7147319 // CameraAccessException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79329591 "handleRecoverableSetupErrors"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "e" type class_ref 7152567 // ServiceSpecificException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79329719 "isAvailable"
	  private explicit_return_type "boolean"
	  nparams 1
	    param in name "status" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79329847 "validStatus"
	  private explicit_return_type "boolean"
	  nparams 1
	    param in name "status" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79329975 "validTorchStatus"
	  private explicit_return_type "boolean"
	  nparams 1
	    param in name "status" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79330103 "postSingleUpdate"
	  private explicit_return_type "void"
	  nparams 4
	    param in name "callback" type class_ref 7152183 // AvailabilityCallback
	    param in name "handler" type class_ref 6926391 // Handler
	    param in name "id" explicit_type "String"
	    param in name "status" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}, final ${t1} ${p1}, final ${t2} ${p2}, final ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79330231 "postSingleTorchUpdate"
	  private explicit_return_type "void"
	  nparams 4
	    param in name "callback" type class_ref 7152311 // TorchCallback
	    param in name "handler" type class_ref 6926391 // Handler
	    param in name "id" explicit_type "String"
	    param in name "status" explicit_type "int"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}, final ${t1} ${p1}, final ${t2} ${p2}, final ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79330359 "updateCallbackLocked"
	  private explicit_return_type "void"
	  nparams 2
	    param inout name "callback" type class_ref 7152183 // AvailabilityCallback
	    param inout name "handler" type class_ref 6926391 // Handler
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Send the state of all known cameras to the provided listener, to initialize
the listener's knowledge of camera state.
"
	end

	operation 79330487 "onStatusChangedLocked"
	  private explicit_return_type "void"
	  nparams 2
	    param in name "status" explicit_type "int"
	    param inout name "id" explicit_type "String"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79330615 "updateTorchCallbackLocked"
	  private explicit_return_type "void"
	  nparams 2
	    param inout name "callback" type class_ref 7152311 // TorchCallback
	    param inout name "handler" type class_ref 6926391 // Handler
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " onStatusChangedLocked"
	end

	operation 79330743 "onTorchStatusChangedLocked"
	  private explicit_return_type "void"
	  nparams 2
	    param in name "status" explicit_type "int"
	    param inout name "id" explicit_type "String"
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79330871 "registerAvailabilityCallback"
	  public explicit_return_type "void"
	  nparams 2
	    param inout name "callback" type class_ref 7152183 // AvailabilityCallback
	    param inout name "handler" type class_ref 6926391 // Handler
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " onTorchStatusChangedLocked

Register a callback to be notified about camera device availability with the
global listener singleton.

@param callback the new callback to send camera availability notices to
@param handler The handler on which the callback should be invoked. May not be null.
"
	end

	operation 79330999 "unregisterAvailabilityCallback"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "callback" type class_ref 7152183 // AvailabilityCallback
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Remove a previously-added callback; the callback will no longer receive connection and
disconnection callbacks, and is no longer referenced by the global listener singleton.

@param callback The callback to remove from the notification list
"
	end

	operation 79331127 "registerTorchCallback"
	  public explicit_return_type "void"
	  nparams 2
	    param inout name "callback" type class_ref 7152311 // TorchCallback
	    param inout name "handler" type class_ref 6926391 // Handler
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79331255 "unregisterTorchCallback"
	  public explicit_return_type "void"
	  nparams 1
	    param inout name "callback" type class_ref 7152311 // TorchCallback
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 79331383 "onStatusChanged"
	  public explicit_return_type "void"
	  nparams 2
	    param in name "status" explicit_type "int"
	    param in name "cameraId" explicit_type "int"
	  nexceptions 1
	    exception class_ref 6931639 // RemoteException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@Override
"
	  
	  
	  
	  comment "Callback from camera service notifying the process about camera availability changes
"
	end

	operation 79331511 "onTorchStatusChanged"
	  public explicit_return_type "void"
	  nparams 2
	    param in name "status" explicit_type "int"
	    param inout name "cameraId" explicit_type "String"
	  nexceptions 1
	    exception class_ref 6931639 // RemoteException
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  java_annotation "@Override
"
	  
	  
	  
	end

	operation 79331639 "scheduleCameraServiceReconnectionLocked"
	  private explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Try to connect to camera service after some delay if any client registered camera
availability callback or torch status callback.
"
	end

	operation 79331767 "binderDied"
	  public explicit_return_type "void"
	  nparams 0
	  cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	  cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Listener for camera service death.

<p>The camera service isn't supposed to die under any normal circumstances, but can be
turned off during debug, or crash due to bugs.  So detect that and null out the interface
object, so that the next calls to the manager can try to reconnect.</p>
"
	end
      end
    end

    class 7153591 "DngCreator"
      visibility public 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      final java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "The {@link DngCreator} class provides functions to write raw pixel data as a DNG file.

<p>
This class is designed to be used with the {@link android.graphics.ImageFormat#RAW_SENSOR}
buffers available from {@link android.hardware.camera2.CameraDevice}, or with Bayer-type raw
pixel data that is otherwise generated by an application.  The DNG metadata tags will be
generated from a {@link android.hardware.camera2.CaptureResult} object or set directly.
</p>

<p>
The DNG file format is a cross-platform file format that is used to store pixel data from
camera sensors with minimal pre-processing applied.  DNG files allow for pixel data to be
defined in a user-defined colorspace, and have associated metadata that allow for this
pixel data to be converted to the standard CIE XYZ colorspace during post-processing.
</p>

<p>
For more information on the DNG file format and associated metadata, please refer to the
<a href=
\"https://wwwimages2.adobe.com/content/dam/Adobe/en/products/photoshop/pdfs/dng_spec_1.4.0.0.pdf\">
Adobe DNG 1.4.0.0 specification</a>.
</p>
"
      operation 79339831 "DngCreator"
	public explicit_return_type ""
	nparams 2
	  param inout name "characteristics" type class_ref 7148855 // CameraCharacteristics
	  param inout name "metadata" type class_ref 7148343 // CaptureResult
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Create a new DNG object.

<p>
It is not necessary to call any set methods to write a well-formatted DNG file.
</p>
<p>
DNG metadata tags will be generated from the corresponding parameters in the
{@link android.hardware.camera2.CaptureResult} object.
</p>
<p>
For best quality DNG files, it is strongly recommended that lens shading map output is
enabled if supported. See {@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE}.
</p>
@param characteristics an object containing the static
         {@link android.hardware.camera2.CameraCharacteristics}.
@param metadata a metadata object to generate tags from.
"
      end

      operation 79339959 "setOrientation"
	public return_type class_ref 7153591 // DngCreator
	nparams 1
	  param in name "orientation" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Set the orientation value to write.

<p>
This will be written as the TIFF \"Orientation\" tag {@code (0x0112)}.
Calling this will override any prior settings for this tag.
</p>

@param orientation the orientation value to set, one of:
                   <ul>
                     <li>{@link android.media.ExifInterface#ORIENTATION_NORMAL}</li>
                     <li>{@link android.media.ExifInterface#ORIENTATION_FLIP_HORIZONTAL}</li>
                     <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_180}</li>
                     <li>{@link android.media.ExifInterface#ORIENTATION_FLIP_VERTICAL}</li>
                     <li>{@link android.media.ExifInterface#ORIENTATION_TRANSPOSE}</li>
                     <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_90}</li>
                     <li>{@link android.media.ExifInterface#ORIENTATION_TRANSVERSE}</li>
                     <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_270}</li>
                   </ul>
@return this {@link #DngCreator} object.
"
      end

      operation 79340087 "setThumbnail"
	public return_type class_ref 7153591 // DngCreator
	nparams 1
	  param inout name "pixels" type class_ref 5824951 // Bitmap
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Set the thumbnail image.

<p>
Pixel data will be converted to a Baseline TIFF RGB image, with 8 bits per color channel.
The alpha channel will be discarded.  Thumbnail images with a dimension larger than
{@link #MAX_THUMBNAIL_DIMENSION} will be rejected.
</p>

@param pixels a {@link android.graphics.Bitmap} of pixel data.
@return this {@link #DngCreator} object.
@throws java.lang.IllegalArgumentException if the given thumbnail image has a dimension
     larger than {@link #MAX_THUMBNAIL_DIMENSION}.
"
      end

      operation 79340215 "setThumbnail"
	public return_type class_ref 7153591 // DngCreator
	nparams 1
	  param inout name "pixels" type class_ref 5893943 // Image
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Set the thumbnail image.

<p>
Pixel data is interpreted as a {@link android.graphics.ImageFormat#YUV_420_888} image.
Thumbnail images with a dimension larger than {@link #MAX_THUMBNAIL_DIMENSION} will be
rejected.
</p>

@param pixels an {@link android.media.Image} object with the format
              {@link android.graphics.ImageFormat#YUV_420_888}.
@return this {@link #DngCreator} object.
@throws java.lang.IllegalArgumentException if the given thumbnail image has a dimension
     larger than {@link #MAX_THUMBNAIL_DIMENSION}.
"
      end

      operation 79340343 "setLocation"
	public return_type class_ref 7153591 // DngCreator
	nparams 1
	  param inout name "location" type class_ref 6060087 // Location
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Set image location metadata.

<p>
The given location object must contain at least a valid time, latitude, and longitude
(equivalent to the values returned by {@link android.location.Location#getTime()},
{@link android.location.Location#getLatitude()}, and
{@link android.location.Location#getLongitude()} methods).
</p>

@param location an {@link android.location.Location} object to set.
@return this {@link #DngCreator} object.

@throws java.lang.IllegalArgumentException if the given location object doesn't
         contain enough information to set location metadata.
"
      end

      operation 79340471 "setDescription"
	public return_type class_ref 7153591 // DngCreator
	nparams 1
	  param inout name "description" explicit_type "String"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@NonNull
"
	
	
	
	comment "Set the user description string to write.

<p>
This is equivalent to setting the TIFF \"ImageDescription\" tag {@code (0x010E)}.
</p>

@param description the user description string.
@return this {@link #DngCreator} object.
"
      end

      operation 79340599 "writeInputStream"
	public explicit_return_type "void"
	nparams 4
	  param inout name "dngOutput" explicit_type "OutputStream"
	  param inout name "size" type class_ref 6985911 // Size
	  param inout name "pixels" explicit_type "InputStream"
	  param in name "offset" explicit_type "long"
	nexceptions 1
	  explicit_exception "IOException"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, @NonNull ${t2} ${p2}, @IntRange(from=0) ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Write the {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data to a DNG file with
the currently configured metadata.

<p>
Raw pixel data must have 16 bits per pixel, and the input must contain at least
{@code offset + 2 * width * height)} bytes.  The width and height of
the input are taken from the width and height set in the {@link DngCreator} metadata tags,
and will typically be equal to the width and height of
{@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE}.  Prior to
API level 23, this was always the same as
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE}.
The pixel layout in the input is determined from the reported color filter arrangement (CFA)
set in {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT}.  If insufficient
metadata is available to write a well-formatted DNG file, an
{@link java.lang.IllegalStateException} will be thrown.
</p>

@param dngOutput an {@link java.io.OutputStream} to write the DNG file to.
@param size the {@link Size} of the image to write, in pixels.
@param pixels an {@link java.io.InputStream} of pixel data to write.
@param offset the offset of the raw image in bytes.  This indicates how many bytes will
              be skipped in the input before any pixel data is read.

@throws IOException if an error was encountered in the input or output stream.
@throws java.lang.IllegalStateException if not enough metadata information has been
         set to write a well-formatted DNG file.
@throws java.lang.IllegalArgumentException if the size passed in does not match the
"
      end

      operation 79340727 "writeByteBuffer"
	public explicit_return_type "void"
	nparams 4
	  param inout name "dngOutput" explicit_type "OutputStream"
	  param inout name "size" type class_ref 6985911 // Size
	  param inout name "pixels" explicit_type "ByteBuffer"
	  param in name "offset" explicit_type "long"
	nexceptions 1
	  explicit_exception "IOException"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}, @NonNull ${t2} ${p2}, @IntRange(from=0) ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Write the {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data to a DNG file with
the currently configured metadata.

<p>
Raw pixel data must have 16 bits per pixel, and the input must contain at least
{@code offset + 2 * width * height)} bytes.  The width and height of
the input are taken from the width and height set in the {@link DngCreator} metadata tags,
and will typically be equal to the width and height of
{@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE}.  Prior to
API level 23, this was always the same as
{@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE}.
The pixel layout in the input is determined from the reported color filter arrangement (CFA)
set in {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT}.  If insufficient
metadata is available to write a well-formatted DNG file, an
{@link java.lang.IllegalStateException} will be thrown.
</p>

<p>
Any mark or limit set on this {@link ByteBuffer} is ignored, and will be cleared by this
method.
</p>

@param dngOutput an {@link java.io.OutputStream} to write the DNG file to.
@param size the {@link Size} of the image to write, in pixels.
@param pixels an {@link java.nio.ByteBuffer} of pixel data to write.
@param offset the offset of the raw image in bytes.  This indicates how many bytes will
              be skipped in the input before any pixel data is read.

@throws IOException if an error was encountered in the input or output stream.
@throws java.lang.IllegalStateException if not enough metadata information has been
         set to write a well-formatted DNG file.
"
      end

      operation 79340855 "writeImage"
	public explicit_return_type "void"
	nparams 2
	  param inout name "dngOutput" explicit_type "OutputStream"
	  param inout name "pixels" type class_ref 5893943 // Image
	nexceptions 1
	  explicit_exception "IOException"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}@NonNull ${t0} ${p0}, @NonNull ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Write the pixel data to a DNG file with the currently configured metadata.

<p>
For this method to succeed, the {@link android.media.Image} input must contain
{@link android.graphics.ImageFormat#RAW_SENSOR} pixel data, otherwise an
{@link java.lang.IllegalArgumentException} will be thrown.
</p>

@param dngOutput an {@link java.io.OutputStream} to write the DNG file to.
@param pixels an {@link android.media.Image} to write.

@throws java.io.IOException if an error was encountered in the output stream.
@throws java.lang.IllegalArgumentException if an image with an unsupported format was used.
@throws java.lang.IllegalStateException if not enough metadata information has been
         set to write a well-formatted DNG file.
"
      end

      operation 79340983 "close"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
      end

      attribute 24803127 "MAX_THUMBNAIL_DIMENSION"
	class_attribute const_attribute public explicit_type "int"
	init_value " 256"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Max width or height dimension for thumbnails.

 max pixel dimension for TIFF/EP"
      end

      operation 79341111 "finalize"
	protected explicit_return_type "void"
	nparams 0
	nexceptions 1
	  explicit_exception "Throwable"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
      end

      attribute 24803255 "sExifGPSDateStamp"
	class_attribute const_attribute private explicit_type "DateFormat"
	init_value " new SimpleDateFormat(GPS_DATE_FORMAT_STR)"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24803383 "sDateTimeStampFormat"
	class_attribute const_attribute private explicit_type "DateFormat"
	init_value "
            new SimpleDateFormat(TIFF_DATETIME_FORMAT)"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 24803511 "mGPSTimeStampCalendar"
	const_attribute private explicit_type "Calendar"
	init_value " Calendar
            .getInstance(TimeZone.getTimeZone(\"UTC\"))"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      extra_member 288567 "initialization"
	
	cpp "" ""
	java "  static {
        sDateTimeStampFormat.setTimeZone(TimeZone.getDefault());
        sExifGPSDateStamp.setTimeZone(TimeZone.getTimeZone(\"UTC\"));
    }"
	php ""
	python ""
	idl ""
	mysql ""
      end

      attribute 24803639 "DEFAULT_PIXEL_STRIDE"
	class_attribute const_attribute private explicit_type "int"
	init_value " 2"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " bytes per sample"
      end

      attribute 24803767 "BYTES_PER_RGB_PIX"
	class_attribute const_attribute private explicit_type "int"
	init_value " 3"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " byts per pixel"
      end

      attribute 24803895 "TAG_ORIENTATION_UNKNOWN"
	class_attribute const_attribute private explicit_type "int"
	init_value " 9"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " TIFF tag values needed to map between public API and TIFF spec
"
      end

      operation 79341239 "writeByteBuffer"
	private explicit_return_type "void"
	nparams 7
	  param in name "width" explicit_type "int"
	  param in name "height" explicit_type "int"
	  param inout name "pixels" explicit_type "ByteBuffer"
	  param inout name "dngOutput" explicit_type "OutputStream"
	  param in name "pixelStride" explicit_type "int"
	  param in name "rowStride" explicit_type "int"
	  param in name "offset" explicit_type "long"
	nexceptions 1
	  explicit_exception "IOException"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6} ${p6}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Offset, rowStride, and pixelStride are given in bytes.  Height and width are given in pixels.
"
      end

      operation 79341367 "yuvToRgb"
	class_operation private explicit_return_type "void"
	nparams 3
	  param inout name "yuvData" explicit_type "byte"
	multiplicity "[]"
	  param in name "outOffset" explicit_type "int"
	  param inout name "rgbOut" explicit_type "byte"
	multiplicity "[]"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2}[] ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convert a single YUV pixel to RGB.
"
      end

      operation 79341495 "colorToRgb"
	class_operation private explicit_return_type "void"
	nparams 3
	  param in name "color" explicit_type "int"
	  param in name "outOffset" explicit_type "int"
	  param inout name "rgbOut" explicit_type "byte"
	multiplicity "[]"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2}[] ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convert a single {@link Color} pixel to RGB.
"
      end

      operation 79341623 "convertToRGB"
	class_operation private explicit_return_type "ByteBuffer"
	nparams 1
	  param inout name "yuvImage" type class_ref 5893943 // Image
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Generate a direct RGB {@link ByteBuffer} from a YUV420_888 {@link Image}.
"
      end

      operation 79341751 "convertToRGB"
	class_operation private explicit_return_type "ByteBuffer"
	nparams 1
	  param inout name "argbBitmap" type class_ref 5824951 // Bitmap
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Generate a direct RGB {@link ByteBuffer} from a {@link Bitmap}.
"
      end

      operation 79341879 "toExifLatLong"
	class_operation private explicit_return_type "int"
	nparams 1
	  param in name "value" explicit_type "double"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}[] ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convert coordinate to EXIF GPS tag format.
"
      end

      attribute 24804023 "mNativeContext"
	private explicit_type "long"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "This field is used by native code, do not access or modify.

"
      end

      operation 79342007 "nativeClassInit"
	class_operation private explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}native ${type} ${name}${(}${)}${throws};
s"
	
	
	
      end

      operation 79342135 "nativeInit"
	private explicit_return_type "void"
	nparams 3
	  param inout name "nativeCharacteristics" type class_ref 7149239 // CameraMetadataNative
	  param inout name "nativeResult" type class_ref 7149239 // CameraMetadataNative
	  param inout name "captureTime" explicit_type "String"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	synchronized java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}native ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws};
s"
	
	
	
      end

      operation 79342263 "nativeDestroy"
	private explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	synchronized java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}native ${type} ${name}${(}${)}${throws};
s"
	
	
	
      end

      operation 79342391 "nativeSetOrientation"
	private explicit_return_type "void"
	nparams 1
	  param in name "orientation" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	synchronized java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}native ${type} ${name}${(}${t0} ${p0}${)}${throws};
s"
	
	
	
      end

      operation 79342519 "nativeSetDescription"
	private explicit_return_type "void"
	nparams 1
	  param inout name "description" explicit_type "String"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	synchronized java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}native ${type} ${name}${(}${t0} ${p0}${)}${throws};
s"
	
	
	
      end

      operation 79342647 "nativeSetGpsTags"
	private explicit_return_type "void"
	nparams 6
	  param inout name "latTag" explicit_type "int"
	multiplicity "[]"
	  param inout name "latRef" explicit_type "String"
	  param inout name "longTag" explicit_type "int"
	multiplicity "[]"
	  param inout name "longRef" explicit_type "String"
	  param inout name "dateTag" explicit_type "String"
	  param inout name "timeTag" explicit_type "int"
	multiplicity "[]"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	synchronized java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}native ${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2}[] ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5}[] ${p5}${)}${throws};
s"
	
	
	
      end

      operation 79342775 "nativeSetThumbnail"
	private explicit_return_type "void"
	nparams 3
	  param inout name "buffer" explicit_type "ByteBuffer"
	  param in name "width" explicit_type "int"
	  param in name "height" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	synchronized java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}native ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws};
s"
	
	
	
      end

      operation 79342903 "nativeWriteImage"
	private explicit_return_type "void"
	nparams 8
	  param inout name "out" explicit_type "OutputStream"
	  param in name "width" explicit_type "int"
	  param in name "height" explicit_type "int"
	  param inout name "rawBuffer" explicit_type "ByteBuffer"
	  param in name "rowStride" explicit_type "int"
	  param in name "pixStride" explicit_type "int"
	  param in name "offset" explicit_type "long"
	  param inout name "isDirect" explicit_type "boolean"
	nexceptions 1
	  explicit_exception "IOException"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	synchronized java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}native ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6} ${p6}, ${t7} ${p7}${)}${throws};
s"
	
	
	
      end

      operation 79343031 "nativeWriteInputStream"
	private explicit_return_type "void"
	nparams 5
	  param inout name "out" explicit_type "OutputStream"
	  param inout name "rawStream" explicit_type "InputStream"
	  param in name "width" explicit_type "int"
	  param in name "height" explicit_type "int"
	  param in name "offset" explicit_type "long"
	nexceptions 1
	  explicit_exception "IOException"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	synchronized java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}native ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}${)}${throws};
s"
	
	
	
      end

      extra_member 288695 "initialization"
	
	cpp "" ""
	java "  static {
        nativeClassInit();
    }"
	php ""
	python ""
	idl ""
	mysql ""
      end
    end
  end

  deploymentview 135351 "camera2"
    //deployment diagram settings
    deploymentdiagramsettings
     end
    artifact 2829623 "CameraAccessException"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.NonNull;
import android.annotation.IntDef;
import android.util.AndroidException;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
${definition}"
      associated_classes
	class_ref 7147319 // CameraAccessException
      end
      comment "Copyright (C) 2013 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2829751 "CameraCaptureSession"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.NonNull;
import android.annotation.Nullable;
import android.os.Handler;
import android.view.Surface;
import java.util.List;
${definition}"
      associated_classes
	class_ref 7147575 // CameraCaptureSession
      end
      comment "Copyright (C) 2014 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2829879 "CameraMetadata"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.NonNull;
import android.hardware.camera2.impl.CameraMetadataNative;
import android.hardware.camera2.impl.PublicKey;
import android.hardware.camera2.impl.SyntheticKey;
import android.util.Log;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
${definition}"
      associated_classes
	class_ref 7148983 // CameraMetadata
      end
      comment "Copyright (C) 2013 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2830007 "CameraCharacteristics"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.NonNull;
import android.annotation.Nullable;
import android.hardware.camera2.impl.CameraMetadataNative;
import android.hardware.camera2.impl.PublicKey;
import android.hardware.camera2.impl.SyntheticKey;
import android.hardware.camera2.utils.TypeReference;
import android.util.Rational;
import java.util.Collections;
import java.util.List;
${definition}"
      associated_classes
	class_ref 7148855 // CameraCharacteristics
      end
      comment "Copyright (C) 2013 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2830135 "CameraConstrainedHighSpeedCaptureSession"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.NonNull;
import android.hardware.camera2.params.StreamConfigurationMap;
import java.util.List;
${definition}"
      associated_classes
	class_ref 7151159 // CameraConstrainedHighSpeedCaptureSession
      end
      comment "Copyright 2015 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2830263 "CameraDevice"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.NonNull;
import android.annotation.Nullable;
import android.annotation.IntDef;
import android.hardware.camera2.params.InputConfiguration;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.hardware.camera2.params.OutputConfiguration;
import android.os.Handler;
import android.view.Surface;
import java.util.List;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
${definition}"
      associated_classes
	class_ref 7147703 // CameraDevice
      end
      comment "Copyright (C) 2013 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2830391 "CameraManager"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.RequiresPermission;
import android.annotation.NonNull;
import android.annotation.Nullable;
import android.content.Context;
import android.hardware.ICameraService;
import android.hardware.ICameraServiceListener;
import android.hardware.CameraInfo;
import android.hardware.camera2.impl.CameraMetadataNative;
import android.hardware.camera2.legacy.CameraDeviceUserShim;
import android.hardware.camera2.legacy.LegacyMetadataMapper;
import android.os.IBinder;
import android.os.Binder;
import android.os.DeadObjectException;
import android.os.Handler;
import android.os.Looper;
import android.os.RemoteException;
import android.os.ServiceManager;
import android.os.ServiceSpecificException;
import android.util.Log;
import android.util.ArrayMap;
import java.util.ArrayList;
${definition}"
      associated_classes
	class_ref 7152055 // CameraManager
      end
      comment "Copyright (C) 2013 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2830519 "CaptureFailure"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.NonNull;
import android.annotation.IntDef;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
${definition}"
      associated_classes
	class_ref 7148599 // CaptureFailure
      end
      comment "Copyright (C) 2013 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2830647 "CaptureRequest"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.NonNull;
import android.annotation.Nullable;
import android.hardware.camera2.impl.CameraMetadataNative;
import android.hardware.camera2.impl.PublicKey;
import android.hardware.camera2.impl.SyntheticKey;
import android.hardware.camera2.utils.HashCodeHelpers;
import android.hardware.camera2.utils.TypeReference;
import android.os.Parcel;
import android.os.Parcelable;
import android.view.Surface;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
${definition}"
      associated_classes
	class_ref 7147831 // CaptureRequest
      end
      comment "Copyright (C) 2013 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2830775 "CaptureResult"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.NonNull;
import android.annotation.Nullable;
import android.hardware.camera2.impl.CameraMetadataNative;
import android.hardware.camera2.impl.CaptureResultExtras;
import android.hardware.camera2.impl.PublicKey;
import android.hardware.camera2.impl.SyntheticKey;
import android.hardware.camera2.utils.TypeReference;
import android.util.Log;
import android.util.Rational;
import java.util.List;
${definition}"
      associated_classes
	class_ref 7148343 // CaptureResult
      end
      comment "Copyright (C) 2012 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2830903 "DngCreator"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.IntRange;
import android.annotation.NonNull;
import android.annotation.Nullable;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.ImageFormat;
import android.hardware.camera2.impl.CameraMetadataNative;
import android.location.Location;
import android.media.ExifInterface;
import android.media.Image;
import android.os.SystemClock;
import android.util.Size;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.TimeZone;
${definition}"
      associated_classes
	class_ref 7153591 // DngCreator
      end
      comment "Copyright 2014 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end

    artifact 2831031 "TotalCaptureResult"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      java_src "${comment}
${package}
${imports}
import android.annotation.NonNull;
import android.hardware.camera2.impl.CameraMetadataNative;
import android.hardware.camera2.impl.CaptureResultExtras;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
${definition}"
      associated_classes
	class_ref 7148471 // TotalCaptureResult
      end
      comment "Copyright (C) 2014 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"
    end
  end

  package_ref 144183 // impl

  package_ref 144311 // utils

  package_ref 144439 // params

  package_ref 144823 // dispatch

  package_ref 145079 // marshal

  package_ref 145207 // legacy
end
