class GL2Encoder
!!!43999927.cpp!!!	GL2Encoder(inout stream : IOStream, inout protocol : ChecksumCalculator)
    m_initialized = false;
    m_state = NULL;
    m_error = GL_NO_ERROR;
    m_num_compressedTextureFormats = 0;
    m_max_cubeMapTextureSize = 0;
    m_max_renderBufferSize = 0;
    m_max_textureSize = 0;
    m_compressedTextureFormats = NULL;

    //overrides
#define OVERRIDE(name)  m_##name##_enc = this-> name ; this-> name = &s_##name

    OVERRIDE(glFlush);
    OVERRIDE(glPixelStorei);
    OVERRIDE(glGetString);
    OVERRIDE(glBindBuffer);
    OVERRIDE(glBufferData);
    OVERRIDE(glBufferSubData);
    OVERRIDE(glDeleteBuffers);
    OVERRIDE(glDrawArrays);
    OVERRIDE(glDrawElements);
    OVERRIDE(glGetIntegerv);
    OVERRIDE(glGetFloatv);
    OVERRIDE(glGetBooleanv);
    OVERRIDE(glVertexAttribPointer);
    OVERRIDE(glEnableVertexAttribArray);
    OVERRIDE(glDisableVertexAttribArray);
    OVERRIDE(glGetVertexAttribiv);
    OVERRIDE(glGetVertexAttribfv);
    OVERRIDE(glGetVertexAttribPointerv);

    this->glShaderBinary = &s_glShaderBinary;
    this->glShaderSource = &s_glShaderSource;
    this->glFinish = &s_glFinish;

    OVERRIDE(glGetError);
    OVERRIDE(glLinkProgram);
    OVERRIDE(glDeleteProgram);
    OVERRIDE(glGetUniformiv);
    OVERRIDE(glGetUniformfv);
    OVERRIDE(glCreateProgram);
    OVERRIDE(glCreateShader);
    OVERRIDE(glDeleteShader);
    OVERRIDE(glAttachShader);
    OVERRIDE(glDetachShader);
    OVERRIDE(glGetAttachedShaders);
    OVERRIDE(glGetShaderSource);
    OVERRIDE(glGetShaderInfoLog);
    OVERRIDE(glGetProgramInfoLog);

    OVERRIDE(glGetUniformLocation);
    OVERRIDE(glUseProgram);

    OVERRIDE(glUniform1f);
    OVERRIDE(glUniform1fv);
    OVERRIDE(glUniform1i);
    OVERRIDE(glUniform1iv);
    OVERRIDE(glUniform2f);
    OVERRIDE(glUniform2fv);
    OVERRIDE(glUniform2i);
    OVERRIDE(glUniform2iv);
    OVERRIDE(glUniform3f);
    OVERRIDE(glUniform3fv);
    OVERRIDE(glUniform3i);
    OVERRIDE(glUniform3iv);
    OVERRIDE(glUniform4f);
    OVERRIDE(glUniform4fv);
    OVERRIDE(glUniform4i);
    OVERRIDE(glUniform4iv);
    OVERRIDE(glUniformMatrix2fv);
    OVERRIDE(glUniformMatrix3fv);
    OVERRIDE(glUniformMatrix4fv);

    OVERRIDE(glActiveTexture);
    OVERRIDE(glBindTexture);
    OVERRIDE(glDeleteTextures);
    OVERRIDE(glGetTexParameterfv);
    OVERRIDE(glGetTexParameteriv);
    OVERRIDE(glTexParameterf);
    OVERRIDE(glTexParameterfv);
    OVERRIDE(glTexParameteri);
    OVERRIDE(glTexParameteriv);
    OVERRIDE(glTexImage2D);
    OVERRIDE(glTexSubImage2D);
!!!44000055.cpp!!!	~GL2Encoder()
    delete m_compressedTextureFormats;
!!!44001335.cpp!!!	override2DTextureTarget(in target : GLenum) : void
    if ((target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) &&
        target != m_state->getPriorityEnabledTarget(GL_TEXTURE_2D)) {
            m_glBindTexture_enc(this, GL_TEXTURE_2D,
                    m_state->getBoundTexture(target));
    }
!!!44001463.cpp!!!	restore2DTextureTarget() : void
    GLenum priorityTarget = m_state->getPriorityEnabledTarget(GL_TEXTURE_2D);
    m_glBindTexture_enc(this, GL_TEXTURE_2D,
            m_state->getBoundTexture(priorityTarget));
!!!44001591.cpp!!!	getCompressedTextureFormats() : GLint
    if (m_compressedTextureFormats == NULL) {
        this->glGetIntegerv(this, GL_NUM_COMPRESSED_TEXTURE_FORMATS,
                            &m_num_compressedTextureFormats);
        if (m_num_compressedTextureFormats > 0) {
            // get number of texture formats;
            m_compressedTextureFormats = new GLint[m_num_compressedTextureFormats];
            this->glGetCompressedTextureFormats(this, m_num_compressedTextureFormats, m_compressedTextureFormats);
        }
    }
    return m_compressedTextureFormats;
!!!44001719.cpp!!!	sendVertexAttributes(in first : GLint, in count : GLsizei) : void
    assert(m_state);

    for (int i = 0; i < m_state->nLocations(); i++) {
        bool enableDirty;
        const GLClientState::VertexAttribState *state = m_state->getStateAndEnableDirty(i, &enableDirty);

        if (!state) {
            continue;
        }

        if (!enableDirty && !state->enabled) {
            continue;
        }


        if (state->enabled) {
            m_glEnableVertexAttribArray_enc(this, i);

            unsigned int datalen = state->elementSize * count;
            int stride = state->stride == 0 ? state->elementSize : state->stride;
            int firstIndex = stride * first;

            this->m_glBindBuffer_enc(this, GL_ARRAY_BUFFER, state->bufferObject);
            if (state->bufferObject == 0) {
                this->glVertexAttribPointerData(this, i, state->size, state->type, state->normalized, state->stride,
                                                (unsigned char *)state->data + firstIndex, datalen);
            } else {
                this->glVertexAttribPointerOffset(this, i, state->size, state->type, state->normalized, state->stride,
                                                  (uintptr_t) state->data + firstIndex);
            }
            this->m_glBindBuffer_enc(this, GL_ARRAY_BUFFER, m_state->currentArrayVbo());
        } else {
            this->m_glDisableVertexAttribArray_enc(this, i);
        }
    }
!!!44001847.cpp!!!	updateHostTexture2DBinding(in texUnit : GLenum, in newTarget : GLenum) : bool
    if (newTarget != GL_TEXTURE_2D && newTarget != GL_TEXTURE_EXTERNAL_OES)
        return false;

    m_state->setActiveTextureUnit(texUnit);

    GLenum oldTarget = m_state->getPriorityEnabledTarget(GL_TEXTURE_2D);
    if (newTarget != oldTarget) {
        if (newTarget == GL_TEXTURE_EXTERNAL_OES) {
            m_state->disableTextureTarget(GL_TEXTURE_2D);
            m_state->enableTextureTarget(GL_TEXTURE_EXTERNAL_OES);
        } else {
            m_state->disableTextureTarget(GL_TEXTURE_EXTERNAL_OES);
            m_state->enableTextureTarget(GL_TEXTURE_2D);
        }
        m_glActiveTexture_enc(this, texUnit);
        m_glBindTexture_enc(this, GL_TEXTURE_2D,
                m_state->getBoundTexture(newTarget));
        return true;
    }

    return false;
!!!44001975.cpp!!!	checkValidUniformParam(inout self : void, in count : GLsizei, in transpose : GLboolean) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLuint program = ctx->m_state->currentProgram();
    SET_ERROR_IF(!ctx->m_shared->isProgram(program), GL_INVALID_OPERATION);
    SET_ERROR_IF((count < 0 || transpose == GL_TRUE), GL_INVALID_VALUE);
!!!44002103.cpp!!!	getHostLocation(inout self : void, in location : GLint, inout hostLoc : GLint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLuint program = ctx->m_state->currentProgram();
    if (location == -1) {
        *hostLoc = location;
        return;
    }
    SET_ERROR_IF((location < 0), GL_INVALID_OPERATION);
    GLint curHostLoc = ctx->m_shared->locationWARAppToHost(program,location);
    SET_ERROR_IF((ctx->m_shared->getProgramUniformType(program,curHostLoc) == 0 &&
            curHostLoc!=-1), GL_INVALID_OPERATION);
    *hostLoc = curHostLoc;
!!!44002231.cpp!!!	s_glGetError(inout self : void) : GLenum
    GL2Encoder *ctx = (GL2Encoder *)self;
    GLenum err = ctx->getError();
    if(err != GL_NO_ERROR) {
        ctx->setError(GL_NO_ERROR);
        return err;
    }

    return ctx->m_glGetError_enc(self);

!!!44002359.cpp!!!	s_glFlush(inout self : void) : void
    GL2Encoder *ctx = (GL2Encoder *) self;
    ctx->m_glFlush_enc(self);
    ctx->m_stream->flush();
!!!44002487.cpp!!!	s_glPixelStorei(inout self : void, in param : GLenum, in value : GLint) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    ctx->m_glPixelStorei_enc(ctx, param, value);
    assert(ctx->m_state != NULL);
    ctx->m_state->setPixelStore(param, value);
!!!44002615.cpp!!!	s_glGetString(inout self : void, in name : GLenum) : GLubyte
    (void)self;

    GLubyte *retval =  (GLubyte *) "";
    switch(name) {
    case GL_VENDOR:
        retval = gVendorString;
        break;
    case GL_RENDERER:
        retval = gRendererString;
        break;
    case GL_VERSION:
        retval = gVersionString;
        break;
    case GL_EXTENSIONS:
        retval = gExtensionsString;
        break;
    }
    return retval;
!!!44002743.cpp!!!	s_glBindBuffer(inout self : void, in target : GLenum, in id : GLuint) : void
    GL2Encoder *ctx = (GL2Encoder *) self;
    assert(ctx->m_state != NULL);
    ctx->m_state->bindBuffer(target, id);
    // TODO set error state if needed;
    ctx->m_glBindBuffer_enc(self, target, id);
!!!44002871.cpp!!!	s_glBufferData(inout self : void, in target : GLenum, in size : GLsizeiptr, in data : GLvoid, in usage : GLenum) : void
    GL2Encoder *ctx = (GL2Encoder *) self;
    SET_ERROR_IF(!(target == GL_ARRAY_BUFFER || target == GL_ELEMENT_ARRAY_BUFFER), GL_INVALID_ENUM);
    GLuint bufferId = ctx->m_state->getBuffer(target);
    SET_ERROR_IF(bufferId==0, GL_INVALID_OPERATION);
    SET_ERROR_IF(size<0, GL_INVALID_VALUE);

    ctx->m_shared->updateBufferData(bufferId, size, (void*)data);
    ctx->m_glBufferData_enc(self, target, size, data, usage);
!!!44002999.cpp!!!	s_glBufferSubData(inout self : void, in target : GLenum, in offset : GLintptr, in size : GLsizeiptr, in data : GLvoid) : void
    GL2Encoder *ctx = (GL2Encoder *) self;
    SET_ERROR_IF(!(target == GL_ARRAY_BUFFER || target == GL_ELEMENT_ARRAY_BUFFER), GL_INVALID_ENUM);
    GLuint bufferId = ctx->m_state->getBuffer(target);
    SET_ERROR_IF(bufferId==0, GL_INVALID_OPERATION);

    GLenum res = ctx->m_shared->subUpdateBufferData(bufferId, offset, size, (void*)data);
    SET_ERROR_IF(res, res);

    ctx->m_glBufferSubData_enc(self, target, offset, size, data);
!!!44003127.cpp!!!	s_glDeleteBuffers(inout self : void, in n : GLsizei, in buffers : GLuint) : void
    GL2Encoder *ctx = (GL2Encoder *) self;
    SET_ERROR_IF(n<0, GL_INVALID_VALUE);
    for (int i=0; i<n; i++) {
        ctx->m_shared->deleteBufferData(buffers[i]);
        ctx->m_state->unBindBuffer(buffers[i]);
        ctx->m_glDeleteBuffers_enc(self,1,&buffers[i]);
    }
!!!44003255.cpp!!!	s_glDrawArrays(inout self : void, in mode : GLenum, in first : GLint, in count : GLsizei) : void
    GL2Encoder *ctx = (GL2Encoder *)self;

    SET_ERROR_IF(!isValidDrawMode(mode), GL_INVALID_ENUM);
    SET_ERROR_IF(count<0, GL_INVALID_VALUE);

    bool has_arrays = false;
    int nLocations = ctx->m_state->nLocations();
    for (int i = 0; i < nLocations; i++) {
        const GLClientState::VertexAttribState *state = ctx->m_state->getState(i);
        if (state->enabled) {
            if (state->bufferObject || state->data)  {
                has_arrays = true;
            }
            else {
                ALOGE("glDrawArrays: a vertex attribute array is enabled with no data bound\n");
                ctx->setError(GL_INVALID_OPERATION);
                return;
            }
        }
    }
    if (!has_arrays) {
        ALOGE("glDrawArrays: no data bound to the command - ignoring\n");
        return;
    }

    ctx->sendVertexAttributes(first, count);
    ctx->m_glDrawArrays_enc(ctx, mode, 0, count);
!!!44003383.cpp!!!	s_glDrawElements(inout self : void, in mode : GLenum, in count : GLsizei, in type : GLenum, in indices : void) : void

    GL2Encoder *ctx = (GL2Encoder *)self;
    assert(ctx->m_state != NULL);
    SET_ERROR_IF(!(isValidDrawMode(mode) && isValidDrawType(type)),GL_INVALID_ENUM);
    SET_ERROR_IF(count<0, GL_INVALID_VALUE);

    bool has_immediate_arrays = false;
    bool has_indirect_arrays = false;
    int nLocations = ctx->m_state->nLocations();

    for (int i = 0; i < nLocations; i++) {
        const GLClientState::VertexAttribState *state = ctx->m_state->getState(i);
        if (state->enabled) {
            if (state->bufferObject != 0) {
                has_indirect_arrays = true;
            } else if (state->data) {
                has_immediate_arrays = true;
            } else {
                ALOGW("glDrawElements: a vertex attribute array is enabled with no data bound\n");
                ctx->setError(GL_INVALID_OPERATION);
                return;
            }
        }
    }

    if (!has_immediate_arrays && !has_indirect_arrays) {
        ALOGE("glDrawElements: no data bound to the command - ignoring\n");
        return;
    }

    bool adjustIndices = true;
    if (ctx->m_state->currentIndexVbo() != 0) {
        if (!has_immediate_arrays) {
            ctx->sendVertexAttributes(0, count);
            ctx->m_glBindBuffer_enc(self, GL_ELEMENT_ARRAY_BUFFER, ctx->m_state->currentIndexVbo());
            ctx->glDrawElementsOffset(ctx, mode, count, type, (uintptr_t)indices);
            adjustIndices = false;
        } else {
            BufferData * buf = ctx->m_shared->getBufferData(ctx->m_state->currentIndexVbo());
            ctx->m_glBindBuffer_enc(self, GL_ELEMENT_ARRAY_BUFFER, 0);
            indices = (void*)((GLintptr)buf->m_fixedBuffer.ptr() + (GLintptr)indices);
        }
    }
    if (adjustIndices) {
        void *adjustedIndices = (void*)indices;
        int minIndex = 0, maxIndex = 0;

        switch(type) {
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
            GLUtils::minmax<unsigned char>((unsigned char *)indices, count, &minIndex, &maxIndex);
            if (minIndex != 0) {
                adjustedIndices =  ctx->m_fixedBuffer.alloc(glSizeof(type) * count);
                GLUtils::shiftIndices<unsigned char>((unsigned char *)indices,
                                                 (unsigned char *)adjustedIndices,
                                                 count, -minIndex);
            }
            break;
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
            GLUtils::minmax<unsigned short>((unsigned short *)indices, count, &minIndex, &maxIndex);
            if (minIndex != 0) {
                adjustedIndices = ctx->m_fixedBuffer.alloc(glSizeof(type) * count);
                GLUtils::shiftIndices<unsigned short>((unsigned short *)indices,
                                                  (unsigned short *)adjustedIndices,
                                                  count, -minIndex);
            }
            break;
        case GL_INT:
        case GL_UNSIGNED_INT:
            GLUtils::minmax<unsigned int>((unsigned int *)indices, count, &minIndex, &maxIndex);
            if (minIndex != 0) {
                adjustedIndices = ctx->m_fixedBuffer.alloc(glSizeof(type) * count);
                GLUtils::shiftIndices<unsigned int>((unsigned int *)indices,
                                                 (unsigned int *)adjustedIndices,
                                                 count, -minIndex);
            }
            break;
        default:
            ALOGE("unsupported index buffer type %d\n", type);
        }
        if (has_indirect_arrays || 1) {
            ctx->sendVertexAttributes(minIndex, maxIndex - minIndex + 1);
            ctx->glDrawElementsData(ctx, mode, count, type, adjustedIndices,
                                    count * glSizeof(type));
            // XXX - OPTIMIZATION (see the other else branch) should be implemented
            if(!has_indirect_arrays) {
                //ALOGD("unoptimized drawelements !!!\n");
            }
        } else {
            // we are all direct arrays and immidate mode index array -
            // rebuild the arrays and the index array;
            ALOGE("glDrawElements: direct index & direct buffer data - will be implemented in later versions;\n");
        }
    }
!!!44003511.cpp!!!	s_glGetIntegerv(inout self : void, in param : GLenum, inout ptr : GLint) : void
    GL2Encoder *ctx = (GL2Encoder *) self;
    assert(ctx->m_state != NULL);
    GLClientState* state = ctx->m_state;

    switch (param) {
    case GL_NUM_SHADER_BINARY_FORMATS:
        *ptr = 0;
        break;
    case GL_SHADER_BINARY_FORMATS:
        // do nothing
        break;

    case GL_COMPRESSED_TEXTURE_FORMATS: {
        GLint *compressedTextureFormats = ctx->getCompressedTextureFormats();
        if (ctx->m_num_compressedTextureFormats > 0 &&
                compressedTextureFormats != NULL) {
            memcpy(ptr, compressedTextureFormats,
                    ctx->m_num_compressedTextureFormats * sizeof(GLint));
        }
        break;
    }

    case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
    case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
    case GL_MAX_TEXTURE_IMAGE_UNITS:
        ctx->m_glGetIntegerv_enc(self, param, ptr);
        *ptr = MIN(*ptr, GLClientState::MAX_TEXTURE_UNITS);
        break;

    case GL_TEXTURE_BINDING_2D:
        *ptr = state->getBoundTexture(GL_TEXTURE_2D);
        break;
    case GL_TEXTURE_BINDING_EXTERNAL_OES:
        *ptr = state->getBoundTexture(GL_TEXTURE_EXTERNAL_OES);
        break;

    case GL_MAX_CUBE_MAP_TEXTURE_SIZE:
        if (ctx->m_max_cubeMapTextureSize != 0) {
            *ptr = ctx->m_max_cubeMapTextureSize;
        } else {
            ctx->m_glGetIntegerv_enc(self, param, ptr);
            ctx->m_max_cubeMapTextureSize = *ptr;
        }
        break;
    case GL_MAX_RENDERBUFFER_SIZE:
        if (ctx->m_max_renderBufferSize != 0) {
            *ptr = ctx->m_max_renderBufferSize;
        } else {
            ctx->m_glGetIntegerv_enc(self, param, ptr);
            ctx->m_max_renderBufferSize = *ptr;
        }
        break;
    case GL_MAX_TEXTURE_SIZE:
        if (ctx->m_max_textureSize != 0) {
            *ptr = ctx->m_max_textureSize;
        } else {
            ctx->m_glGetIntegerv_enc(self, param, ptr);
            ctx->m_max_textureSize = *ptr;
        }
        break;
    case GL_MAX_VERTEX_ATTRIBS:
        if (!ctx->m_state->getClientStateParameter<GLint>(param, ptr)) {
            ctx->m_glGetIntegerv_enc(self, param, ptr);
            ctx->m_state->setMaxVertexAttribs(*ptr);
        }
        break;
    default:
        if (!ctx->m_state->getClientStateParameter<GLint>(param, ptr)) {
            ctx->m_glGetIntegerv_enc(self, param, ptr);
        }
        break;
    }
!!!44003639.cpp!!!	s_glGetFloatv(inout self : void, in param : GLenum, inout ptr : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    assert(ctx->m_state != NULL);
    GLClientState* state = ctx->m_state;

    switch (param) {
    case GL_NUM_SHADER_BINARY_FORMATS:
        *ptr = 0;
        break;
    case GL_SHADER_BINARY_FORMATS:
        // do nothing
        break;

    case GL_COMPRESSED_TEXTURE_FORMATS: {
        GLint *compressedTextureFormats = ctx->getCompressedTextureFormats();
        if (ctx->m_num_compressedTextureFormats > 0 &&
                compressedTextureFormats != NULL) {
            for (int i = 0; i < ctx->m_num_compressedTextureFormats; i++) {
                ptr[i] = (GLfloat) compressedTextureFormats[i];
            }
        }
        break;
    }

    case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
    case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
    case GL_MAX_TEXTURE_IMAGE_UNITS:
        ctx->m_glGetFloatv_enc(self, param, ptr);
        *ptr = MIN(*ptr, (GLfloat)GLClientState::MAX_TEXTURE_UNITS);
        break;

    case GL_TEXTURE_BINDING_2D:
        *ptr = (GLfloat)state->getBoundTexture(GL_TEXTURE_2D);
        break;
    case GL_TEXTURE_BINDING_EXTERNAL_OES:
        *ptr = (GLfloat)state->getBoundTexture(GL_TEXTURE_EXTERNAL_OES);
        break;

    default:
        if (!ctx->m_state->getClientStateParameter<GLfloat>(param, ptr)) {
            ctx->m_glGetFloatv_enc(self, param, ptr);
        }
        break;
    }
!!!44003767.cpp!!!	s_glGetBooleanv(inout self : void, in param : GLenum, inout ptr : GLboolean) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    assert(ctx->m_state != NULL);
    GLClientState* state = ctx->m_state;

    switch (param) {
    case GL_NUM_SHADER_BINARY_FORMATS:
        *ptr = GL_FALSE;
        break;
    case GL_SHADER_BINARY_FORMATS:
        // do nothing
        break;

    case GL_COMPRESSED_TEXTURE_FORMATS: {
        GLint *compressedTextureFormats = ctx->getCompressedTextureFormats();
        if (ctx->m_num_compressedTextureFormats > 0 &&
                compressedTextureFormats != NULL) {
            for (int i = 0; i < ctx->m_num_compressedTextureFormats; i++) {
                ptr[i] = compressedTextureFormats[i] != 0 ? GL_TRUE : GL_FALSE;
            }
        }
        break;
    }

    case GL_TEXTURE_BINDING_2D:
        *ptr = state->getBoundTexture(GL_TEXTURE_2D) != 0 ? GL_TRUE : GL_FALSE;
        break;
    case GL_TEXTURE_BINDING_EXTERNAL_OES:
        *ptr = state->getBoundTexture(GL_TEXTURE_EXTERNAL_OES) != 0
                ? GL_TRUE : GL_FALSE;
        break;

    default:
        if (!ctx->m_state->getClientStateParameter<GLboolean>(param, ptr)) {
            ctx->m_glGetBooleanv_enc(self, param, ptr);
        }
        *ptr = (*ptr != 0) ? GL_TRUE : GL_FALSE;
        break;
    }
!!!44003895.cpp!!!	s_glVertexAttribPointer(inout self : void, in indx : GLuint, in size : GLint, in type : GLenum, in normalized : GLboolean, in stride : GLsizei, in ptr : GLvoid) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    assert(ctx->m_state != NULL);
    ctx->m_state->setState(indx, size, type, normalized, stride, ptr);
!!!44004023.cpp!!!	s_glEnableVertexAttribArray(inout self : void, in index : GLuint) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    assert(ctx->m_state);
    GLint maxIndex;
    ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
    SET_ERROR_IF(!(index < maxIndex), GL_INVALID_VALUE);
    ctx->m_state->enable(index, 1);
!!!44004151.cpp!!!	s_glDisableVertexAttribArray(inout self : void, in index : GLuint) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    assert(ctx->m_state);
    GLint maxIndex;
    ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
    SET_ERROR_IF(!(index < maxIndex), GL_INVALID_VALUE);
    ctx->m_state->enable(index, 0);
!!!44004279.cpp!!!	s_glGetVertexAttribiv(inout self : void, in index : GLuint, in pname : GLenum, inout params : GLint) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    assert(ctx->m_state);
    GLint maxIndex;
    ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
    SET_ERROR_IF(!(index < maxIndex), GL_INVALID_VALUE);

    if (!ctx->m_state->getVertexAttribParameter<GLint>(index, pname, params)) {
        ctx->m_glGetVertexAttribiv_enc(self, index, pname, params);
    }
!!!44004407.cpp!!!	s_glGetVertexAttribfv(inout self : void, in index : GLuint, in pname : GLenum, inout params : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    assert(ctx->m_state);
    GLint maxIndex;
    ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
    SET_ERROR_IF(!(index < maxIndex), GL_INVALID_VALUE);

    if (!ctx->m_state->getVertexAttribParameter<GLfloat>(index, pname, params)) {
        ctx->m_glGetVertexAttribfv_enc(self, index, pname, params);
    }
!!!44004535.cpp!!!	s_glGetVertexAttribPointerv(inout self : void, in index : GLuint, in pname : GLenum, inout pointer : GLvoid) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    if (ctx->m_state == NULL) return;
    GLint maxIndex;
    ctx->glGetIntegerv(self, GL_MAX_VERTEX_ATTRIBS, &maxIndex);
    SET_ERROR_IF(!(index < maxIndex), GL_INVALID_VALUE);
    SET_ERROR_IF(pname != GL_VERTEX_ATTRIB_ARRAY_POINTER, GL_INVALID_ENUM);

    (void)pname;

    const GLClientState::VertexAttribState *va_state = ctx->m_state->getState(index);
    if (va_state != NULL) {
        *pointer = va_state->data;
    }
!!!44004663.cpp!!!	s_glShaderBinary(inout self : void, in n : GLsizei, in shaders : GLuint, in binaryformat : GLenum, in binary : void, in length : GLsizei) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    // Although it is not supported, need to set proper error code.
    SET_ERROR_IF(1, GL_INVALID_ENUM);
!!!44004791.cpp!!!	s_glShaderSource(inout self : void, in shader : GLuint, in count : GLsizei, in string : GLchar, in length : GLint) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    ShaderData* shaderData = ctx->m_shared->getShaderData(shader);
    SET_ERROR_IF(!ctx->m_shared->isObject(shader), GL_INVALID_VALUE);
    SET_ERROR_IF(!shaderData, GL_INVALID_OPERATION);
    SET_ERROR_IF((count<0), GL_INVALID_VALUE);

    int len = glUtilsCalcShaderSourceLen((char**)string, (GLint*)length, count);
    char *str = new char[len + 1];
    glUtilsPackStrings(str, (char**)string, (GLint*)length, count);

    // TODO: pre-process str before calling replaceSamplerExternalWith2D().
    // Perhaps we can borrow Mesa's pre-processor?

    if (!replaceSamplerExternalWith2D(str, shaderData)) {
        delete str;
        ctx->setError(GL_OUT_OF_MEMORY);
        return;
    }

    ctx->glShaderString(ctx, shader, str, len + 1);
    delete str;
!!!44004919.cpp!!!	s_glFinish(inout self : void) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    ctx->glFinishRoundTrip(self);
!!!44005047.cpp!!!	s_glLinkProgram(inout self : void, in program : GLuint) : void
    GL2Encoder *ctx = (GL2Encoder *)self;
    ctx->m_glLinkProgram_enc(self, program);

    GLint linkStatus = 0;
    ctx->glGetProgramiv(self,program,GL_LINK_STATUS,&linkStatus);
    if (!linkStatus)
        return;

    //get number of active uniforms in the program
    GLint numUniforms=0;
    ctx->glGetProgramiv(self, program, GL_ACTIVE_UNIFORMS, &numUniforms);
    ctx->m_shared->initProgramData(program,numUniforms);

    //get the length of the longest uniform name
    GLint maxLength=0;
    ctx->glGetProgramiv(self, program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &maxLength);

    GLint size;
    GLenum type;
    GLchar *name = new GLchar[maxLength+1];
    GLint location;
    //for each active uniform, get its size and starting location.
    for (GLint i=0 ; i<numUniforms ; ++i)
    {
        ctx->glGetActiveUniform(self, program, i, maxLength, NULL, &size, &type, name);
        location = ctx->m_glGetUniformLocation_enc(self, program, name);
        ctx->m_shared->setProgramIndexInfo(program, i, location, size, type, name);
    }
    ctx->m_shared->setupLocationShiftWAR(program);

    delete[] name;
!!!44005175.cpp!!!	s_glDeleteProgram(inout self : void, in program : GLuint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    ctx->m_glDeleteProgram_enc(self, program);

    ctx->m_shared->deleteProgramData(program);
!!!44005303.cpp!!!	s_glGetUniformiv(inout self : void, in program : GLuint, in location : GLint, inout params : GLint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    SET_ERROR_IF(!ctx->m_shared->isObject(program), GL_INVALID_VALUE);
    SET_ERROR_IF(!ctx->m_shared->isProgram(program), GL_INVALID_OPERATION);
    SET_ERROR_IF(!ctx->m_shared->isProgramInitialized(program), GL_INVALID_OPERATION);
    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program, location);
    SET_ERROR_IF(ctx->m_shared->getProgramUniformType(program,hostLoc)==0, GL_INVALID_OPERATION);
    ctx->m_glGetUniformiv_enc(self, program, hostLoc, params);
!!!44005431.cpp!!!	s_glGetUniformfv(inout self : void, in program : GLuint, in location : GLint, inout params : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    SET_ERROR_IF(!ctx->m_shared->isObject(program), GL_INVALID_VALUE);
    SET_ERROR_IF(!ctx->m_shared->isProgram(program), GL_INVALID_OPERATION);
    SET_ERROR_IF(!ctx->m_shared->isProgramInitialized(program), GL_INVALID_OPERATION);
    GLint hostLoc = ctx->m_shared->locationWARAppToHost(program,location);
    SET_ERROR_IF(ctx->m_shared->getProgramUniformType(program,hostLoc)==0, GL_INVALID_OPERATION);
    ctx->m_glGetUniformfv_enc(self, program, hostLoc, params);
!!!44005559.cpp!!!	s_glCreateProgram(inout self : void) : GLuint
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLuint program = ctx->m_glCreateProgram_enc(self);
    if (program!=0)
        ctx->m_shared->addProgramData(program);
    return program;
!!!44005687.cpp!!!	s_glCreateShader(inout self : void, in shaderType : GLenum) : GLuint
    GL2Encoder *ctx = (GL2Encoder*)self;
    RET_AND_SET_ERROR_IF(((shaderType != GL_VERTEX_SHADER) && (shaderType != GL_FRAGMENT_SHADER)),
        GL_INVALID_ENUM, 0);
    GLuint shader = ctx->m_glCreateShader_enc(self, shaderType);
    if (shader != 0) {
        if (!ctx->m_shared->addShaderData(shader)) {
            ctx->m_glDeleteShader_enc(self, shader);
            return 0;
        }
    }
    return shader;
!!!44005943.cpp!!!	s_glAttachShader(inout self : void, in program : GLuint, in shader : GLuint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    ctx->m_glAttachShader_enc(self, program, shader);
    ctx->m_shared->attachShader(program, shader);
!!!44006071.cpp!!!	s_glDetachShader(inout self : void, in program : GLuint, in shader : GLuint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    ctx->m_glDetachShader_enc(self, program, shader);
    ctx->m_shared->detachShader(program, shader);
!!!44006199.cpp!!!	s_glGetAttachedShaders(inout self : void, in program : GLuint, in maxCount : GLsizei, inout count : GLsizei, inout shaders : GLuint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    SET_ERROR_IF(maxCount < 0, GL_INVALID_VALUE);
    ctx->m_glGetAttachedShaders_enc(self, program, maxCount, count, shaders);
!!!44006327.cpp!!!	s_glGetShaderSource(inout self : void, in shader : GLuint, in bufsize : GLsizei, inout length : GLsizei, inout source : GLchar) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    SET_ERROR_IF(bufsize < 0, GL_INVALID_VALUE);
    ctx->m_glGetShaderSource_enc(self, shader, bufsize, length, source);
!!!44006455.cpp!!!	s_glGetShaderInfoLog(inout self : void, in shader : GLuint, in bufsize : GLsizei, inout length : GLsizei, inout infolog : GLchar) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    SET_ERROR_IF(bufsize < 0, GL_INVALID_VALUE);
    ctx->m_glGetShaderInfoLog_enc(self, shader, bufsize, length, infolog);
!!!44006583.cpp!!!	s_glGetProgramInfoLog(inout self : void, in program : GLuint, in bufsize : GLsizei, inout length : GLsizei, inout infolog : GLchar) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    SET_ERROR_IF(bufsize < 0, GL_INVALID_VALUE);
    ctx->m_glGetProgramInfoLog_enc(self, program, bufsize, length, infolog);
!!!44006711.cpp!!!	s_glGetUniformLocation(inout self : void, in program : GLuint, in name : GLchar) : int
    if (!name) return -1;

    GL2Encoder *ctx = (GL2Encoder*)self;

    // if we need the uniform location WAR
    // parse array index from the end of the name string
    int arrIndex = 0;
    bool needLocationWAR = ctx->m_shared->needUniformLocationWAR(program);
    if (needLocationWAR) {
        int namelen = strlen(name);
        if (name[namelen-1] == ']') {
            char *brace = strrchr(name,'[');
            if (!brace || sscanf(brace+1,"%d",&arrIndex) != 1) {
                return -1;
            }

        }
    }

    int hostLoc = ctx->m_glGetUniformLocation_enc(self, program, name);
    if (hostLoc >= 0 && needLocationWAR) {
        return ctx->m_shared->locationWARHostToApp(program, hostLoc, arrIndex);
    }
    return hostLoc;
!!!44006839.cpp!!!	s_glUseProgram(inout self : void, in program : GLuint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLClientState* state = ctx->m_state;
    GLSharedGroupPtr shared = ctx->m_shared;

    ctx->m_glUseProgram_enc(self, program);
    ctx->m_state->setCurrentProgram(program);

    GLenum origActiveTexture = state->getActiveTextureUnit();
    GLenum hostActiveTexture = origActiveTexture;
    GLint samplerIdx = -1;
    GLint samplerVal;
    GLenum samplerTarget;
    while ((samplerIdx = shared->getNextSamplerUniform(program, samplerIdx, &samplerVal, &samplerTarget)) != -1) {
        if (samplerVal < 0 || samplerVal >= GLClientState::MAX_TEXTURE_UNITS)
            continue;
        if (ctx->updateHostTexture2DBinding(GL_TEXTURE0 + samplerVal,
                samplerTarget))
        {
            hostActiveTexture = GL_TEXTURE0 + samplerVal;
        }
    }
    state->setActiveTextureUnit(origActiveTexture);
    if (hostActiveTexture != origActiveTexture) {
        ctx->m_glActiveTexture_enc(self, origActiveTexture);
    }
!!!44006967.cpp!!!	s_glUniform1f(inout self : void, in location : GLint, in x : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, 0, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform1f_enc(self, hostLoc, x);
!!!44007095.cpp!!!	s_glUniform1fv(inout self : void, in location : GLint, in count : GLsizei, in v : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform1fv_enc(self, hostLoc, count, v);
!!!44007223.cpp!!!	s_glUniform1i(inout self : void, in location : GLint, in x : GLint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLClientState* state = ctx->m_state;
    GLSharedGroupPtr shared = ctx->m_shared;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, 0, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform1i_enc(self, hostLoc, x);

    GLenum target;
    if (shared->setSamplerUniform(state->currentProgram(), location, x, &target)) {
        GLenum origActiveTexture = state->getActiveTextureUnit();
        if (ctx->updateHostTexture2DBinding(GL_TEXTURE0 + x, target)) {
            ctx->m_glActiveTexture_enc(self, origActiveTexture);
        }
        state->setActiveTextureUnit(origActiveTexture);
    }
!!!44007351.cpp!!!	s_glUniform1iv(inout self : void, in location : GLint, in count : GLsizei, in v : GLint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform1iv_enc(self, hostLoc, count, v);
!!!44007479.cpp!!!	s_glUniform2f(inout self : void, in location : GLint, in x : GLfloat, in y : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, 0, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform2f_enc(self, hostLoc, x, y);
!!!44007607.cpp!!!	s_glUniform2fv(inout self : void, in location : GLint, in count : GLsizei, in v : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform2fv_enc(self, hostLoc, count, v);
!!!44007735.cpp!!!	s_glUniform2i(inout self : void, in location : GLint, in x : GLint, in y : GLint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, 0, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform2i_enc(self, hostLoc, x, y);
!!!44007863.cpp!!!	s_glUniform2iv(inout self : void, in location : GLint, in count : GLsizei, in v : GLint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform2iv_enc(self, hostLoc, count, v);
!!!44007991.cpp!!!	s_glUniform3f(inout self : void, in location : GLint, in x : GLfloat, in y : GLfloat, in z : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, 0, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform3f_enc(self, hostLoc, x, y, z);
!!!44008119.cpp!!!	s_glUniform3fv(inout self : void, in location : GLint, in count : GLsizei, in v : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform3fv_enc(self, hostLoc, count, v);
!!!44008247.cpp!!!	s_glUniform3i(inout self : void, in location : GLint, in x : GLint, in y : GLint, in z : GLint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, 0, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform3i_enc(self, hostLoc, x, y, z);
!!!44008375.cpp!!!	s_glUniform3iv(inout self : void, in location : GLint, in count : GLsizei, in v : GLint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform3iv_enc(self, hostLoc, count, v);
!!!44008503.cpp!!!	s_glUniform4f(inout self : void, in location : GLint, in x : GLfloat, in y : GLfloat, in z : GLfloat, in w : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, 0, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform4f_enc(self, hostLoc, x, y, z, w);
!!!44008631.cpp!!!	s_glUniform4fv(inout self : void, in location : GLint, in count : GLsizei, in v : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform4fv_enc(self, hostLoc, count, v);
!!!44008759.cpp!!!	s_glUniform4i(inout self : void, in location : GLint, in x : GLint, in y : GLint, in z : GLint, in w : GLint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, 0, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform4i_enc(self, hostLoc, x, y, z, w);
!!!44008887.cpp!!!	s_glUniform4iv(inout self : void, in location : GLint, in count : GLsizei, in v : GLint) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, GL_FALSE);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniform4iv_enc(self, hostLoc, count, v);
!!!44009015.cpp!!!	s_glUniformMatrix2fv(inout self : void, in location : GLint, in count : GLsizei, in transpose : GLboolean, in value : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, transpose);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniformMatrix2fv_enc(self, hostLoc, count, transpose, value);
!!!44009143.cpp!!!	s_glUniformMatrix3fv(inout self : void, in location : GLint, in count : GLsizei, in transpose : GLboolean, in value : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, transpose);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniformMatrix3fv_enc(self, hostLoc, count, transpose, value);
!!!44009271.cpp!!!	s_glUniformMatrix4fv(inout self : void, in location : GLint, in count : GLsizei, in transpose : GLboolean, in value : GLfloat) : void
    GL2Encoder *ctx = (GL2Encoder*)self;
    GLint hostLoc;

    ctx->checkValidUniformParam(self, count, transpose);
    ctx->getHostLocation(self, location, &hostLoc);
    ctx->m_glUniformMatrix4fv_enc(self, hostLoc, count, transpose, value);
!!!44009399.cpp!!!	s_glActiveTexture(inout self : void, in texture : GLenum) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    GLClientState* state = ctx->m_state;
    GLenum err;

    SET_ERROR_IF((err = state->setActiveTextureUnit(texture)) != GL_NO_ERROR, err);

    ctx->m_glActiveTexture_enc(ctx, texture);
!!!44009527.cpp!!!	s_glBindTexture(inout self : void, in target : GLenum, in texture : GLuint) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    GLClientState* state = ctx->m_state;
    GLenum err;
    GLboolean firstUse;

    SET_ERROR_IF((err = state->bindTexture(target, texture, &firstUse)) != GL_NO_ERROR, err);

    if (target != GL_TEXTURE_2D && target != GL_TEXTURE_EXTERNAL_OES) {
        ctx->m_glBindTexture_enc(ctx, target, texture);
        return;
    }

    GLenum priorityTarget = state->getPriorityEnabledTarget(GL_TEXTURE_2D);

    if (target == GL_TEXTURE_EXTERNAL_OES && firstUse) {
        ctx->m_glBindTexture_enc(ctx, GL_TEXTURE_2D, texture);
        ctx->m_glTexParameteri_enc(ctx, GL_TEXTURE_2D,
                GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        ctx->m_glTexParameteri_enc(ctx, GL_TEXTURE_2D,
                GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        ctx->m_glTexParameteri_enc(ctx, GL_TEXTURE_2D,
                GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        if (target != priorityTarget) {
            ctx->m_glBindTexture_enc(ctx, GL_TEXTURE_2D,
                    state->getBoundTexture(GL_TEXTURE_2D));
        }
    }

    if (target == priorityTarget) {
        ctx->m_glBindTexture_enc(ctx, GL_TEXTURE_2D, texture);
    }
!!!44009655.cpp!!!	s_glDeleteTextures(inout self : void, in n : GLsizei, in textures : GLuint) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    GLClientState* state = ctx->m_state;

    state->deleteTextures(n, textures);
    ctx->m_glDeleteTextures_enc(ctx, n, textures);
!!!44009783.cpp!!!	s_glGetTexParameterfv(inout self : void, in target : GLenum, in pname : GLenum, inout params : GLfloat) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    const GLClientState* state = ctx->m_state;

    if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
        ctx->override2DTextureTarget(target);
        ctx->m_glGetTexParameterfv_enc(ctx, GL_TEXTURE_2D, pname, params);
        ctx->restore2DTextureTarget();
    } else {
        ctx->m_glGetTexParameterfv_enc(ctx, target, pname, params);
    }
!!!44009911.cpp!!!	s_glGetTexParameteriv(inout self : void, in target : GLenum, in pname : GLenum, inout params : GLint) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    const GLClientState* state = ctx->m_state;

    switch (pname) {
    case GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES:
        *params = 1;
        break;

    default:
        if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
            ctx->override2DTextureTarget(target);
            ctx->m_glGetTexParameteriv_enc(ctx, GL_TEXTURE_2D, pname, params);
            ctx->restore2DTextureTarget();
        } else {
            ctx->m_glGetTexParameteriv_enc(ctx, target, pname, params);
        }
        break;
    }
!!!44010039.cpp!!!	s_glTexParameterf(inout self : void, in target : GLenum, in pname : GLenum, in param : GLfloat) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    const GLClientState* state = ctx->m_state;

    SET_ERROR_IF((target == GL_TEXTURE_EXTERNAL_OES &&
            !isValidTextureExternalParam(pname, (GLenum)param)),
            GL_INVALID_ENUM);

    if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
        ctx->override2DTextureTarget(target);
        ctx->m_glTexParameterf_enc(ctx, GL_TEXTURE_2D, pname, param);
        ctx->restore2DTextureTarget();
    } else {
        ctx->m_glTexParameterf_enc(ctx, target, pname, param);
    }
!!!44010167.cpp!!!	s_glTexParameterfv(inout self : void, in target : GLenum, in pname : GLenum, in params : GLfloat) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    const GLClientState* state = ctx->m_state;

    SET_ERROR_IF((target == GL_TEXTURE_EXTERNAL_OES &&
            !isValidTextureExternalParam(pname, (GLenum)params[0])),
            GL_INVALID_ENUM);

    if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
        ctx->override2DTextureTarget(target);
        ctx->m_glTexParameterfv_enc(ctx, GL_TEXTURE_2D, pname, params);
        ctx->restore2DTextureTarget();
    } else {
        ctx->m_glTexParameterfv_enc(ctx, target, pname, params);
    }
!!!44010295.cpp!!!	s_glTexParameteri(inout self : void, in target : GLenum, in pname : GLenum, in param : GLint) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    const GLClientState* state = ctx->m_state;

    SET_ERROR_IF((target == GL_TEXTURE_EXTERNAL_OES &&
            !isValidTextureExternalParam(pname, (GLenum)param)),
            GL_INVALID_ENUM);

    if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
        ctx->override2DTextureTarget(target);
        ctx->m_glTexParameteri_enc(ctx, GL_TEXTURE_2D, pname, param);
        ctx->restore2DTextureTarget();
    } else {
        ctx->m_glTexParameteri_enc(ctx, target, pname, param);
    }
!!!44010423.cpp!!!	s_glTexParameteriv(inout self : void, in target : GLenum, in pname : GLenum, in params : GLint) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    const GLClientState* state = ctx->m_state;

    SET_ERROR_IF((target == GL_TEXTURE_EXTERNAL_OES &&
            !isValidTextureExternalParam(pname, (GLenum)params[0])),
            GL_INVALID_ENUM);

    if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
        ctx->override2DTextureTarget(target);
        ctx->m_glTexParameteriv_enc(ctx, GL_TEXTURE_2D, pname, params);
        ctx->restore2DTextureTarget();
    } else {
        ctx->m_glTexParameteriv_enc(ctx, target, pname, params);
    }
!!!44010551.cpp!!!	s_glTexImage2D(inout self : void, in target : GLenum, in level : GLint, in internalformat : GLint, in width : GLsizei, in height : GLsizei, in border : GLint, in format : GLenum, in type : GLenum, in pixels : GLvoid) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
        ctx->override2DTextureTarget(target);
        ctx->m_glTexImage2D_enc(ctx, target, level, internalformat, width,
                height, border, format, type, pixels);
        ctx->restore2DTextureTarget();
    } else {
        ctx->m_glTexImage2D_enc(ctx, target, level, internalformat, width,
                height, border, format, type, pixels);
    }
!!!44010679.cpp!!!	s_glTexSubImage2D(inout self : void, in target : GLenum, in level : GLint, in xoffset : GLint, in yoffset : GLint, in width : GLsizei, in height : GLsizei, in format : GLenum, in type : GLenum, in pixels : GLvoid) : void
    GL2Encoder* ctx = (GL2Encoder*)self;
    GLint maxTextureSize;
    ctx->glGetIntegerv(self, GL_MAX_TEXTURE_SIZE, &maxTextureSize);

    SET_ERROR_IF((level < 0 || level > log2(maxTextureSize)), GL_INVALID_VALUE);

     if (target == GL_TEXTURE_2D || target == GL_TEXTURE_EXTERNAL_OES) {
        ctx->override2DTextureTarget(target);
        ctx->m_glTexSubImage2D_enc(ctx, target, level, xoffset, yoffset, width,
                height, format, type, pixels);
        ctx->restore2DTextureTarget();
     } else {
         ctx->m_glTexSubImage2D_enc(ctx, target, level, xoffset, yoffset, width,
                 height, format, type, pixels);
     }
