class QCameraPostProcessor
!!!44211511.cpp!!!	QCameraPostProcessor(inout cam_ctrl : QCamera2HardwareInterface)
    memset(&mJpegHandle, 0, sizeof(mJpegHandle));
    memset(&m_pJpegOutputMem, 0, sizeof(m_pJpegOutputMem));
!!!44211639.cpp!!!	~QCameraPostProcessor()
    FREE_JPEG_OUTPUT_BUFFER(m_pJpegOutputMem,m_JpegOutputMemCount);
    if (m_pJpegExifObj != NULL) {
        delete m_pJpegExifObj;
        m_pJpegExifObj = NULL;
    }
    if (m_pReprocChannel != NULL) {
        m_pReprocChannel->stop();
        delete m_pReprocChannel;
        m_pReprocChannel = NULL;
    }
!!!44211767.cpp!!!	init(in jpeg_cb : jpeg_encode_callback_t, inout user_data : void) : int32_t
    mJpegCB = jpeg_cb;
    mJpegUserData = user_data;
    mm_dimension max_size;

    //set max pic size
    memset(&max_size, 0, sizeof(mm_dimension));
    max_size.w = m_parent->m_max_pic_width;
    max_size.h = m_parent->m_max_pic_height;

    mJpegClientHandle = jpeg_open(&mJpegHandle, max_size);
    if(!mJpegClientHandle) {
        ALOGE("%s : jpeg_open did not work", __func__);
        return UNKNOWN_ERROR;
    }

    m_dataProcTh.launch(dataProcessRoutine, this);
    m_saveProcTh.launch(dataSaveRoutine, this);

    m_bInited = TRUE;
    return NO_ERROR;
!!!44211895.cpp!!!	deinit() : int32_t
    if (m_bInited == TRUE) {
        m_dataProcTh.exit();
        m_saveProcTh.exit();

        if(mJpegClientHandle > 0) {
            int rc = mJpegHandle.close(mJpegClientHandle);
            CDBG_HIGH("%s: Jpeg closed, rc = %d, mJpegClientHandle = %x",
                  __func__, rc, mJpegClientHandle);
            mJpegClientHandle = 0;
            memset(&mJpegHandle, 0, sizeof(mJpegHandle));
        }
        m_bInited = FALSE;
    }
    return NO_ERROR;
!!!44212023.cpp!!!	start(inout pSrcChannel : QCameraChannel) : int32_t
    char prop[PROPERTY_VALUE_MAX];
    int32_t rc = NO_ERROR;
    if (m_bInited == FALSE) {
        ALOGE("%s: postproc not initialized yet", __func__);
        return UNKNOWN_ERROR;
    }

    if (m_parent->needReprocess()) {
        if (m_pReprocChannel != NULL) {
            delete m_pReprocChannel;
            m_pReprocChannel = NULL;
        }
        // if reprocess is needed, start reprocess channel
        m_pReprocChannel = m_parent->addReprocChannel(pSrcChannel);
        if (m_pReprocChannel == NULL) {
            ALOGE("%s: cannot add reprocess channel", __func__);
            return UNKNOWN_ERROR;
        }

        rc = m_pReprocChannel->start();
        if (rc != 0) {
            ALOGE("%s: cannot start reprocess channel", __func__);
            delete m_pReprocChannel;
            m_pReprocChannel = NULL;
            return rc;
        }
    }

    property_get("persist.camera.longshot.save", prop, "0");
    mUseSaveProc = atoi(prop) > 0 ? true : false;

    m_dataProcTh.sendCmd(CAMERA_CMD_TYPE_START_DATA_PROC, TRUE, FALSE);
    m_parent->m_cbNotifier.startSnapshots();

    // Create Jpeg session
    if ( !m_parent->mParameters.getRecordingHintValue() &&
            !m_parent->isLongshotEnabled() &&
            !m_parent->isZSLMode()) {

        QCameraChannel *pChannel = NULL;
        pChannel = m_parent->needReprocess() ? m_pReprocChannel : pSrcChannel;
        QCameraStream *pSnapshotStream = NULL;
        QCameraStream *pThumbStream = NULL;

        for (int i = 0; i < pChannel->getNumOfStreams(); ++i) {
            QCameraStream *pStream = pChannel->getStreamByIndex(i);

            if ( NULL == pStream ) {
                break;
            }

            if (pStream->isTypeOf(CAM_STREAM_TYPE_SNAPSHOT) ||
                    pStream->isOrignalTypeOf(CAM_STREAM_TYPE_SNAPSHOT)) {
                pSnapshotStream = pStream;
            }

            if (pStream->isTypeOf(CAM_STREAM_TYPE_POSTVIEW) ||
                    pStream->isOrignalTypeOf(CAM_STREAM_TYPE_POSTVIEW)) {
                pThumbStream = pStream;
            }
        }

        // If thumbnail is not part of the reprocess channel, then
        // try to get it from the source channel
        if ((NULL == pThumbStream) && (pChannel == m_pReprocChannel)) {
            for (int i = 0; i < pSrcChannel->getNumOfStreams(); ++i) {
                QCameraStream *pStream = pSrcChannel->getStreamByIndex(i);

                if ( NULL == pStream ) {
                    break;
                }

                if (pStream->isTypeOf(CAM_STREAM_TYPE_POSTVIEW) ||
                    pStream->isOrignalTypeOf(CAM_STREAM_TYPE_POSTVIEW)) {
                    pThumbStream = pStream;
                }
            }
        }

        if (m_parent->mParameters.generateThumbFromMain()) {
            pThumbStream = NULL;
        }

        if ( NULL != pSnapshotStream ) {
            mm_jpeg_encode_params_t encodeParam;
            memset(&encodeParam, 0, sizeof(mm_jpeg_encode_params_t));
            getJpegEncodingConfig(encodeParam, pSnapshotStream, pThumbStream);
            CDBG_HIGH("[KPI Perf] %s : call jpeg create_session", __func__);

            rc = mJpegHandle.create_session(mJpegClientHandle,
                    &encodeParam,
                    &mJpegSessionId);
            if (rc != NO_ERROR) {
                ALOGE("%s: error creating a new jpeg encoding session", __func__);
                return rc;
            }
            mNewJpegSessionNeeded = false;
        }
    }

    return rc;
!!!44212151.cpp!!!	stop() : int32_t
    if (m_bInited == TRUE) {
        m_parent->m_cbNotifier.stopSnapshots();
        // dataProc Thread need to process "stop" as sync call because abort jpeg job should be a sync call
        m_dataProcTh.sendCmd(CAMERA_CMD_TYPE_STOP_DATA_PROC, TRUE, TRUE);
    }

    return NO_ERROR;
!!!44212279.cpp!!!	validatePostProcess(inout frame : mm_camera_super_buf_t) : bool
    bool status = TRUE;
    QCameraChannel *pChannel = NULL;
    QCameraReprocessChannel *m_pReprocChannel = NULL;

    if (frame == NULL) {
        return status;
    }

    pChannel = m_parent->getChannelByHandle(frame->ch_id);
    for (int8_t i = 0; i < mTotalNumReproc; i++) {
        if (pChannel == mPPChannels[i]->getSrcChannel()) {
            m_pReprocChannel = mPPChannels[i];
            break;
        }
    }

    if (m_pReprocChannel != NULL && pChannel == m_pReprocChannel->getSrcChannel()) {
        QCameraStream *pStream = NULL;
        for (uint8_t i = 0; i < m_pReprocChannel->getNumOfStreams(); i++) {
            pStream = m_pReprocChannel->getStreamByIndex(i);
            if (pStream && (m_inputPPQ.getCurrentSize() > 0) &&
                    m_ongoingPPQ.getCurrentSize() >=  pStream->getNumQueuedBuf()) {
                CDBG_HIGH("Out of PP Buffer PPQ = %d ongoingQ = %d Jpeg = %d onJpeg = %d",
                        m_inputPPQ.getCurrentSize(), m_inputPPQ.getCurrentSize(),
                        m_inputJpegQ.getCurrentSize(), m_ongoingJpegQ.getCurrentSize());
                status = FALSE;
                break;
            }
        }
    }
    return status;
!!!44212407.cpp!!!	processData(inout frame : mm_camera_super_buf_t) : int32_t
    if (m_bInited == FALSE) {
        ALOGE("%s: postproc not initialized yet", __func__);
        return UNKNOWN_ERROR;
    }

    if (m_parent->needReprocess()) {
        if ((!m_parent->isLongshotEnabled() &&
             !m_parent->m_stateMachine.isNonZSLCaptureRunning()) ||
            (m_parent->isLongshotEnabled() &&
             m_parent->isCaptureShutterEnabled())) {
            //play shutter sound
            m_parent->playShutter();
        }

        CDBG_HIGH("%s: need reprocess", __func__);
        // enqueu to post proc input queue
        m_inputPPQ.enqueue((void *)frame);
    } else if (m_parent->mParameters.isNV16PictureFormat() ||
        m_parent->mParameters.isNV21PictureFormat()) {
        //check if raw frame information is needed.
        if(m_parent->mParameters.isYUVFrameInfoNeeded())
            setYUVFrameInfo(frame);

        processRawData(frame);
    } else {
        //play shutter sound
        if(!m_parent->m_stateMachine.isNonZSLCaptureRunning() &&
           !m_parent->mLongshotEnabled)
           m_parent->playShutter();

        CDBG_HIGH("%s: no need offline reprocess, sending to jpeg encoding", __func__);
        qcamera_jpeg_data_t *jpeg_job =
            (qcamera_jpeg_data_t *)malloc(sizeof(qcamera_jpeg_data_t));
        if (jpeg_job == NULL) {
            ALOGE("%s: No memory for jpeg job", __func__);
            return NO_MEMORY;
        }

        memset(jpeg_job, 0, sizeof(qcamera_jpeg_data_t));
        jpeg_job->src_frame = frame;

        // find meta data frame
        mm_camera_buf_def_t *meta_frame = NULL;
        for (int i = 0; i < frame->num_bufs; i++) {
            // look through input superbuf
            if (frame->bufs[i]->stream_type == CAM_STREAM_TYPE_METADATA) {
                meta_frame = frame->bufs[i];
                break;
            }
        }

        if (meta_frame != NULL) {
            // fill in meta data frame ptr
            jpeg_job->metadata = (metadata_buffer_t *)meta_frame->buffer;
        }

        // enqueu to jpeg input queue
        m_inputJpegQ.enqueue((void *)jpeg_job);
    }
    m_dataProcTh.sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);

    return NO_ERROR;
!!!44212535.cpp!!!	processRawData(inout frame : mm_camera_super_buf_t) : int32_t
    if (m_bInited == FALSE) {
        ALOGE("%s: postproc not initialized yet", __func__);
        return UNKNOWN_ERROR;
    }

    // enqueu to raw input queue
    m_inputRawQ.enqueue((void *)frame);
    m_dataProcTh.sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);
    return NO_ERROR;
!!!44212663.cpp!!!	processPPData(inout frame : mm_camera_super_buf_t) : int32_t
    bool needSuperBufMatch = m_parent->mParameters.generateThumbFromMain();
    if (m_bInited == FALSE) {
        ALOGE("%s: postproc not initialized yet", __func__);
        return UNKNOWN_ERROR;
    }

    qcamera_pp_data_t *job = (qcamera_pp_data_t *)m_ongoingPPQ.dequeue();

    if (!needSuperBufMatch && (job == NULL || job->src_frame == NULL) ) {
        ALOGE("%s: Cannot find reprocess job", __func__);
        return BAD_VALUE;
    }

    if (!needSuperBufMatch && (m_parent->mParameters.isNV16PictureFormat() ||
        m_parent->mParameters.isNV21PictureFormat())) {
        releaseSuperBuf(job->src_frame);
        free(job->src_frame);
        free(job);

        if(m_parent->mParameters.isYUVFrameInfoNeeded())
            setYUVFrameInfo(frame);
        return processRawData(frame);
    }

    if (m_parent->isLongshotEnabled() &&
            !m_parent->isCaptureShutterEnabled()) {
        // play shutter sound for longshot
        // after reprocess is done
        // TODO: Move this after CAC done event
        m_parent->playShutter();
    }

    qcamera_jpeg_data_t *jpeg_job =
        (qcamera_jpeg_data_t *)malloc(sizeof(qcamera_jpeg_data_t));
    if (jpeg_job == NULL) {
        ALOGE("%s: No memory for jpeg job", __func__);
        return NO_MEMORY;
    }

    memset(jpeg_job, 0, sizeof(qcamera_jpeg_data_t));
    jpeg_job->src_frame = frame;
    jpeg_job->src_reproc_frame = job ? job->src_frame : NULL;
    jpeg_job->src_reproc_bufs = job ? job->src_reproc_bufs : NULL;
    jpeg_job->reproc_frame_release = job ? job->reproc_frame_release : false;

    // find meta data frame
    mm_camera_buf_def_t *meta_frame = NULL;
    for (int i = 0; job && (i < job->src_frame->num_bufs); i++) {
        // look through input superbuf
        if (job->src_frame->bufs[i]->stream_type == CAM_STREAM_TYPE_METADATA) {
            meta_frame = job->src_frame->bufs[i];
            break;
        }
    }

    if (meta_frame == NULL) {
        // look through reprocess superbuf
        for (int i = 0; i < frame->num_bufs; i++) {
            if (frame->bufs[i]->stream_type == CAM_STREAM_TYPE_METADATA) {
                meta_frame = frame->bufs[i];
                break;
            }
        }
    }

    if (meta_frame != NULL) {
        // fill in meta data frame ptr
        jpeg_job->metadata = (metadata_buffer_t *)meta_frame->buffer;
    }

    // free pp job buf
    if (job) {
        free(job);
    }

    // enqueu reprocessed frame to jpeg input queue
    m_inputJpegQ.enqueue((void *)jpeg_job);

    ALOGD("%s: %d] ", __func__, __LINE__);
    // wait up data proc thread
    m_dataProcTh.sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);

    return NO_ERROR;
!!!44212791.cpp!!!	processJpegEvt(inout evt : qcamera_jpeg_evt_payload_t) : int32_t
    if (m_bInited == FALSE) {
        ALOGE("%s: postproc not initialized yet", __func__);
        return UNKNOWN_ERROR;
    }

    int32_t rc = NO_ERROR;
    camera_memory_t *jpeg_mem = NULL;
    omx_jpeg_ouput_buf_t *jpeg_out = NULL;

    if (mUseSaveProc && m_parent->isLongshotEnabled()) {
        qcamera_jpeg_evt_payload_t *saveData = ( qcamera_jpeg_evt_payload_t * ) malloc(sizeof(qcamera_jpeg_evt_payload_t));
        if ( NULL == saveData ) {
            ALOGE("%s: Can not allocate save data message!", __func__);
            return NO_MEMORY;
        }
        *saveData = *evt;
        m_inputSaveQ.enqueue((void *) saveData);
        m_saveProcTh.sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);
    } else {
        // Release jpeg job data
        m_ongoingJpegQ.flushNodes(matchJobId, (void*)&evt->jobId);

        CDBG_HIGH("[KPI Perf] %s : jpeg job %d", __func__, evt->jobId);

        if (m_parent->mDataCb == NULL ||
            m_parent->msgTypeEnabledWithLock(CAMERA_MSG_COMPRESSED_IMAGE) == 0 ) {
            CDBG_HIGH("%s: No dataCB or CAMERA_MSG_COMPRESSED_IMAGE not enabled",
                  __func__);
            rc = NO_ERROR;
            goto end;
        }

        if(evt->status == JPEG_JOB_STATUS_ERROR) {
            ALOGE("%s: Error event handled from jpeg, status = %d",
                  __func__, evt->status);
            rc = FAILED_TRANSACTION;
            goto end;
        }

        m_parent->dumpJpegToFile(evt->out_data.buf_vaddr,
                                  evt->out_data.buf_filled_len,
                                  evt->jobId);
        CDBG_HIGH("%s: Dump jpeg_size=%d", __func__, evt->out_data.buf_filled_len);

        /* check if the all the captures are done */
        if (m_parent->mParameters.isUbiRefocus() &&
            (m_parent->getOutputImageCount() <
            m_parent->mParameters.UfOutputCount())) {
            jpeg_out  = (omx_jpeg_ouput_buf_t*) evt->out_data.buf_vaddr;
            jpeg_mem = (camera_memory_t *)jpeg_out->mem_hdl;
            if (NULL != jpeg_mem) {
                jpeg_mem->release(jpeg_mem);
                jpeg_mem = NULL;
            }
            goto end;
        }

        if (!mJpegMemOpt) {
            // alloc jpeg memory to pass to upper layer
            jpeg_mem = m_parent->mGetMemory(-1, evt->out_data.buf_filled_len,
                1, m_parent->mCallbackCookie);
            if (NULL == jpeg_mem) {
                rc = NO_MEMORY;
                ALOGE("%s : getMemory for jpeg, ret = NO_MEMORY", __func__);
                goto end;
            }
            memcpy(jpeg_mem->data, evt->out_data.buf_vaddr, evt->out_data.buf_filled_len);
        } else {
            jpeg_out  = (omx_jpeg_ouput_buf_t*) evt->out_data.buf_vaddr;
            jpeg_mem = (camera_memory_t *)jpeg_out->mem_hdl;
        }

        CDBG_HIGH("%s : Calling upperlayer callback to store JPEG image", __func__);
        qcamera_release_data_t release_data;
        memset(&release_data, 0, sizeof(qcamera_release_data_t));
        release_data.data = jpeg_mem;
        CDBG_HIGH("[KPI Perf] %s: PROFILE_JPEG_CB ",__func__);
        rc = sendDataNotify(CAMERA_MSG_COMPRESSED_IMAGE,
                            jpeg_mem,
                            0,
                            NULL,
                            &release_data);

end:
        if (rc != NO_ERROR) {
            // send error msg to upper layer
            sendEvtNotify(CAMERA_MSG_ERROR,
                          UNKNOWN_ERROR,
                          0);

            if (NULL != jpeg_mem) {
                jpeg_mem->release(jpeg_mem);
                jpeg_mem = NULL;
            }
        }
    }

    // wait up data proc thread to do next job,
    // if previous request is blocked due to ongoing jpeg job
    m_dataProcTh.sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);

    return rc;
!!!44212919.cpp!!!	getJpegPaddingReq(inout padding_info : cam_padding_info_t) : int32_t
    // TODO: hardcode for now, needs to query from mm-jpeg-interface
    padding_info.width_padding  = CAM_PAD_NONE;
    padding_info.height_padding  = CAM_PAD_TO_16;
    padding_info.plane_padding  = CAM_PAD_TO_WORD;
    return NO_ERROR;
!!!44213047.cpp!!!	getReprocChannel(in index : uint8_t) : QCameraReprocessChannel
    if (index >= mTotalNumReproc) {
        ALOGE("%s: Invalid index value",__func__);
        return NULL;
    }
    return mPPChannels[index];
!!!44213431.cpp!!!	sendDataNotify(in msg_type : int32_t, inout data : camera_memory_t, in index : uint8_t, inout metadata : camera_frame_metadata_t, inout release_data : qcamera_release_data_t) : int32_t
    qcamera_data_argm_t *data_cb = (qcamera_data_argm_t *)malloc(sizeof(qcamera_data_argm_t));
    if (NULL == data_cb) {
        ALOGE("%s: no mem for acamera_data_argm_t", __func__);
        return NO_MEMORY;
    }
    memset(data_cb, 0, sizeof(qcamera_data_argm_t));
    data_cb->msg_type = msg_type;
    data_cb->data = data;
    data_cb->index = index;
    data_cb->metadata = metadata;
    if (release_data != NULL) {
        data_cb->release_data = *release_data;
    }

    qcamera_callback_argm_t cbArg;
    memset(&cbArg, 0, sizeof(qcamera_callback_argm_t));
    cbArg.cb_type = QCAMERA_DATA_SNAPSHOT_CALLBACK;
    cbArg.msg_type = msg_type;
    cbArg.data = data;
    cbArg.metadata = metadata;
    cbArg.user_data = data_cb;
    cbArg.cookie = this;
    cbArg.release_cb = releaseNotifyData;
    int rc = m_parent->m_cbNotifier.notifyCallback(cbArg);
    if ( NO_ERROR != rc ) {
        ALOGE("%s: Error enqueuing jpeg data into notify queue", __func__);
        releaseNotifyData(data_cb, this, UNKNOWN_ERROR);
        return UNKNOWN_ERROR;
    }

    return rc;
!!!44213559.cpp!!!	sendEvtNotify(in msg_type : int32_t, in ext1 : int32_t, in ext2 : int32_t) : int32_t
    return m_parent->sendEvtNotify(msg_type, ext1, ext2);
!!!44213687.cpp!!!	findJpegJobByJobId(in jobId : uint32_t) : qcamera_jpeg_data_t
    qcamera_jpeg_data_t * job = NULL;
    if (jobId == 0) {
        ALOGE("%s: not a valid jpeg jobId", __func__);
        return NULL;
    }

    // currely only one jpeg job ongoing, so simply dequeue the head
    job = (qcamera_jpeg_data_t *)m_ongoingJpegQ.dequeue();
    return job;
!!!44213815.cpp!!!	getColorfmtFromImgFmt(in img_fmt : cam_format_t) : mm_jpeg_color_format
    switch (img_fmt) {
    case CAM_FORMAT_YUV_420_NV21:
        return MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2;
    case CAM_FORMAT_YUV_420_NV21_ADRENO:
        return MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2;
    case CAM_FORMAT_YUV_420_NV12:
        return MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V2;
    case CAM_FORMAT_YUV_420_YV12:
        return MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V2;
    case CAM_FORMAT_YUV_422_NV61:
        return MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V1;
    case CAM_FORMAT_YUV_422_NV16:
        return MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V1;
    default:
        return MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2;
    }
!!!44213943.cpp!!!	getJpegImgTypeFromImgFmt(in img_fmt : cam_format_t) : mm_jpeg_format_t
    switch (img_fmt) {
    case CAM_FORMAT_YUV_420_NV21:
    case CAM_FORMAT_YUV_420_NV21_ADRENO:
    case CAM_FORMAT_YUV_420_NV12:
    case CAM_FORMAT_YUV_420_YV12:
    case CAM_FORMAT_YUV_422_NV61:
    case CAM_FORMAT_YUV_422_NV16:
        return MM_JPEG_FMT_YUV;
    default:
        return MM_JPEG_FMT_YUV;
    }
!!!44214071.cpp!!!	getJpegEncodingConfig(inout encode_parm : mm_jpeg_encode_params_t, inout main_stream : QCameraStream, inout thumb_stream : QCameraStream) : int32_t
    CDBG("%s : E", __func__);
    int32_t ret = NO_ERROR;
    uint32_t out_size;

    char prop[PROPERTY_VALUE_MAX];
    property_get("persist.camera.jpeg_burst", prop, "0");
    mUseJpegBurst = (atoi(prop) > 0) && !mUseSaveProc;
    encode_parm.burst_mode = mUseJpegBurst;

    cam_rect_t crop;
    memset(&crop, 0, sizeof(cam_rect_t));
    main_stream->getCropInfo(crop);

    cam_dimension_t src_dim, dst_dim;
    memset(&src_dim, 0, sizeof(cam_dimension_t));
    memset(&dst_dim, 0, sizeof(cam_dimension_t));
    main_stream->getFrameDimension(src_dim);

    bool hdr_output_crop = m_parent->mParameters.isHDROutputCropEnabled();
    if (hdr_output_crop && crop.height) {
        dst_dim.height = crop.height;
    } else {
        dst_dim.height = src_dim.height;
    }
    if (hdr_output_crop && crop.width) {
        dst_dim.width = crop.width;
    } else {
        dst_dim.width = src_dim.width;
    }

    // set rotation only when no online rotation or offline pp rotation is done before
    if (!m_parent->needRotationReprocess()) {
        encode_parm.rotation = m_parent->getJpegRotation();
    }

    encode_parm.main_dim.src_dim = src_dim;
    encode_parm.main_dim.dst_dim = dst_dim;

    encode_parm.jpeg_cb = mJpegCB;
    encode_parm.userdata = mJpegUserData;

    m_bThumbnailNeeded = TRUE; // need encode thumbnail by default
    cam_dimension_t thumbnailSize;
    memset(&thumbnailSize, 0, sizeof(cam_dimension_t));
    m_parent->getThumbnailSize(thumbnailSize);
    if (thumbnailSize.width == 0 || thumbnailSize.height == 0) {
        // (0,0) means no thumbnail
        m_bThumbnailNeeded = FALSE;
    }
    encode_parm.encode_thumbnail = m_bThumbnailNeeded;

    // get color format
    cam_format_t img_fmt = CAM_FORMAT_YUV_420_NV12;
    main_stream->getFormat(img_fmt);
    encode_parm.color_format = getColorfmtFromImgFmt(img_fmt);

    // get jpeg quality
    encode_parm.quality = m_parent->getJpegQuality();
    if (encode_parm.quality <= 0) {
        encode_parm.quality = 85;
    }
    cam_frame_len_offset_t main_offset;
    memset(&main_offset, 0, sizeof(cam_frame_len_offset_t));
    main_stream->getFrameOffset(main_offset);

    // src buf config
    QCameraMemory *pStreamMem = main_stream->getStreamBufs();
    if (pStreamMem == NULL) {
        ALOGE("%s: cannot get stream bufs from main stream", __func__);
        ret = BAD_VALUE;
        goto on_error;
    }
    encode_parm.num_src_bufs = pStreamMem->getCnt();
    for (uint32_t i = 0; i < encode_parm.num_src_bufs; i++) {
        camera_memory_t *stream_mem = pStreamMem->getMemory(i, false);
        if (stream_mem != NULL) {
            encode_parm.src_main_buf[i].index = i;
            encode_parm.src_main_buf[i].buf_size = stream_mem->size;
            encode_parm.src_main_buf[i].buf_vaddr = (uint8_t *)stream_mem->data;
            encode_parm.src_main_buf[i].fd = pStreamMem->getFd(i);
            encode_parm.src_main_buf[i].format = MM_JPEG_FMT_YUV;
            encode_parm.src_main_buf[i].offset = main_offset;
        }
    }

    if (m_bThumbnailNeeded == TRUE) {
        bool need_thumb_rotate = true;
        int jpeg_rotation = m_parent->getJpegRotation();
        m_parent->getThumbnailSize(encode_parm.thumb_dim.dst_dim);

        if (thumb_stream == NULL) {
            thumb_stream = main_stream;
            need_thumb_rotate = false;
        }
        pStreamMem = thumb_stream->getStreamBufs();
        if (pStreamMem == NULL) {
            ALOGE("%s: cannot get stream bufs from thumb stream", __func__);
            ret = BAD_VALUE;
            goto on_error;
        }
        cam_frame_len_offset_t thumb_offset;
        memset(&thumb_offset, 0, sizeof(cam_frame_len_offset_t));
        thumb_stream->getFrameOffset(thumb_offset);
        encode_parm.num_tmb_bufs =  pStreamMem->getCnt();
        for (int i = 0; i < pStreamMem->getCnt(); i++) {
            camera_memory_t *stream_mem = pStreamMem->getMemory(i, false);
            if (stream_mem != NULL) {
                encode_parm.src_thumb_buf[i].index = i;
                encode_parm.src_thumb_buf[i].buf_size = stream_mem->size;
                encode_parm.src_thumb_buf[i].buf_vaddr = (uint8_t *)stream_mem->data;
                encode_parm.src_thumb_buf[i].fd = pStreamMem->getFd(i);
                encode_parm.src_thumb_buf[i].format = MM_JPEG_FMT_YUV;
                encode_parm.src_thumb_buf[i].offset = thumb_offset;
            }
        }
        cam_format_t img_fmt_thumb = CAM_FORMAT_YUV_420_NV12;
        thumb_stream->getFormat(img_fmt_thumb);
        encode_parm.thumb_color_format = getColorfmtFromImgFmt(img_fmt_thumb);

        // crop is the same if frame is the same
        if (thumb_stream != main_stream) {
            memset(&crop, 0, sizeof(cam_rect_t));
            thumb_stream->getCropInfo(crop);
        }

        memset(&src_dim, 0, sizeof(cam_dimension_t));
        thumb_stream->getFrameDimension(src_dim);
        encode_parm.thumb_dim.src_dim = src_dim;

        if (!m_parent->needRotationReprocess() || need_thumb_rotate) {
            encode_parm.thumb_rotation = jpeg_rotation;
        } else if ((90 == jpeg_rotation) || (270 == jpeg_rotation)) {
            // swap thumbnail dimensions
            cam_dimension_t tmp_dim = encode_parm.thumb_dim.dst_dim;
            encode_parm.thumb_dim.dst_dim.width = tmp_dim.height;
            encode_parm.thumb_dim.dst_dim.height = tmp_dim.width;
        }
        encode_parm.thumb_dim.crop = crop;
    }

    encode_parm.num_dst_bufs = 1;
    if (mUseJpegBurst) {
        encode_parm.num_dst_bufs = MAX_JPEG_BURST;
    }
    encode_parm.get_memory = NULL;
    out_size = main_offset.frame_len;
    if (mJpegMemOpt) {
        encode_parm.get_memory = getJpegMemory;
        out_size = sizeof(omx_jpeg_ouput_buf_t);
        encode_parm.num_dst_bufs = encode_parm.num_src_bufs;
    }
    m_JpegOutputMemCount = encode_parm.num_dst_bufs;
    for (int i = 0; i < (int)m_JpegOutputMemCount; i++) {
        if (m_pJpegOutputMem[i] != NULL)
          free(m_pJpegOutputMem[i]);
        omx_jpeg_ouput_buf_t omx_out_buf;
        omx_out_buf.handle = this;
        // allocate output buf for jpeg encoding
        m_pJpegOutputMem[i] = malloc(out_size);

        if (NULL == m_pJpegOutputMem[i]) {
          ret = NO_MEMORY;
          ALOGE("%s : initHeapMem for jpeg, ret = NO_MEMORY", __func__);
          goto on_error;
        }

        if (mJpegMemOpt) {
            memcpy(m_pJpegOutputMem[i], &omx_out_buf, sizeof(omx_out_buf));
        }


        encode_parm.dest_buf[i].index = i;
        encode_parm.dest_buf[i].buf_size = main_offset.frame_len;
        encode_parm.dest_buf[i].buf_vaddr = (uint8_t *)m_pJpegOutputMem[i];
        encode_parm.dest_buf[i].fd = 0;
        encode_parm.dest_buf[i].format = MM_JPEG_FMT_YUV;
        encode_parm.dest_buf[i].offset = main_offset;
    }


    CDBG("%s : X", __func__);
    return NO_ERROR;

on_error:
    FREE_JPEG_OUTPUT_BUFFER(m_pJpegOutputMem, m_JpegOutputMemCount);

    CDBG("%s : X with error %d", __func__, ret);
    return ret;
!!!44214199.cpp!!!	encodeData(inout jpeg_job_data : qcamera_jpeg_data_t, inout needNewSess : uint8_t) : int32_t
    CDBG("%s : E", __func__);
    int32_t ret = NO_ERROR;
    mm_jpeg_job_t jpg_job;
    uint32_t jobId = 0;
    QCameraStream *reproc_stream = NULL;
    QCameraStream *main_stream = NULL;
    mm_camera_buf_def_t *main_frame = NULL;
    QCameraStream *thumb_stream = NULL;
    mm_camera_buf_def_t *thumb_frame = NULL;
    mm_camera_super_buf_t *recvd_frame = jpeg_job_data->src_frame;
    cam_rect_t crop;
    cam_stream_parm_buffer_t param;
    cam_stream_img_prop_t imgProp;

    // find channel
    QCameraChannel *pChannel = m_parent->getChannelByHandle(recvd_frame->ch_id);
    // check reprocess channel if not found
    if (pChannel == NULL) {
        if (m_pReprocChannel != NULL &&
            m_pReprocChannel->getMyHandle() == recvd_frame->ch_id) {
            pChannel = m_pReprocChannel;
        }
    }

    if (pChannel == NULL) {
        ALOGE("%s:%d] No corresponding channel (ch_id = %d) exist, return here",
              __func__, __LINE__, recvd_frame->ch_id);
        return BAD_VALUE;
    }

    const int jpeg_rotation = m_parent->getJpegRotation();

    ret = queryStreams(&main_stream,
            &thumb_stream,
            &reproc_stream,
            &main_frame,
            &thumb_frame,
            recvd_frame,
            jpeg_job_data->src_reproc_frame);
    if (NO_ERROR != ret) {
        return ret;
    }

    if(NULL == main_frame){
       ALOGE("%s : Main frame is NULL", __func__);
       return BAD_VALUE;
    }

    if(NULL == thumb_frame){
       CDBG("%s : Thumbnail frame does not exist", __func__);
    }

    QCameraMemory *memObj = (QCameraMemory *)main_frame->mem_info;
    if (NULL == memObj) {
        ALOGE("%s : Memeory Obj of main frame is NULL", __func__);
        return NO_MEMORY;
    }

    // dump snapshot frame if enabled
    m_parent->dumpFrameToFile(main_stream, main_frame, QCAMERA_DUMP_FRM_SNAPSHOT);

    // send upperlayer callback for raw image
    camera_memory_t *mem = memObj->getMemory(main_frame->buf_idx, false);
    if (NULL != m_parent->mDataCb &&
        m_parent->msgTypeEnabledWithLock(CAMERA_MSG_RAW_IMAGE) > 0) {
        qcamera_callback_argm_t cbArg;
        memset(&cbArg, 0, sizeof(qcamera_callback_argm_t));
        cbArg.cb_type = QCAMERA_DATA_CALLBACK;
        cbArg.msg_type = CAMERA_MSG_RAW_IMAGE;
        cbArg.data = mem;
        cbArg.index = 1;
        m_parent->m_cbNotifier.notifyCallback(cbArg);
    }
    if (NULL != m_parent->mNotifyCb &&
        m_parent->msgTypeEnabledWithLock(CAMERA_MSG_RAW_IMAGE_NOTIFY) > 0) {
        qcamera_callback_argm_t cbArg;
        memset(&cbArg, 0, sizeof(qcamera_callback_argm_t));
        cbArg.cb_type = QCAMERA_NOTIFY_CALLBACK;
        cbArg.msg_type = CAMERA_MSG_RAW_IMAGE_NOTIFY;
        cbArg.ext1 = 0;
        cbArg.ext2 = 0;
        m_parent->m_cbNotifier.notifyCallback(cbArg);
    }

    if (thumb_frame != NULL) {
        // dump thumbnail frame if enabled
        m_parent->dumpFrameToFile(thumb_stream, thumb_frame, QCAMERA_DUMP_FRM_THUMBNAIL);
    }

    if (mJpegClientHandle <= 0) {
        ALOGE("%s: Error: bug here, mJpegClientHandle is 0", __func__);
        return UNKNOWN_ERROR;
    }

    if (needNewSess) {
        // create jpeg encoding session
        mm_jpeg_encode_params_t encodeParam;
        memset(&encodeParam, 0, sizeof(mm_jpeg_encode_params_t));
        getJpegEncodingConfig(encodeParam, main_stream, thumb_stream);
        CDBG_HIGH("[KPI Perf] %s : call jpeg create_session", __func__);
        ret = mJpegHandle.create_session(mJpegClientHandle, &encodeParam, &mJpegSessionId);
        if (ret != NO_ERROR) {
            ALOGE("%s: error creating a new jpeg encoding session", __func__);
            return ret;
        }
        needNewSess = FALSE;
    }
    // Fill in new job
    memset(&jpg_job, 0, sizeof(mm_jpeg_job_t));
    jpg_job.job_type = JPEG_JOB_TYPE_ENCODE;
    jpg_job.encode_job.session_id = mJpegSessionId;
    jpg_job.encode_job.src_index = main_frame->buf_idx;
    jpg_job.encode_job.dst_index = 0;

    if (mJpegMemOpt) {
        jpg_job.encode_job.dst_index = jpg_job.encode_job.src_index;
    } else if (mUseJpegBurst) {
        jpg_job.encode_job.dst_index = -1;
    }

    cam_dimension_t src_dim;
    memset(&src_dim, 0, sizeof(cam_dimension_t));
    main_stream->getFrameDimension(src_dim);

    bool hdr_output_crop = m_parent->mParameters.isHDROutputCropEnabled();
    bool img_feature_enabled =
      m_parent->mParameters.isUbiFocusEnabled() ||
      m_parent->mParameters.isChromaFlashEnabled() ||
      m_parent->mParameters.isOptiZoomEnabled();

    CDBG_HIGH("%s:%d] Crop needed %d", __func__, __LINE__, img_feature_enabled);
    crop.left = 0;
    crop.top = 0;
    crop.height = src_dim.height;
    crop.width = src_dim.width;

    param = main_stream->getOutputCrop();
    for (int i = 0; i < param.outputCrop.num_of_streams; i++) {
       if (param.outputCrop.crop_info[i].stream_id
           == main_stream->getMyServerID()) {
               crop = param.outputCrop.crop_info[i].crop;
               main_stream->setCropInfo(crop);
       }
    }
    if (img_feature_enabled) {
        memset(&param, 0, sizeof(cam_stream_parm_buffer_t));

        param = main_stream->getImgProp();
        imgProp = param.imgProp;
        main_stream->setCropInfo(imgProp.crop);
        crop = imgProp.crop;
        thumb_stream = NULL; /* use thumbnail from main image */
        if (imgProp.is_raw_image) {
           camera_memory_t *mem = memObj->getMemory(
               main_frame->buf_idx, false);
           ALOGE("%s:%d] Process raw image %p %d", __func__, __LINE__,
               mem, imgProp.size);
           /* dump image */
           if (mem && mem->data) {
               CAM_DUMP_TO_FILE("/data/local/ubifocus", "DepthMapImage",
                                -1, "y",
                                (uint8_t *)mem->data,
                                imgProp.size);
           }
           return NO_ERROR;
        }
    }

    cam_dimension_t dst_dim;

    if (hdr_output_crop && crop.height) {
        dst_dim.height = crop.height;
    } else {
        dst_dim.height = src_dim.height;
    }
    if (hdr_output_crop && crop.width) {
        dst_dim.width = crop.width;
    } else {
        dst_dim.width = src_dim.width;
    }

    // main dim
    jpg_job.encode_job.main_dim.src_dim = src_dim;
    jpg_job.encode_job.main_dim.dst_dim = dst_dim;
    jpg_job.encode_job.main_dim.crop = crop;

    // get exif data
    QCameraExif *pJpegExifObj = m_parent->getExifData();
    jpeg_job_data->pJpegExifObj = pJpegExifObj;
    if (pJpegExifObj != NULL) {
        jpg_job.encode_job.exif_info.exif_data = pJpegExifObj->getEntries();
        jpg_job.encode_job.exif_info.numOfEntries =
            pJpegExifObj->getNumOfEntries();
    }

    // set rotation only when no online rotation or offline pp rotation is done before
    if (!m_parent->needRotationReprocess()) {
        jpg_job.encode_job.rotation = jpeg_rotation;
    }
    CDBG_HIGH("%s: jpeg rotation is set to %d", __func__, jpg_job.encode_job.rotation);

    // thumbnail dim
    if (m_bThumbnailNeeded == TRUE) {
        m_parent->getThumbnailSize(jpg_job.encode_job.thumb_dim.dst_dim);

        if (thumb_stream == NULL) {
            // need jpeg thumbnail, but no postview/preview stream exists
            // we use the main stream/frame to encode thumbnail
            thumb_stream = main_stream;
            thumb_frame = main_frame;
            if (m_parent->needRotationReprocess() &&
                ((90 == jpeg_rotation) || (270 == jpeg_rotation))) {
                // swap thumbnail dimensions
                cam_dimension_t tmp_dim = jpg_job.encode_job.thumb_dim.dst_dim;
                jpg_job.encode_job.thumb_dim.dst_dim.width = tmp_dim.height;
                jpg_job.encode_job.thumb_dim.dst_dim.height = tmp_dim.width;
            }
        }

        memset(&src_dim, 0, sizeof(cam_dimension_t));
        thumb_stream->getFrameDimension(src_dim);
        jpg_job.encode_job.thumb_dim.src_dim = src_dim;

        // crop is the same if frame is the same
        if (thumb_frame != main_frame) {
            crop.left = 0;
            crop.top = 0;
            crop.height = src_dim.height;
            crop.width = src_dim.width;

            param = thumb_stream->getOutputCrop();
            for (int i = 0; i < param.outputCrop.num_of_streams; i++) {
               if (param.outputCrop.crop_info[i].stream_id
                   == thumb_stream->getMyServerID()) {
                       crop = param.outputCrop.crop_info[i].crop;
                       thumb_stream->setCropInfo(crop);
               }
           }
        }

        jpg_job.encode_job.thumb_dim.crop = crop;
        jpg_job.encode_job.thumb_index = thumb_frame->buf_idx;
        CDBG_HIGH("%s, thumbnail src w/h (%dx%d), dst w/h (%dx%d)", __func__,
            jpg_job.encode_job.thumb_dim.src_dim.width,
            jpg_job.encode_job.thumb_dim.src_dim.height,
            jpg_job.encode_job.thumb_dim.dst_dim.width,
            jpg_job.encode_job.thumb_dim.dst_dim.height);
    }

    if (jpeg_job_data->metadata != NULL) {
        // fill in meta data frame ptr
        jpg_job.encode_job.p_metadata = jpeg_job_data->metadata;
    }

    jpg_job.encode_job.hal_version = CAM_HAL_V1;
    jpg_job.encode_job.cam_exif_params = m_parent->mExifParams;

    /* Init the QTable */
    for (int i = 0; i < QTABLE_MAX; i++) {
        jpg_job.encode_job.qtable_set[i] = 0;
    }

    CDBG_HIGH("[KPI Perf] %s : PROFILE_JPEG_JOB_START", __func__);
    ret = mJpegHandle.start_job(&jpg_job, &jobId);
    if (ret == NO_ERROR) {
        // remember job info
        jpeg_job_data->jobId = jobId;
    }

    return ret;
!!!44214327.cpp!!!	queryStreams(inout main : QCameraStream, inout thumb : QCameraStream, inout reproc : QCameraStream, inout main_image : mm_camera_buf_def_t, inout thumb_image : mm_camera_buf_def_t, inout frame : mm_camera_super_buf_t, inout reproc_frame : mm_camera_super_buf_t) : int32_t
    if (NULL == frame) {
        return NO_INIT;
    }

    QCameraChannel *pChannel = m_parent->getChannelByHandle(frame->ch_id);
    // check reprocess channel if not found
    if (pChannel == NULL) {
        if (m_pReprocChannel != NULL &&
            m_pReprocChannel->getMyHandle() == frame->ch_id) {
            pChannel = m_pReprocChannel;
        }
    }
    if (pChannel == NULL) {
        ALOGD("%s: No corresponding channel (ch_id = %d) exist, return here",
              __func__, frame->ch_id);
        return BAD_VALUE;
    }

    // Use snapshot stream to create thumbnail if snapshot and preview
    // flip settings doesn't match in ZSL mode.
    bool thumb_stream_needed = !m_parent->isZSLMode() ||
        (m_parent->mParameters.getFlipMode(CAM_STREAM_TYPE_SNAPSHOT) ==
         m_parent->mParameters.getFlipMode(CAM_STREAM_TYPE_PREVIEW));

    *main = *thumb = *reproc = NULL;
    *main_image = *thumb_image = NULL;
    // find snapshot frame and thumnail frame
    for (int i = 0; i < frame->num_bufs; i++) {
        QCameraStream *pStream =
                pChannel->getStreamByHandle(frame->bufs[i]->stream_id);
        if (pStream != NULL) {
            if (pStream->isTypeOf(CAM_STREAM_TYPE_SNAPSHOT) ||
                pStream->isOrignalTypeOf(CAM_STREAM_TYPE_SNAPSHOT)) {
                *main= pStream;
                *main_image = frame->bufs[i];
            } else if (thumb_stream_needed &&
                       (pStream->isTypeOf(CAM_STREAM_TYPE_PREVIEW) ||
                        pStream->isTypeOf(CAM_STREAM_TYPE_POSTVIEW) ||
                        pStream->isOrignalTypeOf(CAM_STREAM_TYPE_PREVIEW) ||
                        pStream->isOrignalTypeOf(CAM_STREAM_TYPE_POSTVIEW))) {
                *thumb = pStream;
                *thumb_image = frame->bufs[i];
            }
            if (pStream->isTypeOf(CAM_STREAM_TYPE_OFFLINE_PROC) ) {
                *reproc = pStream;
            }
        }
    }

    if (thumb_stream_needed && *thumb_image == NULL && reproc_frame != NULL) {
        QCameraChannel *pSrcReprocChannel = NULL;
        pSrcReprocChannel = m_parent->getChannelByHandle(reproc_frame->ch_id);
        if (pSrcReprocChannel != NULL) {
            // find thumbnail frame
            for (int i = 0; i < reproc_frame->num_bufs; i++) {
                QCameraStream *pStream =
                        pSrcReprocChannel->getStreamByHandle(
                                reproc_frame->bufs[i]->stream_id);
                if (pStream != NULL) {
                    if (pStream->isTypeOf(CAM_STREAM_TYPE_PREVIEW) ||
                        pStream->isTypeOf(CAM_STREAM_TYPE_POSTVIEW)) {
                        *thumb = pStream;
                        *thumb_image = reproc_frame->bufs[i];
                    }
                }
            }
        }
    }

    if (m_parent->mParameters.generateThumbFromMain()) {
        *thumb = NULL;
        *thumb_image = NULL;
    }

    return NO_ERROR;
!!!44214455.cpp!!!	syncStreamParams(inout frame : mm_camera_super_buf_t, inout reproc_frame : mm_camera_super_buf_t) : int32_t
    QCameraStream *reproc_stream = NULL;
    QCameraStream *main_stream = NULL;
    QCameraStream *thumb_stream = NULL;
    mm_camera_buf_def_t *main_frame = NULL;
    mm_camera_buf_def_t *thumb_frame = NULL;
    int32_t ret = NO_ERROR;

    ret = queryStreams(&main_stream,
            &thumb_stream,
            &reproc_stream,
            &main_frame,
            &thumb_frame,
            frame,
            reproc_frame);
    if (NO_ERROR != ret) {
        ALOGE("%s : Camera streams query from input frames failed %d",
                __func__,
                ret);
        return ret;
    }

    if (NULL != main_stream) {
        ret = main_stream->syncRuntimeParams();
        if (NO_ERROR != ret) {
            ALOGE("%s : Syncing of main stream runtime parameters failed %d",
                    __func__,
                    ret);
            return ret;
        }
    }

    if (NULL != thumb_stream) {
        ret = thumb_stream->syncRuntimeParams();
        if (NO_ERROR != ret) {
            ALOGE("%s : Syncing of thumb stream runtime parameters failed %d",
                    __func__,
                    ret);
            return ret;
        }
    }

    if ((NULL != reproc_stream) && (reproc_stream != main_stream)) {
        ret = reproc_stream->syncRuntimeParams();
        if (NO_ERROR != ret) {
            ALOGE("%s : Syncing of reproc stream runtime parameters failed %d",
                    __func__,
                    ret);
            return ret;
        }
    }

    return ret;
!!!44214583.cpp!!!	releaseSuperBuf(inout super_buf : mm_camera_super_buf_t) : void
    QCameraChannel *pChannel = NULL;

    if (NULL != super_buf) {
        pChannel = m_parent->getChannelByHandle(super_buf->ch_id);

        if ( NULL == pChannel ) {
            if (m_pReprocChannel != NULL &&
                m_pReprocChannel->getMyHandle() == super_buf->ch_id) {
                pChannel = m_pReprocChannel;
            }
        }

        if (pChannel != NULL) {
            pChannel->bufDone(super_buf);
        } else {
            ALOGE(" %s : Channel id %d not found!!",
                  __func__,
                  super_buf->ch_id);
        }
    }
!!!44214711.cpp!!!	releaseNotifyData(inout user_data : void, inout cookie : void, in cb_status : int32_t) : void
    qcamera_data_argm_t *app_cb = ( qcamera_data_argm_t * ) user_data;
    QCameraPostProcessor *postProc = ( QCameraPostProcessor * ) cookie;
    if ( ( NULL != app_cb ) && ( NULL != postProc ) ) {

        if ( postProc->mUseSaveProc &&
             app_cb->release_data.unlinkFile &&
             ( NO_ERROR != cb_status ) ) {

            String8 unlinkPath((const char *) app_cb->release_data.data->data,
                                app_cb->release_data.data->size);
            int rc = unlink(unlinkPath.string());
            CDBG_HIGH("%s : Unlinking stored file rc = %d",
                  __func__,
                  rc);
        }

        if (app_cb && NULL != app_cb->release_data.data) {
            app_cb->release_data.data->release(app_cb->release_data.data);
            app_cb->release_data.data = NULL;
        }
        if (app_cb && NULL != app_cb->release_data.frame) {
            postProc->releaseSuperBuf(app_cb->release_data.frame);
            free(app_cb->release_data.frame);
            app_cb->release_data.frame = NULL;
        }
        if (app_cb && NULL != app_cb->release_data.streamBufs) {
            app_cb->release_data.streamBufs->deallocate();
            delete app_cb->release_data.streamBufs;
            app_cb->release_data.streamBufs = NULL;
        }
        free(app_cb);
    }
!!!44214839.cpp!!!	releaseJpegJobData(inout job : qcamera_jpeg_data_t) : void
    CDBG("%s: E", __func__);
    if (NULL != job) {
        if (NULL != job->src_reproc_frame) {
            if (!job->reproc_frame_release) {
                releaseSuperBuf(job->src_reproc_frame);
            }
            free(job->src_reproc_frame);
            job->src_reproc_frame = NULL;
        }

        if (NULL != job->src_frame) {
            releaseSuperBuf(job->src_frame);
            free(job->src_frame);
            job->src_frame = NULL;
        }

        if (NULL != job->pJpegExifObj) {
            delete job->pJpegExifObj;
            job->pJpegExifObj = NULL;
        }

        if (NULL != job->src_reproc_bufs) {
            delete [] job->src_reproc_bufs;
        }

    }
    CDBG("%s: X", __func__);
!!!44214967.cpp!!!	releaseSaveJobData(inout data : void, inout user_data : void) : void
    CDBG("%s: E", __func__);

    QCameraPostProcessor *pme = (QCameraPostProcessor *) user_data;
    if (NULL == pme) {
        ALOGE("%s: Invalid postproc handle", __func__);
        return;
    }

    qcamera_jpeg_evt_payload_t *job_data = (qcamera_jpeg_evt_payload_t *) data;
    if (job_data == NULL) {
        ALOGE("%s: Invalid jpeg event data", __func__);
        return;
    }

    // find job by jobId
    qcamera_jpeg_data_t *job = pme->findJpegJobByJobId(job_data->jobId);

    if (NULL != job) {
        pme->releaseJpegJobData(job);
        free(job);
    } else {
        ALOGE("%s : Invalid jpeg job", __func__);
    }

    CDBG("%s: X", __func__);
!!!44215095.cpp!!!	releaseRawData(inout data : void, inout user_data : void) : void
    CDBG("%s: E", __func__);

    QCameraPostProcessor *pme = (QCameraPostProcessor *) user_data;
    if (NULL == pme) {
        ALOGE("%s: Invalid postproc handle", __func__);
        return;
    }
    mm_camera_super_buf_t *super_buf = (mm_camera_super_buf_t *) data;
    pme->releaseSuperBuf(super_buf);

    CDBG("%s: X", __func__);
!!!44215223.cpp!!!	processRawImageImpl(inout recvd_frame : mm_camera_super_buf_t) : int32_t
    int32_t rc = NO_ERROR;

    QCameraChannel *pChannel = m_parent->getChannelByHandle(recvd_frame->ch_id);
    QCameraStream *pStream = NULL;
    mm_camera_buf_def_t *frame = NULL;
    // check reprocess channel if not found
    if (pChannel == NULL) {
        if (m_pReprocChannel != NULL &&
            m_pReprocChannel->getMyHandle() == recvd_frame->ch_id) {
            pChannel = m_pReprocChannel;
        }
    }
    if (pChannel == NULL) {
        ALOGE("%s:%d] No corresponding channel (ch_id = %d) exist, return here",
              __func__, __LINE__, recvd_frame->ch_id);
        return BAD_VALUE;
    }

    // find snapshot frame
    for (int i = 0; i < recvd_frame->num_bufs; i++) {
        QCameraStream *pCurStream =
            pChannel->getStreamByHandle(recvd_frame->bufs[i]->stream_id);
        if (pCurStream != NULL) {
            if (pCurStream->isTypeOf(CAM_STREAM_TYPE_SNAPSHOT) ||
                pCurStream->isTypeOf(CAM_STREAM_TYPE_RAW) ||
                pCurStream->isOrignalTypeOf(CAM_STREAM_TYPE_SNAPSHOT) ||
                pCurStream->isOrignalTypeOf(CAM_STREAM_TYPE_RAW)) {
                pStream = pCurStream;
                frame = recvd_frame->bufs[i];
                break;
            }
        }
    }

    if ( NULL == frame ) {
        ALOGE("%s: No valid raw buffer", __func__);
        return BAD_VALUE;
    }

    QCameraMemory *rawMemObj = (QCameraMemory *)frame->mem_info;
    bool zslChannelUsed = m_parent->isZSLMode() &&
            ( pChannel != m_pReprocChannel );
    camera_memory_t *raw_mem = NULL;

    if (rawMemObj != NULL) {
        if (zslChannelUsed) {
            raw_mem = rawMemObj->getMemory(frame->buf_idx, false);
        } else {
            raw_mem = m_parent->mGetMemory(-1,
                                           frame->frame_len,
                                           1,
                                           m_parent->mCallbackCookie);
            if (NULL == raw_mem) {
                ALOGE("%s : Not enough memory for RAW cb ", __func__);
                return NO_MEMORY;
            }
            memcpy(raw_mem->data, frame->buffer, frame->frame_len);
        }
    }

    if (NULL != rawMemObj && NULL != raw_mem) {
        // dump frame into file
        if (frame->stream_type == CAM_STREAM_TYPE_SNAPSHOT ||
            pStream->isOrignalTypeOf(CAM_STREAM_TYPE_SNAPSHOT)) {
            // for YUV422 NV16 case
            m_parent->dumpFrameToFile(pStream, frame, QCAMERA_DUMP_FRM_SNAPSHOT);
        } else {
            m_parent->dumpFrameToFile(pStream, frame, QCAMERA_DUMP_FRM_RAW);
        }

        // send data callback / notify for RAW_IMAGE
        if (NULL != m_parent->mDataCb &&
            m_parent->msgTypeEnabledWithLock(CAMERA_MSG_RAW_IMAGE) > 0) {
            qcamera_callback_argm_t cbArg;
            memset(&cbArg, 0, sizeof(qcamera_callback_argm_t));
            cbArg.cb_type = QCAMERA_DATA_CALLBACK;
            cbArg.msg_type = CAMERA_MSG_RAW_IMAGE;
            cbArg.data = raw_mem;
            cbArg.index = 0;
            m_parent->m_cbNotifier.notifyCallback(cbArg);
        }
        if (NULL != m_parent->mNotifyCb &&
            m_parent->msgTypeEnabledWithLock(CAMERA_MSG_RAW_IMAGE_NOTIFY) > 0) {
            qcamera_callback_argm_t cbArg;
            memset(&cbArg, 0, sizeof(qcamera_callback_argm_t));
            cbArg.cb_type = QCAMERA_NOTIFY_CALLBACK;
            cbArg.msg_type = CAMERA_MSG_RAW_IMAGE_NOTIFY;
            cbArg.ext1 = 0;
            cbArg.ext2 = 0;
            m_parent->m_cbNotifier.notifyCallback(cbArg);
        }

        if ((m_parent->mDataCb != NULL) &&
            m_parent->msgTypeEnabledWithLock(CAMERA_MSG_COMPRESSED_IMAGE) > 0) {
            qcamera_release_data_t release_data;
            memset(&release_data, 0, sizeof(qcamera_release_data_t));
            if ( zslChannelUsed ) {
                release_data.frame = recvd_frame;
            } else {
                release_data.data = raw_mem;
            }
            rc = sendDataNotify(CAMERA_MSG_COMPRESSED_IMAGE,
                                raw_mem,
                                0,
                                NULL,
                                &release_data);
        } else {
            raw_mem->release(raw_mem);
        }
    } else {
        ALOGE("%s: Cannot get raw mem", __func__);
        rc = UNKNOWN_ERROR;
    }

    return rc;
!!!44215351.cpp!!!	releaseJpegData(inout data : void, inout user_data : void) : void
    QCameraPostProcessor *pme = (QCameraPostProcessor *)user_data;
    if (NULL != pme) {
        pme->releaseJpegJobData((qcamera_jpeg_data_t *)data);
        CDBG_HIGH("%s : Rleased job ID %u", __func__,
            ((qcamera_jpeg_data_t *)data)->jobId);
    }
!!!44215479.cpp!!!	releasePPInputData(inout data : void, inout user_data : void) : void
    QCameraPostProcessor *pme = (QCameraPostProcessor *)user_data;
    if (NULL != pme) {
        pme->releaseSuperBuf((mm_camera_super_buf_t *)data);
    }
!!!44215607.cpp!!!	releaseOngoingPPData(inout data : void, inout user_data : void) : void
    QCameraPostProcessor *pme = (QCameraPostProcessor *)user_data;
    if (NULL != pme) {
        qcamera_pp_data_t *pp_job = (qcamera_pp_data_t *)data;
        if (NULL != pp_job->src_frame) {
            if (!pp_job->reproc_frame_release) {
                pme->releaseSuperBuf(pp_job->src_frame);
            }
            free(pp_job->src_frame);
            pp_job->src_frame = NULL;
        }
    }
!!!44215735.cpp!!!	dataProcessRoutine(inout data : void) : void
    int running = 1;
    int ret;
    uint8_t is_active = FALSE;
    QCameraPostProcessor *pme = (QCameraPostProcessor *)data;
    QCameraCmdThread *cmdThread = &pme->m_dataProcTh;

    CDBG_HIGH("%s: E", __func__);
    do {
        do {
            ret = cam_sem_wait(&cmdThread->cmd_sem);
            if (ret != 0 && errno != EINVAL) {
                ALOGE("%s: cam_sem_wait error (%s)",
                           __func__, strerror(errno));
                return NULL;
            }
        } while (ret != 0);

        // we got notified about new cmd avail in cmd queue
        camera_cmd_type_t cmd = cmdThread->getCmd();
        switch (cmd) {
        case CAMERA_CMD_TYPE_START_DATA_PROC:
            CDBG_HIGH("%s: start data proc", __func__);
            is_active = TRUE;

            pme->m_ongoingPPQ.init();
            pme->m_inputJpegQ.init();
            pme->m_inputPPQ.init();
            pme->m_inputRawQ.init();

            pme->m_saveProcTh.sendCmd(CAMERA_CMD_TYPE_START_DATA_PROC,
                                      FALSE,
                                      FALSE);

            // signal cmd is completed
            cam_sem_post(&cmdThread->sync_sem);

            break;
        case CAMERA_CMD_TYPE_STOP_DATA_PROC:
            {
                CDBG_HIGH("%s: stop data proc", __func__);
                is_active = FALSE;

                pme->m_saveProcTh.sendCmd(CAMERA_CMD_TYPE_STOP_DATA_PROC,
                                           TRUE,
                                           TRUE);
                // cancel all ongoing jpeg jobs
                qcamera_jpeg_data_t *jpeg_job =
                    (qcamera_jpeg_data_t *)pme->m_ongoingJpegQ.dequeue();
                while (jpeg_job != NULL) {
                    pme->mJpegHandle.abort_job(jpeg_job->jobId);

                    pme->releaseJpegJobData(jpeg_job);
                    free(jpeg_job);

                    jpeg_job = (qcamera_jpeg_data_t *)pme->m_ongoingJpegQ.dequeue();
                }

                // destroy jpeg encoding session
                if ( 0 < pme->mJpegSessionId ) {
                    pme->mJpegHandle.destroy_session(pme->mJpegSessionId);
                    pme->mJpegSessionId = 0;
                }

                // free jpeg out buf and exif obj
                FREE_JPEG_OUTPUT_BUFFER(pme->m_pJpegOutputMem,
                    pme->m_JpegOutputMemCount);

                if (pme->m_pJpegExifObj != NULL) {
                    delete pme->m_pJpegExifObj;
                    pme->m_pJpegExifObj = NULL;
                }

                // stop reproc channel if exists
                if (pme->m_pReprocChannel != NULL) {
                    pme->m_pReprocChannel->stop();
                    delete pme->m_pReprocChannel;
                    pme->m_pReprocChannel = NULL;
                }

                // flush ongoing postproc Queue
                pme->m_ongoingPPQ.flush();

                // flush input jpeg Queue
                pme->m_inputJpegQ.flush();

                // flush input Postproc Queue
                pme->m_inputPPQ.flush();

                // flush input raw Queue
                pme->m_inputRawQ.flush();

                // signal cmd is completed
                cam_sem_post(&cmdThread->sync_sem);

                pme->mNewJpegSessionNeeded = true;
            }
            break;
        case CAMERA_CMD_TYPE_DO_NEXT_JOB:
            {
                CDBG_HIGH("%s: Do next job, active is %d", __func__, is_active);
                if (is_active == TRUE) {
                    qcamera_jpeg_data_t *jpeg_job =
                        (qcamera_jpeg_data_t *)pme->m_inputJpegQ.dequeue();

                    if (NULL != jpeg_job) {
                        // To avoid any race conditions,
                        // sync any stream specific parameters here.
                        pme->syncStreamParams(jpeg_job->src_frame, NULL);

                        // add into ongoing jpeg job Q
                        pme->m_ongoingJpegQ.enqueue((void *)jpeg_job);
                        ret = pme->encodeData(jpeg_job,
                                  pme->mNewJpegSessionNeeded);
                        if (NO_ERROR != ret) {
                            // dequeue the last one
                            pme->m_ongoingJpegQ.dequeue(false);
                            pme->releaseJpegJobData(jpeg_job);
                            free(jpeg_job);
                            pme->sendEvtNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0);
                        }
                    }


                    // process raw data if any
                    mm_camera_super_buf_t *super_buf =
                        (mm_camera_super_buf_t *)pme->m_inputRawQ.dequeue();

                    if (NULL != super_buf) {
                        //play shutter sound
                        pme->m_parent->playShutter();
                        ret = pme->processRawImageImpl(super_buf);
                        if (NO_ERROR != ret) {
                            pme->releaseSuperBuf(super_buf);
                            free(super_buf);
                            pme->sendEvtNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0);
                        }
                    }

                    mm_camera_super_buf_t *pp_frame =
                        (mm_camera_super_buf_t *)pme->m_inputPPQ.dequeue();
                    if (NULL != pp_frame) {
                        qcamera_pp_data_t *pp_job =
                            (qcamera_pp_data_t *)malloc(sizeof(qcamera_pp_data_t));
                        if (pp_job != NULL) {
                            pme->syncStreamParams(pp_frame, NULL);
                            memset(pp_job, 0, sizeof(qcamera_pp_data_t));
                            if (pme->m_pReprocChannel != NULL) {
                                // add into ongoing PP job Q
                                pp_job->src_frame = pp_frame;
                                ret = pme->reprocess(pp_job);
                                if (NO_ERROR == ret) {
                                    pme->stopCapture();
                                }
                            } else {
                                ALOGE("%s: Reprocess channel is NULL", __func__);
                                ret = -1;
                            }
                        } else {
                            ALOGE("%s: no mem for qcamera_pp_data_t", __func__);
                            ret = -1;
                        }

                        if (0 != ret) {
                            // free pp_job
                            if (pp_job != NULL) {
                                free(pp_job);
                            }
                            // free frame
                            if (pp_frame != NULL) {
                                pme->releaseSuperBuf(pp_frame);
                                free(pp_frame);
                            }
                            // send error notify
                            pme->sendEvtNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0);
                        }
                    }
                } else {
                    // not active, simply return buf and do no op
                    qcamera_jpeg_data_t *jpeg_data =
                        (qcamera_jpeg_data_t *)pme->m_inputJpegQ.dequeue();
                    if (NULL != jpeg_data) {
                        pme->releaseJpegJobData(jpeg_data);
                        free(jpeg_data);
                    }
                    mm_camera_super_buf_t *super_buf =
                        (mm_camera_super_buf_t *)pme->m_inputRawQ.dequeue();
                    if (NULL != super_buf) {
                        pme->releaseSuperBuf(super_buf);
                        free(super_buf);
                    }
                    super_buf = (mm_camera_super_buf_t *)pme->m_inputPPQ.dequeue();
                    if (NULL != super_buf) {
                        pme->releaseSuperBuf(super_buf);
                        free(super_buf);
                    }
                }
            }
            break;
        case CAMERA_CMD_TYPE_EXIT:
            running = 0;
            break;
        default:
            break;
        }
    } while (running);
    CDBG_HIGH("%s: X", __func__);
    return NULL;
!!!44215863.cpp!!!	dataSaveRoutine(inout data : void) : void
    int running = 1;
    int ret;
    uint8_t is_active = FALSE;
    QCameraPostProcessor *pme = (QCameraPostProcessor *)data;
    QCameraCmdThread *cmdThread = &pme->m_saveProcTh;
    char saveName[PROPERTY_VALUE_MAX];

    CDBG_HIGH("%s: E", __func__);
    do {
        do {
            ret = cam_sem_wait(&cmdThread->cmd_sem);
            if (ret != 0 && errno != EINVAL) {
                ALOGE("%s: cam_sem_wait error (%s)",
                           __func__, strerror(errno));
                return NULL;
            }
        } while (ret != 0);

        // we got notified about new cmd avail in cmd queue
        camera_cmd_type_t cmd = cmdThread->getCmd();
        switch (cmd) {
        case CAMERA_CMD_TYPE_START_DATA_PROC:
            CDBG_HIGH("%s: start data proc", __func__);
            is_active = TRUE;
            pme->m_inputSaveQ.init();
            break;
        case CAMERA_CMD_TYPE_STOP_DATA_PROC:
            {
                CDBG_HIGH("%s: stop data proc", __func__);
                is_active = FALSE;

                // flush input save Queue
                pme->m_inputSaveQ.flush();

                // signal cmd is completed
                cam_sem_post(&cmdThread->sync_sem);
            }
            break;
        case CAMERA_CMD_TYPE_DO_NEXT_JOB:
            {
                CDBG_HIGH("%s: Do next job, active is %d", __func__, is_active);

                qcamera_jpeg_evt_payload_t *job_data = (qcamera_jpeg_evt_payload_t *) pme->m_inputSaveQ.dequeue();
                if (job_data == NULL) {
                    ALOGE("%s: Invalid jpeg event data", __func__);
                    continue;
                }

                pme->m_ongoingJpegQ.flushNodes(matchJobId, (void*)&job_data->jobId);

                CDBG_HIGH("[KPI Perf] %s : jpeg job %d", __func__, job_data->jobId);

                if (is_active == TRUE) {
                    memset(saveName, '\0', sizeof(saveName));
                    snprintf(saveName,
                             sizeof(saveName),
                             QCameraPostProcessor::STORE_LOCATION,
                             pme->mSaveFrmCnt);

                    int file_fd = open(saveName, O_RDWR | O_CREAT, 0655);
                    if (file_fd > 0) {
                        size_t written_len = write(file_fd,
                                                job_data->out_data.buf_vaddr,
                                                job_data->out_data.buf_filled_len);
                        if ( job_data->out_data.buf_filled_len != written_len ) {
                            ALOGE("%s: Failed save complete data %d bytes written instead of %d bytes!",
                                  __func__,
                                  written_len,
                                  job_data->out_data.buf_filled_len);
                        } else {
                            CDBG_HIGH("%s: written number of bytes %d\n", __func__, written_len);
                        }

                        close(file_fd);
                    } else {
                        ALOGE("%s: fail t open file for saving", __func__);
                    }
                    pme->mSaveFrmCnt++;

                    camera_memory_t* jpeg_mem = pme->m_parent->mGetMemory(-1,
                                                         strlen(saveName),
                                                         1,
                                                         pme->m_parent->mCallbackCookie);
                    if (NULL == jpeg_mem) {
                        ret = NO_MEMORY;
                        ALOGE("%s : getMemory for jpeg, ret = NO_MEMORY", __func__);
                        goto end;
                    }
                    memcpy(jpeg_mem->data, saveName, strlen(saveName));

                    CDBG_HIGH("%s : Calling upperlayer callback to store JPEG image", __func__);
                    qcamera_release_data_t release_data;
                    memset(&release_data, 0, sizeof(qcamera_release_data_t));
                    release_data.data = jpeg_mem;
                    release_data.unlinkFile = true;
                    CDBG_HIGH("[KPI Perf] %s: PROFILE_JPEG_CB ",__func__);
                    ret = pme->sendDataNotify(CAMERA_MSG_COMPRESSED_IMAGE,
                                        jpeg_mem,
                                        0,
                                        NULL,
                                        &release_data);
                }

end:
                free(job_data);
            }
            break;
        case CAMERA_CMD_TYPE_EXIT:
            CDBG_HIGH("%s : save thread exit", __func__);
            running = 0;
            break;
        default:
            break;
        }
    } while (running);
    CDBG_HIGH("%s: X", __func__);
    return NULL;
!!!44215991.cpp!!!	setYUVFrameInfo(inout recvd_frame : mm_camera_super_buf_t) : int32_t
    QCameraChannel *pChannel = m_parent->getChannelByHandle(recvd_frame->ch_id);
    // check reprocess channel if not found
    if (pChannel == NULL) {
        if (m_pReprocChannel != NULL &&
            m_pReprocChannel->getMyHandle() == recvd_frame->ch_id) {
            pChannel = m_pReprocChannel;
        }
    }

    if (pChannel == NULL) {
        ALOGE("%s:%d] No corresponding channel (ch_id = %d) exist, return here",
              __func__, __LINE__, recvd_frame->ch_id);
        return BAD_VALUE;
    }

    // find snapshot frame
    for (int i = 0; i < recvd_frame->num_bufs; i++) {
        QCameraStream *pStream =
            pChannel->getStreamByHandle(recvd_frame->bufs[i]->stream_id);
        if (pStream != NULL) {
            if (pStream->isTypeOf(CAM_STREAM_TYPE_SNAPSHOT) ||
                pStream->isOrignalTypeOf(CAM_STREAM_TYPE_SNAPSHOT)) {
                //get the main frame, use stream info
                cam_frame_len_offset_t frame_offset;
                cam_dimension_t frame_dim;
                cam_format_t frame_fmt;
                const char *fmt_string;
                pStream->getFrameDimension(frame_dim);
                pStream->getFrameOffset(frame_offset);
                pStream->getFormat(frame_fmt);
                fmt_string = m_parent->mParameters.getFrameFmtString(frame_fmt);

                int cbcr_offset = frame_offset.mp[0].len - frame_dim.width * frame_dim.height;
                m_parent->mParameters.set("snapshot-framelen", frame_offset.frame_len);
                m_parent->mParameters.set("snapshot-yoff", frame_offset.mp[0].offset);
                m_parent->mParameters.set("snapshot-cbcroff", cbcr_offset);
                if(fmt_string != NULL){
                    m_parent->mParameters.set("snapshot-format", fmt_string);
                }else{
                    m_parent->mParameters.set("snapshot-format", "");
                }

                CDBG_HIGH("%s: frame width=%d, height=%d, yoff=%d, cbcroff=%d, fmt_string=%s", __func__,
                        frame_dim.width, frame_dim.height, frame_offset.mp[0].offset, cbcr_offset, fmt_string);
                return NO_ERROR;
            }
        }
    }

    return BAD_VALUE;
!!!44216119.cpp!!!	matchJobId(inout data : void, inout user_data : void, inout match_data : void) : bool
  qcamera_jpeg_data_t * job = (qcamera_jpeg_data_t *) data;
  uint32_t job_id = *((uint32_t *) match_data);
  return job->jobId == job_id;
!!!44216247.cpp!!!	getJpegMemory(inout out_buf : omx_jpeg_ouput_buf_t) : int
    CDBG_HIGH("%s: Allocating jpeg out buffer of size: %d", __func__, out_buf->size);
    QCameraPostProcessor *procInst = (QCameraPostProcessor *) out_buf->handle;
    camera_memory_t *cam_mem = procInst->m_parent->mGetMemory(-1, out_buf->size,
        1, procInst->m_parent->mCallbackCookie);
    out_buf->mem_hdl = cam_mem;
    out_buf->vaddr = cam_mem->data;

    return 0;
!!!44216375.cpp!!!	doReprocess() : int32_t
    int32_t ret = NO_ERROR;
    QCameraChannel *m_pSrcChannel;
    QCameraStream *pMetaStream = NULL;
    uint8_t meta_buf_index = 0;
    mm_camera_buf_def_t *meta_buf = NULL;
    bool found_meta = FALSE;

    qcamera_pp_request_t *ppreq_job = (qcamera_pp_request_t *)m_inputPPQ.peek();
    if ((ppreq_job == NULL) || (ppreq_job->src_frame == NULL)) {
        return ret;
    }

    if (!validatePostProcess(ppreq_job->src_frame)) {
        return ret;
    }

    ppreq_job = (qcamera_pp_request_t *)m_inputPPQ.dequeue();
    if (ppreq_job == NULL || ppreq_job->src_frame == NULL ||
            ppreq_job->src_reproc_frame == NULL) {
        return ret;
    }

    mm_camera_super_buf_t *src_frame = ppreq_job->src_frame;
    mm_camera_super_buf_t *src_reproc_frame = ppreq_job->src_reproc_frame;
    int8_t mCurReprocCount = ppreq_job->reprocCount;

    CDBG("%s: frame = %p src_frame = %p mCurReprocCount = %d",__func__,
            src_frame,src_reproc_frame,mCurReprocCount);

    // find meta data stream and index of meta data frame in the superbuf
    for (int8_t j = 0; j < mTotalNumReproc; j++) {
        uint32_t i;
        m_pSrcChannel = mPPChannels[j]->getSrcChannel();
        if (m_pSrcChannel == NULL)
            continue;
        for (i = 0; i < src_reproc_frame->num_bufs; i++) {
            QCameraStream *pStream =
                    m_pSrcChannel->getStreamByHandle(src_reproc_frame->bufs[i]->stream_id);
            if (pStream != NULL && pStream->isTypeOf(CAM_STREAM_TYPE_METADATA)) {
                meta_buf_index = (uint8_t) src_reproc_frame->bufs[i]->buf_idx;
                pMetaStream = pStream;
                meta_buf = src_reproc_frame->bufs[i];
                break;
            }
        }
        if (i < src_reproc_frame->num_bufs) {
            CDBG(" %s: Found Meta data info for reprocessing index = %d", __func__,
                    (int)meta_buf_index);
            break;
        }
    }

    qcamera_pp_data_t *pp_job =
            (qcamera_pp_data_t *)malloc(sizeof(qcamera_pp_data_t));
    if (pp_job != NULL) {
        syncStreamParams(src_frame, src_reproc_frame);
        memset(pp_job, 0, sizeof(qcamera_pp_data_t));
        if (mPPChannels[mCurReprocCount] != NULL) {
            // add into ongoing PP job Q
            pp_job->src_frame = src_frame;
            pp_job->src_reproc_frame = src_reproc_frame;
            pp_job->reprocCount = (int8_t) (mCurReprocCount + 1);

            if (m_parent->isRegularCapture()) {
                if ((NULL != pp_job->src_frame) &&
                    (0 < pp_job->src_frame->num_bufs)) {
                    mm_camera_buf_def_t *bufs = NULL;
                    uint32_t num_bufs = pp_job->src_frame->num_bufs;
                    bufs = new mm_camera_buf_def_t[num_bufs];
                    if (NULL == bufs) {
                        ALOGE("%s:Unable to allocate cached buffers",
                            __func__);
                        return NO_MEMORY;
                    }

                    for (uint32_t i = 0; i < num_bufs; i++) {
                        bufs[i] = *pp_job->src_frame->bufs[i];
                        pp_job->src_frame->bufs[i] = &bufs[i];
                    }
                    pp_job->src_reproc_bufs = bufs;
                }

                m_bufCountPPQ++;

                // Don't release source frame after encoding
                // at this point the source channel will not exist.
                pp_job->reproc_frame_release = true;
                if (m_ongoingPPQ.enqueue((void *)pp_job)) {
                    ret = mPPChannels[mCurReprocCount]->doReprocessOffline(pp_job->src_frame,
                            meta_buf);
                } else {
                    CDBG_HIGH("%s : m_ongoingJpegQ is not active!!!", __func__);
                    releaseOngoingPPData(pp_job, this);
                    free(pp_job);
                    pp_job = NULL;
                }
            } else {

                m_bufCountPPQ++;
                if (!m_ongoingPPQ.enqueue((void *)pp_job)) {
                    CDBG_HIGH("%s : m_ongoingJpegQ is not active!!!", __func__);
                    releaseOngoingPPData(pp_job, this);
                    free(pp_job);
                    pp_job = NULL;
                    goto end;
                }

                int32_t numRequiredPPQBufsForSingleOutput = (int32_t)
                        m_parent->mParameters.getNumberInBufsForSingleShot();

                if (m_bufCountPPQ % numRequiredPPQBufsForSingleOutput == 0) {
                    int32_t extra_pp_job_count =
                            m_parent->mParameters.getNumberOutBufsForSingleShot() -
                            m_parent->mParameters.getNumberInBufsForSingleShot();

                    for (int32_t i = 0; i < extra_pp_job_count; i++) {
                        qcamera_pp_data_t *extra_pp_job =
                                (qcamera_pp_data_t *)calloc(1, sizeof(qcamera_pp_data_t));
                        if (!extra_pp_job) {
                            ALOGE("%s: no mem for qcamera_pp_data_t", __func__);
                            ret = NO_MEMORY;
                            break;
                        }
                        extra_pp_job->reprocCount = pp_job->reprocCount;
                        if (!m_ongoingPPQ.enqueue((void *)extra_pp_job)) {
                            CDBG_HIGH("%s : m_ongoingJpegQ is not active!!!", __func__);
                            releaseOngoingPPData(extra_pp_job, this);
                            free(extra_pp_job);
                            extra_pp_job = NULL;
                            goto end;
                        }
                    }
                }

                ret = mPPChannels[mCurReprocCount]->doReprocess(pp_job->src_frame,
                        m_parent->mParameters, pMetaStream, meta_buf_index);
            }
        } else {
            ALOGE("%s: Reprocess channel is NULL", __func__);
            if (pp_job != NULL) {
                free(pp_job);
                pp_job = NULL;
            }
            releasePPInputData(ppreq_job, this);
            ret = UNKNOWN_ERROR;
        }
    } else {
        ALOGE("%s: no mem for qcamera_pp_data_t", __func__);
        ret = NO_MEMORY;
    }

end:
    free(ppreq_job);
    ppreq_job = NULL;
    return ret;
!!!44216503.cpp!!!	stopCapture() : int32_t
     int rc = NO_ERROR;

     if (m_parent->isRegularCapture()) {
        rc = m_parent->processAPI(
                        QCAMERA_SM_EVT_STOP_CAPTURE_CHANNEL,
                        NULL);
     }

     return rc;
