class QCameraParameters
!!!44169271.cpp!!!	QCameraParameters()
    char value[PROPERTY_VALUE_MAX];
    // TODO: may move to parameter instead of sysprop
    property_get("persist.debug.sf.showfps", value, "0");
    m_bDebugFps = atoi(value) > 0 ? true : false;
    m_bReleaseTorchCamera = false;
    m_pTorch = NULL;

    // For thermal mode, it should be set as system property
    // because system property applies to all applications, while
    // parameters only apply to specific app.
    property_get("persist.camera.thermal.mode", value, "fps");
    if (!strcmp(value, "frameskip")) {
        m_ThermalMode = QCAMERA_THERMAL_ADJUST_FRAMESKIP;
    } else {
        if (strcmp(value, "fps"))
            ALOGE("%s: Invalid camera thermal mode %s", __func__, value);
        m_ThermalMode = QCAMERA_THERMAL_ADJUST_FPS;
    }

    memset(&m_LiveSnapshotSize, 0, sizeof(m_LiveSnapshotSize));
    memset(&m_default_fps_range, 0, sizeof(m_default_fps_range));
    memset(&m_hfrFpsRange, 0, sizeof(m_hfrFpsRange));
!!!44169399.cpp!!!	QCameraParameters(in params : String8)
    memset(&m_LiveSnapshotSize, 0, sizeof(m_LiveSnapshotSize));
    memset(&m_default_fps_range, 0, sizeof(m_default_fps_range));
    memset(&m_hfrFpsRange, 0, sizeof(m_hfrFpsRange));
    m_pTorch = NULL;
    m_bReleaseTorchCamera = false;
!!!44169527.cpp!!!	~QCameraParameters()
    deinit();
!!!44169655.cpp!!!	getSupportedHfrSizes(inout sizes : Vector<Size>) : void
    const char *hfrSizesStr = get(KEY_QC_SUPPORTED_HFR_SIZES);
    parseSizesList(hfrSizesStr, sizes);
!!!44169783.cpp!!!	setPreviewFrameRateMode(in mode : char) : void
    set(KEY_QC_PREVIEW_FRAME_RATE_MODE, mode);
!!!44169911.cpp!!!	getPreviewFrameRateMode() : char
    return get(KEY_QC_PREVIEW_FRAME_RATE_MODE);
!!!44170039.cpp!!!	setTouchIndexAec(in x : int, in y : int) : void
    char str[32];
    snprintf(str, sizeof(str), "%dx%d", x, y);
    set(KEY_QC_TOUCH_INDEX_AEC, str);
!!!44170167.cpp!!!	getTouchIndexAec(inout x : int, inout y : int) : void
    *x = -1;
    *y = -1;

    // Get the current string, if it doesn't exist, leave the -1x-1
    const char *p = get(KEY_QC_TOUCH_INDEX_AEC);
    if (p == 0)
        return;

    int tempX, tempY;
    if (parse_pair(p, &tempX, &tempY, 'x') == 0) {
        *x = tempX;
        *y = tempY;
    }
!!!44170295.cpp!!!	setTouchIndexAf(in x : int, in y : int) : void
    char str[32];
    snprintf(str, sizeof(str), "%dx%d", x, y);
    set(KEY_QC_TOUCH_INDEX_AF, str);
!!!44170423.cpp!!!	getTouchIndexAf(inout x : int, inout y : int) : void
    *x = -1;
    *y = -1;

    // Get the current string, if it doesn't exist, leave the -1x-1
    const char *p = get(KEY_QC_TOUCH_INDEX_AF);
    if (p == 0)
        return;

    int tempX, tempY;
    if (parse_pair(p, &tempX, &tempY, 'x') == 0) {
        *x = tempX;
        *y = tempY;
    }
!!!44170551.cpp!!!	init(inout capabilities : cam_capability_t, inout mmOps : mm_camera_vtbl_t, inout adjustFPS : QCameraAdjustFPS) : int32_t
    int32_t rc = NO_ERROR;

    m_pCapability = capabilities;
    m_pCamOpsTbl = mmOps;
    m_AdjustFPS = adjustFPS;

    //Allocate Set Param Buffer
    m_pParamHeap = new QCameraHeapMemory(QCAMERA_ION_USE_CACHE);
    rc = m_pParamHeap->allocate(1, sizeof(parm_buffer_t), NON_SECURE);
    if(rc != OK) {
        rc = NO_MEMORY;
        ALOGE("Failed to allocate SETPARM Heap memory");
        goto TRANS_INIT_ERROR1;
    }

    //Map memory for parameters buffer
    rc = m_pCamOpsTbl->ops->map_buf(m_pCamOpsTbl->camera_handle,
                             CAM_MAPPING_BUF_TYPE_PARM_BUF,
                             m_pParamHeap->getFd(0),
                             sizeof(parm_buffer_t));
    if(rc < 0) {
        ALOGE("%s:failed to map SETPARM buffer",__func__);
        rc = FAILED_TRANSACTION;
        goto TRANS_INIT_ERROR2;
    }
    m_pParamBuf = (parm_buffer_t*) DATA_PTR(m_pParamHeap,0);

    initDefaultParameters();

    m_bInited = true;

    goto TRANS_INIT_DONE;

TRANS_INIT_ERROR2:
    m_pParamHeap->deallocate();

TRANS_INIT_ERROR1:
    delete m_pParamHeap;
    m_pParamHeap = NULL;

TRANS_INIT_DONE:
    return rc;
!!!44170679.cpp!!!	deinit() : void
    if (!m_bInited) {
        return;
    }

    //clear all entries in the map
    String8 emptyStr;
    QCameraParameters::unflatten(emptyStr);

    if (NULL != m_pCamOpsTbl) {
        m_pCamOpsTbl->ops->unmap_buf(
                             m_pCamOpsTbl->camera_handle,
                             CAM_MAPPING_BUF_TYPE_PARM_BUF);
        m_pCamOpsTbl = NULL;
    }
    m_pCapability = NULL;
    if (NULL != m_pParamHeap) {
        m_pParamHeap->deallocate();
        delete m_pParamHeap;
        m_pParamHeap = NULL;
        m_pParamBuf = NULL;
    }

    m_AdjustFPS = NULL;

    m_tempMap.clear();

    m_bInited = false;
!!!44170935.cpp!!!	initDefaultParameters() : int32_t
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }
    int32_t hal_version = CAM_HAL_V1;
    AddSetParmEntryToBatch(m_pParamBuf,
                           CAM_INTF_PARM_HAL_VERSION,
                           sizeof(hal_version),
                           &hal_version);

    /*************************Initialize Values******************************/
    // Set read only parameters from camera capability
    set(KEY_SMOOTH_ZOOM_SUPPORTED,
        m_pCapability->smooth_zoom_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_ZOOM_SUPPORTED,
        m_pCapability->zoom_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_VIDEO_SNAPSHOT_SUPPORTED,
        m_pCapability->video_snapshot_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_VIDEO_STABILIZATION_SUPPORTED,
        m_pCapability->video_stablization_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_AUTO_EXPOSURE_LOCK_SUPPORTED,
        m_pCapability->auto_exposure_lock_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED,
        m_pCapability->auto_wb_lock_supported? VALUE_TRUE : VALUE_FALSE);
    set(KEY_QC_SUPPORTED_CAMERA_FEATURES,
        m_pCapability->qcom_supported_feature_mask);
    set(KEY_MAX_NUM_DETECTED_FACES_HW, m_pCapability->max_num_roi);
    set(KEY_MAX_NUM_DETECTED_FACES_SW, m_pCapability->max_num_roi);
    set(KEY_QC_MAX_NUM_REQUESTED_FACES, m_pCapability->max_num_roi);
    // Set focal length, horizontal view angle, and vertical view angle
    setFloat(KEY_FOCAL_LENGTH, m_pCapability->focal_length);
    setFloat(KEY_HORIZONTAL_VIEW_ANGLE, m_pCapability->hor_view_angle);
    setFloat(KEY_VERTICAL_VIEW_ANGLE, m_pCapability->ver_view_angle);
    set(QCameraParameters::KEY_FOCUS_DISTANCES, "Infinity,Infinity,Infinity");
    set(KEY_QC_AUTO_HDR_SUPPORTED,
        (m_pCapability->auto_hdr_supported)? VALUE_TRUE : VALUE_FALSE);
    // Set supported preview sizes
    if (m_pCapability->preview_sizes_tbl_cnt > 0 &&
        m_pCapability->preview_sizes_tbl_cnt <= MAX_SIZES_CNT) {
        String8 previewSizeValues = createSizesString(
                m_pCapability->preview_sizes_tbl, m_pCapability->preview_sizes_tbl_cnt);
        set(KEY_SUPPORTED_PREVIEW_SIZES, previewSizeValues.string());
        CDBG_HIGH("%s: supported preview sizes: %s", __func__, previewSizeValues.string());
        // Set default preview size
        CameraParameters::setPreviewSize(m_pCapability->preview_sizes_tbl[0].width,
                                         m_pCapability->preview_sizes_tbl[0].height);
    } else {
        ALOGE("%s: supported preview sizes cnt is 0 or exceeds max!!!", __func__);
    }

    // Set supported video sizes
    if (m_pCapability->video_sizes_tbl_cnt > 0 &&
        m_pCapability->video_sizes_tbl_cnt <= MAX_SIZES_CNT) {
        String8 videoSizeValues = createSizesString(
                m_pCapability->video_sizes_tbl, m_pCapability->video_sizes_tbl_cnt);
        set(KEY_SUPPORTED_VIDEO_SIZES, videoSizeValues.string());
        CDBG_HIGH("%s: supported video sizes: %s", __func__, videoSizeValues.string());
        // Set default video size
        CameraParameters::setVideoSize(m_pCapability->video_sizes_tbl[0].width,
                                       m_pCapability->video_sizes_tbl[0].height);

        //Set preferred Preview size for video
        String8 vSize = createSizesString(&m_pCapability->preview_sizes_tbl[0], 1);
        set(KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO, vSize.string());
    } else {
        ALOGE("%s: supported video sizes cnt is 0 or exceeds max!!!", __func__);
    }

    // Set supported picture sizes
    if (m_pCapability->picture_sizes_tbl_cnt > 0 &&
        m_pCapability->picture_sizes_tbl_cnt <= MAX_SIZES_CNT) {
        String8 pictureSizeValues = createSizesString(
                m_pCapability->picture_sizes_tbl, m_pCapability->picture_sizes_tbl_cnt);
        set(KEY_SUPPORTED_PICTURE_SIZES, pictureSizeValues.string());
        CDBG_HIGH("%s: supported pic sizes: %s", __func__, pictureSizeValues.string());
        // Set default picture size to the smallest resolution
        CameraParameters::setPictureSize(
           m_pCapability->picture_sizes_tbl[m_pCapability->picture_sizes_tbl_cnt-1].width,
           m_pCapability->picture_sizes_tbl[m_pCapability->picture_sizes_tbl_cnt-1].height);
    } else {
        ALOGE("%s: supported picture sizes cnt is 0 or exceeds max!!!", __func__);
    }

    // Need check if scale should be enabled
    if (m_pCapability->scale_picture_sizes_cnt > 0 &&
        m_pCapability->scale_picture_sizes_cnt <= MAX_SCALE_SIZES_CNT){
        //get scale size, enable scaling. And re-set picture size table with scale sizes
        m_reprocScaleParam.setScaleEnable(true);
        int rc_s = m_reprocScaleParam.setScaleSizeTbl(
            m_pCapability->scale_picture_sizes_cnt, m_pCapability->scale_picture_sizes,
            m_pCapability->picture_sizes_tbl_cnt, m_pCapability->picture_sizes_tbl);
        if(rc_s == NO_ERROR){
            cam_dimension_t *totalSizeTbl = m_reprocScaleParam.getTotalSizeTbl();
            uint8_t totalSizeCnt = m_reprocScaleParam.getTotalSizeTblCnt();
            String8 pictureSizeValues = createSizesString(totalSizeTbl, totalSizeCnt);
            set(KEY_SUPPORTED_PICTURE_SIZES, pictureSizeValues.string());
            CDBG_HIGH("%s: scaled supported pic sizes: %s", __func__, pictureSizeValues.string());
        }else{
            m_reprocScaleParam.setScaleEnable(false);
            ALOGE("%s: reset scaled picture size table failed.", __func__);
        }
    }else{
        m_reprocScaleParam.setScaleEnable(false);
    }

    // Set supported thumbnail sizes
    String8 thumbnailSizeValues = createSizesString(
            THUMBNAIL_SIZES_MAP,
            sizeof(THUMBNAIL_SIZES_MAP)/sizeof(cam_dimension_t));
    set(KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, thumbnailSizeValues.string());
    // Set default thumnail size
    set(KEY_JPEG_THUMBNAIL_WIDTH, THUMBNAIL_SIZES_MAP[0].width);
    set(KEY_JPEG_THUMBNAIL_HEIGHT, THUMBNAIL_SIZES_MAP[0].height);

    // Set supported livesnapshot sizes
    if (m_pCapability->livesnapshot_sizes_tbl_cnt > 0 &&
        m_pCapability->livesnapshot_sizes_tbl_cnt <= MAX_SIZES_CNT) {
        String8 liveSnpashotSizeValues = createSizesString(
                m_pCapability->livesnapshot_sizes_tbl,
                m_pCapability->livesnapshot_sizes_tbl_cnt);
        set(KEY_QC_SUPPORTED_LIVESNAPSHOT_SIZES, liveSnpashotSizeValues.string());
        CDBG("%s: supported live snapshot sizes: %s", __func__, liveSnpashotSizeValues.string());
        m_LiveSnapshotSize =
            m_pCapability->livesnapshot_sizes_tbl[m_pCapability->livesnapshot_sizes_tbl_cnt-1];
    }

    // Set supported preview formats
    String8 previewFormatValues = createValuesString(
            (int *)m_pCapability->supported_preview_fmts,
            m_pCapability->supported_preview_fmt_cnt,
            PREVIEW_FORMATS_MAP,
            sizeof(PREVIEW_FORMATS_MAP)/sizeof(QCameraMap));
    set(KEY_SUPPORTED_PREVIEW_FORMATS, previewFormatValues.string());
    // Set default preview format
    CameraParameters::setPreviewFormat(PIXEL_FORMAT_YUV420SP);

    // Set default Video Format
    set(KEY_VIDEO_FRAME_FORMAT, PIXEL_FORMAT_YUV420SP);

    // Set supported picture formats
    String8 pictureTypeValues(PIXEL_FORMAT_JPEG);
    String8 str = createValuesString(
            (int *)m_pCapability->supported_raw_fmts,
            m_pCapability->supported_raw_fmt_cnt,
            PICTURE_TYPES_MAP,
            sizeof(PICTURE_TYPES_MAP)/sizeof(QCameraMap));
    if (str.string() != NULL) {
        pictureTypeValues.append(",");
        pictureTypeValues.append(str);
    }

    set(KEY_SUPPORTED_PICTURE_FORMATS, pictureTypeValues.string());
    // Set default picture Format
    CameraParameters::setPictureFormat(PIXEL_FORMAT_JPEG);
    // Set raw image size
    char raw_size_str[32];
    snprintf(raw_size_str, sizeof(raw_size_str), "%dx%d",
             m_pCapability->raw_dim[0].width, m_pCapability->raw_dim[0].height);
    set(KEY_QC_RAW_PICUTRE_SIZE, raw_size_str);
    CDBG("%s: KEY_QC_RAW_PICUTRE_SIZE: w: %d, h: %d ", __func__,
       m_pCapability->raw_dim[0].width, m_pCapability->raw_dim[0].height);

    //set default jpeg quality and thumbnail quality
    set(KEY_JPEG_QUALITY, 85);
    set(KEY_JPEG_THUMBNAIL_QUALITY, 85);

    // Set FPS ranges
    if (m_pCapability->fps_ranges_tbl_cnt > 0 &&
        m_pCapability->fps_ranges_tbl_cnt <= MAX_SIZES_CNT) {
        int default_fps_index = 0;
        String8 fpsRangeValues = createFpsRangeString(m_pCapability->fps_ranges_tbl,
                                                      m_pCapability->fps_ranges_tbl_cnt,
                                                      default_fps_index);
        set(KEY_SUPPORTED_PREVIEW_FPS_RANGE, fpsRangeValues.string());

        int min_fps =
            int(m_pCapability->fps_ranges_tbl[default_fps_index].min_fps * 1000);
        int max_fps =
            int(m_pCapability->fps_ranges_tbl[default_fps_index].max_fps * 1000);
        m_default_fps_range = m_pCapability->fps_ranges_tbl[default_fps_index];
        //Set video fps same as preview fps
        setPreviewFpsRange(min_fps, max_fps, min_fps, max_fps);

        // Set legacy preview fps
        String8 fpsValues = createFpsString(m_pCapability->fps_ranges_tbl[default_fps_index]);
        set(KEY_SUPPORTED_PREVIEW_FRAME_RATES, fpsValues.string());
        CDBG_HIGH("%s: supported fps rates: %s", __func__, fpsValues.string());
        CameraParameters::setPreviewFrameRate(int(m_pCapability->fps_ranges_tbl[default_fps_index].max_fps));
    } else {
        ALOGE("%s: supported fps ranges cnt is 0 or exceeds max!!!", __func__);
    }

    // Set supported focus modes
    if (m_pCapability->supported_focus_modes_cnt > 0) {
        String8 focusModeValues = createValuesString(
                (int *)m_pCapability->supported_focus_modes,
                m_pCapability->supported_focus_modes_cnt,
                FOCUS_MODES_MAP,
                sizeof(FOCUS_MODES_MAP)/sizeof(QCameraMap));
        set(KEY_SUPPORTED_FOCUS_MODES, focusModeValues);

        // Set default focus mode and update corresponding parameter buf
        const char *focusMode = lookupNameByValue(FOCUS_MODES_MAP,
                                             sizeof(FOCUS_MODES_MAP)/sizeof(QCameraMap),
                                             m_pCapability->supported_focus_modes[0]);
        if (focusMode != NULL) {
            setFocusMode(focusMode);
        } else {
            setFocusMode(FOCUS_MODE_FIXED);
        }
    } else {
        ALOGE("%s: supported focus modes cnt is 0!!!", __func__);
    }

    // Set focus areas
    if (m_pCapability->max_num_focus_areas > MAX_ROI) {
        m_pCapability->max_num_focus_areas = MAX_ROI;
    }
    set(KEY_MAX_NUM_FOCUS_AREAS, m_pCapability->max_num_focus_areas);
    if (m_pCapability->max_num_focus_areas > 0) {
        setFocusAreas(DEFAULT_CAMERA_AREA);
    }

    // Set metering areas
    if (m_pCapability->max_num_metering_areas > MAX_ROI) {
        m_pCapability->max_num_metering_areas = MAX_ROI;
    }
    set(KEY_MAX_NUM_METERING_AREAS, m_pCapability->max_num_metering_areas);
    if (m_pCapability->max_num_metering_areas > 0) {
        setMeteringAreas(DEFAULT_CAMERA_AREA);
    }

    // Set Saturation
    set(KEY_QC_MIN_SATURATION, m_pCapability->saturation_ctrl.min_value);
    set(KEY_QC_MAX_SATURATION, m_pCapability->saturation_ctrl.max_value);
    set(KEY_QC_SATURATION_STEP, m_pCapability->saturation_ctrl.step);
    setSaturation(m_pCapability->saturation_ctrl.def_value);

    // Set Sharpness
    set(KEY_QC_MIN_SHARPNESS, m_pCapability->sharpness_ctrl.min_value);
    set(KEY_QC_MAX_SHARPNESS, m_pCapability->sharpness_ctrl.max_value);
    set(KEY_QC_SHARPNESS_STEP, m_pCapability->sharpness_ctrl.step);
    setSharpness(m_pCapability->sharpness_ctrl.def_value);

    // Set Contrast
    set(KEY_QC_MIN_CONTRAST, m_pCapability->contrast_ctrl.min_value);
    set(KEY_QC_MAX_CONTRAST, m_pCapability->contrast_ctrl.max_value);
    set(KEY_QC_CONTRAST_STEP, m_pCapability->contrast_ctrl.step);
    setContrast(m_pCapability->contrast_ctrl.def_value);

    // Set SCE factor
    set(KEY_QC_MIN_SCE_FACTOR, m_pCapability->sce_ctrl.min_value); // -100
    set(KEY_QC_MAX_SCE_FACTOR, m_pCapability->sce_ctrl.max_value); // 100
    set(KEY_QC_SCE_FACTOR_STEP, m_pCapability->sce_ctrl.step);     // 10
    setSkinToneEnhancement(m_pCapability->sce_ctrl.def_value);     // 0

    // Set Brightness
    set(KEY_QC_MIN_BRIGHTNESS, m_pCapability->brightness_ctrl.min_value); // 0
    set(KEY_QC_MAX_BRIGHTNESS, m_pCapability->brightness_ctrl.max_value); // 6
    set(KEY_QC_BRIGHTNESS_STEP, m_pCapability->brightness_ctrl.step);     // 1
    setBrightness(m_pCapability->brightness_ctrl.def_value);

    // Set Auto exposure
    String8 autoExposureValues = createValuesString(
            (int *)m_pCapability->supported_aec_modes,
            m_pCapability->supported_aec_modes_cnt,
            AUTO_EXPOSURE_MAP,
            sizeof(AUTO_EXPOSURE_MAP) / sizeof(QCameraMap));
    set(KEY_QC_SUPPORTED_AUTO_EXPOSURE, autoExposureValues.string());
    setAutoExposure(AUTO_EXPOSURE_FRAME_AVG);

    // Set Exposure Compensation
    set(KEY_MAX_EXPOSURE_COMPENSATION, m_pCapability->exposure_compensation_max); // 12
    set(KEY_MIN_EXPOSURE_COMPENSATION, m_pCapability->exposure_compensation_min); // -12
    setFloat(KEY_EXPOSURE_COMPENSATION_STEP, m_pCapability->exposure_compensation_step); // 1/6
    setExposureCompensation(m_pCapability->exposure_compensation_default); // 0

    // Set Antibanding
    String8 antibandingValues = createValuesString(
            (int *)m_pCapability->supported_antibandings,
            m_pCapability->supported_antibandings_cnt,
            ANTIBANDING_MODES_MAP,
            sizeof(ANTIBANDING_MODES_MAP) / sizeof(QCameraMap));
    set(KEY_SUPPORTED_ANTIBANDING, antibandingValues);
    setAntibanding(ANTIBANDING_OFF);

    // Set Effect
    String8 effectValues = createValuesString(
            (int *)m_pCapability->supported_effects,
            m_pCapability->supported_effects_cnt,
            EFFECT_MODES_MAP,
            sizeof(EFFECT_MODES_MAP) / sizeof(QCameraMap));
    set(KEY_SUPPORTED_EFFECTS, effectValues);
    setEffect(EFFECT_NONE);

    // Set WhiteBalance
    String8 whitebalanceValues = createValuesString(
            (int *)m_pCapability->supported_white_balances,
            m_pCapability->supported_white_balances_cnt,
            WHITE_BALANCE_MODES_MAP,
            sizeof(WHITE_BALANCE_MODES_MAP) / sizeof(QCameraMap));
    set(KEY_SUPPORTED_WHITE_BALANCE, whitebalanceValues);
    setWhiteBalance(WHITE_BALANCE_AUTO);

    // Set Flash mode
    if(m_pCapability->supported_flash_modes_cnt > 0) {
       String8 flashValues = createValuesString(
               (int *)m_pCapability->supported_flash_modes,
               m_pCapability->supported_flash_modes_cnt,
               FLASH_MODES_MAP,
               sizeof(FLASH_MODES_MAP) / sizeof(QCameraMap));
       set(KEY_SUPPORTED_FLASH_MODES, flashValues);
       setFlash(FLASH_MODE_OFF);
    } else {
        ALOGE("%s: supported flash modes cnt is 0!!!", __func__);
    }

    // Set Scene Mode
    String8 sceneModeValues = createValuesString(
            (int *)m_pCapability->supported_scene_modes,
            m_pCapability->supported_scene_modes_cnt,
            SCENE_MODES_MAP,
            sizeof(SCENE_MODES_MAP) / sizeof(QCameraMap));
    set(KEY_SUPPORTED_SCENE_MODES, sceneModeValues);
    setSceneMode(SCENE_MODE_AUTO);

    // Set ISO Mode
    String8 isoValues = createValuesString(
            (int *)m_pCapability->supported_iso_modes,
            m_pCapability->supported_iso_modes_cnt,
            ISO_MODES_MAP,
            sizeof(ISO_MODES_MAP) / sizeof(QCameraMap));
    set(KEY_QC_SUPPORTED_ISO_MODES, isoValues);
    setISOValue(ISO_AUTO);

    // Set HFR
    String8 hfrValues = createHfrValuesString(
            m_pCapability->hfr_tbl,
            m_pCapability->hfr_tbl_cnt,
            HFR_MODES_MAP,
            sizeof(HFR_MODES_MAP) / sizeof(QCameraMap));
    set(KEY_QC_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES, hfrValues.string());
    set(KEY_QC_VIDEO_HIGH_SPEED_RECORDING, "off");
    String8 hfrSizeValues = createHfrSizesString(
            m_pCapability->hfr_tbl,
            m_pCapability->hfr_tbl_cnt);
    set(KEY_QC_SUPPORTED_HFR_SIZES, hfrSizeValues.string());
    setHighFrameRate(VIDEO_HFR_OFF);

    // Set Focus algorithms
    String8 focusAlgoValues = createValuesString(
            (int *)m_pCapability->supported_focus_algos,
            m_pCapability->supported_focus_algos_cnt,
            FOCUS_ALGO_MAP,
            sizeof(FOCUS_ALGO_MAP) / sizeof(QCameraMap));
    set(KEY_QC_SUPPORTED_FOCUS_ALGOS, focusAlgoValues);
    setSelectableZoneAf(FOCUS_ALGO_AUTO);

    // Set Zoom Ratios
    if (m_pCapability->zoom_supported > 0) {
        String8 zoomRatioValues = createZoomRatioValuesString(
                m_pCapability->zoom_ratio_tbl,
                m_pCapability->zoom_ratio_tbl_cnt);
        set(KEY_ZOOM_RATIOS, zoomRatioValues);
        set(KEY_MAX_ZOOM, m_pCapability->zoom_ratio_tbl_cnt - 1);
        setZoom(0);
    }

    // Set Bracketing/HDR
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    property_get("persist.capture.burst.exposures", prop, "");
    if (strlen(prop) > 0) {
        set(KEY_QC_CAPTURE_BURST_EXPOSURE, prop);
    }
    String8 bracketingValues = createValuesStringFromMap(
            BRACKETING_MODES_MAP,
            sizeof(BRACKETING_MODES_MAP) / sizeof(QCameraMap));
    set(KEY_QC_SUPPORTED_AE_BRACKET_MODES, bracketingValues);
    setAEBracket(AE_BRACKET_OFF);

    //Set AF Bracketing.
    for(int i = 0; i < m_pCapability->supported_focus_modes_cnt; i++) {
        if ((CAM_FOCUS_MODE_AUTO == m_pCapability->supported_focus_modes[i]) &&
                ((m_pCapability->qcom_supported_feature_mask &
                        CAM_QCOM_FEATURE_UBIFOCUS) > 0)) {
            String8 afBracketingValues = createValuesStringFromMap(
                    AF_BRACKETING_MODES_MAP,
                    sizeof(AF_BRACKETING_MODES_MAP) / sizeof(QCameraMap));
            set(KEY_QC_SUPPORTED_AF_BRACKET_MODES, afBracketingValues);
            setAFBracket(AF_BRACKET_OFF);
            break;
         }
    }

    //Set Refocus.
    //Re-use ubifocus flag for now.
    if ((m_pCapability->qcom_supported_feature_mask &
        CAM_QCOM_FEATURE_UBIFOCUS) > 0){
            String8 reFocusValues = createValuesStringFromMap(
                RE_FOCUS_MODES_MAP,
                sizeof(RE_FOCUS_MODES_MAP) / sizeof(QCameraMap));
            set(KEY_QC_SUPPORTED_RE_FOCUS_MODES, reFocusValues);
    }

    //Set Chroma Flash.
    if ((m_pCapability->supported_flash_modes_cnt > 0) &&
            (m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_CHROMA_FLASH) > 0) {
        String8 chromaFlashValues = createValuesStringFromMap(
                CHROMA_FLASH_MODES_MAP,
                sizeof(CHROMA_FLASH_MODES_MAP) / sizeof(QCameraMap));
        set(KEY_QC_SUPPORTED_CHROMA_FLASH_MODES, chromaFlashValues);
        setChromaFlash(CHROMA_FLASH_OFF);
    }

    //Set Opti Zoom.
    if (m_pCapability->zoom_supported &&
            (m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_OPTIZOOM) > 0){
        String8 optiZoomValues = createValuesStringFromMap(
                OPTI_ZOOM_MODES_MAP,
                sizeof(OPTI_ZOOM_MODES_MAP) / sizeof(QCameraMap));
        set(KEY_QC_SUPPORTED_OPTI_ZOOM_MODES, optiZoomValues);
        setOptiZoom(OPTI_ZOOM_OFF);
    }

    // Set Denoise
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_DENOISE2D) > 0){
    String8 denoiseValues = createValuesStringFromMap(
       DENOISE_ON_OFF_MODES_MAP, sizeof(DENOISE_ON_OFF_MODES_MAP) / sizeof(QCameraMap));
    set(KEY_QC_SUPPORTED_DENOISE, denoiseValues.string());
#ifdef DEFAULT_DENOISE_MODE_ON
    setWaveletDenoise(DENOISE_ON);
#else
    setWaveletDenoise(DENOISE_OFF);
#endif
    }

    // Set feature enable/disable
    String8 enableDisableValues = createValuesStringFromMap(
        ENABLE_DISABLE_MODES_MAP, sizeof(ENABLE_DISABLE_MODES_MAP) / sizeof(QCameraMap));

    // Set Lens Shading
    set(KEY_QC_SUPPORTED_LENSSHADE_MODES, enableDisableValues);
    setLensShadeValue(VALUE_ENABLE);

    // Set MCE
    set(KEY_QC_SUPPORTED_MEM_COLOR_ENHANCE_MODES, enableDisableValues);
    setMCEValue(VALUE_ENABLE);

    // Set DIS
    set(KEY_QC_SUPPORTED_DIS_MODES, enableDisableValues);
    setDISValue(VALUE_DISABLE);

    // Set Histogram
    set(KEY_QC_SUPPORTED_HISTOGRAM_MODES,
        m_pCapability->histogram_supported ? enableDisableValues : "");
    set(KEY_QC_HISTOGRAM, VALUE_DISABLE);

    //Set Red Eye Reduction
    set(KEY_QC_SUPPORTED_REDEYE_REDUCTION, enableDisableValues);
    setRedeyeReduction(VALUE_DISABLE);

    //Set SkinTone Enhancement
    set(KEY_QC_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES, enableDisableValues);

    // Set feature on/off
    String8 onOffValues = createValuesStringFromMap(
        ON_OFF_MODES_MAP, sizeof(ON_OFF_MODES_MAP) / sizeof(QCameraMap));

    //Set Scene Detection
    set(KEY_QC_SUPPORTED_SCENE_DETECT, onOffValues);
    setSceneDetect(VALUE_OFF);
    m_bHDREnabled = false;
    m_bHDR1xFrameEnabled = true;

    m_bHDRThumbnailProcessNeeded = false;
    m_bHDR1xExtraBufferNeeded = true;
    for (uint32_t i=0; i<m_pCapability->hdr_bracketing_setting.num_frames; i++) {
        if (0 == m_pCapability->hdr_bracketing_setting.exp_val.values[i]) {
            m_bHDR1xExtraBufferNeeded = false;
            break;
        }
    }

    // Set HDR output scaling
    char value[PROPERTY_VALUE_MAX];

    property_get("persist.camera.hdr.outcrop", value, VALUE_DISABLE);
    if (strncmp(VALUE_ENABLE, value, sizeof(VALUE_ENABLE))) {
      m_bHDROutputCropEnabled = false;
    } else {
      m_bHDROutputCropEnabled = true;
    }

    //Set Face Detection
    set(KEY_QC_SUPPORTED_FACE_DETECTION, onOffValues);
    set(KEY_QC_FACE_DETECTION, VALUE_OFF);

    //Set Face Recognition
    //set(KEY_QC_SUPPORTED_FACE_RECOGNITION, onOffValues);
    //set(KEY_QC_FACE_RECOGNITION, VALUE_OFF);

    //Set ZSL
    set(KEY_QC_SUPPORTED_ZSL_MODES, onOffValues);
#ifdef DEFAULT_ZSL_MODE_ON
    set(KEY_QC_ZSL, VALUE_ON);
    m_bZslMode = true;
#else
    set(KEY_QC_ZSL, VALUE_OFF);
    m_bZslMode = false;
#endif
    m_bZslMode_new = m_bZslMode;

    set(KEY_QC_SCENE_SELECTION, VALUE_DISABLE);

    // Rdi mode
    set(KEY_QC_SUPPORTED_RDI_MODES, enableDisableValues);
    setRdiMode(VALUE_DISABLE);

    // Secure mode
    set(KEY_QC_SUPPORTED_SECURE_MODES, enableDisableValues);
    setSecureMode(VALUE_DISABLE);

    //Set video HDR
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_VIDEO_HDR) > 0) {
        set(KEY_QC_SUPPORTED_VIDEO_HDR_MODES, onOffValues);
        set(KEY_QC_VIDEO_HDR, VALUE_OFF);
    }

    //Set HW Sensor Snapshot HDR
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_SENSOR_HDR)> 0) {
        set(KEY_QC_SUPPORTED_SENSOR_HDR_MODES, onOffValues);
        set(KEY_QC_SENSOR_HDR, VALUE_OFF);
        m_bSensorHDREnabled = false;
    }

    // Set VT TimeStamp
    set(KEY_QC_VT_ENABLE, VALUE_DISABLE);
    //Set Touch AF/AEC
    String8 touchValues = createValuesStringFromMap(
       TOUCH_AF_AEC_MODES_MAP, sizeof(TOUCH_AF_AEC_MODES_MAP) / sizeof(QCameraMap));

    set(KEY_QC_SUPPORTED_TOUCH_AF_AEC, touchValues);
    set(KEY_QC_TOUCH_AF_AEC, TOUCH_AF_AEC_OFF);

    //set flip mode
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_FLIP) > 0) {
        String8 flipModes = createValuesStringFromMap(
           FLIP_MODES_MAP, sizeof(FLIP_MODES_MAP) / sizeof(QCameraMap));
        set(KEY_QC_SUPPORTED_FLIP_MODES, flipModes);
        set(KEY_QC_PREVIEW_FLIP, FLIP_MODE_OFF);
        set(KEY_QC_VIDEO_FLIP, FLIP_MODE_OFF);
        set(KEY_QC_SNAPSHOT_PICTURE_FLIP, FLIP_MODE_OFF);
    }

    // Set default Auto Exposure lock value
    setAecLock(VALUE_FALSE);

    // Set default AWB_LOCK lock value
    setAwbLock(VALUE_FALSE);

    // Set default Camera mode
    set(KEY_QC_CAMERA_MODE, 0);

    // Add support for internal preview restart
    set(KEY_INTERNAL_PERVIEW_RESTART, VALUE_TRUE);
    // Set default burst number
    set(KEY_QC_SNAPSHOT_BURST_NUM, 0);
    set(KEY_QC_NUM_RETRO_BURST_PER_SHUTTER, 0);

    int32_t rc = commitParameters();
    if (rc == NO_ERROR) {
        rc = setNumOfSnapshot();
    }
    return rc;
!!!44171063.cpp!!!	updateParameters(inout params : QCameraParameters, inout needRestart : bool) : int32_t
    int32_t final_rc = NO_ERROR;
    int32_t rc;
    m_bNeedRestart = false;

    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table",__func__);
        rc = BAD_TYPE;
        goto UPDATE_PARAM_DONE;
    }

    if ((rc = setPreviewSize(params)))                  final_rc = rc;
    if ((rc = setVideoSize(params)))                    final_rc = rc;
    if ((rc = setPictureSize(params)))                  final_rc = rc;
    if ((rc = setPreviewFormat(params)))                final_rc = rc;
    if ((rc = setPictureFormat(params)))                final_rc = rc;
    if ((rc = setJpegQuality(params)))                  final_rc = rc;
    if ((rc = setOrientation(params)))                  final_rc = rc;
    if ((rc = setRotation(params)))                     final_rc = rc;
    if ((rc = setVideoRotation(params)))                final_rc = rc;
    if ((rc = setNoDisplayMode(params)))                final_rc = rc;
    if ((rc = setZslMode(params)))                      final_rc = rc;
    if ((rc = setZslAttributes(params)))                final_rc = rc;
    if ((rc = setCameraMode(params)))                   final_rc = rc;
    if ((rc = setSceneSelectionMode(params)))           final_rc = rc;
    if ((rc = setRecordingHint(params)))                final_rc = rc;
    if ((rc = setRdiMode(params)))                      final_rc = rc;
    if ((rc = setSecureMode(params)))                   final_rc = rc;
    if ((rc = setPreviewFrameRate(params)))             final_rc = rc;
    if ((rc = setPreviewFpsRange(params)))              final_rc = rc;
    if ((rc = setAutoExposure(params)))                 final_rc = rc;
    if ((rc = setEffect(params)))                       final_rc = rc;
    if ((rc = setBrightness(params)))                   final_rc = rc;
    if ((rc = setZoom(params)))                         final_rc = rc;
    if ((rc = setSharpness(params)))                    final_rc = rc;
    if ((rc = setSaturation(params)))                   final_rc = rc;
    if ((rc = setContrast(params)))                     final_rc = rc;
    if ((rc = setFocusMode(params)))                    final_rc = rc;
    if ((rc = setISOValue(params)))                     final_rc = rc;
    if ((rc = setSkinToneEnhancement(params)))          final_rc = rc;
    if ((rc = setFlash(params)))                        final_rc = rc;
    if ((rc = setAecLock(params)))                      final_rc = rc;
    if ((rc = setAwbLock(params)))                      final_rc = rc;
    if ((rc = setLensShadeValue(params)))               final_rc = rc;
    if ((rc = setMCEValue(params)))                     final_rc = rc;
    if ((rc = setDISValue(params)))                     final_rc = rc;
    if ((rc = setHighFrameRate(params)))                final_rc = rc;
    if ((rc = setHighSpeedRecording(params)))           final_rc = rc;
    if ((rc = setAntibanding(params)))                  final_rc = rc;
    if ((rc = setExposureCompensation(params)))         final_rc = rc;
    if ((rc = setWhiteBalance(params)))                 final_rc = rc;
    if ((rc = setSceneMode(params)))                    final_rc = rc;
    if ((rc = setFocusAreas(params)))                   final_rc = rc;
    if ((rc = setMeteringAreas(params)))                final_rc = rc;
    if ((rc = setSelectableZoneAf(params)))             final_rc = rc;
    if ((rc = setRedeyeReduction(params)))              final_rc = rc;
    if ((rc = setAEBracket(params)))                    final_rc = rc;
    if ((rc = setAutoHDR(params)))                      final_rc = rc;
    if ((rc = setGpsLocation(params)))                  final_rc = rc;
    if ((rc = setWaveletDenoise(params)))               final_rc = rc;
    if ((rc = setFaceRecognition(params)))              final_rc = rc;
    if ((rc = setFlip(params)))                         final_rc = rc;
    if ((rc = setVideoHDR(params)))                     final_rc = rc;
    if ((rc = setVtEnable(params)))                     final_rc = rc;
    if ((rc = setAFBracket(params)))                    final_rc = rc;
    if ((rc = setChromaFlash(params)))                  final_rc = rc;
    if ((rc = setOptiZoom(params)))                     final_rc = rc;
    if ((rc = setBurstNum(params)))                     final_rc = rc;
    if ((rc = setBurstLEDOnPeriod(params)))             final_rc = rc;
    if ((rc = setRetroActiveBurstNum(params)))          final_rc = rc;
    if ((rc = setSnapshotFDReq(params)))                final_rc = rc;
    if ((rc = setTintlessValue(params)))                final_rc = rc;
    if ((rc = setCDSMode(params)))                      final_rc = rc;

    // update live snapshot size after all other parameters are set
    if ((rc = setLiveSnapshotSize(params)))             final_rc = rc;
    if ((rc = setJpegThumbnailSize(params)))            final_rc = rc;
    if ((rc = setStatsDebugMask()))                     final_rc = rc;
    if ((rc = setPAAF()))                               final_rc = rc;
    if ((rc = setMobicat(params)))                      final_rc = rc;

    if ((rc = updateFlash(false)))                      final_rc = rc;

UPDATE_PARAM_DONE:
    needRestart = m_bNeedRestart;
    return final_rc;
!!!44171191.cpp!!!	commitParameters() : int32_t
    return commitSetBatch();
!!!44171319.cpp!!!	getPreviewHalPixelFormat() : int
    int32_t halPixelFormat;

    switch (mPreviewFormat) {
    case CAM_FORMAT_YUV_420_NV12:
        halPixelFormat = HAL_PIXEL_FORMAT_YCbCr_420_SP;
        break;
    case CAM_FORMAT_YUV_420_NV21:
        halPixelFormat = HAL_PIXEL_FORMAT_YCrCb_420_SP;
        break;
    case CAM_FORMAT_YUV_420_NV21_ADRENO:
        halPixelFormat = HAL_PIXEL_FORMAT_YCrCb_420_SP_ADRENO;
        break;
    case CAM_FORMAT_YUV_420_YV12:
        halPixelFormat = HAL_PIXEL_FORMAT_YV12;
        break;
    case CAM_FORMAT_YUV_420_NV12_VENUS:
        halPixelFormat = HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS;
        break;
    case CAM_FORMAT_YUV_422_NV16:
    case CAM_FORMAT_YUV_422_NV61:
    default:
        halPixelFormat = HAL_PIXEL_FORMAT_YCrCb_420_SP;
        break;
    }
    CDBG_HIGH("%s: format %d\n", __func__, halPixelFormat);
    return halPixelFormat;
!!!44171447.cpp!!!	getStreamRotation(in streamType : cam_stream_type_t, inout featureConfig : cam_pp_feature_config_t, inout dim : cam_dimension_t) : int32_t
    int32_t ret = NO_ERROR;
    int rotationParam = getInt(KEY_QC_VIDEO_ROTATION);
    featureConfig.rotation = ROTATE_0;
    int swapDim = 0;
    switch (streamType) {
    case CAM_STREAM_TYPE_VIDEO:
           switch(rotationParam) {
            case 90:
               featureConfig.feature_mask |= CAM_QCOM_FEATURE_ROTATION;
               featureConfig.rotation = ROTATE_90;
               swapDim = 1;
               break;
            case 180:
               featureConfig.feature_mask |= CAM_QCOM_FEATURE_ROTATION;
               featureConfig.rotation = ROTATE_180;
               break;
            case 270:
               featureConfig.feature_mask |= CAM_QCOM_FEATURE_ROTATION;
               featureConfig.rotation = ROTATE_270;
               swapDim = 1;
              break;
            default:
               featureConfig.rotation = ROTATE_0;
        }
        break;
    case CAM_STREAM_TYPE_PREVIEW:
    case CAM_STREAM_TYPE_POSTVIEW:
    case CAM_STREAM_TYPE_SNAPSHOT:
    case CAM_STREAM_TYPE_RAW:
    case CAM_STREAM_TYPE_METADATA:
    case CAM_STREAM_TYPE_OFFLINE_PROC:
    case CAM_STREAM_TYPE_DEFAULT:
    default:
        break;
    }

    if (swapDim > 0) {
        int w = 0;
        w = dim.width;
        dim.width = dim.height;
        dim.height = w;
    }
    return ret;
!!!44171575.cpp!!!	getStreamFormat(in streamType : cam_stream_type_t, inout format : cam_format_t) : int32_t
    int32_t ret = NO_ERROR;

    format = CAM_FORMAT_MAX;
    switch (streamType) {
    case CAM_STREAM_TYPE_PREVIEW:
    case CAM_STREAM_TYPE_POSTVIEW:
        format = mPreviewFormat;
        break;
    case CAM_STREAM_TYPE_SNAPSHOT:
        if ( mPictureFormat == CAM_FORMAT_YUV_422_NV16 ) {
            format = CAM_FORMAT_YUV_422_NV16;
        } else {
            char prop[PROPERTY_VALUE_MAX];
            int snapshotFormat;
            memset(prop, 0, sizeof(prop));
            property_get("persist.camera.snap.format", prop, "0");
            snapshotFormat = atoi(prop);
            if(snapshotFormat == 1) {
                format = CAM_FORMAT_YUV_422_NV61;
            } else {
                format = CAM_FORMAT_YUV_420_NV21;
            }
        }
        break;
    case CAM_STREAM_TYPE_VIDEO:
        format = CAM_FORMAT_YUV_420_NV12;
        break;
    case CAM_STREAM_TYPE_RAW:
        if (isRdiMode()) {
            format = m_pCapability->rdi_mode_stream_fmt;
        } else if (mPictureFormat >= CAM_FORMAT_YUV_RAW_8BIT_YUYV) {
            format = (cam_format_t)mPictureFormat;
        } else {
            char raw_format[PROPERTY_VALUE_MAX];
            int rawFormat;
            memset(raw_format, 0, sizeof(raw_format));
            /*Default value is CAM_FORMAT_BAYER_QCOM_RAW_10BPP_GBRG*/
            property_get("persist.camera.raw.format", raw_format, "16");
            rawFormat = atoi(raw_format);
            format = (cam_format_t)rawFormat;
            CDBG_HIGH("%s: Raw stream format %d bundled with snapshot",
                   __func__, format);
        }
        break;
    case CAM_STREAM_TYPE_METADATA:
    case CAM_STREAM_TYPE_OFFLINE_PROC:
    case CAM_STREAM_TYPE_DEFAULT:
    default:
        break;
    }

    return ret;
!!!44171703.cpp!!!	getStreamDimension(in streamType : cam_stream_type_t, inout dim : cam_dimension_t) : int32_t
    int32_t ret = NO_ERROR;
    memset(&dim, 0, sizeof(cam_dimension_t));

    switch (streamType) {
    case CAM_STREAM_TYPE_PREVIEW:
        getPreviewSize(&dim.width, &dim.height);
        break;
    case CAM_STREAM_TYPE_POSTVIEW:
        getPreviewSize(&dim.width, &dim.height);
        break;
    case CAM_STREAM_TYPE_SNAPSHOT:
        if (getRecordingHintValue() == true) {
            // live snapshot
            getLiveSnapshotSize(dim);
        } else {
            getPictureSize(&dim.width, &dim.height);
        }
        break;
    case CAM_STREAM_TYPE_VIDEO:
        getVideoSize(&dim.width, &dim.height);
        break;
    case CAM_STREAM_TYPE_RAW:
        //dim = m_pCapability->raw_dim;
        getRawSize(dim);
        break;
    case CAM_STREAM_TYPE_METADATA:
        dim.width = sizeof(metadata_buffer_t);
        dim.height = 1;
        break;
    case CAM_STREAM_TYPE_OFFLINE_PROC:
        break;
    case CAM_STREAM_TYPE_DEFAULT:
    default:
        ALOGE("%s: no dimension for unsupported stream type %d",
              __func__, streamType);
        ret = BAD_VALUE;
        break;
    }
    return ret;
!!!44171831.cpp!!!	getThumbnailSize(inout width : int, inout height : int) : void
    *width = getInt(KEY_JPEG_THUMBNAIL_WIDTH);
    *height = getInt(KEY_JPEG_THUMBNAIL_HEIGHT);
!!!44171959.cpp!!!	getZSLBurstInterval() : uint8_t
    int interval = getInt(KEY_QC_ZSL_BURST_INTERVAL);
    if (interval < 0) {
        interval = 1;
    }
    return interval;
!!!44172087.cpp!!!	getZSLQueueDepth() : uint8_t
    int qdepth = getInt(KEY_QC_ZSL_QUEUE_DEPTH);
    if (qdepth < 0) {
        qdepth = 2;
    }
    return qdepth;
!!!44172215.cpp!!!	getZSLBackLookCount() : uint8_t
    int look_back = getInt(KEY_QC_ZSL_BURST_LOOKBACK);
    if (look_back < 0) {
        look_back = 2;
    }
    return look_back;
!!!44172343.cpp!!!	getMaxUnmatchedFramesInQueue() : uint8_t
    return m_pCapability->min_num_pp_bufs + (m_nBurstNum / 10);
!!!44173623.cpp!!!	getNumOfSnapshots() : uint8_t
    int numOfSnapshot = getInt(KEY_QC_NUM_SNAPSHOT_PER_SHUTTER);
    if (numOfSnapshot <= 0) {
        numOfSnapshot = 1; // set to default value
    }

    /* update the count for refocus */
    if (isUbiRefocus())
       numOfSnapshot += UfOutputCount();

    return (uint8_t)numOfSnapshot;
!!!44173751.cpp!!!	getNumOfRetroSnapshots() : uint8_t
    int numOfRetroSnapshots = getInt(KEY_QC_NUM_RETRO_BURST_PER_SHUTTER);
    if (numOfRetroSnapshots < 0) {
        numOfRetroSnapshots = 0;
    }
    CDBG_HIGH("%s: [ZSL Retro] : numOfRetroSnaps - %d", __func__, numOfRetroSnapshots);
    return (uint8_t)numOfRetroSnapshots;
!!!44173879.cpp!!!	getNumOfExtraHDRInBufsIfNeeded() : uint8_t
    uint8_t numOfBufs = 0;

    if (isHDREnabled()) {
        numOfBufs += m_pCapability->hdr_bracketing_setting.num_frames;
        if (isHDR1xFrameEnabled() && isHDR1xExtraBufferNeeded()) {
            numOfBufs++;
        }
        numOfBufs--; // Only additional buffers need to be returned
    }

    return numOfBufs * getBurstNum();
!!!44174007.cpp!!!	getNumOfExtraHDROutBufsIfNeeded() : uint8_t
    uint8_t numOfBufs = 0;

    if (isHDREnabled() && isHDR1xFrameEnabled()) {
        numOfBufs++;
    }

    return numOfBufs * getBurstNum();
!!!44174135.cpp!!!	getBurstNum() : uint8_t
    CDBG_HIGH("%s: m_nBurstNum = %d", __func__, m_nBurstNum);
    return m_nBurstNum;
!!!44174263.cpp!!!	getBurstLEDOnPeriod() : int
  CDBG_HIGH("%s: [ZSL Retro] burst LED ON period: %d", __func__, m_nBurstLEDOnPeriod);
  return m_nBurstLEDOnPeriod;
!!!44174647.cpp!!!	setRecordingHintValue(in value : int32_t) : int
    CDBG_HIGH("%s: VideoHint = %d", __func__, value);
    bool newValue = (value > 0)? true : false;

    if ( m_bRecordingHint != newValue ) {
        m_bNeedRestart = true;
        m_bRecordingHint_new = newValue;
    } else {
        m_bRecordingHint_new = m_bRecordingHint;
    }
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_RECORDING_HINT,
                                  sizeof(value),
                                  &value);
!!!44174775.cpp!!!	getJpegQuality() : uint32_t
    int quality = getInt(KEY_JPEG_QUALITY);
    if (quality < 0) {
        quality = 85; // set to default quality value
    }
    return quality;
!!!44174903.cpp!!!	getRotation() : uint32_t
    int rotation = 0;

    //If exif rotation is set, do not rotate captured image
    if (!useJpegExifRotation()) {
        rotation = mRotation;
        if (rotation < 0) {
            rotation = 0;
        }
    }
    return (uint32_t)rotation;
!!!44175031.cpp!!!	getDeviceRotation() : uint32_t
    int rotation = 0;

    rotation = mRotation;
    if (rotation < 0) {
        rotation = 0;
    }

    return (uint32_t)rotation;
!!!44175159.cpp!!!	getJpegExifRotation() : uint32_t
    int rotation = 0;

    if (useJpegExifRotation()) {
        rotation = mRotation;
        if (rotation < 0) {
            rotation = 0;
        }
    }
    return (uint32_t)rotation;
!!!44175287.cpp!!!	useJpegExifRotation() : bool
    char exifRotation[PROPERTY_VALUE_MAX];

    property_get("persist.camera.exif.rotation", exifRotation, "off");
    if (!strcmp(exifRotation, "on")) {
        return true;
    }
    return false;
!!!44175415.cpp!!!	getEffectValue() : int32_t
    uint32_t cnt = 0;
    const char *effect = get(KEY_EFFECT);
    if (effect) {
        while (NULL != EFFECT_MODES_MAP[cnt].desc) {
            if (!strcmp(EFFECT_MODES_MAP[cnt].desc, effect)) {
                return EFFECT_MODES_MAP[cnt].val;
            }
            cnt++;
        }
    } else {
        ALOGE("%s: Missing effect value", __func__);
    }
    return CAM_EFFECT_MODE_OFF;
!!!44175543.cpp!!!	getExifDateTime(inout dateTime : String8, inout subsecTime : String8) : int32_t
    int32_t ret = NO_ERROR;

    //get time and date from system
    struct timeval tv;
    struct tm timeinfo_data;

    int res = gettimeofday(&tv, NULL);
    if (0 == res) {
        struct tm *timeinfo = localtime_r(&tv.tv_sec, &timeinfo_data);
        if (NULL != timeinfo) {
            //Write datetime according to EXIF Spec
            //"YYYY:MM:DD HH:MM:SS" (20 chars including \0)
            dateTime = String8::format("%04d:%02d:%02d %02d:%02d:%02d",
                    timeinfo->tm_year + 1900, timeinfo->tm_mon + 1,
                    timeinfo->tm_mday, timeinfo->tm_hour,
                    timeinfo->tm_min, timeinfo->tm_sec);
            //Write subsec according to EXIF Sepc
            subsecTime = String8::format("%06ld", tv.tv_usec);
        } else {
            ALOGE("%s: localtime_r() error", __func__);
            ret = UNKNOWN_ERROR;
        }
    } else if (-1 == res) {
        ALOGE("%s: gettimeofday() error: %s", __func__, strerror(errno));
        ret = UNKNOWN_ERROR;
    } else {
        ALOGE("%s: gettimeofday() unexpected return code: %d", __func__, res);
        ret = UNKNOWN_ERROR;
    }

    return ret;
!!!44175671.cpp!!!	getExifFocalLength(inout focalLength : rat_t) : int32_t
    int focalLengthValue =
        (int)(getFloat(QCameraParameters::KEY_FOCAL_LENGTH) * FOCAL_LENGTH_DECIMAL_PRECISION);
    return getRational(focalLength, focalLengthValue, FOCAL_LENGTH_DECIMAL_PRECISION);
!!!44175799.cpp!!!	getExifIsoSpeed() : uint16_t
    uint16_t isoSpeed = 0;
    const char *iso_str = get(QCameraParameters::KEY_QC_ISO_MODE);
    int iso_index = lookupAttr(ISO_MODES_MAP,
        sizeof(ISO_MODES_MAP)/sizeof(ISO_MODES_MAP[0]), iso_str);
    switch (iso_index) {
    case CAM_ISO_MODE_AUTO:
        isoSpeed = 0;
        break;
    case CAM_ISO_MODE_DEBLUR:
        isoSpeed = 1;
        break;
    case CAM_ISO_MODE_100:
        isoSpeed = 100;
        break;
    case CAM_ISO_MODE_200:
        isoSpeed = 200;
        break;
    case CAM_ISO_MODE_400:
        isoSpeed = 400;
        break;
    case CAM_ISO_MODE_800:
        isoSpeed = 800;
        break;
    case CAM_ISO_MODE_1600:
        isoSpeed = 1600;
        break;
    }
    return isoSpeed;
!!!44175927.cpp!!!	getExifGpsProcessingMethod(inout gpsProcessingMethod : char, inout count : uint32_t) : int32_t
    const char *str = get(KEY_GPS_PROCESSING_METHOD);
    if(str != NULL) {
        memcpy(gpsProcessingMethod, ExifAsciiPrefix, EXIF_ASCII_PREFIX_SIZE);
        count = EXIF_ASCII_PREFIX_SIZE;
        strncpy(gpsProcessingMethod + EXIF_ASCII_PREFIX_SIZE, str, strlen(str));
        count += strlen(str);
        gpsProcessingMethod[count++] = '\0'; // increase 1 for the last NULL char
        return NO_ERROR;
    } else {
        return BAD_VALUE;
    }
!!!44176055.cpp!!!	getExifLatitude(inout latitude : rat_t, inout latRef : char) : int32_t
    const char *str = get(KEY_GPS_LATITUDE);
    if(str != NULL) {
        parseGPSCoordinate(str, latitude);

        //set Latitude Ref
        float latitudeValue = getFloat(KEY_GPS_LATITUDE);
        if(latitudeValue < 0.0f) {
            latRef[0] = 'S';
        } else {
            latRef[0] = 'N';
        }
        latRef[1] = '\0';
        return NO_ERROR;
    }else{
        return BAD_VALUE;
    }
!!!44176183.cpp!!!	getExifLongitude(inout longitude : rat_t, inout lonRef : char) : int32_t
    const char *str = get(KEY_GPS_LONGITUDE);
    if(str != NULL) {
        parseGPSCoordinate(str, longitude);

        //set Longitude Ref
        float longitudeValue = getFloat(KEY_GPS_LONGITUDE);
        if(longitudeValue < 0.0f) {
            lonRef[0] = 'W';
        } else {
            lonRef[0] = 'E';
        }
        lonRef[1] = '\0';
        return NO_ERROR;
    }else{
        return BAD_VALUE;
    }
!!!44176311.cpp!!!	getExifAltitude(inout altitude : rat_t, inout altRef : char) : int32_t
    const char *str = get(KEY_GPS_ALTITUDE);
    if(str != NULL) {
        double value = atof(str);
        *altRef = 0;
        if(value < 0){
            *altRef = 1;
            value = -value;
        }
        return getRational(altitude, value*1000, 1000);
    }else{
        return BAD_VALUE;
    }
!!!44176439.cpp!!!	getExifGpsDateTimeStamp(inout gpsDateStamp : char, in bufLen : uint32_t, inout gpsTimeStamp : rat_t) : int32_t
    const char *str = get(KEY_GPS_TIMESTAMP);
    if(str != NULL) {
        time_t unixTime = (time_t)atol(str);
        struct tm *UTCTimestamp = gmtime(&unixTime);

        strftime(gpsDateStamp, bufLen, "%Y:%m:%d", UTCTimestamp);

        getRational(&gpsTimeStamp[0], UTCTimestamp->tm_hour, 1);
        getRational(&gpsTimeStamp[1], UTCTimestamp->tm_min, 1);
        getRational(&gpsTimeStamp[2], UTCTimestamp->tm_sec, 1);

        return NO_ERROR;
    } else {
        return BAD_VALUE;
    }
!!!44176567.cpp!!!	updateFocusDistances(inout focusDistances : cam_focus_distances_info_t) : int32_t
    String8 str;
    char buffer[32] = {0};
    //set all distances to infinity if focus mode is infinity
    if(mFocusMode == CAM_FOCUS_MODE_INFINITY) {
        str.append("Infinity,Infinity,Infinity");
    } else {
        snprintf(buffer, sizeof(buffer), "%f", focusDistances->focus_distance[0]);
        str.append(buffer);
        snprintf(buffer, sizeof(buffer), ",%f", focusDistances->focus_distance[1]);
        str.append(buffer);
        snprintf(buffer, sizeof(buffer), ",%f", focusDistances->focus_distance[2]);
        str.append(buffer);
    }
    CDBG_HIGH("%s: setting KEY_FOCUS_DISTANCES as %s", __FUNCTION__, str.string());
    set(QCameraParameters::KEY_FOCUS_DISTANCES, str.string());
    return NO_ERROR;
!!!44176695.cpp!!!	isAEBracketEnabled() : bool
    const char *str = get(KEY_QC_AE_BRACKET_HDR);
    if (str != NULL) {
        if (strcmp(str, AE_BRACKET_OFF) != 0) {
            return true;
        }
    }
    return false;
!!!44176823.cpp!!!	setAEBracketing() : int32_t
    int32_t rc = NO_ERROR;
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    rc = AddSetParmEntryToBatch(m_pParamBuf,
            CAM_INTF_PARM_HDR,
            sizeof(m_AEBracketingClient),
            &m_AEBracketingClient);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update AE bracketing", __func__);
        return rc;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to configure AE bracketing", __func__);
        return rc;
    }

    return rc;
!!!44177335.cpp!!!	setSelectedScene(in scene : cam_scene_mode_type) : int32_t
    Mutex::Autolock l(m_SceneSelectLock);
    m_SelectedScene = scene;
    return NO_ERROR;
!!!44177463.cpp!!!	getSelectedScene() : cam_scene_mode_type
    Mutex::Autolock l(m_SceneSelectLock);
    return m_SelectedScene;
!!!44177847.cpp!!!	setFaceDetectionOption(in enabled : bool) : int32_t
    m_bFaceDetectionOn = enabled;
    return NO_ERROR;
!!!44177975.cpp!!!	setHistogram(in enabled : bool) : int32_t
    if(m_bHistogramEnabled == enabled) {
        CDBG_HIGH("%s: histogram flag not changed, no ops here", __func__);
        return NO_ERROR;
    }

    // set parm for histogram
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    int32_t value = enabled;
    int32_t rc = NO_ERROR;
    rc = AddSetParmEntryToBatch(m_pParamBuf,
                                CAM_INTF_PARM_HISTOGRAM,
                                sizeof(value),
                                &value);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update table", __func__);
        return rc;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to set histogram", __func__);
        return rc;
    }

    m_bHistogramEnabled = enabled;

    CDBG_HIGH(" Histogram -> %s", m_bHistogramEnabled ? "Enabled" : "Disabled");

    return rc;
!!!44178103.cpp!!!	setFaceDetection(in enabled : bool, in initCommit : bool) : int32_t
    int faceProcMask = m_nFaceProcMask;
    // set face detection mask
    if (enabled) {
        faceProcMask |= CAM_FACE_PROCESS_MASK_DETECTION;
    } else {
        faceProcMask &= ~CAM_FACE_PROCESS_MASK_DETECTION;
    }

    if(m_nFaceProcMask == faceProcMask) {
        CDBG_HIGH("%s: face process mask not changed, no ops here", __func__);
        return NO_ERROR;
    }

    m_nFaceProcMask = faceProcMask;

    // set parm for face detection
    int requested_faces = getInt(KEY_QC_MAX_NUM_REQUESTED_FACES);
    cam_fd_set_parm_t fd_set_parm;
    memset(&fd_set_parm, 0, sizeof(cam_fd_set_parm_t));
    fd_set_parm.fd_mode = faceProcMask;
    fd_set_parm.num_fd = requested_faces;

    CDBG_HIGH("[KPI Perf] %s: PROFILE_FACE_DETECTION_VALUE = %d num_fd = %d",
          __func__, faceProcMask,requested_faces);

    if (initCommit) {
        if(initBatchUpdate(m_pParamBuf) < 0 ) {
            ALOGE("%s:Failed to initialize group update table", __func__);
            return BAD_TYPE;
        }
    }

    int32_t rc = NO_ERROR;

    rc = AddSetParmEntryToBatch(m_pParamBuf,
                                CAM_INTF_PARM_FD,
                                sizeof(fd_set_parm),
                                &fd_set_parm);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update table", __func__);
        return rc;
    }

    if (initCommit) {
        rc = commitSetBatch();
        if (rc != NO_ERROR) {
            ALOGE("%s:Failed to set face detection parm", __func__);
            return rc;
        }
    }

    CDBG_HIGH("%s: FaceProcMask -> %d", __func__, m_nFaceProcMask);

    return rc;
!!!44178231.cpp!!!	setFrameSkip(in pattern : msm_vfe_frame_skip_pattern) : int32_t
    int32_t rc = NO_ERROR;
    int32_t value = (int32_t)pattern;

    if ( m_pParamBuf == NULL ) {
        return NO_INIT;
    }

    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    rc = AddSetParmEntryToBatch(m_pParamBuf,
                                CAM_INTF_PARM_FRAMESKIP,
                                sizeof(value),
                                &value);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update table", __func__);
        return rc;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to set frameskip info parm", __func__);
        return rc;
    }

    return rc;
!!!44178487.cpp!!!	updateRecordingHintValue(in value : int32_t) : int32_t
    int32_t rc = NO_ERROR;
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    rc = setRecordingHintValue(value);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update table", __func__);
        return rc;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update recording hint", __func__);
        return rc;
    }

    return rc;
!!!44178615.cpp!!!	setHDRAEBracket(in hdrBracket : cam_exp_bracketing_t) : int32_t
    int32_t rc = NO_ERROR;
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    rc = AddSetParmEntryToBatch(m_pParamBuf,
            CAM_INTF_PARM_HDR,
            sizeof(hdrBracket),
            &hdrBracket);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update table", __func__);
        return rc;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to configure HDR bracketing", __func__);
        return rc;
    }

    return rc;
!!!44178743.cpp!!!	isHDREnabled() : bool
    return ((m_nBurstNum == 1) && (m_bHDREnabled || m_HDRSceneEnabled));
!!!44178871.cpp!!!	isAutoHDREnabled() : bool
    const char *str = get(KEY_QC_AUTO_HDR_ENABLE);
    if (str != NULL) {
        int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                                   sizeof(ENABLE_DISABLE_MODES_MAP)/sizeof(QCameraMap),
                                   str);
        if (value == NAME_NOT_FOUND) {
            ALOGE("%s: Invalid Auto HDR value %s", __func__, str);
            return false;
        }

        CDBG_HIGH("%s : Auto HDR status is: %d", __func__, value);
        return value ? true : false;
    }

    CDBG_HIGH("%s : Auto HDR status not set!", __func__);
    return false;
!!!44178999.cpp!!!	stopAEBracket() : int32_t
  cam_exp_bracketing_t bracketing;

  bracketing.mode = CAM_EXP_BRACKETING_OFF;

  return setHDRAEBracket(bracketing);
!!!44179127.cpp!!!	updateFlash(in commitSettings : bool) : int32_t
    int32_t rc = NO_ERROR;
    int32_t value;

    if (commitSettings) {
      if(initBatchUpdate(m_pParamBuf) < 0 ) {
          ALOGE("%s:Failed to initialize group update table", __func__);
          return BAD_TYPE;
      }
    }

    if (isHDREnabled() || m_bAeBracketingEnabled || m_bAFBracketingOn ||
          m_bOptiZoomOn) {
        value = CAM_FLASH_MODE_OFF;
    } else if (m_bChromaFlashOn) {
        value = CAM_FLASH_MODE_ON;
    } else {
        value = mFlashValue;
    }

    if (value != mFlashDaemonValue) {
        CDBG("%s: Setting Flash value %d", __func__, value);
        rc = AddSetParmEntryToBatch(m_pParamBuf,
                                      CAM_INTF_PARM_LED_MODE,
                                      sizeof(value),
                                      &value);
        if (rc != NO_ERROR) {
            rc = BAD_VALUE;
            ALOGE("%s:Failed to set led mode", __func__);
            return rc;
        }

        mFlashDaemonValue = value;
    } else {
        rc = NO_ERROR;
    }

    if (commitSettings) {
      rc = commitSetBatch();
      if (rc != NO_ERROR) {
          ALOGE("%s:Failed to configure HDR bracketing", __func__);
          return rc;
      }
    }

    return rc;
!!!44179255.cpp!!!	updateRAW(in max_dim : cam_dimension_t) : int32_t
    int32_t rc = NO_ERROR;
    cam_dimension_t raw_dim;

    if (max_dim.width == 0 || max_dim.height == 0) {
        max_dim = m_pCapability->raw_dim[0];
    }

    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    rc = AddSetParmEntryToBatch(m_pParamBuf,
                                CAM_INTF_PARM_MAX_DIMENSION,
                                sizeof(cam_dimension_t),
                                &max_dim);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update table for CAM_INTF_PARM_MAX_DIMENSION ", __func__);
        return rc;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to set lock CAM_INTF_PARM_MAX_DIMENSION parm", __func__);
        return rc;
    }

    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    rc = AddGetParmEntryToBatch(m_pParamBuf,
                                CAM_INTF_PARM_RAW_DIMENSION);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to get CAM_INTF_PARM_RAW_DIMENSION", __func__);
        return rc;
    }

    rc = commitGetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to get commit CAM_INTF_PARM_RAW_DIMENSION", __func__);
        return rc;
    }
    memcpy(&raw_dim,
            POINTER_OF_PARAM(CAM_INTF_PARM_RAW_DIMENSION,m_pParamBuf),
            sizeof(cam_dimension_t));
    CDBG_HIGH("%s : RAW Dimension = %d X %d",__func__,raw_dim.width,raw_dim.height);
    if (raw_dim.width == 0 || raw_dim.height == 0) {
        ALOGE("%s: Error getting RAW size. Setting to Capability value",__func__);
        raw_dim = m_pCapability->raw_dim[0];
    }
    setRawSize(raw_dim);
    return rc;
!!!44179383.cpp!!!	isAVTimerEnabled() : bool
    return m_bAVTimerEnabled;
!!!44179511.cpp!!!	isDISEnabled() : bool
    return m_bDISEnabled;
!!!44179639.cpp!!!	getISType() : cam_is_type_t
    return mIsType;
!!!44179767.cpp!!!	getMobicatMask() : uint8_t
    return m_MobiMask;
!!!44180023.cpp!!!	setNumOfSnapshot() : int32_t
    int nBurstNum = getBurstNum();
    uint8_t nExpnum = 0;

    const char *bracket_str = get(KEY_QC_AE_BRACKET_HDR);
    if (bracket_str != NULL && strlen(bracket_str) > 0) {
        int value = lookupAttr(BRACKETING_MODES_MAP,
                               sizeof(BRACKETING_MODES_MAP)/sizeof(QCameraMap),
                               bracket_str);
        switch (value) {
        case CAM_EXP_BRACKETING_ON:
            {
                nExpnum = 0;
                const char *str_val = get(KEY_QC_CAPTURE_BURST_EXPOSURE);
                if ((str_val != NULL) && (strlen(str_val) > 0)) {
                    char prop[PROPERTY_VALUE_MAX];
                    memset(prop, 0, sizeof(prop));
                    strcpy(prop, str_val);
                    char *saveptr = NULL;
                    char *token = strtok_r(prop, ",", &saveptr);
                    while (token != NULL) {
                        token = strtok_r(NULL, ",", &saveptr);
                        nExpnum++;
                    }
                }
                if (nExpnum == 0) {
                    nExpnum = 1;
                }
            }
            break;
        default:
            nExpnum = 1 + getNumOfExtraHDROutBufsIfNeeded();
            break;
        }
    }

    CDBG_HIGH("%s: nBurstNum = %d, nExpnum = %d", __func__, nBurstNum, nExpnum);
    set(KEY_QC_NUM_SNAPSHOT_PER_SHUTTER, nBurstNum * nExpnum);
    return NO_ERROR;
!!!44180151.cpp!!!	adjustPreviewFpsRange(inout fpsRange : cam_fps_range_t) : int32_t
    if ( fpsRange == NULL ) {
        return BAD_VALUE;
    }

    if ( m_pParamBuf == NULL ) {
        return NO_INIT;
    }

    int32_t rc = initBatchUpdate(m_pParamBuf);
    if ( rc != NO_ERROR ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return rc;
    }

    rc = AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_FPS_RANGE,
                                  sizeof(cam_fps_range_t),
                                  fpsRange);
    if ( rc != NO_ERROR ) {
        ALOGE("%s: Parameters batch failed",__func__);
        return rc;
    }

    rc = commitSetBatch();
    if ( rc != NO_ERROR ) {
        ALOGE("%s:Failed to commit batch parameters", __func__);
        return rc;
    }

    return rc;
!!!44180663.cpp!!!	getDenoiseProcessPlate(in type : cam_intf_parm_type_t) : cam_denoise_process_type_t
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    cam_denoise_process_type_t processPlate = CAM_WAVELET_DENOISE_CBCR_ONLY;
    if (CAM_INTF_PARM_WAVELET_DENOISE == type) {
        property_get("persist.denoise.process.plates", prop, "");
    } else if (CAM_INTF_PARM_TEMPORAL_DENOISE == type) {
        property_get("persist.tnr.process.plates", prop, "");
    } else {
        ALOGE("%s: Type not supported", __func__);
        prop[0] = '\0';
    }
    if (strlen(prop) > 0) {
        switch(atoi(prop)) {
        case 0:
            processPlate = CAM_WAVELET_DENOISE_YCBCR_PLANE;
            break;
        case 1:
            processPlate = CAM_WAVELET_DENOISE_CBCR_ONLY;
            break;
        case 2:
            processPlate = CAM_WAVELET_DENOISE_STREAMLINE_YCBCR;
            break;
        case 3:
            processPlate = CAM_WAVELET_DENOISE_STREAMLINED_CBCR;
            break;
        default:
            processPlate = CAM_WAVELET_DENOISE_CBCR_ONLY;
            break;
        }
    }
    return processPlate;
!!!44180791.cpp!!!	getLiveSnapshotSize(inout dim : cam_dimension_t) : void
    if(is4k2kVideoResolution()) {
        // We support maximum 8M liveshot @4K2K video resolution
        cam_dimension_t resolution = {0, 0};
        CameraParameters::getVideoSize(&resolution.width, &resolution.height);
        if((m_LiveSnapshotSize.width > resolution.width) ||
                (m_LiveSnapshotSize.height > resolution.height)) {
            m_LiveSnapshotSize.width = resolution.width;
            m_LiveSnapshotSize.height = resolution.height;
        }
    }
    dim = m_LiveSnapshotSize;
    CDBG_HIGH("%s: w x h: %d x %d", __func__, dim.width, dim.height);
!!!44181047.cpp!!!	setRawSize(inout dim : cam_dimension_t) : int32_t
    m_rawSize = dim;
    return NO_ERROR;
!!!44181175.cpp!!!	getFlipMode(in type : cam_stream_type_t) : int
    const char *str = NULL;
    int flipMode = 0; // no flip

    switch(type){
    case CAM_STREAM_TYPE_PREVIEW:
        if (!isRdiMode()) {
            str = get(KEY_QC_PREVIEW_FLIP);
        }
        break;
    case CAM_STREAM_TYPE_VIDEO:
        str = get(KEY_QC_VIDEO_FLIP);
        break;
    case CAM_STREAM_TYPE_SNAPSHOT:
    case CAM_STREAM_TYPE_POSTVIEW:
        str = get(KEY_QC_SNAPSHOT_PICTURE_FLIP);
        break;
    default:
        CDBG("%s: No flip mode for stream type %d", __func__, type);
        break;
    }

    if(str != NULL){
        //Need give corresponding filp value based on flip mode strings
        int value = lookupAttr(FLIP_MODES_MAP,
                sizeof(FLIP_MODES_MAP)/sizeof(QCameraMap), str);
        if(value != NAME_NOT_FOUND)
            flipMode = value;
        }

    CDBG_HIGH("%s: the filp mode of stream type %d is %d .", __func__, type, flipMode);
    return flipMode;
!!!44181303.cpp!!!	isSnapshotFDNeeded() : bool
    return getInt(KEY_QC_SNAPSHOT_FD_DATA);
!!!44181559.cpp!!!	isYUVFrameInfoNeeded() : bool
    //In AE-Bracket mode, we need set raw buffer information for up-layer
    if(!isNV21PictureFormat() && !isNV16PictureFormat()){
        return false;
    }
    const char *aecBracketStr =  get(KEY_QC_AE_BRACKET_HDR);

    int value = lookupAttr(BRACKETING_MODES_MAP,
                   sizeof(BRACKETING_MODES_MAP)/sizeof(QCameraMap),
                           aecBracketStr);
    CDBG_HIGH("%s: aecBracketStr=%s, value=%d.", __func__, aecBracketStr, value);
    return (value == CAM_EXP_BRACKETING_ON);
!!!44181687.cpp!!!	getFrameFmtString(in fmt : cam_format_t) : char
    return lookupNameByValue(PICTURE_TYPES_MAP,
                             sizeof(PICTURE_TYPES_MAP)/sizeof(QCameraMap),
                             fmt);
!!!44182455.cpp!!!	setHDRSceneEnable(in bflag : bool) : void
    bool bupdate = false;
    if (m_HDRSceneEnabled != bflag) {
        bupdate = true;
    }
    m_HDRSceneEnabled = bflag;

    if (bupdate) {
        updateFlash(true);
    }
!!!44182583.cpp!!!	updateAWBParams(inout awb_params : cam_awb_params_t) : int32_t
    //check and update CCT
    int32_t prev_cct = getInt(KEY_QC_WB_MANUAL_CCT);
    if (prev_cct != awb_params.cct_value) {
        CDBG("%s: update current cct value. old:%d, now:%d", __func__,
                prev_cct, awb_params.cct_value);
        set(KEY_QC_WB_MANUAL_CCT, awb_params.cct_value);
    }

    //check and update WB gains
    const char *prev_gains = get(KEY_QC_MANUAL_WB_GAINS);
    char gainStr[30];
    snprintf(gainStr, sizeof(gainStr), "%f,%f,%f", awb_params.rgb_gains.r_gain,
        awb_params.rgb_gains.g_gain, awb_params.rgb_gains.b_gain);

    if (prev_gains == NULL || strcmp(prev_gains, gainStr)) {
        set(KEY_QC_MANUAL_WB_GAINS, gainStr);
        CDBG("%s: update currernt RGB gains: old %s new %s",__func__, prev_gains, gainStr);
    }
    return NO_ERROR;
!!!44182711.cpp!!!	getASDStateString(in scene : cam_auto_scene_t) : char
    switch (scene) {
      case S_NORMAL :
        return "Normal";
      case S_SCENERY:
        return "Scenery";
      case S_PORTRAIT:
        return "Portrait";
      case S_PORTRAIT_BACKLIGHT:
        return "Portrait-Backlight";
      case S_SCENERY_BACKLIGHT:
        return "Scenery-Backlight";
      case S_BACKLIGHT:
        return "Backlight";
      default:
        return "<Unknown!>";
      }
!!!44182967.cpp!!!	getAutoFlickerMode() : int
    /* Enable Advanced Auto Antibanding where we can set
       any of the following option
       ie. CAM_ANTIBANDING_MODE_AUTO
           CAM_ANTIBANDING_MODE_AUTO_50HZ
           CAM_ANTIBANDING_MODE_AUTO_60HZ
      Currently setting it to default    */
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.set.afd", prop, "3");
    return atoi(prop);
!!!44183223.cpp!!!	sendStreamConfigInfo(inout stream_config_info : cam_stream_size_info_t) : bool
    int32_t rc = NO_ERROR;
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf,
            CAM_INTF_META_STREAM_INFO, stream_config_info)) {
        ALOGE("%s:Failed to update table", __func__);
        return BAD_VALUE;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to set stream info parm", __func__);
        return rc;
    }

    return rc;
!!!44183351.cpp!!!	setStreamConfigure(in isCapture : bool, in previewAsPostview : bool, in resetConfig : bool) : bool

    int32_t rc = NO_ERROR;
    cam_stream_size_info_t stream_config_info;
    char value[PROPERTY_VALUE_MAX];
    bool raw_yuv = false;
    bool raw_capture = false;

    if ( m_pParamBuf == NULL ) {
        return NO_INIT;
    }

    memset(&stream_config_info, 0, sizeof(stream_config_info));
    stream_config_info.num_streams = 0;

    if (m_bStreamsConfigured) {
        CDBG_HIGH("%s: Reset stream config!!", __func__);
        rc = sendStreamConfigInfo(stream_config_info);
        m_bStreamsConfigured = false;
    }
    if (resetConfig) {
        CDBG_HIGH("%s: Done Resetting stream config!!", __func__);
        return rc;
    }

    property_get("persist.camera.raw_yuv", value, "0");
    raw_yuv = atoi(value) > 0 ? true : false;

    if (isZSLMode() && getRecordingHintValue() != true) {
        stream_config_info.type[stream_config_info.num_streams] =
            CAM_STREAM_TYPE_PREVIEW;
        getStreamDimension(CAM_STREAM_TYPE_PREVIEW,
                stream_config_info.stream_sizes[stream_config_info.num_streams]);
        updatePpFeatureMask(CAM_STREAM_TYPE_PREVIEW);
        stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                mStreamPpMask[CAM_STREAM_TYPE_PREVIEW];
        stream_config_info.num_streams++;

        stream_config_info.type[stream_config_info.num_streams] =
                CAM_STREAM_TYPE_ANALYSIS;
        getStreamDimension(CAM_STREAM_TYPE_ANALYSIS,
                stream_config_info.stream_sizes[stream_config_info.num_streams]);
        updatePpFeatureMask(CAM_STREAM_TYPE_ANALYSIS);
        stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                mStreamPpMask[CAM_STREAM_TYPE_ANALYSIS];
        stream_config_info.num_streams++;

        stream_config_info.type[stream_config_info.num_streams] =
                CAM_STREAM_TYPE_SNAPSHOT;
        getStreamDimension(CAM_STREAM_TYPE_SNAPSHOT,
                stream_config_info.stream_sizes[stream_config_info.num_streams]);
        updatePpFeatureMask(CAM_STREAM_TYPE_SNAPSHOT);
        stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                mStreamPpMask[CAM_STREAM_TYPE_SNAPSHOT];
        stream_config_info.num_streams++;

    } else if (!isCapture) {
        if (m_bRecordingHint) {
            if (m_bDISEnabled) {
                char value[PROPERTY_VALUE_MAX];
                // Make default value for IS_TYPE as IS_TYPE_EIS_2_0
                property_get("persist.camera.is_type", value, "4");
                mIsType = static_cast<cam_is_type_t>(atoi(value));
            } else {
                mIsType = IS_TYPE_NONE;
            }
            stream_config_info.is_type = mIsType;
            stream_config_info.type[stream_config_info.num_streams] =
                    CAM_STREAM_TYPE_SNAPSHOT;
            getStreamDimension(CAM_STREAM_TYPE_SNAPSHOT,
                    stream_config_info.stream_sizes[stream_config_info.num_streams]);
            updatePpFeatureMask(CAM_STREAM_TYPE_SNAPSHOT);
            stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                    mStreamPpMask[CAM_STREAM_TYPE_SNAPSHOT];
            stream_config_info.num_streams++;

            stream_config_info.type[stream_config_info.num_streams] =
                    CAM_STREAM_TYPE_VIDEO;
            getStreamDimension(CAM_STREAM_TYPE_VIDEO,
                    stream_config_info.stream_sizes[stream_config_info.num_streams]);
            updatePpFeatureMask(CAM_STREAM_TYPE_VIDEO);
            stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                    mStreamPpMask[CAM_STREAM_TYPE_VIDEO];
            stream_config_info.num_streams++;
        }

        if (getRecordingHintValue() != true) {
            /* Analysis stream is used only in capture usecase */
            stream_config_info.type[stream_config_info.num_streams] =
                    CAM_STREAM_TYPE_ANALYSIS;
            getStreamDimension(CAM_STREAM_TYPE_ANALYSIS,
                    stream_config_info.stream_sizes[stream_config_info.num_streams]);
            updatePpFeatureMask(CAM_STREAM_TYPE_ANALYSIS);
            stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                    mStreamPpMask[CAM_STREAM_TYPE_ANALYSIS];
            stream_config_info.num_streams++;
        }

        stream_config_info.type[stream_config_info.num_streams] =
                CAM_STREAM_TYPE_PREVIEW;
        getStreamDimension(CAM_STREAM_TYPE_PREVIEW,
                stream_config_info.stream_sizes[stream_config_info.num_streams]);
        updatePpFeatureMask(CAM_STREAM_TYPE_PREVIEW);
        stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                mStreamPpMask[CAM_STREAM_TYPE_PREVIEW];
        stream_config_info.num_streams++;

    } else {
        if (isJpegPictureFormat() || isNV16PictureFormat() || isNV21PictureFormat()) {
            if (!getofflineRAW()) {
                stream_config_info.type[stream_config_info.num_streams] =
                        CAM_STREAM_TYPE_SNAPSHOT;
                getStreamDimension(CAM_STREAM_TYPE_SNAPSHOT,
                        stream_config_info.stream_sizes[stream_config_info.num_streams]);
                updatePpFeatureMask(CAM_STREAM_TYPE_SNAPSHOT);
                stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                        mStreamPpMask[CAM_STREAM_TYPE_SNAPSHOT];
                stream_config_info.num_streams++;
            }

            if (previewAsPostview) {
                stream_config_info.type[stream_config_info.num_streams] =
                        CAM_STREAM_TYPE_PREVIEW;
                getStreamDimension(CAM_STREAM_TYPE_PREVIEW,
                        stream_config_info.stream_sizes[stream_config_info.num_streams]);
                updatePpFeatureMask(CAM_STREAM_TYPE_PREVIEW);
                stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                        mStreamPpMask[CAM_STREAM_TYPE_PREVIEW];
                stream_config_info.num_streams++;
            } else {
                stream_config_info.type[stream_config_info.num_streams] =
                        CAM_STREAM_TYPE_POSTVIEW;
                getStreamDimension(CAM_STREAM_TYPE_POSTVIEW,
                        stream_config_info.stream_sizes[stream_config_info.num_streams]);
                updatePpFeatureMask(CAM_STREAM_TYPE_POSTVIEW);
                stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                        mStreamPpMask[CAM_STREAM_TYPE_POSTVIEW];
                stream_config_info.num_streams++;
            }
        } else {
            raw_capture = true;
            stream_config_info.type[stream_config_info.num_streams] =
                    CAM_STREAM_TYPE_RAW;
            getStreamDimension(CAM_STREAM_TYPE_RAW,
                    stream_config_info.stream_sizes[stream_config_info.num_streams]);
            updatePpFeatureMask(CAM_STREAM_TYPE_RAW);
            stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                    mStreamPpMask[CAM_STREAM_TYPE_RAW];
            stream_config_info.num_streams++;
        }
    }
    if (raw_yuv && !raw_capture && (isZSLMode() ||
            (getofflineRAW() && isCapture && !getRecordingHintValue()))) {
        cam_dimension_t max_dim = {0,0};
        updateRAW(max_dim);
        stream_config_info.type[stream_config_info.num_streams] =
                CAM_STREAM_TYPE_RAW;
        getStreamDimension(CAM_STREAM_TYPE_RAW,
                stream_config_info.stream_sizes[stream_config_info.num_streams]);
        updatePpFeatureMask(CAM_STREAM_TYPE_RAW);
        stream_config_info.postprocess_mask[stream_config_info.num_streams] =
                mStreamPpMask[CAM_STREAM_TYPE_RAW];
        stream_config_info.num_streams++;
    }
    for (uint32_t k = 0; k < stream_config_info.num_streams; k++) {
        ALOGI("%s: stream type %d, w x h: %d x %d, pp_mask: 0x%x", __func__,
                stream_config_info.type[k],
                stream_config_info.stream_sizes[k].width,
                stream_config_info.stream_sizes[k].height,
                stream_config_info.postprocess_mask[k]);
    }

    rc = sendStreamConfigInfo(stream_config_info);
    m_bStreamsConfigured = true;

    return rc;
!!!44183479.cpp!!!	addOnlineRotation(in rotation : uint32_t, in streamId : uint32_t, in device_rotation : int32_t) : int32_t
    int32_t rc = NO_ERROR;
    cam_rotation_info_t rotation_info;
    memset(&rotation_info, 0, sizeof(cam_rotation_info_t));

    /* Add jpeg rotation information */
    if (rotation == 0) {
        rotation_info.rotation = ROTATE_0;
    } else if (rotation == 90) {
        rotation_info.rotation = ROTATE_90;
    } else if (rotation == 180) {
        rotation_info.rotation = ROTATE_180;
    } else if (rotation == 270) {
        rotation_info.rotation = ROTATE_270;
    } else {
        rotation_info.rotation = ROTATE_0;
    }
    rotation_info.streamId = streamId;

    /* Add device rotation information */
    if (device_rotation == 0) {
        rotation_info.device_rotation = ROTATE_0;
    } else if (device_rotation == 90) {
        rotation_info.device_rotation = ROTATE_90;
    } else if (device_rotation == 180) {
        rotation_info.device_rotation = ROTATE_180;
    } else if (device_rotation == 270) {
        rotation_info.device_rotation = ROTATE_270;
    } else {
        rotation_info.device_rotation = ROTATE_0;
    }

    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_ROTATION, rotation_info)) {
        ALOGE("%s:Failed to update table", __func__);
        return BAD_VALUE;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to set stream info parm", __func__);
        return rc;
    }

    return rc;
!!!44183607.cpp!!!	getNumOfExtraBuffersForImageProc() : uint8_t
    uint8_t numOfBufs = 0;

    if (isUbiFocusEnabled()) {
        numOfBufs += m_pCapability->ubifocus_af_bracketing_need.burst_count - 1;
        if (isUbiRefocus()) {
            numOfBufs +=
                m_pCapability->ubifocus_af_bracketing_need.burst_count + 1;
        }
    } else if (m_bOptiZoomOn) {
        numOfBufs += m_pCapability->opti_zoom_settings_need.burst_count - 1;
    } else if (isChromaFlashEnabled()) {
        numOfBufs += 1; /* flash and non flash */
    }

    return numOfBufs * getBurstNum();
!!!44183735.cpp!!!	getNumOfExtraBuffersForVideo() : uint8_t
    uint8_t numOfBufs = 0;

    if (isSeeMoreEnabled()) {
        numOfBufs = 1;
    }

    return numOfBufs;
!!!44183863.cpp!!!	getNumOfExtraBuffersForPreview() : uint8_t
    uint8_t numOfBufs = 0;

    if (isSeeMoreEnabled() && !isZSLMode() && getRecordingHintValue()) {
        numOfBufs = 1;
    }

    return numOfBufs;
!!!44183991.cpp!!!	getExifBufIndex(in captureIndex : uint32_t) : uint32_t
    uint32_t index = captureIndex;

    if (isUbiRefocus()) {
        if (captureIndex < m_pCapability->refocus_af_bracketing_need.burst_count) {
            index = captureIndex;
        } else {
            index = 0;
        }
    } else if (isChromaFlashEnabled()) {
        index = m_pCapability->chroma_flash_settings_need.metadata_index;
    } else if (isHDREnabled()) {
        if (isHDR1xFrameEnabled() && isHDR1xExtraBufferNeeded()) {
            index = m_pCapability->hdr_bracketing_setting.num_frames;
        } else {
            for (index = 0; index < m_pCapability->hdr_bracketing_setting.num_frames; index++) {
                if (0 == m_pCapability->hdr_bracketing_setting.exp_val.values[index]) {
                    break;
                }
            }
            if (index == m_pCapability->hdr_bracketing_setting.num_frames) {
                index = captureIndex;
            }
        }
    }

    return index;
!!!44184119.cpp!!!	needThumbnailReprocess(inout pFeatureMask : uint32_t) : bool
    if (isUbiFocusEnabled() || isChromaFlashEnabled() ||
        isOptiZoomEnabled()) {
        *pFeatureMask &= ~CAM_QCOM_FEATURE_CHROMA_FLASH;
        *pFeatureMask &= ~CAM_QCOM_FEATURE_UBIFOCUS;
        *pFeatureMask &= ~CAM_QCOM_FEATURE_OPTIZOOM;
        return false;
    } else {
        return true;
    }
!!!44185015.cpp!!!	isOptiZoomEnabled() : bool
    if (m_bOptiZoomOn) {
        uint8_t zoom_level = (uint8_t) getInt(CameraParameters::KEY_ZOOM);
        cam_opti_zoom_t *opti_zoom_settings_need =
                &(m_pCapability->opti_zoom_settings_need);
        uint8_t zoom_threshold = opti_zoom_settings_need->zoom_threshold;
        CDBG_HIGH("%s: current zoom level =%d & zoom_threshold =%d",
                __func__, zoom_level, zoom_threshold);

        if (zoom_level >= zoom_threshold) {
            return true;
        }
    }

    return false;
!!!44185143.cpp!!!	commitAFBracket(in afBracket : cam_af_bracketing_t) : int32_t

    int32_t rc = NO_ERROR;
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    rc = AddSetParmEntryToBatch(m_pParamBuf,
            CAM_INTF_PARM_FOCUS_BRACKETING,
            sizeof(afBracket),
            &afBracket);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update table", __func__);
        return rc;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to commit batch", __func__);
    }

    return rc;
!!!44185271.cpp!!!	commitFlashBracket(in flashBracket : cam_flash_bracketing_t) : int32_t
    CDBG_HIGH("%s: E",__func__);
    int32_t rc = NO_ERROR;
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    rc = AddSetParmEntryToBatch(m_pParamBuf,
            CAM_INTF_PARM_FLASH_BRACKETING,
            sizeof(flashBracket),
            &flashBracket);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update table", __func__);
        return rc;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to commit batch", __func__);
    }

    CDBG_HIGH("%s: X",__func__);
    return rc;
!!!44185399.cpp!!!	set3ALock(in lockStr : char) : int32_t
    int32_t rc = NO_ERROR;
    if (lockStr != NULL) {
        int32_t value = lookupAttr(TRUE_FALSE_MODES_MAP,
                                   sizeof(TRUE_FALSE_MODES_MAP)/sizeof(QCameraMap),
                                   lockStr);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting Lock lockStr =%s", __func__, lockStr);
            if(initBatchUpdate(m_pParamBuf) < 0 ) {
                ALOGE("%s:Failed to initialize group update table", __func__);
                return BAD_TYPE;
            }
            int32_t focus_mode;
            if (value == 1) {
                if (isUbiFocusEnabled()) {
                    //For Ubi focus move focus to infinity.
                    focus_mode = CAM_FOCUS_MODE_INFINITY;
                } else if (isOptiZoomEnabled()){
                    //For optizoom set focus as fixed.
                    focus_mode = CAM_FOCUS_MODE_FIXED;
                }
            } else {
               // retrieve previous focus value.
               const char *focus = get(KEY_FOCUS_MODE);
               focus_mode = lookupAttr(FOCUS_MODES_MAP,
                               sizeof(FOCUS_MODES_MAP)/sizeof(QCameraMap),
                               focus);
               CDBG("%s: focus mode %s", __func__, focus);
            }
            //Lock AWB
            rc = AddSetParmEntryToBatch(m_pParamBuf,
                                    CAM_INTF_PARM_AWB_LOCK,
                                    sizeof(value),
                                    &value);
            if (NO_ERROR != rc) {
                return rc;
            }
            //Lock AEC
            rc = AddSetParmEntryToBatch(m_pParamBuf,
                                    CAM_INTF_PARM_AEC_LOCK,
                                    sizeof(value),
                                    &value);
            if (NO_ERROR != rc) {
                return rc;
            }
            rc = AddSetParmEntryToBatch(m_pParamBuf,
                                    CAM_INTF_PARM_FOCUS_MODE,
                                    sizeof(focus_mode),
                                    &focus_mode);
            if (NO_ERROR != rc) {
                return rc;
            }

            rc = commitSetBatch();
            if (rc != NO_ERROR) {
                ALOGE("%s:Failed to commit batch", __func__);
            }
        }
    }
    return rc;
!!!44185527.cpp!!!	setAndCommitZoom(in zoom_level : int) : int32_t
    CDBG_HIGH("%s: E",__func__);
    int32_t rc = NO_ERROR;
        if(initBatchUpdate(m_pParamBuf) < 0 ) {
            ALOGE("%s:Failed to initialize group update table", __func__);
            return BAD_TYPE;
        }
        rc = AddSetParmEntryToBatch(m_pParamBuf,
                              CAM_INTF_PARM_ZOOM,
                              sizeof(zoom_level),
                              &zoom_level);

        if (rc != NO_ERROR) {
             ALOGE("%s:Failed to update table", __func__);
             return rc;
        }
    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to set Flash value", __func__);
    }
    CDBG_HIGH("%s: X",__func__);
    return rc;
!!!44185655.cpp!!!	getBurstCountForAdvancedCapture() : uint8_t
    int burstCount = 0;
    if (isUbiFocusEnabled()) {
        //number of snapshots required for Ubi Focus.
        burstCount = m_pCapability->ubifocus_af_bracketing_need.burst_count;
    } else if (isOptiZoomEnabled()) {
        //number of snapshots required for Opti Zoom.
        burstCount = m_pCapability->opti_zoom_settings_need.burst_count;
    } else if (isChromaFlashEnabled()) {
        //number of snapshots required for Chroma Flash.
        //TODO: remove hardcoded value, add in capability.
        burstCount = 2;
    } else if (isHDREnabled()) {
        //number of snapshots required for HDR.
        burstCount = m_pCapability->hdr_bracketing_setting.num_frames;
    } else if (isAEBracketEnabled()) {
      burstCount = 0;
      const char *str_val = m_AEBracketingClient.values;
      if ((str_val != NULL) && (strlen(str_val) > 0)) {
          char prop[PROPERTY_VALUE_MAX];
          memset(prop, 0, sizeof(prop));
          strcpy(prop, str_val);
          char *saveptr = NULL;
          char *token = strtok_r(prop, ",", &saveptr);
          while (token != NULL) {
              token = strtok_r(NULL, ",", &saveptr);
              burstCount++;
          }
      }
    }

    if (burstCount <= 0) {
        burstCount = 1;
    }
    return (uint8_t)burstCount;
!!!44185783.cpp!!!	getNumberInBufsForSingleShot() : uint32_t
    uint32_t numOfBufs = 1;

    if (isUbiRefocus()) {
        numOfBufs = m_pCapability->refocus_af_bracketing_need.burst_count;
    } else if (isUbiFocusEnabled()) {
        numOfBufs = m_pCapability->ubifocus_af_bracketing_need.burst_count;
    } else if (m_bOptiZoomOn) {
        numOfBufs = m_pCapability->opti_zoom_settings_need.burst_count;
    } else if (isChromaFlashEnabled()) {
        numOfBufs = m_pCapability->chroma_flash_settings_need.burst_count;
    } else if (isHDREnabled()) {
        numOfBufs = m_pCapability->hdr_bracketing_setting.num_frames;
        if (isHDR1xFrameEnabled() && isHDR1xExtraBufferNeeded()) {
            numOfBufs++;
        }
    } else if (isStillMoreEnabled()) {
        if (isSeeMoreEnabled()) {
            m_stillmore_config.burst_count = 1;
            numOfBufs = m_stillmore_config.burst_count;
        } else if ((m_stillmore_config.burst_count >=
                m_pCapability->stillmore_settings_need.min_burst_count) &&
                (m_stillmore_config.burst_count <=
                m_pCapability->stillmore_settings_need.max_burst_count)) {
            numOfBufs = m_stillmore_config.burst_count;
        } else {
            numOfBufs = m_pCapability->stillmore_settings_need.burst_count;
        }
    }

    return numOfBufs;
!!!44185911.cpp!!!	getNumberOutBufsForSingleShot() : uint32_t
    uint32_t numOfBufs = 1;

    if (isUbiRefocus()) {
        numOfBufs = m_pCapability->refocus_af_bracketing_need.output_count;
    } else if (isHDREnabled()) {
        if (isHDR1xFrameEnabled()) {
            numOfBufs++;
        }
    }

    return numOfBufs;
!!!44186039.cpp!!!	setLongshotEnable(in enable : bool) : int32_t
    int32_t rc = NO_ERROR;
    int8_t value = enable;

    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    rc = AddSetParmEntryToBatch(m_pParamBuf,
          CAM_INTF_PARM_LONGSHOT_ENABLE,
          sizeof(value),
          &value);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update table", __func__);
        return rc;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to parameter changes", __func__);
        return rc;
    }

    return rc;
!!!44186167.cpp!!!	dump() : String8
    String8 str("\n");
    char s[128];

    snprintf(s, 128, "Preview Pixel Fmt: %d\n", getPreviewHalPixelFormat());
    str += s;

    snprintf(s, 128, "ZSL Burst Interval: %d\n", getZSLBurstInterval());
    str += s;

    snprintf(s, 128, "ZSL Queue Depth: %d\n", getZSLQueueDepth());
    str += s;

    snprintf(s, 128, "ZSL Back Look Count %d\n", getZSLBackLookCount());
    str += s;

    snprintf(s, 128, "Max Unmatched Frames In Queue: %d\n",
        getMaxUnmatchedFramesInQueue());
    str += s;

    snprintf(s, 128, "Is ZSL Mode: %d\n", isZSLMode());
    str += s;

    snprintf(s, 128, "Is No Display Mode: %d\n", isNoDisplayMode());
    str += s;

    snprintf(s, 128, "Is WNR Enabled: %d\n", isWNREnabled());
    str += s;

    snprintf(s, 128, "isHfrMode: %d\n", isHfrMode());
    str += s;

    snprintf(s, 128, "getNumOfSnapshots: %d\n", getNumOfSnapshots());
    str += s;

    snprintf(s, 128, "getNumOfExtraHDRInBufsIfNeeded: %d\n",
        getNumOfExtraHDRInBufsIfNeeded());
    str += s;

    snprintf(s, 128, "getNumOfExtraHDROutBufsIfNeeded: %d\n",
        getNumOfExtraHDROutBufsIfNeeded());
    str += s;

    snprintf(s, 128, "getBurstNum: %d\n", getBurstNum());
    str += s;

    snprintf(s, 128, "getRecordingHintValue: %d\n", getRecordingHintValue());
    str += s;

    snprintf(s, 128, "getJpegQuality: %d\n", getJpegQuality());
    str += s;

    snprintf(s, 128, "getJpegRotation: %d\n", getJpegRotation());
    str += s;

    snprintf(s, 128, "isHistogramEnabled: %d\n", isHistogramEnabled());
    str += s;

    snprintf(s, 128, "isFaceDetectionEnabled: %d\n", isFaceDetectionEnabled());
    str += s;

    snprintf(s, 128, "isHDREnabled: %d\n", isHDREnabled());
    str += s;

    snprintf(s, 128, "isAutoHDREnabled: %d\n", isAutoHDREnabled());
    str += s;

    snprintf(s, 128, "isAVTimerEnabled: %d\n", isAVTimerEnabled());
    str += s;

    snprintf(s, 128, "getFocusMode: %d\n", getFocusMode());
    str += s;

    snprintf(s, 128, "isJpegPictureFormat: %d\n", isJpegPictureFormat());
    str += s;

    snprintf(s, 128, "isNV16PictureFormat: %d\n", isNV16PictureFormat());
    str += s;

    snprintf(s, 128, "isNV21PictureFormat: %d\n", isNV21PictureFormat());
    str += s;

    snprintf(s, 128, "isSnapshotFDNeeded: %d\n", isSnapshotFDNeeded());
    str += s;

    snprintf(s, 128, "isHDR1xFrameEnabled: %d\n", isHDR1xFrameEnabled());
    str += s;

    snprintf(s, 128, "isYUVFrameInfoNeeded: %d\n", isYUVFrameInfoNeeded());
    str += s;

    snprintf(s, 128, "isHDR1xExtraBufferNeeded: %d\n",
        isHDR1xExtraBufferNeeded());
    str += s;

    snprintf(s, 128, "isHDROutputCropEnabled: %d\n", isHDROutputCropEnabled());
    str += s;

    snprintf(s, 128, "isPreviewFlipChanged: %d\n", isPreviewFlipChanged());
    str += s;

    snprintf(s, 128, "isVideoFlipChanged: %d\n", isVideoFlipChanged());
    str += s;

    snprintf(s, 128, "isSnapshotFlipChanged: %d\n", isSnapshotFlipChanged());
    str += s;

    snprintf(s, 128, "isHDRThumbnailProcessNeeded: %d\n",
        isHDRThumbnailProcessNeeded());
    str += s;

    snprintf(s, 128, "getAutoFlickerMode: %d\n", getAutoFlickerMode());
    str += s;

    snprintf(s, 128, "getNumOfExtraBuffersForImageProc: %d\n",
        getNumOfExtraBuffersForImageProc());
    str += s;

    snprintf(s, 128, "isUbiFocusEnabled: %d\n", isUbiFocusEnabled());
    str += s;

    snprintf(s, 128, "isChromaFlashEnabled: %d\n", isChromaFlashEnabled());
    str += s;

    snprintf(s, 128, "isOptiZoomEnabled: %d\n", isOptiZoomEnabled());
    str += s;

    snprintf(s, 128, "getBurstCountForAdvancedCapture: %d\n",
        getBurstCountForAdvancedCapture());
    str += s;

    return str;
!!!44186807.cpp!!!	updateCurrentFocusPosition(inout cur_pos_info : cam_focus_pos_info_t) : void
    int prevScalePos = getInt(KEY_QC_FOCUS_POSITION_SCALE);
    int newScalePos = (int) cur_pos_info.scale;
    if (prevScalePos != newScalePos) {
        CDBG("update focus scale: old:%d, new:%d", prevScalePos, newScalePos);
        set(KEY_QC_FOCUS_POSITION_SCALE, newScalePos);
    }

    float prevDiopterPos = getFloat(KEY_QC_FOCUS_POSITION_DIOPTER);
    float newDiopterPos = cur_pos_info.diopter;
    if (prevDiopterPos != newDiopterPos) {
        CDBG("update focus diopter: old:%f, new:%f", prevDiopterPos, newDiopterPos);
        setFloat(KEY_QC_FOCUS_POSITION_DIOPTER, newDiopterPos);
    }
!!!44186935.cpp!!!	updateAEInfo(inout ae_params : cam_3a_params_t) : void
    const char *prevExpTime = get(KEY_QC_CURRENT_EXPOSURE_TIME);
    char newExpTime[15];
    snprintf(newExpTime, sizeof(newExpTime), "%f", ae_params.exp_time*1000.0);

    if (prevExpTime == NULL || strcmp(prevExpTime, newExpTime)) {
        CDBG("update exposure time: old: %s, new: %s", prevExpTime, newExpTime);
        set(KEY_QC_CURRENT_EXPOSURE_TIME, newExpTime);
    }

    int32_t prevISO = getInt(KEY_QC_CURRENT_ISO);
    int32_t newISO = ae_params.iso_value;
    if (prevISO != newISO) {
        CDBG("update iso: old:%d, new:%d", prevISO, newISO);
        set(KEY_QC_CURRENT_ISO, newISO);
    }
!!!44187447.cpp!!!	setAecLock(in aecLockStr : char) : int32_t
    if (aecLockStr != NULL) {
        int32_t value = lookupAttr(TRUE_FALSE_MODES_MAP,
                                  sizeof(TRUE_FALSE_MODES_MAP)/
                                      sizeof(QCameraMap),
                                  aecLockStr);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting AECLock value %s", __func__, aecLockStr);
            updateParamEntry(KEY_AUTO_EXPOSURE_LOCK, aecLockStr);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_AEC_LOCK,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid AECLock value: %s",
        (aecLockStr == NULL) ? "NULL" : aecLockStr);
    return BAD_VALUE;
!!!44187575.cpp!!!	updateDebugLevel() : int32_t
    if ( m_pParamBuf == NULL ) {
        return NO_INIT;
    }

    int32_t rc = initBatchUpdate(m_pParamBuf);
    if ( rc != NO_ERROR ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return rc;
    }

    uint32_t dummyDebugLevel = 0;
    /* The value of dummyDebugLevel is irrelavent. On
     * CAM_INTF_PARM_UPDATE_DEBUG_LEVEL, read debug property */
    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_UPDATE_DEBUG_LEVEL, dummyDebugLevel)) {
        ALOGE("%s: Parameters batch failed",__func__);
        return BAD_VALUE;
    }

    rc = commitSetBatch();
    if ( rc != NO_ERROR ) {
        ALOGE("%s:Failed to commit batch parameters", __func__);
        return rc;
    }

    return NO_ERROR;
!!!44187703.cpp!!!	is4k2kVideoResolution() : bool
   bool enabled = false;
   cam_dimension_t resolution;
   getVideoSize(&resolution.width, &resolution.height);
   if (!(resolution.width < 3840 && resolution.height < 2160)) {
      enabled = true;
   }
   return enabled;
!!!44187831.cpp!!!	getBrightness() : int
    return getInt(KEY_QC_BRIGHTNESS);
!!!44187959.cpp!!!	updateOisValue(in oisValue : bool) : int32_t
    uint8_t enable = 0;
    int32_t rc = NO_ERROR;

    // Check for OIS disable
    char ois_prop[PROPERTY_VALUE_MAX];
    memset(ois_prop, 0, sizeof(ois_prop));
    property_get("persist.camera.ois.disable", ois_prop, "0");
    uint8_t ois_disable = (uint8_t)atoi(ois_prop);

    //Enable OIS if it is camera mode or Camcoder 4K mode
    if (!m_bRecordingHint || (is4k2kVideoResolution() && m_bRecordingHint)) {
        enable = 1;
        CDBG_HIGH("%s: Valid OIS mode!! ", __func__);
    }
    // Disable OIS if setprop is set
    if (ois_disable || !oisValue) {
        //Disable OIS
        enable = 0;
        CDBG_HIGH("%s: Disable OIS mode!! ois_disable(%d) oisValue(%d)",
                __func__, ois_disable, oisValue);

    }
    m_bOISEnabled = enable;
    if (m_bOISEnabled) {
        updateParamEntry(KEY_QC_OIS, VALUE_ENABLE);
    } else {
        updateParamEntry(KEY_QC_OIS, VALUE_DISABLE);
    }

    if (initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    CDBG_HIGH("%s: Sending OIS mode (%d)", __func__, enable);
    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_META_LENS_OPT_STAB_MODE, enable)) {
        ALOGE("%s:Failed to update table", __func__);
        return BAD_VALUE;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to parameter changes", __func__);
        return rc;
    }

    return rc;
!!!44188087.cpp!!!	setIntEvent(in params : cam_int_evt_params_t) : int32_t
    int32_t rc = NO_ERROR;

    if ( m_pParamBuf == NULL ) {
        return NO_INIT;
    }

    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }

    //Sending snapshot taken notification back to Eztune"
    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_INT_EVT, params)) {
        ALOGE("%s:Failed to update table", __func__);
        return BAD_VALUE;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to set frameskip info parm", __func__);
        return rc;
    }

    return rc;
!!!44188215.cpp!!!	setOfflineRAW() : void
   char value[PROPERTY_VALUE_MAX];
   bool raw_yuv = false;
   bool offlineRaw = false;

   property_get("persist.camera.raw_yuv", value, "0");
   raw_yuv = atoi(value) > 0 ? true : false;
   property_get("persist.camera.offlineraw", value, "0");
   offlineRaw = atoi(value) > 0 ? true : false;
   if((raw_yuv || isRdiMode()) && offlineRaw){
       mOfflineRAW = true;
   }else{
       mOfflineRAW = false;
   }
   CDBG_HIGH("%s: Offline Raw  %d",__func__, mOfflineRAW);
!!!44188471.cpp!!!	updatePpFeatureMask(in stream_type : cam_stream_type_t) : int32_t

    uint32_t feature_mask = 0;

    if (stream_type >= CAM_STREAM_TYPE_MAX) {
        ALOGE("%s: Error!! stream type: %d not valid", __func__, stream_type);
        return -1;
    }

    // Update feature mask for SeeMore in video and video preview
    if (isSeeMoreEnabled() &&
            !is4k2kVideoResolution() &&
            ((stream_type == CAM_STREAM_TYPE_VIDEO) ||
            (stream_type == CAM_STREAM_TYPE_PREVIEW && getRecordingHintValue()))) {
       feature_mask |= CAM_QCOM_FEATURE_LLVD;
    }

    // Do not enable feature mask for ZSL/non-ZSL/liveshot snapshot except for 4K2k case
    if ((getRecordingHintValue() &&
            (stream_type == CAM_STREAM_TYPE_SNAPSHOT) && is4k2kVideoResolution()) ||
            (stream_type != CAM_STREAM_TYPE_SNAPSHOT)) {
        if ((m_nMinRequiredPpMask & CAM_QCOM_FEATURE_SHARPNESS) &&
                !isOptiZoomEnabled()) {
            feature_mask |= CAM_QCOM_FEATURE_SHARPNESS;
        }

        if (m_nMinRequiredPpMask & CAM_QCOM_FEATURE_EFFECT) {
            feature_mask |= CAM_QCOM_FEATURE_EFFECT;
        }
        if (isWNREnabled() && (getRecordingHintValue() == false)) {
            feature_mask |= CAM_QCOM_FEATURE_DENOISE2D;
        }

        //Set flip mode based on Stream type;
        int flipMode = getFlipMode(stream_type);
        if (flipMode > 0) {
            feature_mask |= CAM_QCOM_FEATURE_FLIP;
        }
    }

    if ((isTNRVideoEnabled() && (CAM_STREAM_TYPE_VIDEO == stream_type))
            || (isTNRPreviewEnabled() && (CAM_STREAM_TYPE_PREVIEW == stream_type))) {
        feature_mask |= CAM_QCOM_FEATURE_CPP_TNR;
    }

    //Rotation could also have an effect on pp feature mask
    cam_pp_feature_config_t config;
    cam_dimension_t dim;
    memset(&config, 0, sizeof(cam_pp_feature_config_t));
    getStreamRotation(stream_type, config, dim);
    feature_mask |= config.feature_mask;

    // Store stream feature mask
    setStreamPpMask(stream_type, feature_mask);
    CDBG_HIGH("%s: stream type: %d, pp_mask: 0x%x", __func__, stream_type, feature_mask);

    return NO_ERROR;
!!!44188599.cpp!!!	setStreamPpMask(in stream_type : cam_stream_type_t, in pp_mask : uint32_t) : int32_t

    if(stream_type >= CAM_STREAM_TYPE_MAX) {
        return BAD_TYPE;
    }

    mStreamPpMask[stream_type] = pp_mask;
    return NO_ERROR;
!!!44188727.cpp!!!	getStreamPpMask(in stream_type : cam_stream_type_t, inout pp_mask : uint32_t) : int32_t

    if(stream_type >= CAM_STREAM_TYPE_MAX) {
        return BAD_TYPE;
    }

    pp_mask = mStreamPpMask[stream_type];
    return NO_ERROR;
!!!44189111.cpp!!!	updateFlashMode(in flash_mode : cam_flash_mode_t) : int32_t
    int32_t rc = NO_ERROR;
    if (flash_mode >= CAM_FLASH_MODE_MAX) {
        CDBG_HIGH("%s: Error!! Invalid flash mode (%d)", __func__, flash_mode);
        return BAD_VALUE;
    }
    CDBG_HIGH("%s: Setting Flash mode from EZTune %d", __func__, flash_mode);

    const char *flash_mode_str = lookupNameByValue(FLASH_MODES_MAP,
            PARAM_MAP_SIZE(FLASH_MODES_MAP), flash_mode);
    if(initBatchUpdate(m_pParamBuf) < 0 ) {
        ALOGE("%s:Failed to initialize group update table", __func__);
        return BAD_TYPE;
    }
    rc = setFlash(flash_mode_str);
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to update Flash mode", __func__);
        return rc;
    }

    CDBG_HIGH("%s: Setting Flash mode %d", __func__, mFlashValue);
    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_LED_MODE, mFlashValue)) {
        ALOGE("%s:Failed to set led mode", __func__);
        return BAD_VALUE;
    }

    rc = commitSetBatch();
    if (rc != NO_ERROR) {
        ALOGE("%s:Failed to commit parameters", __func__);
        return rc;
    }

    return NO_ERROR;
!!!44189239.cpp!!!	configureFlash(inout frame_config : cam_capture_frame_config_t) : int32_t
    CDBG_HIGH("%s: E",__func__);
    int32_t rc = NO_ERROR;
    uint32_t i = 0;

    if (isChromaFlashEnabled()) {

        rc = setToneMapMode(false, false);
        if (rc != NO_ERROR) {
            ALOGE("%s: Failed to configure tone map", __func__);
            return rc;
        }

        rc = setCDSMode(CAM_CDS_MODE_OFF, false);
        if (rc != NO_ERROR) {
            ALOGE("%s: Failed to configure csd mode", __func__);
            return rc;
        }

        CDBG_HIGH("%s : Enable Chroma Flash capture", __func__);
        cam_flash_mode_t flash_mode = CAM_FLASH_MODE_OFF;
        frame_config.num_batch =
                m_pCapability->chroma_flash_settings_need.burst_count;
        if (frame_config.num_batch > CAM_MAX_FLASH_BRACKETING) {
            frame_config.num_batch = CAM_MAX_FLASH_BRACKETING;
        }
        for (i = 0; i < frame_config.num_batch; i++) {
            flash_mode = (m_pCapability->chroma_flash_settings_need.flash_bracketing[i]) ?
                    CAM_FLASH_MODE_ON:CAM_FLASH_MODE_OFF;
            frame_config.configs[i].num_frames = 1;
            frame_config.configs[i].type = CAM_CAPTURE_FLASH;
            frame_config.configs[i].flash_mode = flash_mode;
        }
    } else if (mFlashValue != CAM_FLASH_MODE_OFF) {
        frame_config.num_batch = 1;
        for (i = 0; i < frame_config.num_batch; i++) {
            frame_config.configs[i].num_frames = 1;
            frame_config.configs[i].type = CAM_CAPTURE_FLASH;
            frame_config.configs[i].flash_mode =(cam_flash_mode_t)mFlashValue;
        }
    }

    CDBG("%s: Chroma Flash cnt = %d", __func__,frame_config.num_batch);
    return rc;
!!!44189367.cpp!!!	configureAEBracketing(inout frame_config : cam_capture_frame_config_t) : int32_t
    CDBG_HIGH("%s: E",__func__);
    int32_t rc = NO_ERROR;
    uint32_t i = 0;
    char exp_value[MAX_EXP_BRACKETING_LENGTH];

    rc = setToneMapMode(false, true);
    if (rc != NO_ERROR) {
        CDBG_HIGH("%s: Failed to disable tone map during AEBracketing", __func__);
    }

    uint32_t burstCount = 0;
    const char *str_val = m_AEBracketingClient.values;
    if ((str_val != NULL) && (strlen(str_val) > 0)) {
        char prop[PROPERTY_VALUE_MAX];
        memset(prop, 0, sizeof(prop));
        strlcpy(prop, str_val, PROPERTY_VALUE_MAX);
        char *saveptr = NULL;
        char *token = strtok_r(prop, ",", &saveptr);
        if (token != NULL) {
            exp_value[burstCount++] = (char)atoi(token);
            while (token != NULL) {
                token = strtok_r(NULL, ",", &saveptr);
                if (token != NULL) {
                    exp_value[burstCount++] = (char)atoi(token);
                }
            }
        }
    }

    frame_config.num_batch = burstCount;
    cam_bracket_mode mode = m_AEBracketingClient.mode;

    for (i = 0; i < frame_config.num_batch; i++) {
        frame_config.configs[i].num_frames = 1;
        frame_config.configs[i].type = CAM_CAPTURE_BRACKETING;
        frame_config.configs[i].hdr_mode.mode = mode;
        frame_config.configs[i].hdr_mode.values =
                m_AEBracketingClient.values[i];
        CDBG("%s: exp values %d", __func__, (int)m_AEBracketingClient.values[i]);
    }

    CDBG_HIGH("%s: num_frame = %d X",__func__, burstCount);
    return rc;
!!!44189495.cpp!!!	configureHDRBracketing(inout frame_config : cam_capture_frame_config_t) : int32_t
    CDBG_HIGH("%s: E",__func__);
    int32_t rc = NO_ERROR;
    uint32_t i = 0;

    uint32_t hdrFrameCount = m_pCapability->hdr_bracketing_setting.num_frames;
    CDBG_HIGH("%s : HDR values %d, %d frame count: %u",
          __func__,
          (int8_t) m_pCapability->hdr_bracketing_setting.exp_val.values[0],
          (int8_t) m_pCapability->hdr_bracketing_setting.exp_val.values[1],
          hdrFrameCount);

    frame_config.num_batch = hdrFrameCount;

    cam_bracket_mode mode =
            m_pCapability->hdr_bracketing_setting.exp_val.mode;
    if (mode == CAM_EXP_BRACKETING_ON) {
        rc = setToneMapMode(false, true);
        if (rc != NO_ERROR) {
            ALOGE("%s: Failed to disable tone map during HDR", __func__);
        }
    }
    for (i = 0; i < frame_config.num_batch; i++) {
        frame_config.configs[i].num_frames = 1;
        frame_config.configs[i].type = CAM_CAPTURE_BRACKETING;
        frame_config.configs[i].hdr_mode.mode = mode;
        frame_config.configs[i].hdr_mode.values =
                m_pCapability->hdr_bracketing_setting.exp_val.values[i];
        CDBG("%s: exp values %d", __func__,
                (int)frame_config.configs[i].hdr_mode.values);
    }
    return rc;
!!!44189623.cpp!!!	configFrameCapture(in commitSettings : bool) : int32_t
    int32_t rc = NO_ERROR;
    memset(&m_captureFrameConfig, 0, sizeof(cam_capture_frame_config_t));

    if (commitSettings) {
        if(initBatchUpdate(m_pParamBuf) < 0 ) {
            ALOGE("%s:Failed to initialize group update table", __func__);
            return BAD_TYPE;
        }
    }

    if (isChromaFlashEnabled() || mFlashValue != CAM_FLASH_MODE_OFF) {
        configureFlash(m_captureFrameConfig);
    } else if(isHDREnabled()) {
        configureHDRBracketing (m_captureFrameConfig);
    } else if(isAEBracketEnabled()) {
        configureAEBracketing (m_captureFrameConfig);
    }

    rc = ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_CAPTURE_FRAME_CONFIG,
            (cam_capture_frame_config_t)m_captureFrameConfig);
    if (rc != NO_ERROR) {
        rc = BAD_VALUE;
        ALOGE("%s:Failed to set capture settings", __func__);
        return rc;
    }

    if (commitSettings) {
        rc = commitSetBatch();
        if (rc != NO_ERROR) {
            ALOGE("%s:Failed to commit parameters", __func__);
            return rc;
        }
    }
    return rc;
!!!44189751.cpp!!!	resetFrameCapture(in commitSettings : bool) : int32_t
    int32_t rc = NO_ERROR, i = 0;
    memset(&m_captureFrameConfig, 0, sizeof(cam_capture_frame_config_t));

    if (commitSettings) {
        if(initBatchUpdate(m_pParamBuf) < 0 ) {
            ALOGE("%s:Failed to initialize group update table", __func__);
            return BAD_TYPE;
        }
    }

    if (isHDREnabled() || isAEBracketEnabled()) {
        rc = setToneMapMode(true, true);
        if (rc != NO_ERROR) {
            CDBG_HIGH("%s: Failed to enable tone map during HDR/AEBracketing", __func__);
        }
        rc = stopAEBracket();
    } else if (isChromaFlashEnabled()) {
        rc = setToneMapMode(true, false);
        if (rc != NO_ERROR) {
            CDBG_HIGH("%s: Failed to enable tone map during chroma flash", __func__);
        }

        rc = setCDSMode(mCds_mode, false);
        if (rc != NO_ERROR) {
            ALOGE("%s: Failed to configure csd mode", __func__);
            return rc;
        }
    }

    rc = ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_CAPTURE_FRAME_CONFIG,
            (cam_capture_frame_config_t)m_captureFrameConfig);
    if (rc != NO_ERROR) {
        rc = BAD_VALUE;
        ALOGE("%s:Failed to set capture settings", __func__);
        return rc;
    }

    if (commitSettings) {
        rc = commitSetBatch();
        if (rc != NO_ERROR) {
            ALOGE("%s:Failed to commit parameters", __func__);
            return rc;
        }
    }
    return rc;
!!!44190775.cpp!!!	setReprocCount() : void
    mTotalPPCount = 1; //Default reprocessing Pass count
    char value[PROPERTY_VALUE_MAX];
    int multpass = 0;

    property_get("persist.camera.multi_pass", value, "0");
    multpass = atoi(value);

   if ( multpass == 0 ) {
       return;
   }

    if ((getZoomLevel() != 0) && (isZSLMode())) {
        ALOGW("Zoom Present. Need 2nd pass for post processing");
        mTotalPPCount++;
    }
!!!44191159.cpp!!!	setToneMapMode(in enable : uint32_t, in initCommit : bool) : int32_t
    int32_t rc = NO_ERROR;
    CDBG_HIGH("%s: tone map mode %d ", __func__, enable);

    if (initCommit) {
        if (initBatchUpdate(m_pParamBuf) < 0) {
            ALOGE("%s:Failed to initialize group update table", __func__);
            return FAILED_TRANSACTION;
        }
    }

    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_TONE_MAP_MODE, enable)) {
        ALOGE("%s:Failed to update tone map mode", __func__);
        return BAD_VALUE;
    }

    if (initCommit) {
        rc = commitSetBatch();
        if (rc != NO_ERROR) {
            ALOGE("%s:Failed to commit tone map mode", __func__);
            return rc;
        }
    }

    return rc;
!!!44191287.cpp!!!	setTintless(in enable : bool) : void
    if (enable) {
        setTintlessValue(VALUE_ENABLE);
    } else {
        setTintlessValue(VALUE_DISABLE);
    }
!!!44191415.cpp!!!	setBufBatchCount(in buf_cnt : int8_t) : void
    mBufBatchCnt = 0;
    char value[PROPERTY_VALUE_MAX];
    int8_t count = 0;

    property_get("persist.camera.batchcount", value, "0");
    count = atoi(value);

    if (!(count != 0 || buf_cnt > CAMERA_MIN_BATCH_COUNT)) {
        CDBG_HIGH("%s : Buffer batch count = %d", __func__, mBufBatchCnt);
        return;
    }

    while((m_pCapability->max_batch_bufs_supported != 0)
            && (m_pCapability->max_batch_bufs_supported < buf_cnt)) {
        buf_cnt = buf_cnt / 2;
    }

    if (count > 0) {
        mBufBatchCnt = count;
        CDBG_HIGH("%s : Buffer batch count = %d", __func__, mBufBatchCnt);
        return;
    }

    if (buf_cnt > CAMERA_MIN_BATCH_COUNT) {
        mBufBatchCnt = buf_cnt;
        CDBG_HIGH("%s : Buffer batch count = %d", __func__, mBufBatchCnt);
        return;
    }
!!!44191799.cpp!!!	setJpegRotation(in rotation : int) : void
    if (rotation == 0 || rotation == 90 ||
            rotation == 180 || rotation == 270) {
        mJpegRotation = (uint32_t)rotation;
    }
!!!44192055.cpp!!!	setPreviewSize(in params : QCameraParameters) : int32_t
    int width, height;
    params.getPreviewSize(&width, &height);
    CDBG("Requested preview size %d x %d", width, height);

    // Validate the preview size
    for (size_t i = 0; i < m_pCapability->preview_sizes_tbl_cnt; ++i) {
        if (width ==  m_pCapability->preview_sizes_tbl[i].width
           && height ==  m_pCapability->preview_sizes_tbl[i].height) {
            // check if need to restart preview in case of preview size change
            int old_width, old_height;
            CameraParameters::getPreviewSize(&old_width, &old_height);
            if (width != old_width || height != old_height) {
                m_bNeedRestart = true;
            }

            // set the new value
            CameraParameters::setPreviewSize(width, height);
            return NO_ERROR;
        }
    }
    ALOGE("Invalid preview size requested: %dx%d", width, height);
    return BAD_VALUE;
!!!44192183.cpp!!!	setVideoSize(in params : QCameraParameters) : int32_t
    const char *str= NULL;
    int width, height;
    str = params.get(KEY_VIDEO_SIZE);
    if(!str) {
        //If application didn't set this parameter string, use the values from
        //getPreviewSize() as video dimensions.
        params.getPreviewSize(&width, &height);
        ALOGE("No Record Size requested, use the preview dimensions");
    } else {
        params.getVideoSize(&width, &height);
    }

    // Validate the video size
    for (size_t i = 0; i < m_pCapability->video_sizes_tbl_cnt; ++i) {
        if (width ==  m_pCapability->video_sizes_tbl[i].width
                && height ==  m_pCapability->video_sizes_tbl[i].height) {
            // check if need to restart preview in case of video size change
            int old_width, old_height;
            CameraParameters::getVideoSize(&old_width, &old_height);
            if (m_bRecordingHint &&
               (width != old_width || height != old_height)) {
                m_bNeedRestart = true;
            }

            // set the new value
            CameraParameters::setVideoSize(width, height);
            return NO_ERROR;
        }
    }

    ALOGE("Invalid video size requested: %dx%d", width, height);
    return BAD_VALUE;
!!!44192311.cpp!!!	setPictureSize(in params : QCameraParameters) : int32_t
    int width, height;
    params.getPictureSize(&width, &height);
    CDBG("Requested picture size %d x %d", width, height);

    // Validate the picture size
    if(!m_reprocScaleParam.isScaleEnabled()){
        for (size_t i = 0; i < m_pCapability->picture_sizes_tbl_cnt; ++i) {
            if (width ==  m_pCapability->picture_sizes_tbl[i].width
               && height ==  m_pCapability->picture_sizes_tbl[i].height) {
                // check if need to restart preview in case of picture size change
                int old_width, old_height;
                CameraParameters::getPictureSize(&old_width, &old_height);
                if ((m_bZslMode || m_bRecordingHint) &&
                    (width != old_width || height != old_height)) {
                    m_bNeedRestart = true;
                }

                // set the new value
                CameraParameters::setPictureSize(width, height);
                return NO_ERROR;
            }
        }
    }else{
        //should use scaled picture size table to validate
        if(m_reprocScaleParam.setValidatePicSize(width, height) == NO_ERROR){
            // check if need to restart preview in case of picture size change
            int old_width, old_height;
            CameraParameters::getPictureSize(&old_width, &old_height);
            if ((m_bZslMode || m_bRecordingHint) &&
                (width != old_width || height != old_height)) {
                m_bNeedRestart = true;
            }

            // set the new value
            char val[32];
            sprintf(val, "%dx%d", width, height);
            updateParamEntry(KEY_PICTURE_SIZE, val);
            CDBG("%s: %s", __func__, val);
            return NO_ERROR;
        }
    }
    ALOGE("Invalid picture size requested: %dx%d", width, height);
    return BAD_VALUE;
!!!44192439.cpp!!!	setLiveSnapshotSize(in params : QCameraParameters) : int32_t
    char value[PROPERTY_VALUE_MAX];
    property_get("persist.camera.opt.livepic", value, "1");
    bool useOptimal = atoi(value) > 0 ? true : false;

    // use picture size from user setting
    params.getPictureSize(&m_LiveSnapshotSize.width, &m_LiveSnapshotSize.height);

    uint8_t livesnapshot_sizes_tbl_cnt = m_pCapability->livesnapshot_sizes_tbl_cnt;
    cam_dimension_t *livesnapshot_sizes_tbl = &m_pCapability->livesnapshot_sizes_tbl[0];

    // check if HFR is enabled
    const char *hfrStr = params.get(KEY_QC_VIDEO_HIGH_FRAME_RATE);
    cam_hfr_mode_t hfrMode = CAM_HFR_MODE_OFF;
    const char *hsrStr = params.get(KEY_QC_VIDEO_HIGH_SPEED_RECORDING);

    if (hsrStr != NULL && !strcmp(hsrStr, "on")) {
        for (int i = 0; i < m_pCapability->hfr_tbl_cnt; i++) {
            if (m_pCapability->hfr_tbl[i].mode == CAM_HFR_MODE_120FPS) {
                livesnapshot_sizes_tbl_cnt =
                    m_pCapability->hfr_tbl[i].livesnapshot_sizes_tbl_cnt;
                livesnapshot_sizes_tbl =
                    &m_pCapability->hfr_tbl[i].livesnapshot_sizes_tbl[0];
                hfrMode = m_pCapability->hfr_tbl[i].mode;
                break;
            }
        }
    }
    else if (hfrStr != NULL) {
        int32_t value = lookupAttr(HFR_MODES_MAP,
                                   sizeof(HFR_MODES_MAP)/sizeof(QCameraMap),
                                   hfrStr);
        if (value != NAME_NOT_FOUND) {
            // if HFR is enabled, change live snapshot size
            if (value > CAM_HFR_MODE_OFF) {
                for (int i = 0; i < m_pCapability->hfr_tbl_cnt; i++) {
                    if (m_pCapability->hfr_tbl[i].mode == value) {
                        livesnapshot_sizes_tbl_cnt =
                            m_pCapability->hfr_tbl[i].livesnapshot_sizes_tbl_cnt;
                        livesnapshot_sizes_tbl =
                            &m_pCapability->hfr_tbl[i].livesnapshot_sizes_tbl[0];
                        hfrMode = m_pCapability->hfr_tbl[i].mode;
                        break;
                    }
                }
            }
        }
    }

    if (useOptimal || hfrMode != CAM_HFR_MODE_OFF) {
        bool found = false;

        // first check if picture size is within the list of supported sizes
        for (int i = 0; i < livesnapshot_sizes_tbl_cnt; ++i) {
            if (m_LiveSnapshotSize.width == livesnapshot_sizes_tbl[i].width &&
                m_LiveSnapshotSize.height == livesnapshot_sizes_tbl[i].height) {
                found = true;
                break;
            }
        }

        if (!found) {
            // use optimal live snapshot size from supported list,
            // that has same preview aspect ratio
            int width = 0, height = 0;
            params.getPreviewSize(&width, &height);

            double previewAspectRatio = (double)width / height;
            for (int i = 0; i < livesnapshot_sizes_tbl_cnt; ++i) {
                double ratio = (double)livesnapshot_sizes_tbl[i].width /
                                livesnapshot_sizes_tbl[i].height;
                if (fabs(previewAspectRatio - ratio) <= ASPECT_TOLERANCE) {
                    m_LiveSnapshotSize = livesnapshot_sizes_tbl[i];
                    found = true;
                    break;
                }
            }

            if (!found && hfrMode != CAM_HFR_MODE_OFF) {
                // Cannot find matching aspect ration from supported live snapshot list
                // choose the max dim from preview and video size
                CDBG("%s: Cannot find matching aspect ratio, choose max of preview or video size", __func__);
                params.getVideoSize(&m_LiveSnapshotSize.width, &m_LiveSnapshotSize.height);
                if (m_LiveSnapshotSize.width < width && m_LiveSnapshotSize.height < height) {
                    m_LiveSnapshotSize.width = width;
                    m_LiveSnapshotSize.height = height;
                }
            }
        }
    }
    CDBG("%s: live snapshot size %d x %d", __func__,
          m_LiveSnapshotSize.width, m_LiveSnapshotSize.height);

    return NO_ERROR;
!!!44192567.cpp!!!	setPreviewFormat(in params : QCameraParameters) : int32_t
    const char *str = params.getPreviewFormat();
    int32_t previewFormat =
        lookupAttr(PREVIEW_FORMATS_MAP,
                   sizeof(PREVIEW_FORMATS_MAP) / sizeof(QCameraMap),
                   str);
    if (previewFormat != NAME_NOT_FOUND) {
        mPreviewFormat = (cam_format_t)previewFormat;

        CameraParameters::setPreviewFormat(str);
        CDBG_HIGH("%s: format %d\n", __func__, mPreviewFormat);
        return NO_ERROR;
    }
    ALOGE("Invalid preview format value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44192695.cpp!!!	setPictureFormat(in params : QCameraParameters) : int32_t
    const char *str = params.getPictureFormat();
    int32_t pictureFormat =
        lookupAttr(PICTURE_TYPES_MAP,
                   sizeof(PICTURE_TYPES_MAP) / sizeof(QCameraMap),
                   str);
    if (pictureFormat != NAME_NOT_FOUND) {
        mPictureFormat = pictureFormat;

        CameraParameters::setPictureFormat(str);
        CDBG_HIGH("%s: format %d\n", __func__, mPictureFormat);
        return NO_ERROR;
    }
    ALOGE("%s: Invalid picture format value: %s", __func__, (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44192823.cpp!!!	setOrientation(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_ORIENTATION);

    if (str != NULL) {
        if (strcmp(str, portrait) == 0 || strcmp(str, landscape) == 0) {
            // Camera service needs this to decide if the preview frames and raw
            // pictures should be rotated.
            set(KEY_QC_ORIENTATION, str);
        } else {
            ALOGE("%s: Invalid orientation value: %s", __func__, str);
            return BAD_VALUE;
        }
    }
    return NO_ERROR;
!!!44192951.cpp!!!	setJpegThumbnailSize(in params : QCameraParameters) : int32_t
    int width = params.getInt(KEY_JPEG_THUMBNAIL_WIDTH);
    int height = params.getInt(KEY_JPEG_THUMBNAIL_HEIGHT);

    CDBG("requested jpeg thumbnail size %d x %d", width, height);

    int sizes_cnt = sizeof(THUMBNAIL_SIZES_MAP) / sizeof(cam_dimension_t);

    cam_dimension_t dim;

    // While taking livesnaphot match jpeg thumbnail size aspect
    // ratio to liveshot size. For normal snapshot match thumbnail
    // aspect ratio to picture size.
    if (m_bRecordingHint) {
        getLiveSnapshotSize(dim);
    } else {
        params.getPictureSize(&dim.width, &dim.height);
    }

    if (0 == dim.height) {
        ALOGE("%s: picture size is invalid (%d x %d)", __func__, dim.width, dim.height);
        return BAD_VALUE;
    }
    double picAspectRatio = (double)dim.width / (double)dim.height;

    int optimalWidth = 0, optimalHeight = 0;
    if (width != 0 || height != 0) {
        // If input jpeg thumnmail size is (0,0), meaning no thumbnail needed
        // hornor this setting.
        // Otherwise, search for optimal jpeg thumbnail size that has the same
        // aspect ratio as picture size.
        // If missign jpeg thumbnail size with appropriate aspect ratio,
        // just honor setting supplied by application.

        // Try to find a size matches aspect ratio and has the largest width
        for (int i = 0; i < sizes_cnt; i++) {
            if (THUMBNAIL_SIZES_MAP[i].height == 0) {
                // No thumbnail case, just skip
                continue;
            }
            double ratio =
                (double)THUMBNAIL_SIZES_MAP[i].width / THUMBNAIL_SIZES_MAP[i].height;
            if (fabs(ratio - picAspectRatio) > ASPECT_TOLERANCE)  {
                continue;
            }
            if (THUMBNAIL_SIZES_MAP[i].width > optimalWidth) {
                optimalWidth = THUMBNAIL_SIZES_MAP[i].width;
                optimalHeight = THUMBNAIL_SIZES_MAP[i].height;
            }
        }

        if ((0 == optimalWidth) || (0 == optimalHeight)) {
            // Optimal size not found
            // Validate thumbnail size
            for (int i = 0; i < sizes_cnt; i++) {
                if (width == THUMBNAIL_SIZES_MAP[i].width &&
                    height == THUMBNAIL_SIZES_MAP[i].height) {
                    optimalWidth = width;
                    optimalHeight = height;
                    break;
                }
            }
        }
    }

    set(KEY_JPEG_THUMBNAIL_WIDTH, optimalWidth);
    set(KEY_JPEG_THUMBNAIL_HEIGHT, optimalHeight);
    return NO_ERROR;
!!!44193079.cpp!!!	setJpegQuality(in params : QCameraParameters) : int32_t
    int32_t rc = NO_ERROR;
    int quality = params.getInt(KEY_JPEG_QUALITY);
    if (quality >= 0 && quality <= 100) {
        set(KEY_JPEG_QUALITY, quality);
    } else {
        ALOGE("%s: Invalid jpeg quality=%d", __func__, quality);
        rc = BAD_VALUE;
    }

    quality = params.getInt(KEY_JPEG_THUMBNAIL_QUALITY);
    if (quality >= 0 && quality <= 100) {
        set(KEY_JPEG_THUMBNAIL_QUALITY, quality);
    } else {
        ALOGE("%s: Invalid jpeg thumbnail quality=%d", __func__, quality);
        rc = BAD_VALUE;
    }
    return rc;
!!!44193207.cpp!!!	setPreviewFpsRange(in params : QCameraParameters) : int32_t
    int minFps,maxFps;
    int prevMinFps, prevMaxFps, vidMinFps, vidMaxFps;
    int rc = NO_ERROR;
    bool found = false, updateNeeded = false;

    CameraParameters::getPreviewFpsRange(&prevMinFps, &prevMaxFps);
    params.getPreviewFpsRange(&minFps, &maxFps);

    CDBG_HIGH("%s: FpsRange Values:(%d, %d)", __func__, prevMinFps, prevMaxFps);
    CDBG_HIGH("%s: Requested FpsRange Values:(%d, %d)", __func__, minFps, maxFps);

    //first check if we need to change fps because of HFR mode change
    updateNeeded = UpdateHFRFrameRate(params);
    CDBG_HIGH("%s: UpdateHFRFrameRate %d", __func__, updateNeeded);

    vidMinFps = m_hfrFpsRange.video_min_fps;
    vidMaxFps = m_hfrFpsRange.video_max_fps;

    if(minFps == prevMinFps && maxFps == prevMaxFps) {
        if ( m_bFixedFrameRateSet ) {
            minFps = params.getPreviewFrameRate() * 1000;
            maxFps = params.getPreviewFrameRate() * 1000;
            m_bFixedFrameRateSet = false;
        } else if (!updateNeeded) {
            CDBG_HIGH("%s: No change in FpsRange", __func__);
            rc = NO_ERROR;
            goto end;
        }
    }
    for(int i = 0; i < m_pCapability->fps_ranges_tbl_cnt; i++) {
        // if the value is in the supported list
        if(minFps >= m_pCapability->fps_ranges_tbl[i].min_fps * 1000 &&
           maxFps <= m_pCapability->fps_ranges_tbl[i].max_fps * 1000) {
            found = true;
            CDBG_HIGH("%s: FPS i=%d : minFps = %d, maxFps = %d"
                    " vidMinFps = %d, vidMaxFps = %d",
                    __func__, i, minFps, maxFps,
                    (int)m_hfrFpsRange.video_min_fps,
                    (int)m_hfrFpsRange.video_max_fps);
            if ((m_hfrFpsRange.video_min_fps == 0) ||
                    (m_hfrFpsRange.video_max_fps == 0)) {
                vidMinFps = minFps;
                vidMaxFps = maxFps;
            }
            else {
                vidMinFps = m_hfrFpsRange.video_min_fps;
                vidMaxFps = m_hfrFpsRange.video_max_fps;
            }

            setPreviewFpsRange(minFps, maxFps, vidMinFps, vidMaxFps);
            break;
        }
    }
    if(found == false){
        ALOGE("%s: error: FPS range value not supported", __func__);
        rc = BAD_VALUE;
    }
end:
    return rc;
!!!44193335.cpp!!!	setPreviewFrameRate(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_PREVIEW_FRAME_RATE);
    const char *prev_str = get(KEY_PREVIEW_FRAME_RATE);

    if ( str ) {
        if ( prev_str &&
             strcmp(str, prev_str)) {
            CDBG("%s: Requested Fixed Frame Rate %s", __func__, str);
            updateParamEntry(KEY_PREVIEW_FRAME_RATE, str);
            m_bFixedFrameRateSet = true;
        }
    }
    return NO_ERROR;
!!!44193463.cpp!!!	setAutoExposure(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_AUTO_EXPOSURE);
    const char *prev_str = get(KEY_QC_AUTO_EXPOSURE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setAutoExposure(str);
        }
    }
    return NO_ERROR;
!!!44193591.cpp!!!	setEffect(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_EFFECT);
    const char *prev_str = get(KEY_EFFECT);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0 ||
            m_bUpdateEffects == true ) {
            m_bUpdateEffects = false;
            return setEffect(str);
        }
    }
    return NO_ERROR;
!!!44193719.cpp!!!	setBrightness(in params : QCameraParameters) : int32_t
    int currentBrightness = getInt(KEY_QC_BRIGHTNESS);
    int brightness = params.getInt(KEY_QC_BRIGHTNESS);

    if(params.get(KEY_QC_BRIGHTNESS) == NULL) {
       CDBG_HIGH("%s: Brigtness not set by App ",__func__);
       return NO_ERROR;
    }
    if (currentBrightness !=  brightness) {
        if (brightness >= m_pCapability->brightness_ctrl.min_value &&
            brightness <= m_pCapability->brightness_ctrl.max_value) {
            CDBG(" new brightness value : %d ", brightness);
            return setBrightness(brightness);
        } else {
            ALOGE("%s: invalid value %d out of (%d, %d)",
                  __func__, brightness,
                  m_pCapability->brightness_ctrl.min_value,
                  m_pCapability->brightness_ctrl.max_value);
            return BAD_VALUE;
        }
    } else {
        CDBG("%s: No brightness value changed.", __func__);
        return NO_ERROR;
    }
!!!44193847.cpp!!!	setFocusMode(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_FOCUS_MODE);
    const char *prev_str = get(KEY_FOCUS_MODE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setFocusMode(str);
        }
    }
    return NO_ERROR;
!!!44193975.cpp!!!	setFocusPosition(in params : QCameraParameters) : int32_t
    const char *focus_str = params.get(KEY_FOCUS_MODE);

    if (NULL == focus_str) {
        return NO_ERROR;
    }

    CDBG("%s, current focus mode: %s", __func__, focus_str);
    if (strcmp(focus_str, FOCUS_MODE_MANUAL_POSITION)) {
        CDBG_HIGH("%s, dont set focus pos to back-end!", __func__);
        return NO_ERROR;
    }

    const char *pos = params.get(KEY_QC_MANUAL_FOCUS_POSITION);
    const char *prev_pos = get(KEY_QC_MANUAL_FOCUS_POSITION);
    const char *type = params.get(KEY_QC_MANUAL_FOCUS_POS_TYPE);
    const char *prev_type = get(KEY_QC_MANUAL_FOCUS_POS_TYPE);

    if ((pos != NULL) && (type != NULL)) {
        if (prev_pos  == NULL || (strcmp(pos, prev_pos) != 0) ||
                prev_type == NULL || (strcmp(type, prev_type) != 0)) {
            return setFocusPosition(type, pos);
        }
    }

    return NO_ERROR;
!!!44194103.cpp!!!	setSharpness(in params : QCameraParameters) : int32_t
    int shaprness = params.getInt(KEY_QC_SHARPNESS);
    int prev_sharp = getInt(KEY_QC_SHARPNESS);

    if(params.get(KEY_QC_SHARPNESS) == NULL) {
       CDBG_HIGH("%s: Sharpness not set by App ",__func__);
       return NO_ERROR;
    }
    if (prev_sharp !=  shaprness) {
        if((shaprness >= m_pCapability->sharpness_ctrl.min_value) &&
           (shaprness <= m_pCapability->sharpness_ctrl.max_value)) {
            CDBG(" new sharpness value : %d ", shaprness);
            return setSharpness(shaprness);
        } else {
            ALOGE("%s: invalid value %d out of (%d, %d)",
                  __func__, shaprness,
                  m_pCapability->sharpness_ctrl.min_value,
                  m_pCapability->sharpness_ctrl.max_value);
            return BAD_VALUE;
        }
    } else {
        CDBG("%s: No value change in shaprness", __func__);
        return NO_ERROR;
    }
!!!44194231.cpp!!!	setSaturation(in params : QCameraParameters) : int32_t
    int saturation = params.getInt(KEY_QC_SATURATION);
    int prev_sat = getInt(KEY_QC_SATURATION);

    if(params.get(KEY_QC_SATURATION) == NULL) {
       CDBG_HIGH("%s: Saturation not set by App ",__func__);
       return NO_ERROR;
    }
    if (prev_sat !=  saturation) {
        if((saturation >= m_pCapability->saturation_ctrl.min_value) &&
           (saturation <= m_pCapability->saturation_ctrl.max_value)) {
            CDBG(" new saturation value : %d ", saturation);
            return setSaturation(saturation);
        } else {
            ALOGE("%s: invalid value %d out of (%d, %d)",
                  __func__, saturation,
                  m_pCapability->saturation_ctrl.min_value,
                  m_pCapability->saturation_ctrl.max_value);
            return BAD_VALUE;
        }
    } else {
        CDBG("%s: No value change in saturation factor", __func__);
        return NO_ERROR;
    }
!!!44194359.cpp!!!	setContrast(in params : QCameraParameters) : int32_t
    int contrast = params.getInt(KEY_QC_CONTRAST);
    int prev_contrast = getInt(KEY_QC_CONTRAST);

    if(params.get(KEY_QC_CONTRAST) == NULL) {
       CDBG_HIGH("%s: Contrast not set by App ",__func__);
       return NO_ERROR;
    }
    if (prev_contrast !=  contrast) {
        if((contrast >= m_pCapability->contrast_ctrl.min_value) &&
           (contrast <= m_pCapability->contrast_ctrl.max_value)) {
            CDBG(" new contrast value : %d ", contrast);
            int32_t rc = setContrast(contrast);
            return rc;
        } else {
            ALOGE("%s: invalid value %d out of (%d, %d)",
                  __func__, contrast,
                  m_pCapability->contrast_ctrl.min_value,
                  m_pCapability->contrast_ctrl.max_value);
            return BAD_VALUE;
        }
    } else {
        CDBG("%s: No value change in contrast", __func__);
        return NO_ERROR;
    }
!!!44194487.cpp!!!	setSkinToneEnhancement(in params : QCameraParameters) : int32_t
    int sceFactor = params.getInt(KEY_QC_SCE_FACTOR);
    int prev_sceFactor = getInt(KEY_QC_SCE_FACTOR);

    if(params.get(KEY_QC_SCE_FACTOR) == NULL) {
       CDBG_HIGH("%s: Skintone enhancement not set by App ",__func__);
       return NO_ERROR;
    }
    if (prev_sceFactor != sceFactor) {
        if((sceFactor >= m_pCapability->sce_ctrl.min_value) &&
           (sceFactor <= m_pCapability->sce_ctrl.max_value)) {
            CDBG(" new Skintone Enhancement value : %d ", sceFactor);
            return setSkinToneEnhancement(sceFactor);
        } else {
            ALOGE("%s: invalid value %d out of (%d, %d)",
                  __func__, sceFactor,
                  m_pCapability->sce_ctrl.min_value,
                  m_pCapability->sce_ctrl.max_value);
            return BAD_VALUE;
        }
    } else {
        CDBG("%s: No value change in skintone enhancement factor", __func__);
        return NO_ERROR;
    }
!!!44194615.cpp!!!	setSceneDetect(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_SCENE_DETECT);
    const char *prev_str = get(KEY_QC_SCENE_DETECT);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setSceneDetect(str);
        }
    }
    return NO_ERROR;
!!!44194743.cpp!!!	setVideoHDR(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_VIDEO_HDR);
    const char *prev_str = get(KEY_QC_VIDEO_HDR);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setVideoHDR(str);
        }
    }
    return NO_ERROR;
!!!44194871.cpp!!!	setVtEnable(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_VT_ENABLE);
    const char *prev_str = get(KEY_QC_VT_ENABLE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setVtEnable(str);
        }
    }
    return NO_ERROR;
!!!44194999.cpp!!!	setZoom(in params : QCameraParameters) : int32_t
    if ((m_pCapability->zoom_supported == 0 ||
         m_pCapability->zoom_ratio_tbl_cnt == 0)) {
        CDBG_HIGH("%s: no zoom support", __func__);
        return NO_ERROR;
    }

    int zoomLevel = params.getInt(KEY_ZOOM);
    if((zoomLevel < 0) ||
       (zoomLevel >= m_pCapability->zoom_ratio_tbl_cnt)) {
        ALOGE("%s: invalid value %d out of (%d, %d)",
              __func__, zoomLevel,
              0, m_pCapability->zoom_ratio_tbl_cnt-1);
        return BAD_VALUE;
    }

    int prevZoomLevel = getInt(KEY_ZOOM);
    if (prevZoomLevel == zoomLevel) {
        CDBG("%s: No value change in contrast", __func__);
        return NO_ERROR;
    }

    return setZoom(zoomLevel);
!!!44195127.cpp!!!	setISOValue(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_ISO_MODE);
    const char *prev_str = get(KEY_QC_ISO_MODE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setISOValue(str);
        }
    }
    return NO_ERROR;
!!!44195255.cpp!!!	setContinuousISO(in params : QCameraParameters) : int32_t
    const char *iso = params.get(KEY_QC_ISO_MODE);
    CDBG("%s, current iso mode: %s", __func__, iso);

    if (iso != NULL) {
        if (strcmp(iso, ISO_MANUAL)) {
            CDBG("%s, dont set iso to back-end.", __func__);
            return NO_ERROR;
        }
    }

    const char *str = params.get(KEY_QC_CONTINUOUS_ISO);
    const char *prev_str = get(KEY_QC_CONTINUOUS_ISO);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setContinuousISO(str);
        }
    }
    return NO_ERROR;
!!!44195383.cpp!!!	setExposureTime(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_EXPOSURE_TIME);
    const char *prev_str = get(KEY_QC_EXPOSURE_TIME);
    if (str != NULL) {
        if (prev_str == NULL ||
                strcmp(str, prev_str) != 0) {
            return setExposureTime(str);
        }
    }

    return NO_ERROR;
!!!44195511.cpp!!!	setRotation(in params : QCameraParameters) : int32_t
    int rotation = params.getInt(KEY_ROTATION);
    if (rotation != -1) {
        if (rotation == 0 || rotation == 90 ||
            rotation == 180 || rotation == 270) {
            set(KEY_ROTATION, rotation);
        } else {
            ALOGE("Invalid rotation value: %d", rotation);
            return BAD_VALUE;
        }
    }
    return NO_ERROR;
!!!44195639.cpp!!!	setVideoRotation(in params : QCameraParameters) : int32_t
    int rotation = params.getInt(KEY_QC_VIDEO_ROTATION);
    if (rotation != -1) {
        if (rotation == 0 || rotation == 90 ||
            rotation == 180 || rotation == 270) {
            set(KEY_QC_VIDEO_ROTATION, rotation);
        } else {
            ALOGE("Invalid rotation value: %d", rotation);
            return BAD_VALUE;
        }
    }
    return NO_ERROR;
!!!44195767.cpp!!!	setFlash(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_FLASH_MODE);
    const char *prev_str = get(KEY_FLASH_MODE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setFlash(str);
        }
    }
    return NO_ERROR;
!!!44195895.cpp!!!	setAecLock(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_AUTO_EXPOSURE_LOCK);
    const char *prev_str = get(KEY_AUTO_EXPOSURE_LOCK);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setAecLock(str);
        }
    }
    return NO_ERROR;
!!!44196023.cpp!!!	setAwbLock(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_AUTO_WHITEBALANCE_LOCK);
    const char *prev_str = get(KEY_AUTO_WHITEBALANCE_LOCK);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setAwbLock(str);
        }
    }
    return NO_ERROR;
!!!44196151.cpp!!!	setMCEValue(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_MEMORY_COLOR_ENHANCEMENT);
    const char *prev_str = get(KEY_QC_MEMORY_COLOR_ENHANCEMENT);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setMCEValue(str);
        }
    }
    return NO_ERROR;
!!!44196279.cpp!!!	setDISValue(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_DIS);
    const char *prev_str = get(KEY_QC_DIS);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setDISValue(str);
        }
    }
    return NO_ERROR;
!!!44196407.cpp!!!	setLensShadeValue(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_LENSSHADE);
    const char *prev_str = get(KEY_QC_LENSSHADE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setLensShadeValue(str);
        }
    }
    return NO_ERROR;
!!!44196535.cpp!!!	setExposureCompensation(in params : QCameraParameters) : int32_t
    int expComp = params.getInt(KEY_EXPOSURE_COMPENSATION);
    int prev_expComp = getInt(KEY_EXPOSURE_COMPENSATION);

    if(params.get(KEY_EXPOSURE_COMPENSATION) == NULL) {
       CDBG_HIGH("%s: Exposure compensation not set by App ",__func__);
       return NO_ERROR;
    }
    if (prev_expComp != expComp) {
        if((expComp >= m_pCapability->exposure_compensation_min) &&
           (expComp <= m_pCapability->exposure_compensation_max)) {
            CDBG(" new Exposure Compensation value : %d ", expComp);
            return setExposureCompensation(expComp);
        } else {
            ALOGE("%s: invalid value %d out of (%d, %d)",
                  __func__, expComp,
                  m_pCapability->exposure_compensation_min,
                  m_pCapability->exposure_compensation_max);
            return BAD_VALUE;
        }
    } else {
        CDBG("%s: No value change in Exposure Compensation", __func__);
        return NO_ERROR;
    }
!!!44196663.cpp!!!	setWhiteBalance(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_WHITE_BALANCE);
    const char *prev_str = get(KEY_WHITE_BALANCE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setWhiteBalance(str);
        }
    }
    return NO_ERROR;
!!!44196791.cpp!!!	setManualWhiteBalance(in params : QCameraParameters) : int32_t
    int32_t rc = NO_ERROR;
    const char *wb_str = params.get(KEY_WHITE_BALANCE);
    CDBG("%s, current wb mode: %s", __func__, wb_str);

    if (wb_str != NULL) {
        if (strcmp(wb_str, WHITE_BALANCE_MANUAL)) {
            CDBG("%s, dont set cct to back-end.", __func__);
            return NO_ERROR;
        }
    }

    const char *value = params.get(KEY_QC_MANUAL_WB_VALUE);
    const char *prev_value = get(KEY_QC_MANUAL_WB_VALUE);
    const char *type = params.get(KEY_QC_MANUAL_WB_TYPE);
    const char *prev_type = get(KEY_QC_MANUAL_WB_TYPE);

    if ((value != NULL) && (type != NULL)) {
        if (prev_value  == NULL || (strcmp(value, prev_value) != 0) ||
                prev_type == NULL || (strcmp(type, prev_type) != 0)) {
            updateParamEntry(KEY_QC_MANUAL_WB_TYPE, type);
            updateParamEntry(KEY_QC_MANUAL_WB_VALUE, value);
            int32_t wb_type = atoi(type);
            if (wb_type == CAM_MANUAL_WB_MODE_CCT) {
                rc = setWBManualCCT(value);
            } else if (wb_type == CAM_MANUAL_WB_MODE_GAIN) {
                rc = setManualWBGains(value);
            } else {
                rc = BAD_VALUE;
            }
        }
    }
    return rc;
!!!44196919.cpp!!!	setAntibanding(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_ANTIBANDING);
    const char *prev_str = get(KEY_ANTIBANDING);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setAntibanding(str);
        }
    }
    return NO_ERROR;
!!!44197047.cpp!!!	setFocusAreas(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_FOCUS_AREAS);
    if (str != NULL) {
        int max_num_af_areas = getInt(KEY_MAX_NUM_FOCUS_AREAS);
        if(max_num_af_areas == 0) {
            ALOGE("%s: max num of AF area is 0, cannot set focus areas", __func__);
            return BAD_VALUE;
        }

        const char *prev_str = get(KEY_FOCUS_AREAS);
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setFocusAreas(str);
        }
    }
    return NO_ERROR;
!!!44197175.cpp!!!	setMeteringAreas(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_METERING_AREAS);
    if (str != NULL) {
        int max_num_mtr_areas = getInt(KEY_MAX_NUM_METERING_AREAS);
        if(max_num_mtr_areas == 0) {
            ALOGE("%s: max num of metering areas is 0, cannot set focus areas", __func__);
            return BAD_VALUE;
        }

        const char *prev_str = get(KEY_METERING_AREAS);
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setMeteringAreas(str);
        }
    }
    return NO_ERROR;
!!!44197303.cpp!!!	setSceneMode(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_SCENE_MODE);
    const char *prev_str = get(KEY_SCENE_MODE);
    CDBG_HIGH("%s: str - %s, prev_str - %s",__func__, str, prev_str);

    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {

            if(strcmp(str, SCENE_MODE_AUTO) == 0) {
                m_bSceneTransitionAuto = true;
            }
            if (strcmp(str, SCENE_MODE_HDR) == 0) {
                // If HDR is set from client  and the feature is not enabled in the backend, ignore it.
                if (m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_SENSOR_HDR) {
                    m_bSensorHDREnabled = true;
                    CDBG_HIGH("%s: Sensor HDR mode Enabled",__func__);

                }
                else if (m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_HDR) {
                    m_bHDREnabled = true;
                    CDBG_HIGH("%s: S/W HDR Enabled",__func__);
                }
                else {
                    return NO_ERROR;
                }
            } else {
                m_bHDREnabled = false;
                if (m_bSensorHDREnabled) {
                    m_bSensorHDREnabled = false;
                    m_bNeedRestart = true;
                    setSensorSnapshotHDR("off");
                }
            }

            if (m_bSensorHDREnabled) {
                setSensorSnapshotHDR("on");
                m_bNeedRestart = true;
            } else if ((m_bHDREnabled) ||
                ((prev_str != NULL) && (strcmp(prev_str, SCENE_MODE_HDR) == 0))) {
                CDBG_HIGH("%s: scene mode changed between HDR and non-HDR, need restart", __func__);

                m_bNeedRestart = true;
                // set if hdr 1x image is needed
                const char *need_hdr_1x = params.get(KEY_QC_HDR_NEED_1X);
                if (need_hdr_1x != NULL) {
                    if (strcmp(need_hdr_1x, VALUE_TRUE) == 0) {
                        m_bHDR1xFrameEnabled = true;
                    } else {
                        m_bHDR1xFrameEnabled = false;
                    }

                    updateParamEntry(KEY_QC_HDR_NEED_1X, need_hdr_1x);
                }

                AddSetParmEntryToBatch(m_pParamBuf,
                                       CAM_INTF_PARM_HDR_NEED_1X,
                                       sizeof(m_bHDR1xFrameEnabled),
                                       &m_bHDR1xFrameEnabled);
            }

            return setSceneMode(str);
        }
    }
    return NO_ERROR;
!!!44197431.cpp!!!	setSelectableZoneAf(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_SELECTABLE_ZONE_AF);
    const char *prev_str = get(KEY_QC_SELECTABLE_ZONE_AF);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setSelectableZoneAf(str);
        }
    }
    return NO_ERROR;
!!!44197559.cpp!!!	setAEBracket(in params : QCameraParameters) : int32_t
    if (isHDREnabled()) {
        CDBG_HIGH("%s: scene mode is HDR, overwrite AE bracket setting to off", __func__);
        return setAEBracket(AE_BRACKET_OFF);
    }

    const char *expStr = params.get(KEY_QC_CAPTURE_BURST_EXPOSURE);
    if (NULL != expStr && strlen(expStr) > 0) {
        set(KEY_QC_CAPTURE_BURST_EXPOSURE, expStr);
    } else {
        char prop[PROPERTY_VALUE_MAX];
        memset(prop, 0, sizeof(prop));
        property_get("persist.capture.burst.exposures", prop, "");
        if (strlen(prop) > 0) {
            set(KEY_QC_CAPTURE_BURST_EXPOSURE, prop);
        } else {
            remove(KEY_QC_CAPTURE_BURST_EXPOSURE);
        }
    }

    const char *str = params.get(KEY_QC_AE_BRACKET_HDR);
    const char *prev_str = get(KEY_QC_AE_BRACKET_HDR);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setAEBracket(str);
        }
    }
    return NO_ERROR;
!!!44197687.cpp!!!	setAFBracket(in params : QCameraParameters) : int32_t
    if ((m_pCapability->qcom_supported_feature_mask &
        CAM_QCOM_FEATURE_UBIFOCUS) == 0){
        CDBG_HIGH("%s: AF Bracketing is not supported",__func__);
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_AF_BRACKET);
    const char *prev_str = get(KEY_QC_AF_BRACKET);
    CDBG_HIGH("%s: str =%s & prev_str =%s",__func__, str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setAFBracket(str);
        }
    }
    return NO_ERROR;
!!!44197815.cpp!!!	setReFocus(in params : QCameraParameters) : int32_t
    if ((m_pCapability->qcom_supported_feature_mask &
            (CAM_QCOM_FEATURE_REFOCUS | CAM_QCOM_FEATURE_UBIFOCUS)) == 0) {
        ALOGD("%s: AF Bracketing is not supported",__func__);
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_RE_FOCUS);
    const char *prev_str = get(KEY_QC_RE_FOCUS);
    CDBG_HIGH("%s: str =%s & prev_str =%s",__func__, str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setReFocus(str);
        }
    }
    return NO_ERROR;
!!!44197943.cpp!!!	setChromaFlash(in params : QCameraParameters) : int32_t
    if ((m_pCapability->qcom_supported_feature_mask &
        CAM_QCOM_FEATURE_CHROMA_FLASH) == 0) {
        CDBG_HIGH("%s: Chroma Flash is not supported",__func__);
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_CHROMA_FLASH);
    const char *prev_str = get(KEY_QC_CHROMA_FLASH);
    CDBG_HIGH("%s: str =%s & prev_str =%s",__func__, str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setChromaFlash(str);
        }
    }
    return NO_ERROR;
!!!44198071.cpp!!!	setOptiZoom(in params : QCameraParameters) : int32_t
    if ((m_pCapability->qcom_supported_feature_mask &
        CAM_QCOM_FEATURE_OPTIZOOM) == 0){
        CDBG_HIGH("%s: Opti Zoom is not supported",__func__);
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_OPTI_ZOOM);
    const char *prev_str = get(KEY_QC_OPTI_ZOOM);
    CDBG_HIGH("%s: str =%s & prev_str =%s",__func__, str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setOptiZoom(str);
        }
    }
    return NO_ERROR;
!!!44198199.cpp!!!	setHDRMode(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_HDR_MODE);
    const char *prev_str = get(KEY_QC_HDR_MODE);
    uint32_t supported_hdr_modes = m_pCapability->qcom_supported_feature_mask &
          (CAM_QCOM_FEATURE_SENSOR_HDR | CAM_QCOM_FEATURE_HDR);

    CDBG_HIGH("%s: str =%s & prev_str =%s",__func__, str, prev_str);
    if (str != NULL) {
        if ((CAM_QCOM_FEATURE_SENSOR_HDR == supported_hdr_modes) &&
                (strncmp(str, HDR_MODE_SENSOR, strlen(HDR_MODE_SENSOR)))) {
            CDBG_HIGH("%s: Only sensor HDR is supported",__func__);
            return NO_ERROR;
        } else if  ((CAM_QCOM_FEATURE_HDR == supported_hdr_modes) &&
                (strncmp(str, HDR_MODE_SENSOR, strlen(HDR_MODE_MULTI_FRAME)))) {
            CDBG_HIGH("%s: Only multi frame HDR is supported",__func__);
            return NO_ERROR;
        } else if (!supported_hdr_modes) {
            CDBG_HIGH("%s: HDR is not supported",__func__);
            return NO_ERROR;
        }
        if (prev_str == NULL ||
                strcmp(str, prev_str) != 0) {
            return setHDRMode(str);
        }
    }

    return NO_ERROR;
!!!44198327.cpp!!!	setHDRNeed1x(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_HDR_NEED_1X);
    const char *prev_str = get(KEY_QC_HDR_NEED_1X);

    CDBG_HIGH("%s: str =%s & prev_str =%s", __func__, str, prev_str);
    if (str != NULL) {
        if (m_bHDRModeSensor) {
            CDBG_HIGH("%s: Only multi frame HDR supports 1x frame",__func__);
            return NO_ERROR;
        }
        if ((prev_str == NULL) || (strcmp(str, prev_str) != 0)) {
            return setHDRNeed1x(str);
        }
    }
    return NO_ERROR;
!!!44198455.cpp!!!	setTruePortrait(in params : QCameraParameters) : int32_t
    if ((m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_TRUEPORTRAIT) == 0) {
        CDBG("%s: True Portrait is not supported",__func__);
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_TRUE_PORTRAIT);
    const char *prev_str = get(KEY_QC_TRUE_PORTRAIT);
    CDBG_HIGH("%s: str =%s & prev_str =%s", __func__, str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setTruePortrait(str);
        }
    }
    return NO_ERROR;
!!!44198583.cpp!!!	setSeeMore(in params : QCameraParameters) : int32_t
    if ((m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_LLVD) == 0) {
        CDBG("%s: See more is not supported", __func__);
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_SEE_MORE);
    const char *prev_str = get(KEY_QC_SEE_MORE);
    CDBG_HIGH("%s: str =%s & prev_str =%s", __func__, str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL || strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setSeeMore(str);
        }
    }
    return NO_ERROR;
!!!44198711.cpp!!!	setStillMore(in params : QCameraParameters) : int32_t
    if ((m_pCapability->qcom_supported_feature_mask &
            CAM_QCOM_FEATURE_STILLMORE) == 0) {
        CDBG("%s: Stillmore is not supported",__func__);
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_STILL_MORE);
    const char *prev_str = get(KEY_QC_STILL_MORE);
    CDBG_HIGH("%s: str =%s & prev_str =%s", __func__, str, prev_str);
    if (str != NULL) {
        if (prev_str == NULL || strcmp(str, prev_str) != 0) {
            m_bNeedRestart = true;
            return setStillMore(str);
        }
    }
    return NO_ERROR;
!!!44198839.cpp!!!	setRedeyeReduction(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_REDEYE_REDUCTION);
    const char *prev_str = get(KEY_QC_REDEYE_REDUCTION);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setRedeyeReduction(str);
        }
    }
    return NO_ERROR;
!!!44198967.cpp!!!	setGpsLocation(in params : QCameraParameters) : int32_t
    const char *method = params.get(KEY_GPS_PROCESSING_METHOD);
    if (method) {
        set(KEY_GPS_PROCESSING_METHOD, method);
    }else {
        remove(KEY_GPS_PROCESSING_METHOD);
    }

    const char *latitude = params.get(KEY_GPS_LATITUDE);
    if (latitude) {
        set(KEY_GPS_LATITUDE, latitude);
    }else {
        remove(KEY_GPS_LATITUDE);
    }

    const char *latitudeRef = params.get(KEY_QC_GPS_LATITUDE_REF);
    if (latitudeRef) {
        set(KEY_QC_GPS_LATITUDE_REF, latitudeRef);
    }else {
        remove(KEY_QC_GPS_LATITUDE_REF);
    }

    const char *longitude = params.get(KEY_GPS_LONGITUDE);
    if (longitude) {
        set(KEY_GPS_LONGITUDE, longitude);
    }else {
        remove(KEY_GPS_LONGITUDE);
    }

    const char *longitudeRef = params.get(KEY_QC_GPS_LONGITUDE_REF);
    if (longitudeRef) {
        set(KEY_QC_GPS_LONGITUDE_REF, longitudeRef);
    }else {
        remove(KEY_QC_GPS_LONGITUDE_REF);
    }

    const char *altitudeRef = params.get(KEY_QC_GPS_ALTITUDE_REF);
    if (altitudeRef) {
        set(KEY_QC_GPS_ALTITUDE_REF, altitudeRef);
    }else {
        remove(KEY_QC_GPS_ALTITUDE_REF);
    }

    const char *altitude = params.get(KEY_GPS_ALTITUDE);
    if (altitude) {
        set(KEY_GPS_ALTITUDE, altitude);
    }else {
        remove(KEY_GPS_ALTITUDE);
    }

    const char *status = params.get(KEY_QC_GPS_STATUS);
    if (status) {
        set(KEY_QC_GPS_STATUS, status);
    } else {
        remove(KEY_QC_GPS_STATUS);
    }

    const char *timestamp = params.get(KEY_GPS_TIMESTAMP);
    if (timestamp) {
        set(KEY_GPS_TIMESTAMP, timestamp);
    }else {
        remove(KEY_GPS_TIMESTAMP);
    }
    return NO_ERROR;
!!!44199095.cpp!!!	setRecordingHint(in params : QCameraParameters) : int32_t
    const char * str = params.get(KEY_RECORDING_HINT);
    const char *prev_str = get(KEY_RECORDING_HINT);
    if (str != NULL) {
        if (prev_str == NULL || strcmp(str, prev_str) != 0) {
            int32_t value = lookupAttr(TRUE_FALSE_MODES_MAP,
                                       sizeof(TRUE_FALSE_MODES_MAP)/sizeof(QCameraMap),
                                       str);
            if(value != NAME_NOT_FOUND){
                updateParamEntry(KEY_RECORDING_HINT, str);
                setRecordingHintValue(value);
                if (getFaceDetectionOption() == true) {
                    setFaceDetection(value > 0 ? false : true, false);
                }
                return NO_ERROR;
            } else {
                ALOGE("Invalid recording hint value: %s", str);
                return BAD_VALUE;
            }
        }
    }
    return NO_ERROR;
!!!44199223.cpp!!!	setNoDisplayMode(in params : QCameraParameters) : int32_t
    const char *str_val  = params.get(KEY_QC_NO_DISPLAY_MODE);
    const char *prev_str = get(KEY_QC_NO_DISPLAY_MODE);
    if(str_val && strlen(str_val) > 0) {
        if (prev_str == NULL || strcmp(str_val, prev_str) != 0) {
            m_bNoDisplayMode = atoi(str_val);
            set(KEY_QC_NO_DISPLAY_MODE, str_val);
            m_bNeedRestart = true;
        }
    } else {
        m_bNoDisplayMode = false;
    }
    CDBG_HIGH("Param m_bNoDisplayMode = %d", m_bNoDisplayMode);
    return NO_ERROR;
!!!44199351.cpp!!!	setWaveletDenoise(in params : QCameraParameters) : int32_t
    const char *str_pf = params.getPictureFormat();
    int32_t pictureFormat =
        lookupAttr(PICTURE_TYPES_MAP,
                   sizeof(PICTURE_TYPES_MAP) / sizeof(QCameraMap),
                   str_pf);
    if (pictureFormat != NAME_NOT_FOUND) {
        if (CAM_FORMAT_YUV_422_NV16 == pictureFormat) {
            ALOGE("NV16 format isn't supported in denoise lib!");
            return setWaveletDenoise(DENOISE_OFF);
        }
    }
    const char *str = params.get(KEY_QC_DENOISE);
    const char *prev_str = get(KEY_QC_DENOISE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setWaveletDenoise(str);
        }
    }
    return NO_ERROR;
!!!44199479.cpp!!!	setTemporalDenoise(in params : QCameraParameters) : int32_t
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_CPP_TNR) == 0) {
        CDBG_HIGH("%s: TNR is not supported",__func__);
        return NO_ERROR;
    }
    const char *str = params.get(KEY_QC_TNR_MODE);
    const char *prev_str = get(KEY_QC_TNR_MODE);
    const char *video_str = params.get(KEY_QC_VIDEO_TNR_MODE);
    const char *video_prev_str = get(KEY_QC_VIDEO_TNR_MODE);

    if (m_bRecordingHint_new == true) {
        if (video_str) {
            if ((video_prev_str == NULL) || (strcmp(video_str, video_prev_str) != 0)) {
                if (!strcmp(video_str, VALUE_ON)) {
                    m_bTNRVideoOn = true;
                    m_bTNRPreviewOn = true;
                } else {
                    m_bTNRVideoOn = false;
                    m_bTNRPreviewOn = false;
                }
                updateParamEntry(KEY_QC_VIDEO_TNR_MODE, video_str);
            } else {
                return NO_ERROR;
            }
        } else {
            char video_value[PROPERTY_VALUE_MAX];
            memset(video_value, 0, sizeof(video_value));
            property_get("persist.camera.tnr.video", video_value, VALUE_OFF);
            if (!strcmp(video_value, VALUE_ON)) {
                m_bTNRVideoOn = true;
            } else {
                m_bTNRVideoOn = false;
            }
            updateParamEntry(KEY_QC_VIDEO_TNR_MODE, video_value);

            char preview_value[PROPERTY_VALUE_MAX];
            memset(preview_value, 0, sizeof(preview_value));
            property_get("persist.camera.tnr.preview", preview_value, video_value);
            if (!strcmp(preview_value, VALUE_ON)) {
                m_bTNRPreviewOn = true;
            } else {
                m_bTNRPreviewOn = false;
            }
            updateParamEntry(KEY_QC_TNR_MODE, preview_value);
        }

        cam_denoise_param_t temp;
        memset(&temp, 0, sizeof(temp));
        if (m_bTNRVideoOn || m_bTNRPreviewOn) {
            temp.denoise_enable = 1;
            temp.process_plates = getDenoiseProcessPlate(CAM_INTF_PARM_TEMPORAL_DENOISE);

            int32_t cds_mode = lookupAttr(CDS_MODES_MAP, PARAM_MAP_SIZE(CDS_MODES_MAP),
                    CDS_MODE_OFF);

            if (cds_mode != NAME_NOT_FOUND) {
                updateParamEntry(KEY_QC_VIDEO_CDS_MODE, CDS_MODE_OFF);
                if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_CDS_MODE, cds_mode)) {
                    ALOGE("%s:Failed CDS MODE to update table", __func__);
                    return BAD_VALUE;
                }
                CDBG("%s: CDS in video mode is set to = %s when TNR is enabled",
                        __func__, CDS_MODE_OFF);
                mCds_mode = cds_mode;
            } else {
                ALOGE("%s: Invalid argument for video CDS MODE %d", __func__, cds_mode);
            }
        }
        CDBG("%s: TNR enable in video mode = %d, plates = %d", __func__,
                temp.denoise_enable, temp.process_plates);
        if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_TEMPORAL_DENOISE, temp)) {
            return BAD_VALUE;
        }
    } else {
        if (str) {
            if ((prev_str == NULL) || (strcmp(str, prev_str) != 0)) {
                if (!strcmp(str, VALUE_ON)) {
                    m_bTNRPreviewOn = true;
                } else {
                    m_bTNRPreviewOn = false;
                }
                updateParamEntry(KEY_QC_TNR_MODE, str);
            } else {
                return NO_ERROR;
            }
        } else {
            char value[PROPERTY_VALUE_MAX];
            memset(value, 0, sizeof(value));
            property_get("persist.camera.tnr.preview", value, VALUE_OFF);
            if (!strcmp(value, VALUE_ON)) {
                m_bTNRPreviewOn = true;
            } else {
                m_bTNRPreviewOn = false;
            }
            updateParamEntry(KEY_QC_TNR_MODE, value);
        }
        cam_denoise_param_t temp;
        memset(&temp, 0, sizeof(temp));
        if (m_bTNRPreviewOn) {
            temp.denoise_enable = 1;
            temp.process_plates = getDenoiseProcessPlate(CAM_INTF_PARM_TEMPORAL_DENOISE);

            int32_t cds_mode = lookupAttr(CDS_MODES_MAP, PARAM_MAP_SIZE(CDS_MODES_MAP),
                    CDS_MODE_OFF);

            if (cds_mode != NAME_NOT_FOUND) {
                updateParamEntry(KEY_QC_CDS_MODE, CDS_MODE_OFF);
                if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_CDS_MODE, cds_mode)) {
                    ALOGE("%s:Failed CDS MODE to update table", __func__);
                    return BAD_VALUE;
                }
                CDBG("%s: CDS in snapshot mode is set to = %s when TNR is enabled",
                        __func__, CDS_MODE_OFF);
                mCds_mode = cds_mode;
            } else {
                ALOGE("%s: Invalid argument for snapshot CDS MODE %d", __func__, cds_mode);
            }
        }
        CDBG("%s: TNR enable in snapshot mode = %d, plates = %d", __func__,
                temp.denoise_enable, temp.process_plates);
        if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_TEMPORAL_DENOISE, temp)) {
            return BAD_VALUE;
        }
    }

    return NO_ERROR;
!!!44199607.cpp!!!	setZslMode(in params : QCameraParameters) : int32_t
    const char *str_val  = params.get(KEY_QC_ZSL);
    const char *prev_val  = get(KEY_QC_ZSL);

    if (str_val != NULL) {
        if (prev_val == NULL || strcmp(str_val, prev_val) != 0) {
            int32_t value = lookupAttr(ON_OFF_MODES_MAP,
                                       sizeof(ON_OFF_MODES_MAP)/sizeof(QCameraMap),
                                       str_val);
            if (value != NAME_NOT_FOUND) {
                set(KEY_QC_ZSL, str_val);
                m_bZslMode_new = (value > 0)? true : false;

                // ZSL mode changed, need restart preview
                m_bNeedRestart = true;

                return AddSetParmEntryToBatch(m_pParamBuf,
                                              CAM_INTF_PARM_ZSL_MODE,
                                              sizeof(value),
                                              &value);
            } else {
                ALOGE("Invalid ZSL mode value: %s", str_val);
                return BAD_VALUE;
            }
        }
    }
    return NO_ERROR;
!!!44199735.cpp!!!	setZslAttributes(in params : QCameraParameters) : int32_t
    // TODO: may switch to pure param instead of sysprop
    char prop[PROPERTY_VALUE_MAX];

    const char *str = params.get(KEY_QC_ZSL_BURST_INTERVAL);
    if (str != NULL) {
        set(KEY_QC_ZSL_BURST_INTERVAL, str);
    } else {
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.zsl.interval", prop, "1");
        set(KEY_QC_ZSL_BURST_INTERVAL, prop);
        CDBG_HIGH("%s: [ZSL Retro] burst interval: %s", __func__, prop);
    }

    str = params.get(KEY_QC_ZSL_BURST_LOOKBACK);
    if (str != NULL) {
        set(KEY_QC_ZSL_BURST_LOOKBACK, str);
    } else {
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.zsl.backlookcnt", prop, "2");
        set(KEY_QC_ZSL_BURST_LOOKBACK, prop);
        CDBG_HIGH("%s: [ZSL Retro] look back count: %s", __func__, prop);
    }

    str = params.get(KEY_QC_ZSL_QUEUE_DEPTH);
    if (str != NULL) {
        set(KEY_QC_ZSL_QUEUE_DEPTH, str);
    } else {
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.zsl.queuedepth", prop, "2");
        set(KEY_QC_ZSL_QUEUE_DEPTH, prop);
        CDBG_HIGH("%s: [ZSL Retro] queue depth: %s", __func__, prop);
    }

    return NO_ERROR;
!!!44199863.cpp!!!	setAutoHDR(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_AUTO_HDR_ENABLE);
    const char *prev_str = get(KEY_QC_AUTO_HDR_ENABLE);
    char prop[PROPERTY_VALUE_MAX];

    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.auto.hdr.enable", prop, VALUE_DISABLE);
    if (str != NULL) {
       if (prev_str == NULL ||
           strcmp(str, prev_str) != 0) {
           CDBG_HIGH("%s : Auto HDR set to: %s", __func__, str);
           return updateParamEntry(KEY_QC_AUTO_HDR_ENABLE, str);
       }
    } else {
       if (prev_str == NULL ||
           strcmp(prev_str, prop) != 0 ) {
           CDBG_HIGH("%s : Auto HDR set to: %s", __func__, prop);
           updateParamEntry(KEY_QC_AUTO_HDR_ENABLE, prop);
       }
    }

       return NO_ERROR;
!!!44199991.cpp!!!	setCameraMode(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_CAMERA_MODE);
    if (str != NULL) {
        set(KEY_QC_CAMERA_MODE, str);
    } else {
        remove(KEY_QC_CAMERA_MODE);
    }
    return NO_ERROR;
!!!44200119.cpp!!!	setSceneSelectionMode(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_SCENE_SELECTION);
    const char *prev_str = get(KEY_QC_SCENE_SELECTION);
    if (NULL != str) {
        if ((NULL == prev_str) || (strcmp(str, prev_str) != 0)) {
            int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                    sizeof(ENABLE_DISABLE_MODES_MAP)/sizeof(QCameraMap),
                    str);
            if (value != NAME_NOT_FOUND) {
                ALOGD("%s: Setting selection value %s", __func__, str);
                if (value && m_bZslMode_new) {
                    updateParamEntry(KEY_QC_SCENE_SELECTION, str);
                    m_bNeedRestart = true;
                    m_bSceneSelection = true;
                } else if (!value) {
                    updateParamEntry(KEY_QC_SCENE_SELECTION, str);
                    m_bNeedRestart = true;
                    m_bSceneSelection = false;
                } else {
                    ALOGE("%s: Trying to enable scene selection in non ZSL mode!!!",
                            __func__);
                    return BAD_VALUE;
                }
            } else {
                ALOGE("%s: Trying to configure invalid scene selection value: %s",
                        __func__,
                        str);
                return BAD_VALUE;
            }
        }
    }

    return NO_ERROR;
!!!44200247.cpp!!!	setFaceRecognition(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_FACE_RECOGNITION);
    const char *prev_str = get(KEY_QC_FACE_RECOGNITION);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            int maxFaces = params.getInt(KEY_QC_MAX_NUM_REQUESTED_FACES);
            return setFaceRecognition(str, maxFaces);
        }
    }
    return NO_ERROR;
!!!44200375.cpp!!!	setFlip(in params : QCameraParameters) : int32_t
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_FLIP) == 0) {
        CDBG_HIGH("%s: flip is not supported.", __func__);
        return NO_ERROR;
    }

    //check preview flip setting
    const char *str = params.get(KEY_QC_PREVIEW_FLIP);
    const char *prev_val = get(KEY_QC_PREVIEW_FLIP);
    if(str != NULL){
        if (prev_val == NULL || strcmp(str, prev_val) != 0) {
            int32_t value = lookupAttr(FLIP_MODES_MAP,
                                       sizeof(FLIP_MODES_MAP)/sizeof(QCameraMap),
                                       str);
            if(value != NAME_NOT_FOUND){
                set(KEY_QC_PREVIEW_FLIP, str);
                m_bPreviewFlipChanged = true;
            }
        }
    }

    // check video filp setting
    str = params.get(KEY_QC_VIDEO_FLIP);
    prev_val = get(KEY_QC_VIDEO_FLIP);
    if(str != NULL){
        if (prev_val == NULL || strcmp(str, prev_val) != 0) {
            int32_t value = lookupAttr(FLIP_MODES_MAP,
                                       sizeof(FLIP_MODES_MAP)/sizeof(QCameraMap),
                                       str);
            if(value != NAME_NOT_FOUND){
                set(KEY_QC_VIDEO_FLIP, str);
                m_bVideoFlipChanged = true;
            }
        }
    }

    // check picture filp setting
    str = params.get(KEY_QC_SNAPSHOT_PICTURE_FLIP);
    prev_val = get(KEY_QC_SNAPSHOT_PICTURE_FLIP);
    if(str != NULL){
        if (prev_val == NULL || strcmp(str, prev_val) != 0) {
            int32_t value = lookupAttr(FLIP_MODES_MAP,
                                       sizeof(FLIP_MODES_MAP)/sizeof(QCameraMap),
                                       str);
            if(value != NAME_NOT_FOUND){
                set(KEY_QC_SNAPSHOT_PICTURE_FLIP, str);
                m_bSnapshotFlipChanged = true;
            }
        }
    }

    return NO_ERROR;
!!!44200503.cpp!!!	setBurstNum(in params : QCameraParameters) : int32_t
    int nBurstNum = params.getInt(KEY_QC_SNAPSHOT_BURST_NUM);
    if (isAdvCamFeaturesEnabled()) {
        nBurstNum = 1;
    }
    if (nBurstNum <= 0) {
        // if burst number is not set in parameters,
        // read from sys prop
        char prop[PROPERTY_VALUE_MAX];
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.snapshot.number", prop, "0");
        nBurstNum = atoi(prop);
        if (nBurstNum <= 0) {
            nBurstNum = 1;
        }
    }
    set(KEY_QC_SNAPSHOT_BURST_NUM, nBurstNum);
    m_nBurstNum = nBurstNum;
    CDBG_HIGH("%s: [ZSL Retro] m_nBurstNum = %d", __func__, m_nBurstNum);
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_BURST_NUM,
                                  sizeof(nBurstNum),
                                  &nBurstNum);
!!!44200631.cpp!!!	setRetroActiveBurstNum(in params : QCameraParameters) : int32_t
    int32_t nBurstNum = params.getInt(KEY_QC_NUM_RETRO_BURST_PER_SHUTTER);
    CDBG_HIGH("%s:[ZSL Retro] m_nRetroBurstNum = %d", __func__, m_nRetroBurstNum);
    if (nBurstNum <= 0) {
        // if burst number is not set in parameters,
        // read from sys prop
        char prop[PROPERTY_VALUE_MAX];
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.retro.number", prop, "0");
        nBurstNum = atoi(prop);
        if (nBurstNum < 0) {
            nBurstNum = 0;
        }
    }

    set(KEY_QC_NUM_RETRO_BURST_PER_SHUTTER, nBurstNum);

    m_nRetroBurstNum = nBurstNum;
    CDBG_HIGH("%s: [ZSL Retro] m_nRetroBurstNum = %d", __func__, m_nRetroBurstNum);
    return NO_ERROR;
!!!44200759.cpp!!!	setBurstLEDOnPeriod(in params : QCameraParameters) : int32_t
    uint32_t nBurstLEDOnPeriod =
      params.getInt(KEY_QC_SNAPSHOT_BURST_LED_ON_PERIOD);
    //Check if the LED ON period is within limits
    if ((nBurstLEDOnPeriod <= 0) || (nBurstLEDOnPeriod > 800)) {
        // if burst led on period is not set in parameters,
        // read from sys prop
        char prop[PROPERTY_VALUE_MAX];
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.led.on.period", prop, "0");
        nBurstLEDOnPeriod = atoi(prop);
        if (nBurstLEDOnPeriod <= 0) {
            nBurstLEDOnPeriod = 100;
        }
    }

    set(KEY_QC_SNAPSHOT_BURST_LED_ON_PERIOD, nBurstLEDOnPeriod);
    m_nBurstLEDOnPeriod = nBurstLEDOnPeriod;
    CDBG_HIGH("%s: Burst LED on period  %d", __func__, nBurstLEDOnPeriod);
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_BURST_LED_ON_PERIOD,
                                  sizeof(nBurstLEDOnPeriod),
                                  &nBurstLEDOnPeriod);
!!!44200887.cpp!!!	setSnapshotFDReq(in params : QCameraParameters) : int32_t
    char prop[PROPERTY_VALUE_MAX];
    const char *str = params.get(KEY_QC_SNAPSHOT_FD_DATA);

    if(str != NULL){
        set(KEY_QC_SNAPSHOT_FD_DATA, str);
    }else{
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.snapshot.fd", prop, "0");
        set(KEY_QC_SNAPSHOT_FD_DATA, prop);
    }
    return NO_ERROR;
!!!44201015.cpp!!!	setStatsDebugMask() : int32_t
    uint32_t mask = 0;
    char value[PROPERTY_VALUE_MAX];

    property_get("persist.camera.stats.debug.mask", value, "0");
    mask = (uint32_t)atoi(value);

    CDBG_HIGH("%s: ctrl mask :%d", __func__, mask);

    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_STATS_DEBUG_MASK,
                                  sizeof(mask),
                                  &mask);
!!!44201143.cpp!!!	setPAAF() : int32_t
    uint32_t paaf = 0;
    char value[PROPERTY_VALUE_MAX];

    property_get("persist.camera.stats.af.paaf", value, "1");
    paaf = (uint32_t)atoi(value);

    ALOGE("%s: PAAF is: %s", __func__, paaf ? "ON": "OFF");

    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_STATS_AF_PAAF,
                                  sizeof(paaf),
                                  &paaf);
!!!44201271.cpp!!!	setTintlessValue(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_TINTLESS_ENABLE);
    const char *prev_str = get(KEY_QC_TINTLESS_ENABLE);
    char prop[PROPERTY_VALUE_MAX];

    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.tintless", prop, VALUE_DISABLE);
    if (str != NULL) {
        if (prev_str == NULL ||
            strcmp(str, prev_str) != 0) {
            return setTintlessValue(str);
        }
    } else {
        if (prev_str == NULL ||
            strcmp(prev_str, prop) != 0 ) {
            setTintlessValue(prop);
        }
    }

    return NO_ERROR;
!!!44201399.cpp!!!	setCDSMode(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_CDS_MODE);
    const char *prev_str = get(KEY_QC_CDS_MODE);
    char *cds_mode_str = NULL;
    int32_t rc = NO_ERROR;

    if (str) {
        if (!prev_str || !strcmp(str, prev_str)) {
            cds_mode_str = (char *)str;
        }
    } else {
        char prop[PROPERTY_VALUE_MAX];
        memset(prop, 0, sizeof(prop));
        property_get("persist.camera.CDS", prop, CDS_MODE_AUTO);
        cds_mode_str = prop;
    }

    if (cds_mode_str) {
        ALOGV("%s: Set CDS mode = %s", __func__, cds_mode_str);

        int32_t cds_mode = lookupAttr(CDS_MODES_MAP,
                                  sizeof(CDS_MODES_MAP) / sizeof(QCameraMap),
                                  cds_mode_str);

        rc = AddSetParmEntryToBatch(m_pParamBuf,
                                    CAM_INTF_PARM_CDS_MODE,
                                    sizeof(cds_mode),
                                    &cds_mode);
        if (rc != NO_ERROR) {
            ALOGE("%s:Failed CDS MODE to update table", __func__);
        }
    }
    return rc;
!!!44201527.cpp!!!	setMobicat(in params : QCameraParameters) : int32_t
    char value [PROPERTY_VALUE_MAX];
    property_get("persist.camera.mobicat", value, "0");
    bool enableMobi = atoi(value) > 0 ? true : false;
    int32_t ret = NO_ERROR;;

    if (enableMobi) {
        tune_cmd_t tune_cmd;
        tune_cmd.type = 2;
        tune_cmd.module = 0;
        tune_cmd.value = 1;

        ret = AddSetParmEntryToBatch(m_pParamBuf,
                                CAM_INTF_PARM_SET_VFE_COMMAND,
                                sizeof(tune_cmd_t),
                                &tune_cmd);
        if (NO_ERROR != ret) {
            return ret;
        }
        tune_cmd.module = 0;

        ret = AddSetParmEntryToBatch(m_pParamBuf,
                                CAM_INTF_PARM_SET_PP_COMMAND,
                                sizeof(tune_cmd_t),
                                &tune_cmd);
    }

    return ret;
!!!44201655.cpp!!!	setRdiMode(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_RDI_MODE);
    const char *prev_str = get(KEY_QC_RDI_MODE);
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));

    property_get("persist.camera.rdi.mode", prop, VALUE_DISABLE);
    if ((str != NULL) && (prev_str == NULL || strcmp(str, prev_str) != 0)) {
        ALOGD("%s:%d : RDI mode set to %s", __func__, __LINE__, str);
        setRdiMode(str);
    } else if (prev_str == NULL || strcmp(prev_str, prop) != 0 ) {
        ALOGD("%s:%d : RDI mode set to prop: %s", __func__, __LINE__, prop);
        setRdiMode(prop);
    }
    return NO_ERROR;
!!!44201783.cpp!!!	setSecureMode(in params : QCameraParameters) : int32_t
    const char *str = params.get(KEY_QC_SECURE_MODE);
    const char *prev_str = get(KEY_QC_SECURE_MODE);
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));

    property_get("persist.camera.secure.mode", prop, VALUE_DISABLE);
    if ((str != NULL) && (prev_str == NULL || strcmp(str, prev_str) != 0)) {
        ALOGD("%s : Secure mode set to KEY: %s", __func__, str);
        setSecureMode(str);
    } else if (prev_str == NULL || strcmp(prev_str, prop) != 0 ) {
        ALOGD("%s : Secure mode set to prop: %s", __func__, prop);
        setSecureMode(prop);
    }
    return NO_ERROR;
!!!44201911.cpp!!!	setAutoExposure(in autoExp : char) : int32_t
    if (autoExp != NULL) {
        int32_t value = lookupAttr(AUTO_EXPOSURE_MAP,
                                   sizeof(AUTO_EXPOSURE_MAP)/sizeof(AUTO_EXPOSURE_MAP[0]),
                                   autoExp);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting auto exposure %s", __func__, autoExp);
            updateParamEntry(KEY_QC_AUTO_EXPOSURE, autoExp);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_AEC_ALGO_TYPE,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid auto exposure value: %s", (autoExp == NULL) ? "NULL" : autoExp);
    return BAD_VALUE;
!!!44202039.cpp!!!	setPreviewFpsRange(in min_fps : int, in max_fps : int, in vid_min_fps : int, in vid_max_fps : int) : int32_t
    char str[32];
    char value[PROPERTY_VALUE_MAX];
    int fixedFpsValue;
    /*This property get value should be the fps that user needs*/
    property_get("persist.debug.set.fixedfps", value, "0");
    fixedFpsValue = atoi(value);

    CDBG_HIGH("%s: E minFps = %d, maxFps = %d , vid minFps = %d, vid maxFps = %d",
                __func__, min_fps, max_fps, vid_min_fps, vid_max_fps);

    if(fixedFpsValue != 0) {
      min_fps = (int)fixedFpsValue*1000;
      max_fps = (int)fixedFpsValue*1000;
    }
    snprintf(str, sizeof(str), "%d,%d", min_fps, max_fps);
    CDBG_HIGH("%s: Setting preview fps range %s", __func__, str);
    updateParamEntry(KEY_PREVIEW_FPS_RANGE, str);
    cam_fps_range_t fps_range;
    memset(&fps_range, 0x00, sizeof(cam_fps_range_t));
    fps_range.min_fps = min_fps / float (1000.0);
    fps_range.max_fps = max_fps / float (1000.0);
    fps_range.video_min_fps = vid_min_fps / float (1000.0);
    fps_range.video_max_fps = vid_max_fps / float (1000.0);


    CDBG_HIGH("%s: Updated: minFps = %d, maxFps = %d ,"
            " vid minFps = %d, vid maxFps = %d",
            __func__, min_fps, max_fps, vid_min_fps, vid_max_fps);

    if ( NULL != m_AdjustFPS ) {
        m_AdjustFPS->recalcFPSRange(min_fps, max_fps, vid_min_fps, vid_max_fps);
        CDBG_HIGH("%s: Thermal adjusted preview fps range %d,%d, %d, %d",
              __func__,
              min_fps,
              max_fps, vid_min_fps, vid_max_fps);
        fps_range.min_fps = min_fps;
        fps_range.max_fps = max_fps;
        fps_range.video_min_fps = vid_min_fps;
        fps_range.video_max_fps = vid_max_fps;

    }

    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_FPS_RANGE,
                                  sizeof(cam_fps_range_t),
                                  &fps_range);
!!!44202167.cpp!!!	setEffect(in effect : char) : int32_t
    if (effect != NULL) {
        int32_t value = lookupAttr(EFFECT_MODES_MAP,
                                   sizeof(EFFECT_MODES_MAP)/sizeof(QCameraMap),
                                   effect);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting effect %s", __func__, effect);
            updateParamEntry(KEY_EFFECT, effect);
            uint8_t prmEffect = static_cast<uint8_t>(value);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_EFFECT,
                                          sizeof(prmEffect),
                                          &prmEffect);
        }
    }
    ALOGE("Invalid effect value: %s", (effect == NULL) ? "NULL" : effect);
    return BAD_VALUE;
!!!44202295.cpp!!!	setBrightness(in brightness : int) : int32_t
    char val[16];
    sprintf(val, "%d", brightness);
    updateParamEntry(KEY_QC_BRIGHTNESS, val);

    int32_t value = brightness;
    CDBG_HIGH("%s: Setting brightness %s", __func__, val);
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_BRIGHTNESS,
                                  sizeof(value),
                                  &value);
!!!44202423.cpp!!!	setFocusMode(in focusMode : char) : int32_t
    int32_t rc;
    if (focusMode != NULL) {
        int32_t value = lookupAttr(FOCUS_MODES_MAP,
                                   sizeof(FOCUS_MODES_MAP)/sizeof(QCameraMap),
                                   focusMode);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting focus mode %s", __func__, focusMode);
            uint8_t fm = (uint8_t)value;
            mFocusMode = (cam_focus_mode_type)value;

            updateParamEntry(KEY_FOCUS_MODE, focusMode);
            rc = AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_FOCUS_MODE,
                                          sizeof(fm),
                                          &fm);
            if (strcmp(focusMode,"infinity")==0){
                set(QCameraParameters::KEY_FOCUS_DISTANCES, "Infinity,Infinity,Infinity");
            }
            return rc;
        }
    }
    ALOGE("Invalid focus mode value: %s", (focusMode == NULL) ? "NULL" : focusMode);
    return BAD_VALUE;
!!!44202551.cpp!!!	setFocusPosition(in typeStr : char, in posStr : char) : int32_t
    CDBG_HIGH("%s, type:%s, pos: %s", __func__, typeStr, posStr);
    int32_t type = atoi(typeStr);
    float pos = (float) atof(posStr);

    if ((type >= CAM_MANUAL_FOCUS_MODE_INDEX) &&
            (type < CAM_MANUAL_FOCUS_MODE_MAX)) {
        // get max and min focus position from m_pCapability
        int32_t minFocusPos = (int32_t) m_pCapability->min_focus_pos[type];
        int32_t maxFocusPos = (int32_t) m_pCapability->max_focus_pos[type];
        CDBG_HIGH("%s, focusPos min: %d, max: %d", __func__, minFocusPos, maxFocusPos);

        if (pos >= minFocusPos && pos <= maxFocusPos) {
            updateParamEntry(KEY_QC_MANUAL_FOCUS_POS_TYPE, typeStr);
            updateParamEntry(KEY_QC_MANUAL_FOCUS_POSITION, posStr);

            cam_manual_focus_parm_t manual_focus;
            manual_focus.flag = (cam_manual_focus_mode_type)type;
            if (manual_focus.flag == CAM_MANUAL_FOCUS_MODE_DIOPTER) {
                manual_focus.af_manual_diopter = pos;
            } else if (manual_focus.flag == CAM_MANUAL_FOCUS_MODE_RATIO) {
                manual_focus.af_manual_lens_position_ratio = (int32_t) pos;
            } else if (manual_focus.flag == CAM_MANUAL_FOCUS_MODE_INDEX) {
                manual_focus.af_manual_lens_position_index = (int32_t) pos;
            } else {
                manual_focus.af_manual_lens_position_dac = (int32_t) pos;
            }

            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_MANUAL_FOCUS_POS,
                    manual_focus)) {
                return BAD_VALUE;
            }
            return NO_ERROR;
        }
    }

    ALOGE("%s, invalid params, type:%d, pos: %d", __func__, type, pos);
    return BAD_VALUE;
!!!44202679.cpp!!!	setSharpness(in sharpness : int) : int32_t
    char val[16];
    sprintf(val, "%d", sharpness);
    updateParamEntry(KEY_QC_SHARPNESS, val);
    CDBG_HIGH("%s: Setting sharpness %s", __func__, val);

    int32_t value = sharpness;
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_SHARPNESS,
                                  sizeof(value),
                                  &value);
!!!44202807.cpp!!!	setSaturation(in saturation : int) : int32_t
    char val[16];
    sprintf(val, "%d", saturation);
    updateParamEntry(KEY_QC_SATURATION, val);
    CDBG_HIGH("%s: Setting saturation %s", __func__, val);

    int32_t value = saturation;
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_SATURATION,
                                  sizeof(value),
                                  &value);
!!!44202935.cpp!!!	setContrast(in contrast : int) : int32_t
    char val[16];
    sprintf(val, "%d", contrast);
    updateParamEntry(KEY_QC_CONTRAST, val);
    CDBG_HIGH("%s: Setting contrast %s", __func__, val);

    int32_t value = contrast;
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_CONTRAST,
                                  sizeof(value),
                                  &value);
!!!44203063.cpp!!!	setSkinToneEnhancement(in sceFactor : int) : int32_t
    char val[16];
    sprintf(val, "%d", sceFactor);
    updateParamEntry(KEY_QC_SCE_FACTOR, val);
    CDBG_HIGH("%s: Setting skintone enhancement %s", __func__, val);

    int32_t value = sceFactor;
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_SCE_FACTOR,
                                  sizeof(value),
                                  &value);
!!!44203191.cpp!!!	setSceneDetect(in sceneDetect : char) : int32_t
    if (sceneDetect != NULL) {
        int32_t value = lookupAttr(ON_OFF_MODES_MAP,
                                   sizeof(ON_OFF_MODES_MAP)/sizeof(QCameraMap),
                                   sceneDetect);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting Scene Detect %s", __func__, sceneDetect);
            updateParamEntry(KEY_QC_SCENE_DETECT, sceneDetect);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_ASD_ENABLE,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid Scene Detect value: %s",
          (sceneDetect == NULL) ? "NULL" : sceneDetect);
    return BAD_VALUE;
!!!44203319.cpp!!!	setVideoHDR(in videoHDR : char) : int32_t
    if (videoHDR != NULL) {
        int32_t value = lookupAttr(ON_OFF_MODES_MAP,
                                   sizeof(ON_OFF_MODES_MAP)/sizeof(QCameraMap),
                                   videoHDR);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting Video HDR %s", __func__, videoHDR);
            updateParamEntry(KEY_QC_VIDEO_HDR, videoHDR);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_VIDEO_HDR,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid Video HDR value: %s",
          (videoHDR == NULL) ? "NULL" : videoHDR);
    return BAD_VALUE;
!!!44203447.cpp!!!	setSensorSnapshotHDR(in snapshotHDR : char) : int32_t
    if (snapshotHDR != NULL) {
        int32_t value = lookupAttr(ON_OFF_MODES_MAP,
                                   sizeof(ON_OFF_MODES_MAP)/sizeof(QCameraMap),
                                   snapshotHDR);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting Sensor Snapshot HDR %s", __func__, snapshotHDR);
            updateParamEntry(KEY_QC_SENSOR_HDR, snapshotHDR);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_SENSOR_HDR,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid Snapshot HDR value: %s",
          (snapshotHDR == NULL) ? "NULL" : snapshotHDR);
    return BAD_VALUE;

!!!44203575.cpp!!!	setVtEnable(in vtEnable : char) : int32_t
    if (vtEnable != NULL) {
        int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                                   sizeof(ENABLE_DISABLE_MODES_MAP)/sizeof(QCameraMap),
                                   vtEnable);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting Vt Enable %s", __func__, vtEnable);
            m_bAVTimerEnabled = true;
            updateParamEntry(KEY_QC_VT_ENABLE, vtEnable);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_VT,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid Vt Enable value: %s",
          (vtEnable == NULL) ? "NULL" : vtEnable);
    m_bAVTimerEnabled = false;
    return BAD_VALUE;
!!!44203703.cpp!!!	setZoom(in zoom_level : int) : int32_t
    char val[16];
    sprintf(val, "%d", zoom_level);
    updateParamEntry(KEY_ZOOM, val);

    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_ZOOM,
                                  sizeof(zoom_level),
                                  &zoom_level);
!!!44203831.cpp!!!	setISOValue(in isoValue : char) : int32_t
    if (isoValue != NULL) {
        int32_t value = lookupAttr(ISO_MODES_MAP,
                                   sizeof(ISO_MODES_MAP)/sizeof(QCameraMap),
                                   isoValue);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting ISO value %s", __func__, isoValue);
            updateParamEntry(KEY_QC_ISO_MODE, isoValue);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_ISO,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid ISO value: %s",
          (isoValue == NULL) ? "NULL" : isoValue);
    return BAD_VALUE;
!!!44203959.cpp!!!	setContinuousISO(in isoValue : char) : int32_t
    char iso[PROPERTY_VALUE_MAX];
    int32_t continous_iso = 0;

    // Check if continuous ISO is set through setproperty
    property_get("persist.camera.continuous.iso", iso, "");
    if (strlen(iso) > 0) {
        continous_iso = atoi(iso);
    } else {
        continous_iso = atoi(isoValue);
    }

    if ((continous_iso >= 0) &&
            (continous_iso <= m_pCapability->sensitivity_range.max_sensitivity)) {
        CDBG_HIGH("%s: Setting continuous ISO value %d", __func__, continous_iso);
        updateParamEntry(KEY_QC_CONTINUOUS_ISO, isoValue);
        if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_ISO, continous_iso)) {
            return BAD_VALUE;
        }
        return NO_ERROR;
    }
    ALOGE("Invalid iso value: %d", continous_iso);
    return BAD_VALUE;
!!!44204087.cpp!!!	setExposureTime(in expTimeStr : char) : int32_t
    if (expTimeStr != NULL) {
        double expTimeMs = atof(expTimeStr);
        //input is in milli seconds. Convert to nano sec for backend
        int64_t expTimeNs = ((int64_t)expTimeMs)*1000000L;

        // expTime == 0 means not to use manual exposure time.
        if ((0 <= expTimeNs) &&
                ((expTimeNs == 0) ||
                ((expTimeNs >= m_pCapability->exposure_time_range[0]) &&
                (expTimeNs <= m_pCapability->exposure_time_range[1])))) {
            CDBG_HIGH("%s, exposure time: %f ms", __func__, expTimeMs);
            updateParamEntry(KEY_QC_EXPOSURE_TIME, expTimeStr);
            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_EXPOSURE_TIME,
                    (uint64_t)expTimeNs)) {
                return BAD_VALUE;
            }
            return NO_ERROR;
        }
    }

    ALOGE("Invalid exposure time, value: %s",
          (expTimeStr == NULL) ? "NULL" : expTimeStr);
    return BAD_VALUE;
!!!44204215.cpp!!!	setFlash(in flashStr : char) : int32_t
    if (flashStr != NULL) {
        int32_t value = lookupAttr(FLASH_MODES_MAP,
                                   sizeof(FLASH_MODES_MAP)/sizeof(QCameraMap),
                                   flashStr);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting Flash value %s", __func__, flashStr);

            if (NULL != m_pTorch && !m_bRecordingHint_new) {
                if ( value == CAM_FLASH_MODE_TORCH ) {
                    m_pTorch->prepareTorchCamera();
                } else {
                    m_bReleaseTorchCamera = true;
                }
            }

            updateParamEntry(KEY_FLASH_MODE, flashStr);
            mFlashValue = value;
            return NO_ERROR;
        }
    }
    ALOGE("Invalid flash value: %s", (flashStr == NULL) ? "NULL" : flashStr);
    return BAD_VALUE;
!!!44204343.cpp!!!	setAwbLock(in awbLockStr : char) : int32_t
    if (awbLockStr != NULL) {
        int32_t value = lookupAttr(TRUE_FALSE_MODES_MAP,
                                   sizeof(TRUE_FALSE_MODES_MAP)/sizeof(QCameraMap),
                                   awbLockStr);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting AWBLock value %s", __func__, awbLockStr);
            updateParamEntry(KEY_AUTO_WHITEBALANCE_LOCK, awbLockStr);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_AWB_LOCK,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid AWBLock value: %s", (awbLockStr == NULL) ? "NULL" : awbLockStr);
    return BAD_VALUE;
!!!44204471.cpp!!!	setMCEValue(in mceStr : char) : int32_t
    if (mceStr != NULL) {
        int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                                   sizeof(ENABLE_DISABLE_MODES_MAP)/sizeof(QCameraMap),
                                   mceStr);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting AWBLock value %s", __func__, mceStr);
            updateParamEntry(KEY_QC_MEMORY_COLOR_ENHANCEMENT, mceStr);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_MCE,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid MCE value: %s", (mceStr == NULL) ? "NULL" : mceStr);
    return BAD_VALUE;
!!!44204599.cpp!!!	setDISValue(in disStr : char) : int32_t
    if (disStr != NULL) {
        int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                                   sizeof(ENABLE_DISABLE_MODES_MAP)/sizeof(QCameraMap),
                                   disStr);
        if (value != NAME_NOT_FOUND) {
            //For some IS types (like EIS 2.0), when DIS value is changed, we need to restart
            //preview because of topology change in backend. But, for now, restart preview
            //for all IS types.
            m_bNeedRestart = true;
            CDBG("%s: Setting DIS value %s", __func__, disStr);
            updateParamEntry(KEY_QC_DIS, disStr);
            if (!(strcmp(disStr,"enable"))) {
                m_bDISEnabled = true;
            } else {
                m_bDISEnabled = false;
            }
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_DIS_ENABLE,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid DIS value: %s", (disStr == NULL) ? "NULL" : disStr);
    m_bDISEnabled = false;
    return BAD_VALUE;
!!!44204727.cpp!!!	setHighFrameRate(in hfrMode : int32_t) : int32_t
    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_HFR, hfrMode)) {
        return BAD_VALUE;
    }

    return NO_ERROR;
!!!44204855.cpp!!!	setLensShadeValue(in lensShadeStr : char) : int32_t
    if (lensShadeStr != NULL) {
        int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                                   sizeof(ENABLE_DISABLE_MODES_MAP)/sizeof(QCameraMap),
                                   lensShadeStr);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting LensShade value %s", __func__, lensShadeStr);
            updateParamEntry(KEY_QC_LENSSHADE, lensShadeStr);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_ROLLOFF,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid LensShade value: %s",
          (lensShadeStr == NULL) ? "NULL" : lensShadeStr);
    return BAD_VALUE;
!!!44204983.cpp!!!	setExposureCompensation(in expComp : int) : int32_t
    char val[16];
    sprintf(val, "%d", expComp);
    updateParamEntry(KEY_EXPOSURE_COMPENSATION, val);

    // Don't need to pass step as part of setParameter because
    // camera daemon is already aware of it.
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_EXPOSURE_COMPENSATION,
                                  sizeof(expComp),
                                  &expComp);
!!!44205111.cpp!!!	setWhiteBalance(in wbStr : char) : int32_t
    if (wbStr != NULL) {
        int32_t value = lookupAttr(WHITE_BALANCE_MODES_MAP,
                                   sizeof(WHITE_BALANCE_MODES_MAP)/sizeof(QCameraMap),
                                   wbStr);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting WhiteBalance value %s", __func__, wbStr);
            updateParamEntry(KEY_WHITE_BALANCE, wbStr);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_WHITE_BALANCE,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid WhiteBalance value: %s", (wbStr == NULL) ? "NULL" : wbStr);
    return BAD_VALUE;
!!!44205239.cpp!!!	setWBManualCCT(in cctStr : char) : int32_t
    if (cctStr != NULL) {
        int32_t cctVal = atoi(cctStr);
        int32_t minCct = m_pCapability->min_wb_cct; /* 2000K */
        int32_t maxCct = m_pCapability->max_wb_cct; /* 8000K */

        if (cctVal >= minCct && cctVal <= maxCct) {
            CDBG_HIGH("%s, cct value: %d", __func__, cctVal);
            updateParamEntry(KEY_QC_WB_MANUAL_CCT, cctStr);
            cam_manual_wb_parm_t manual_wb;
            manual_wb.type = CAM_MANUAL_WB_MODE_CCT;
            manual_wb.cct = cctVal;
            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_WB_MANUAL, manual_wb)) {
                return BAD_VALUE;
            }
            return NO_ERROR;
        }
    }

    ALOGE("Invalid cct, value: %s",
            (cctStr == NULL) ? "NULL" : cctStr);
    return BAD_VALUE;
!!!44205367.cpp!!!	setManualWBGains(in gainStr : char) : int32_t
    int32_t rc = NO_ERROR;
    if (gainStr != NULL) {
        float r_gain, g_gain, b_gain;
        rc = parseGains(gainStr, r_gain, g_gain, b_gain);
        if (rc != NO_ERROR) {
            return rc;
        }

        float minGain = m_pCapability->min_wb_gain;
        float maxGain = m_pCapability->max_wb_gain;

        if ((r_gain >= minGain) && (r_gain <= maxGain) &&
                (g_gain >= minGain) && (g_gain <= maxGain) &&
                (b_gain >= minGain) && (b_gain <= maxGain)) {
            CDBG_HIGH("%s, setting rgb gains: %s", __func__, gainStr);
            updateParamEntry(KEY_QC_MANUAL_WB_GAINS, gainStr);
            cam_manual_wb_parm_t manual_wb;
            manual_wb.type = CAM_MANUAL_WB_MODE_GAIN;
            manual_wb.gains.r_gain = r_gain;
            manual_wb.gains.g_gain = g_gain;
            manual_wb.gains.b_gain = b_gain;
            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_WB_MANUAL, manual_wb)) {
                return BAD_VALUE;
            }
            return NO_ERROR;
        }
    }

    CDBG_HIGH("Invalid manual wb gains: %s",
          (gainStr == NULL) ? "NULL" : gainStr);
    return BAD_VALUE;
!!!44205495.cpp!!!	setAntibanding(in antiBandingStr : char) : int32_t
    if (antiBandingStr != NULL) {
        int32_t value = lookupAttr(ANTIBANDING_MODES_MAP,
                                   sizeof(ANTIBANDING_MODES_MAP)/sizeof(QCameraMap),
                                   antiBandingStr);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting AntiBanding value %s", __func__, antiBandingStr);
            updateParamEntry(KEY_ANTIBANDING, antiBandingStr);
            if(value == CAM_ANTIBANDING_MODE_AUTO) {
               value = getAutoFlickerMode();
            }
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_ANTIBANDING,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid AntiBanding value: %s",
          (antiBandingStr == NULL) ? "NULL" : antiBandingStr);
    return BAD_VALUE;
!!!44205623.cpp!!!	setFocusAreas(in focusAreasStr : char) : int32_t
    if (m_pCapability->max_num_focus_areas == 0 ||
        focusAreasStr == NULL) {
        CDBG("%s: Parameter string is null", __func__);
        return NO_ERROR;
    }

    cam_area_t *areas = (cam_area_t *)malloc(sizeof(cam_area_t) * m_pCapability->max_num_focus_areas);
    if (NULL == areas) {
        ALOGE("%s: No memory for areas", __func__);
        return NO_MEMORY;
    }
    memset(areas, 0, sizeof(cam_area_t) * m_pCapability->max_num_focus_areas);
    int num_areas_found = 0;
    if (parseCameraAreaString(focusAreasStr,
                              m_pCapability->max_num_focus_areas,
                              areas,
                              num_areas_found) != NO_ERROR) {
        ALOGE("%s: Failed to parse the string: %s", __func__, focusAreasStr);
        free(areas);
        return BAD_VALUE;
    }

    if (validateCameraAreas(areas, num_areas_found) == false) {
        ALOGE("%s: invalid areas specified : %s", __func__, focusAreasStr);
        free(areas);
        return BAD_VALUE;
    }

    updateParamEntry(KEY_FOCUS_AREAS, focusAreasStr);

    //for special area string (0, 0, 0, 0, 0), set the num_areas_found to 0,
    //so no action is takenby the lower layer
    if (num_areas_found == 1 &&
        areas[0].rect.left == 0 &&
        areas[0].rect.top == 0 &&
        areas[0].rect.width == 0 &&
        areas[0].rect.height == 0 &&
        areas[0].weight == 0) {
        num_areas_found = 0;
    }

    int previewWidth, previewHeight;
    getPreviewSize(&previewWidth, &previewHeight);
    cam_roi_info_t af_roi_value;
    memset(&af_roi_value, 0, sizeof(cam_roi_info_t));
    af_roi_value.num_roi = num_areas_found;
    for (int i = 0; i < num_areas_found; i++) {
        CDBG_HIGH("%s: FocusArea[%d] = (%d, %d, %d, %d)",
              __func__, i, (areas[i].rect.top), (areas[i].rect.left),
              (areas[i].rect.width), (areas[i].rect.height));

        //transform the coords from (-1000, 1000) to (0, previewWidth or previewHeight)
        af_roi_value.roi[i].left = (int32_t)((areas[i].rect.left + 1000.0f) * (previewWidth / 2000.0f));
        af_roi_value.roi[i].top = (int32_t)((areas[i].rect.top + 1000.0f) * (previewHeight / 2000.0f));
        af_roi_value.roi[i].width = (int32_t)(areas[i].rect.width * previewWidth / 2000.0f);
        af_roi_value.roi[i].height = (int32_t)(areas[i].rect.height * previewHeight / 2000.0f);
        af_roi_value.weight[i] = areas[i].weight;
    }
    free(areas);
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_AF_ROI,
                                  sizeof(af_roi_value),
                                  &af_roi_value);
!!!44205751.cpp!!!	setMeteringAreas(in meteringAreasStr : char) : int32_t
    if (m_pCapability->max_num_metering_areas == 0 ||
        meteringAreasStr == NULL) {
        CDBG("%s: Parameter string is null", __func__);
        return NO_ERROR;
    }

    cam_area_t *areas = (cam_area_t *)malloc(sizeof(cam_area_t) * m_pCapability->max_num_metering_areas);
    if (NULL == areas) {
        ALOGE("%s: No memory for areas", __func__);
        return NO_MEMORY;
    }
    memset(areas, 0, sizeof(cam_area_t) * m_pCapability->max_num_metering_areas);
    int num_areas_found = 0;
    if (parseCameraAreaString(meteringAreasStr,
                              m_pCapability->max_num_metering_areas,
                              areas,
                              num_areas_found) < 0) {
        ALOGE("%s: Failed to parse the string: %s", __func__, meteringAreasStr);
        free(areas);
        return BAD_VALUE;
    }

    if (validateCameraAreas(areas, num_areas_found) == false) {
        ALOGE("%s: invalid areas specified : %s", __func__, meteringAreasStr);
        free(areas);
        return BAD_VALUE;
    }

    updateParamEntry(KEY_METERING_AREAS, meteringAreasStr);

    //for special area string (0, 0, 0, 0, 0), set the num_areas_found to 0,
    //so no action is takenby the lower layer
    if (num_areas_found == 1 &&
        areas[0].rect.left == 0 &&
        areas[0].rect.top == 0 &&
        areas[0].rect.width == 0 &&
        areas[0].rect.height == 0 &&
        areas[0].weight == 0) {
        num_areas_found = 0;
    }
    cam_set_aec_roi_t aec_roi_value;
    int previewWidth, previewHeight;
    getPreviewSize(&previewWidth, &previewHeight);

    memset(&aec_roi_value, 0, sizeof(cam_set_aec_roi_t));
    if (num_areas_found > 0) {
        aec_roi_value.aec_roi_enable = CAM_AEC_ROI_ON;
        aec_roi_value.aec_roi_type = CAM_AEC_ROI_BY_COORDINATE;

        for (int i = 0; i < num_areas_found; i++) {
            CDBG_HIGH("%s: MeteringArea[%d] = (%d, %d, %d, %d)",
                  __func__, i, (areas[i].rect.top), (areas[i].rect.left),
                  (areas[i].rect.width), (areas[i].rect.height));

            //transform the coords from (-1000, 1000) to (0, previewWidth or previewHeight)
            aec_roi_value.cam_aec_roi_position.coordinate[i].x =
                (uint32_t)(((areas[i].rect.left + areas[i].rect.width / 2) + 1000.0f) * previewWidth / 2000.0f) ;
            aec_roi_value.cam_aec_roi_position.coordinate[i].y =
                (uint32_t)(((areas[i].rect.top + areas[i].rect.height / 2) + 1000.0f) * previewHeight / 2000.0f) ;
        }
    } else {
        aec_roi_value.aec_roi_enable = CAM_AEC_ROI_OFF;
    }
    free(areas);
    return AddSetParmEntryToBatch(m_pParamBuf,
                                  CAM_INTF_PARM_AEC_ROI,
                                  sizeof(aec_roi_value),
                                  &aec_roi_value);
!!!44205879.cpp!!!	setSceneMode(in sceneModeStr : char) : int32_t
    if (sceneModeStr != NULL) {
        int32_t value = lookupAttr(SCENE_MODES_MAP,
                                   sizeof(SCENE_MODES_MAP)/sizeof(QCameraMap),
                                   sceneModeStr);
        if (value != NAME_NOT_FOUND) {
            CDBG("%s: Setting SceneMode %s", __func__, sceneModeStr);
            updateParamEntry(KEY_SCENE_MODE, sceneModeStr);
            if (m_bSensorHDREnabled) {
              // Incase of HW HDR mode, we do not update the same as Best shot mode.
              CDBG_HIGH("%s: H/W HDR mode enabled. Do not set Best Shot Mode", __func__);
              return NO_ERROR;
            }
            if (m_bSceneSelection) {
                setSelectedScene((cam_scene_mode_type) value);
            }
            int32_t rc = AddSetParmEntryToBatch(m_pParamBuf,
                                                CAM_INTF_PARM_BESTSHOT_MODE,
                                                sizeof(value),
                                                &value);
            return rc;
        }
    }
    ALOGE("%s: Invalid Secene Mode: %s",
          __func__, (sceneModeStr == NULL) ? "NULL" : sceneModeStr);
    return BAD_VALUE;
!!!44206007.cpp!!!	setSelectableZoneAf(in selZoneAFStr : char) : int32_t
    if (selZoneAFStr != NULL) {
        int32_t value = lookupAttr(FOCUS_ALGO_MAP,
                                   sizeof(FOCUS_ALGO_MAP)/sizeof(QCameraMap),
                                   selZoneAFStr);
        if (value != NAME_NOT_FOUND) {
            CDBG("%s: Setting Selectable Zone AF value %s", __func__, selZoneAFStr);
            updateParamEntry(KEY_QC_SELECTABLE_ZONE_AF, selZoneAFStr);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_FOCUS_ALGO_TYPE,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("%s: Invalid selectable zone af value: %s",
          __func__, (selZoneAFStr == NULL) ? "NULL" : selZoneAFStr);
    return BAD_VALUE;
!!!44206135.cpp!!!	setAEBracket(in aecBracketStr : char) : int32_t
    if (aecBracketStr == NULL) {
        CDBG("%s: setAEBracket with NULL value", __func__);
        return NO_ERROR;
    }

    cam_exp_bracketing_t expBracket;
    memset(&expBracket, 0, sizeof(expBracket));

    int value = lookupAttr(BRACKETING_MODES_MAP,
                           sizeof(BRACKETING_MODES_MAP)/sizeof(QCameraMap),
                           aecBracketStr);
    switch (value) {
    case CAM_EXP_BRACKETING_ON:
        {
            CDBG("%s, EXP_BRACKETING_ON", __func__);
            const char *str_val = get(KEY_QC_CAPTURE_BURST_EXPOSURE);
            if ((str_val != NULL) && (strlen(str_val)>0)) {
                expBracket.mode = CAM_EXP_BRACKETING_ON;
                m_bAeBracketingEnabled = true;
                strlcpy(expBracket.values, str_val, MAX_EXP_BRACKETING_LENGTH);
                CDBG("%s: setting Exposure Bracketing value of %s",
                      __func__, expBracket.values);
            }
            else {
                /* Apps not set capture-burst-exposures, error case fall into bracketing off mode */
                CDBG("%s: capture-burst-exposures not set, back to HDR OFF mode", __func__);
                m_bAeBracketingEnabled = false;
                expBracket.mode = CAM_EXP_BRACKETING_OFF;
            }
        }
        break;
    default:
        {
            m_bAeBracketingEnabled = false;
            CDBG_HIGH("%s, EXP_BRACKETING_OFF", __func__);
            expBracket.mode = CAM_EXP_BRACKETING_OFF;
        }
        break;
    }

    // Cache client AE bracketing configuration
    memcpy(&m_AEBracketingClient, &expBracket, sizeof(cam_exp_bracketing_t));

    /* save the value*/
    updateParamEntry(KEY_QC_AE_BRACKET_HDR, aecBracketStr);
    return NO_ERROR;
!!!44206263.cpp!!!	setAFBracket(in afBracketStr : char) : int32_t
    CDBG_HIGH("%s: afBracketStr =%s",__func__,afBracketStr);

    if(afBracketStr != NULL) {
        int value = lookupAttr(AF_BRACKETING_MODES_MAP,
                              sizeof(AF_BRACKETING_MODES_MAP)/
                                  sizeof(QCameraMap),
                              afBracketStr);
        if (value != NAME_NOT_FOUND) {
            m_bAFBracketingOn = (value != 0);
            updateParamEntry(KEY_QC_AF_BRACKET, afBracketStr);

            return NO_ERROR;
        }
    }

    ALOGE("Invalid af bracket value: %s",
        (afBracketStr == NULL) ? "NULL" : afBracketStr);
    return BAD_VALUE;
!!!44206391.cpp!!!	setReFocus(in reFocusStr : char) : int32_t
    CDBG_HIGH("%s: reFocusStr =%s",__func__,reFocusStr);

    if (reFocusStr != NULL) {
        int value = lookupAttr(RE_FOCUS_MODES_MAP, PARAM_MAP_SIZE(RE_FOCUS_MODES_MAP),
                reFocusStr);
        if (value != NAME_NOT_FOUND) {
            m_bReFocusOn = (value != 0);
            updateParamEntry(KEY_QC_RE_FOCUS, reFocusStr);
            return NO_ERROR;
        }
    }

    return NO_ERROR;
!!!44206519.cpp!!!	setChromaFlash(in chromaFlashStr : char) : int32_t
    CDBG_HIGH("%s: chromaFlashStr =%s",__func__,chromaFlashStr);
    if(chromaFlashStr != NULL) {
        int value = lookupAttr(CHROMA_FLASH_MODES_MAP,
                              sizeof(CHROMA_FLASH_MODES_MAP)/sizeof(QCameraMap),
                              chromaFlashStr);
        if(value != NAME_NOT_FOUND) {
            m_bChromaFlashOn = (value != 0);
            updateParamEntry(KEY_QC_CHROMA_FLASH, chromaFlashStr);

            return NO_ERROR;
        }
    }

    ALOGE("Invalid chroma flash value: %s",
        (chromaFlashStr == NULL) ? "NULL" : chromaFlashStr);
    return BAD_VALUE;
!!!44206647.cpp!!!	setOptiZoom(in optiZoomStr : char) : int32_t
    CDBG_HIGH("%s: optiZoomStr =%s",__func__,optiZoomStr);
    if(optiZoomStr != NULL) {
        int value = lookupAttr(OPTI_ZOOM_MODES_MAP,
                               sizeof(OPTI_ZOOM_MODES_MAP)/sizeof(QCameraMap),
                               optiZoomStr);
        if(value != NAME_NOT_FOUND) {
            m_bOptiZoomOn = (value != 0);
            updateParamEntry(KEY_QC_OPTI_ZOOM, optiZoomStr);

            return NO_ERROR;
        }
    }
    ALOGE("Invalid opti zoom value: %s",
        (optiZoomStr == NULL) ? "NULL" : optiZoomStr);
    return BAD_VALUE;
!!!44206775.cpp!!!	setHDRMode(in hdrModeStr : char) : int32_t
    CDBG_HIGH("%s: hdrModeStr =%s", __func__, hdrModeStr);
    if (hdrModeStr != NULL) {
        int value = lookupAttr(HDR_MODES_MAP, PARAM_MAP_SIZE(HDR_MODES_MAP), hdrModeStr);
        if (value != NAME_NOT_FOUND) {
            const char *str = get(KEY_SCENE_MODE);

            m_bHDRModeSensor = !strncmp(hdrModeStr, HDR_MODE_SENSOR, strlen(HDR_MODE_SENSOR));

            updateParamEntry(KEY_QC_HDR_MODE, hdrModeStr);

            // If hdr is already selected, need to deselect it in local cache
            // So the new hdr mode will be applied
            if (str && !strncmp(str, SCENE_MODE_HDR, strlen(SCENE_MODE_HDR))) {
                updateParamEntry(KEY_SCENE_MODE, SCENE_MODE_AUTO);
                m_bNeedRestart = true;
            }

            return NO_ERROR;
        }
    }
    CDBG_HIGH("Invalid hdr mode value: %s",
            (hdrModeStr == NULL) ? "NULL" : hdrModeStr);
    return BAD_VALUE;
!!!44206903.cpp!!!	setHDRNeed1x(in hdrNeed1xStr : char) : int32_t
    CDBG_HIGH("%s: hdrNeed1xStr =%s", __func__, hdrNeed1xStr);
    if (hdrNeed1xStr != NULL) {
        int value = lookupAttr(TRUE_FALSE_MODES_MAP, PARAM_MAP_SIZE(TRUE_FALSE_MODES_MAP),
                hdrNeed1xStr);
        if (value != NAME_NOT_FOUND) {
            updateParamEntry(KEY_QC_HDR_NEED_1X, hdrNeed1xStr);
            m_bHDR1xFrameEnabled = !strncmp(hdrNeed1xStr, VALUE_TRUE, strlen(VALUE_TRUE));
            m_bNeedRestart = true;

            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_HDR_NEED_1X,
                    m_bHDR1xFrameEnabled)) {
                return BAD_VALUE;
            }
            return NO_ERROR;
        }
    }

    CDBG_HIGH("Invalid hdr need 1x value: %s",
            (hdrNeed1xStr == NULL) ? "NULL" : hdrNeed1xStr);
    return BAD_VALUE;
!!!44207031.cpp!!!	setTruePortrait(in truePortraitStr : char) : int32_t
    CDBG_HIGH("%s: truePortraitStr =%s", __func__, truePortraitStr);
    if (truePortraitStr != NULL) {
        int value = lookupAttr(TRUE_PORTRAIT_MODES_MAP,
                PARAM_MAP_SIZE(TRUE_PORTRAIT_MODES_MAP),
                truePortraitStr);
        if (value != NAME_NOT_FOUND) {
            m_bTruePortraitOn = (value != 0);
            updateParamEntry(KEY_QC_TRUE_PORTRAIT, truePortraitStr);
            return NO_ERROR;
        }
    }
    CDBG_HIGH("Invalid true portrait value: %s",
            (truePortraitStr == NULL) ? "NULL" : truePortraitStr);
    return BAD_VALUE;
!!!44207159.cpp!!!	setSeeMore(in seeMoreStr : char) : int32_t
    int32_t rc = NO_ERROR;

    CDBG_HIGH("%s: seeMoreStr =%s", __func__, seeMoreStr);
    if (seeMoreStr != NULL) {
        int value = lookupAttr(ON_OFF_MODES_MAP,
                PARAM_MAP_SIZE(ON_OFF_MODES_MAP),
                seeMoreStr);
        if (value != NAME_NOT_FOUND) {
            m_bSeeMoreOn = (value != 0);

            // If SeeMore is enabled, enable StillMore for live snapshot
            // and disable tone map
            if (m_bSeeMoreOn) {
                m_bStillMoreOn = TRUE;
                rc = setToneMapMode(false, false);
                if (rc != NO_ERROR) {
                    CDBG_HIGH("%s: Failed to disable tone map during SeeMore", __func__);
                }
            } else {
                m_bStillMoreOn = FALSE;
                rc = setToneMapMode(true, false);
                if (rc != NO_ERROR) {
                    CDBG_HIGH("%s: Failed to enable tone map during SeeMore", __func__);
                }
            }
            updateParamEntry(KEY_QC_SEE_MORE, seeMoreStr);
            return NO_ERROR;
        }
    }
    ALOGE("Invalid see more value: %s",
            (seeMoreStr == NULL) ? "NULL" : seeMoreStr);
    return BAD_VALUE;
!!!44207287.cpp!!!	setStillMore(in stillMoreStr : char) : int32_t
    CDBG_HIGH("%s: stillMoreStr =%s", __func__, stillMoreStr);
    if (stillMoreStr != NULL) {
        int value = lookupAttr(STILL_MORE_MODES_MAP, PARAM_MAP_SIZE(STILL_MORE_MODES_MAP),
                stillMoreStr);
        if (value != NAME_NOT_FOUND) {
            m_bStillMoreOn = (value != 0);
            updateParamEntry(KEY_QC_STILL_MORE, stillMoreStr);

            return NO_ERROR;
        }
    }
    ALOGE("Invalid still more value: %s",
            (stillMoreStr == NULL) ? "NULL" : stillMoreStr);
    return BAD_VALUE;
!!!44207415.cpp!!!	setRedeyeReduction(in redeyeStr : char) : int32_t
    if (redeyeStr != NULL) {
        int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                                   sizeof(ENABLE_DISABLE_MODES_MAP)/sizeof(QCameraMap),
                                   redeyeStr);
        if (value != NAME_NOT_FOUND) {
            CDBG("%s: Setting RedEye Reduce value %s", __func__, redeyeStr);
            updateParamEntry(KEY_QC_REDEYE_REDUCTION, redeyeStr);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_REDEYE_REDUCTION,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("%s: Invalid RedEye Reduce value: %s",
          __func__, (redeyeStr == NULL) ? "NULL" : redeyeStr);
    return BAD_VALUE;
!!!44207543.cpp!!!	setWaveletDenoise(in wnrStr : char) : int32_t
    if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_DENOISE2D) == 0){
        CDBG_HIGH("%s: WNR is not supported",__func__);
        return NO_ERROR;
    }

    if (wnrStr != NULL) {
        int value = lookupAttr(DENOISE_ON_OFF_MODES_MAP,
                               sizeof(DENOISE_ON_OFF_MODES_MAP)/sizeof(QCameraMap),
                               wnrStr);
        if (value != NAME_NOT_FOUND) {
            updateParamEntry(KEY_QC_DENOISE, wnrStr);

            cam_denoise_param_t temp;
            memset(&temp, 0, sizeof(temp));
            temp.denoise_enable = value;
            m_bWNROn = (value != 0);
            if (m_bWNROn) {
                temp.process_plates = getWaveletDenoiseProcessPlate();
            }
            CDBG("%s: Denoise enable=%d, plates=%d",
                  __func__, temp.denoise_enable, temp.process_plates);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_WAVELET_DENOISE,
                                          sizeof(temp),
                                          &temp);
        }
    }
    ALOGE("%s: Invalid Denoise value: %s", __func__, (wnrStr == NULL) ? "NULL" : wnrStr);
    return BAD_VALUE;
!!!44207671.cpp!!!	setFaceRecognition(in faceRecog : char, in maxFaces : uint32_t) : int32_t
    if (faceRecog != NULL) {
        int32_t value = lookupAttr(ON_OFF_MODES_MAP, PARAM_MAP_SIZE(ON_OFF_MODES_MAP), faceRecog);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting face recognition %s", __func__, faceRecog);
            updateParamEntry(KEY_QC_FACE_RECOGNITION, faceRecog);

            uint32_t faceProcMask = m_nFaceProcMask;
            if (value > 0) {
                faceProcMask |= CAM_FACE_PROCESS_MASK_RECOGNITION;
            } else {
                faceProcMask &= (uint32_t)(~CAM_FACE_PROCESS_MASK_RECOGNITION);
            }

            if(m_nFaceProcMask == faceProcMask) {
                CDBG_HIGH("%s: face process mask not changed, no ops here", __func__);
                return NO_ERROR;
            }
            m_nFaceProcMask = faceProcMask;
            CDBG_HIGH("%s: FaceProcMask -> %d", __func__, m_nFaceProcMask);

            // set parm for face process
            cam_fd_set_parm_t fd_set_parm;
            memset(&fd_set_parm, 0, sizeof(cam_fd_set_parm_t));
            fd_set_parm.fd_mode = m_nFaceProcMask;
            fd_set_parm.num_fd = maxFaces;

            if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_FD, fd_set_parm)) {
                return BAD_VALUE;
            }
            return NO_ERROR;
        }
    }
    ALOGE("Invalid face recognition value: %s", (faceRecog == NULL) ? "NULL" : faceRecog);
    return BAD_VALUE;
!!!44207799.cpp!!!	setTintlessValue(in tintStr : char) : int32_t
    if (tintStr != NULL) {
        int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                                   sizeof(ENABLE_DISABLE_MODES_MAP)/sizeof(QCameraMap),
                                   tintStr);
        if (value != NAME_NOT_FOUND) {
            CDBG_HIGH("%s: Setting Tintless value %s", __func__, tintStr);
            updateParamEntry(KEY_QC_TINTLESS_ENABLE, tintStr);
            return AddSetParmEntryToBatch(m_pParamBuf,
                                          CAM_INTF_PARM_TINTLESS,
                                          sizeof(value),
                                          &value);
        }
    }
    ALOGE("Invalid Tintless value: %s", (tintStr == NULL) ? "NULL" : tintStr);
    return BAD_VALUE;
!!!44207927.cpp!!!	UpdateHFRFrameRate(in params : QCameraParameters) : bool
    bool updateNeeded = false;
    int min_fps, max_fps;
    int32_t hfrMode = CAM_HFR_MODE_OFF;

    int parm_minfps,parm_maxfps;
    int prevMinFps, prevMaxFps;
    CameraParameters::getPreviewFpsRange(&prevMinFps, &prevMaxFps);
    params.getPreviewFpsRange(&parm_minfps, &parm_maxfps);
    CDBG_HIGH("%s: CameraParameters - : minFps = %d, maxFps = %d ",
                __func__, prevMinFps, prevMaxFps);
    CDBG_HIGH("%s: Requested params - : minFps = %d, maxFps = %d ",
                __func__, parm_minfps, parm_maxfps);

    // check if HFR is enabled
    const char *hfrStr = params.get(KEY_QC_VIDEO_HIGH_FRAME_RATE);
    const char *prev_hfrStr = get(KEY_QC_VIDEO_HIGH_FRAME_RATE);
    CDBG_HIGH("%s: prevHfrStr - %s, hfrStr = %s ",
                __func__, prev_hfrStr, hfrStr);
    if(hfrStr != NULL){
        hfrMode = lookupAttr(HFR_MODES_MAP,
                               sizeof(HFR_MODES_MAP)/sizeof(QCameraMap),
                               hfrStr);
    }
    // check if HSR is enabled
    const char *hsrStr = params.get(KEY_QC_VIDEO_HIGH_SPEED_RECORDING);
    const char *prev_hsrStr = get(KEY_QC_VIDEO_HIGH_SPEED_RECORDING);

    if (hsrStr != NULL && !strcmp(hsrStr, "on")) {
        CDBG_HIGH("%s: HSR mode enabled ", __func__);
        hfrMode = CAM_HFR_MODE_120FPS;
    }

    // if HSR is made ON just now
    if(hsrStr != NULL && (prev_hsrStr == NULL || (strcmp(hsrStr, prev_hsrStr))) &&
        !strcmp(hsrStr, "on")) {
        min_fps = 120000;
        max_fps = 120000;
        m_hfrFpsRange.video_min_fps = min_fps;
        m_hfrFpsRange.video_max_fps = max_fps;

        CDBG_HIGH("%s: HFR mode change - Set FPS : minFps = %d, maxFps = %d ",
               __func__,min_fps,max_fps);
        updateNeeded = true;
    }

    // else if HSR is made OFF just now or HSR is OFF for some time
    // and HFR is changed just now
    else if (hfrStr != NULL && ((prev_hfrStr == NULL || strcmp(hfrStr,prev_hfrStr)) ||
        (hsrStr != NULL && (prev_hsrStr == NULL || strcmp(hsrStr, prev_hsrStr)))) &&
        ((hsrStr != NULL && strcmp(hsrStr, "on"))|| hsrStr == NULL)) {
        if (hfrMode != NAME_NOT_FOUND) {
            // if HFR is enabled, change fps range
            switch(hfrMode){
                case CAM_HFR_MODE_60FPS:
                    min_fps = 60000;
                    max_fps = 60000;
                    break;
                case CAM_HFR_MODE_90FPS:
                    min_fps = 90000;
                    max_fps = 90000;
                    break;
                case CAM_HFR_MODE_120FPS:
                    min_fps = 120000;
                    max_fps = 120000;
                    break;
                case CAM_HFR_MODE_150FPS:
                    min_fps = 150000;
                    max_fps = 150000;
                    break;
                case CAM_HFR_MODE_OFF:
                default:
                    // Set Video Fps to zero
                    min_fps = 0;
                    max_fps = 0;
                    break;
            }
            m_hfrFpsRange.video_min_fps = min_fps;
            m_hfrFpsRange.video_max_fps = max_fps;

            CDBG_HIGH("%s: HFR mode (%d) Set video FPS : minFps = %d, maxFps = %d ",
                   __func__, hfrMode, min_fps, max_fps);
            // Signifies that there is a change in video FPS and need to set Fps
            updateNeeded = true;
        }
    }
    // Remember if HFR mode is ON
    if ((hfrMode > CAM_HFR_MODE_OFF) && (hfrMode < CAM_HFR_MODE_MAX)){
        CDBG_HIGH("HFR mode is ON");
        m_bHfrMode = true;
    }
    else {
        m_hfrFpsRange.video_min_fps = 0;
        m_hfrFpsRange.video_max_fps = 0;
        m_bHfrMode = false;
        CDBG_HIGH("HFR mode is OFF");
    }
    return updateNeeded;
!!!44208055.cpp!!!	setRdiMode(in str : char) : int32_t
  CDBG("RDI_DEBUG %s: rdi mode value: %s", __func__, str);

  if (str != NULL) {
    int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
                           sizeof(ENABLE_DISABLE_MODES_MAP)/sizeof(QCameraMap),
                           str);
    if (value != NAME_NOT_FOUND) {
      updateParamEntry(KEY_QC_RDI_MODE, str);
      m_bRdiMode = (value == 0)? false : true;
      return AddSetParmEntryToBatch(m_pParamBuf,
                                    CAM_INTF_PARM_RDI_MODE,
                                    sizeof(value),
                                    &value);
    }
  }
  ALOGE("%s: Invalid rdi mode value: %s",
    __func__, (str == NULL) ? "NULL" : str);
  return BAD_VALUE;
!!!44208183.cpp!!!	setSecureMode(in str : char) : int32_t
  ALOGD("%s: Secure mode value: %s", __func__, str);

  if (str != NULL) {
    int32_t value = lookupAttr(ENABLE_DISABLE_MODES_MAP,
            sizeof(ENABLE_DISABLE_MODES_MAP)/sizeof(QCameraMap),
            str);
    if (value != NAME_NOT_FOUND) {
      updateParamEntry(KEY_QC_SECURE_MODE, str);
      m_bSecureMode = (value == 0)? false : true;
      return NO_ERROR;
    }
  }
  ALOGE("%s: Invalid Secure mode value: %s",
    __func__, (str == NULL) ? "NULL" : str);
  return BAD_VALUE;
!!!44208311.cpp!!!	setCDSMode(in cds_mode : int32_t, in initCommit : bool) : int32_t
    if (initCommit) {
        if (initBatchUpdate(m_pParamBuf) < 0) {
            ALOGE("%s:Failed to initialize group update table", __func__);
            return FAILED_TRANSACTION;
        }
    }

    int32_t rc = NO_ERROR;
    if (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_CDS_MODE, cds_mode)) {
        ALOGE("%s:Failed to update cds mode", __func__);
        return BAD_VALUE;
    }

    if (initCommit) {
        rc = commitSetBatch();
        if (NO_ERROR != rc) {
            ALOGE("%s:Failed to set cds mode", __func__);
            return rc;
        }
    }

    CDBG_HIGH(" cds mode -> %d", cds_mode);

    return rc;
!!!44208439.cpp!!!	parseGains(in gainStr : char, inout r_gain : float, inout g_gain : float, inout b_gain : float) : int32_t
    int32_t rc = NO_ERROR;
    char *saveptr = NULL;
    char* gains = (char*) calloc(1, strlen(gainStr) + 1);
    if (NULL == gains) {
        ALOGE("%s: No memory for gains", __func__);
        return NO_MEMORY;
    }
    strlcpy(gains, gainStr, strlen(gainStr) + 1);
    char *token = strtok_r(gains, ",", &saveptr);

    if (NULL != token) {
        r_gain = atof(token);
        token = strtok_r(NULL, ",", &saveptr);
    }

    if (NULL != token) {
        g_gain = atof(token);
        token = strtok_r(NULL, ",", &saveptr);
    }

    if (NULL != token) {
        b_gain = (float) atof(token);
    } else {
        ALOGE("%s: Malformed string for gains", __func__);
        rc = BAD_VALUE;
    }

    free(gains);
    return rc;
!!!44208567.cpp!!!	parse_pair(in str : char, inout first : int, inout second : int, in delim : char, inout endptr : char) : int32_t
    // Find the first integer.
    char *end;
    int w = (int)strtol(str, &end, 10);
    // If a delimeter does not immediately follow, give up.
    if (*end != delim) {
        ALOGE("Cannot find delimeter (%c) in str=%s", delim, str);
        return BAD_VALUE;
    }

    // Find the second integer, immediately after the delimeter.
    int h = (int)strtol(end+1, &end, 10);

    *first = w;
    *second = h;

    if (endptr) {
        *endptr = end;
    }

    return NO_ERROR;
!!!44208695.cpp!!!	parseSizesList(in sizesStr : char, inout sizes : Vector<Size>) : void
    if (sizesStr == 0) {
        return;
    }

    char *sizeStartPtr = (char *)sizesStr;

    while (true) {
        int width, height;
        int success = parse_pair(sizeStartPtr, &width, &height, 'x',
                                 &sizeStartPtr);
        if (success == -1 || (*sizeStartPtr != ',' && *sizeStartPtr != '\0')) {
            ALOGE("Picture sizes string \"%s\" contains invalid character.", sizesStr);
            return;
        }
        sizes.push(Size(width, height));

        if (*sizeStartPtr == '\0') {
            return;
        }
        sizeStartPtr++;
    }
!!!44208823.cpp!!!	parseNDimVector(in str : char, inout num : int, in N : int, in delim : char) : int32_t
    char *start, *end;
    if (num == NULL) {
        ALOGE("%s: Invalid output array (num == NULL)", __func__);
        return BAD_VALUE;
    }

    //check if string starts and ends with parantheses
    if(str[0] != '(' || str[strlen(str)-1] != ')') {
        ALOGE("%s: Invalid format of string %s, valid format is (n1, n2, n3, n4 ...)",
              __func__, str);
        return BAD_VALUE;
    }
    start = (char*) str;
    start++;
    for(int i=0; i<N; i++) {
        *(num+i) = (int) strtol(start, &end, 10);
        if(*end != delim && i < N-1) {
            ALOGE("%s: Cannot find delimeter '%c' in string \"%s\". end = %c",
                  __func__, delim, str, *end);
            return -1;
        }
        start = end+1;
    }
    return NO_ERROR;
!!!44208951.cpp!!!	parseCameraAreaString(in str : char, in max_num_areas : int, inout pAreas : cam_area_t, inout num_areas_found : int) : int32_t
    char area_str[32];
    const char *start, *end, *p;
    start = str; end = NULL;
    int values[5], index=0;
    num_areas_found = 0;

    memset(values, 0, sizeof(values));
    while(start != NULL) {
       if(*start != '(') {
            ALOGE("%s: error: Ill formatted area string: %s", __func__, str);
            return BAD_VALUE;
       }
       end = strchr(start, ')');
       if(end == NULL) {
            ALOGE("%s: error: Ill formatted area string: %s", __func__, str);
            return BAD_VALUE;
       }
       int i;
       for (i=0,p=start; p<=end; p++, i++) {
           area_str[i] = *p;
       }
       area_str[i] = '\0';
       if(parseNDimVector(area_str, values, 5) < 0){
            ALOGE("%s: error: Failed to parse the area string: %s", __func__, area_str);
            return BAD_VALUE;
       }
       // no more areas than max_num_areas are accepted.
       if(index >= max_num_areas) {
            ALOGE("%s: error: too many areas specified %s", __func__, str);
            return BAD_VALUE;
       }
       pAreas[index].rect.left = values[0];
       pAreas[index].rect.top = values[1];
       pAreas[index].rect.width = values[2] - values[0];
       pAreas[index].rect.height = values[3] - values[1];
       pAreas[index].weight = values[4];

       index++;
       start = strchr(end, '('); // serach for next '('
    }
    num_areas_found = index;
    return 0;
!!!44209079.cpp!!!	validateCameraAreas(inout areas : cam_area_t, in num_areas : int) : bool
    // special case: default area
    if (num_areas == 1 &&
        areas[0].rect.left == 0 &&
        areas[0].rect.top == 0 &&
        areas[0].rect.width == 0 &&
        areas[0].rect.height == 0 &&
        areas[0].weight == 0) {
        return true;
    }

    for(int i = 0; i < num_areas; i++) {
        // left should be >= -1000
        if(areas[i].rect.left < -1000) {
            return false;
        }

        // top  should be >= -1000
        if(areas[i].rect.top < -1000) {
            return false;
        }

        // width or height should be > 0
        if (areas[i].rect.width <= 0 || areas[i].rect.height <= 0) {
            return false;
        }

        // right  should be <= 1000
        if(areas[i].rect.left + areas[i].rect.width > 1000) {
            return false;
        }

        // bottom should be <= 1000
        if(areas[i].rect.top + areas[i].rect.height > 1000) {
            return false;
        }

        // weight should be within (1, 1000)
        if (areas[i].weight < 1 || areas[i].weight > 1000) {
            return false;
        }
    }
    return true;
!!!44209207.cpp!!!	parseGPSCoordinate(in coord_str : char, inout coord : rat_t) : int
    if(coord == NULL) {
        ALOGE("%s: error, invalid argument coord == NULL", __func__);
        return BAD_VALUE;
    }
    float degF = atof(coord_str);
    if (degF < 0) {
        degF = -degF;
    }
    float minF = (degF - (int) degF) * 60;
    float secF = (minF - (int) minF) * 60;

    getRational(&coord[0], (int)degF, 1);
    getRational(&coord[1], (int)minF, 1);
    getRational(&coord[2], (int)(secF * 10000), 10000);
    return NO_ERROR;
!!!44209335.cpp!!!	getRational(inout rat : rat_t, in num : int, in denom : int) : int32_t
    if (NULL == rat) {
        ALOGE("%s: NULL rat input", __func__);
        return BAD_VALUE;
    }
    rat->num = num;
    rat->denom = denom;
    return NO_ERROR;
!!!44209463.cpp!!!	createSizesString(in sizes : cam_dimension_t, in len : size_t) : String8
    String8 str;
    char buffer[32];

    if (len > 0) {
        snprintf(buffer, sizeof(buffer), "%dx%d", sizes[0].width, sizes[0].height);
        str.append(buffer);
    }
    for (size_t i = 1; i < len; i++) {
        snprintf(buffer, sizeof(buffer), ",%dx%d",
                sizes[i].width, sizes[i].height);
        str.append(buffer);
    }
    return str;
!!!44209719.cpp!!!	createHfrSizesString(in values : cam_hfr_info_t, in len : size_t) : String8
    String8 str;
    char buffer[32];

    if (len > 0) {
        snprintf(buffer, sizeof(buffer), "%dx%d",
                 values[0].dim.width, values[0].dim.height);
        str.append(buffer);
    }
    for (size_t i = 1; i < len; i++) {
        snprintf(buffer, sizeof(buffer), ",%dx%d",
                 values[i].dim.width, values[i].dim.height);
        str.append(buffer);
    }
    return str;
!!!44209847.cpp!!!	createFpsRangeString(in fps : cam_fps_range_t, in len : size_t, inout default_fps_index : int) : String8
    String8 str;
    char buffer[32];
    int max_range = 0;
    int min_fps, max_fps;

    if (len > 0) {
        min_fps = int(fps[0].min_fps * 1000);
        max_fps = int(fps[0].max_fps * 1000);
        max_range = max_fps - min_fps;
        default_fps_index = 0;
        snprintf(buffer, sizeof(buffer), "(%d,%d)", min_fps, max_fps);
        str.append(buffer);
    }
    for (size_t i = 1; i < len; i++) {
        min_fps = int(fps[i].min_fps * 1000);
        max_fps = int(fps[i].max_fps * 1000);
        if (max_range < (max_fps - min_fps)) {
            max_range = max_fps - min_fps;
            default_fps_index = (int)i;
        }
        snprintf(buffer, sizeof(buffer), ",(%d,%d)", min_fps, max_fps);
        str.append(buffer);
    }
    return str;
!!!44209975.cpp!!!	createFpsString(inout fps : cam_fps_range_t) : String8
    char buffer[32];
    String8 fpsValues;

    int min_fps = int(fps.min_fps);
    int max_fps = int(fps.max_fps);

    if (min_fps < fps.min_fps){
        min_fps++;
    }
    if (max_fps > fps.max_fps) {
        max_fps--;
    }
    if (min_fps <= max_fps) {
        snprintf(buffer, sizeof(buffer), "%d", min_fps);
        fpsValues.append(buffer);
    }

    for (int i = min_fps+1; i <= max_fps; i++) {
        snprintf(buffer, sizeof(buffer), ",%d", i);
        fpsValues.append(buffer);
    }

    return fpsValues;
!!!44210103.cpp!!!	createZoomRatioValuesString(inout zoomRatios : uint32_t, in length : size_t) : String8
    String8 str;
    char buffer[32] = {0};

    if(length > 0){
        snprintf(buffer, sizeof(buffer), "%d", zoomRatios[0]);
        str.append(buffer);
    }

    for (size_t i = 1; i < length; i++) {
        memset(buffer, 0, sizeof(buffer));
        snprintf(buffer, sizeof(buffer), ",%d", zoomRatios[i]);
        str.append(buffer);
    }
    return str;
!!!44210231.cpp!!!	initBatchUpdate(inout p_table : parm_buffer_t) : int32_t
    m_tempMap.clear();

    memset(p_table, 0, sizeof(parm_buffer_t));
    return NO_ERROR;
!!!44210359.cpp!!!	commitSetBatch() : int32_t
    int32_t rc = NO_ERROR;
    int32_t i = 0;

    /* Loop to check if atleast one entry is valid */
    for(i = 0; i < CAM_INTF_PARM_MAX; i++){
        if(m_pParamBuf->is_valid[i])
            break;
    }

    if (i < CAM_INTF_PARM_MAX) {
        rc = m_pCamOpsTbl->ops->set_parms(m_pCamOpsTbl->camera_handle, m_pParamBuf);
    }
    if (rc == NO_ERROR) {
        // commit change from temp storage into param map
        rc = commitParamChanges();
    }
    return rc;
!!!44210487.cpp!!!	commitGetBatch() : int32_t
    int32_t rc = NO_ERROR;
    int32_t i = 0;

    /* Loop to check if atleast one entry is valid */
    for(i = 0; i < CAM_INTF_PARM_MAX; i++){
        if(m_pParamBuf->is_valid[i])
            break;
    }

    if (i < CAM_INTF_PARM_MAX) {
        return m_pCamOpsTbl->ops->get_parms(m_pCamOpsTbl->camera_handle, m_pParamBuf);
    } else {
        return NO_ERROR;
    }
    return rc;
!!!44210615.cpp!!!	updateParamEntry(in key : char, in value : char) : int32_t
    m_tempMap.replaceValueFor(String8(key), String8(value));
    return NO_ERROR;
!!!44210743.cpp!!!	commitParamChanges() : int32_t
    size_t size = m_tempMap.size();
    for (size_t i = 0; i < size; i++) {
        String8 k, v;
        k = m_tempMap.keyAt(i);
        v = m_tempMap.valueAt(i);
        set(k, v);
    }
    m_tempMap.clear();

    // update local changes
    m_bRecordingHint = m_bRecordingHint_new;
    m_bZslMode = m_bZslMode_new;

    /* After applying scene mode auto,
      Camera effects need to be reapplied */
    if ( m_bSceneTransitionAuto ) {
        m_bUpdateEffects = true;
        m_bSceneTransitionAuto = false;
    }

    if ( m_bReleaseTorchCamera && ( NULL != m_pTorch) ) {
        m_pTorch->releaseTorchCamera();
        m_bReleaseTorchCamera = false;
    }


    return NO_ERROR;
