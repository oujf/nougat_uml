class QCameraHardwareInterface
!!!44380471.cpp!!!	QCameraHardwareInterface(in cameraId : int, in mode : int)

    cam_ctrl_dimension_t mDimension;

    /* Open camera stack! */
    memset(&mMemHooks, 0, sizeof(mm_camear_mem_vtbl_t));
    mMemHooks.user_data=this;
    mMemHooks.get_buf=get_buffer_hook;
    mMemHooks.put_buf=put_buffer_hook;

    mCameraHandle=camera_open(mCameraId, &mMemHooks);
    ALOGV("Cam open returned %p",mCameraHandle);
    if(mCameraHandle == NULL) {
        ALOGE("startCamera: cam_ops_open failed: id = %d", mCameraId);
        return;
    }
    mCameraHandle->ops->sync(mCameraHandle->camera_handle);

    mChannelId=mCameraHandle->ops->ch_acquire(mCameraHandle->camera_handle);
    if(mChannelId<=0)
    {
        ALOGE("%s:Channel aquire failed",__func__);
        mCameraHandle->ops->camera_close(mCameraHandle->camera_handle);
        return;
    }

    /* Initialize # of frame requests the HAL is handling to zero*/
    mPendingRequests=0;
!!!44380599.cpp!!!	setPreviewWindow(inout window : preview_stream_ops_t) : int
    status_t retVal = NO_ERROR;
    ALOGE(" %s: E mPreviewState = %d, mStreamDisplay = %p",
          __func__, mPreviewState, mStreams[MM_CAMERA_PREVIEW]);
    if( window == NULL) {
        ALOGE("%s:Received Setting NULL preview window", __func__);
    }
    Mutex::Autolock lock(mLock);
    switch(mPreviewState) {
    case QCAMERA_HAL_PREVIEW_START:
        mPreviewWindow = window;
        if(mPreviewWindow) {
            /* we have valid surface now, start preview */
            ALOGE("%s:  calling startPreview2", __func__);
            retVal = startPreview2();
            if(retVal == NO_ERROR)
                mPreviewState = QCAMERA_HAL_PREVIEW_STARTED;
            ALOGE("%s:  startPreview2 done, mPreviewState = %d", __func__, mPreviewState);
        } else
            ALOGE("%s: null window received, mPreviewState = %d", __func__, mPreviewState);
        break;
    case QCAMERA_HAL_PREVIEW_STARTED:
        /* new window comes */
        ALOGE("%s: bug, cannot handle new window in started state", __func__);
        //retVal = UNKNOWN_ERROR;
        break;
    case QCAMERA_HAL_PREVIEW_STOPPED:
    case QCAMERA_HAL_TAKE_PICTURE:
        mPreviewWindow = window;
        ALOGE("%s: mPreviewWindow = 0x%p, mStreamDisplay = 0x%p",
                                    __func__, mPreviewWindow, mStreams[MM_CAMERA_PREVIEW]);
        break;
    default:
        ALOGE("%s: bug, cannot handle new window in state %d", __func__, mPreviewState);
        retVal = UNKNOWN_ERROR;
        break;
    }
    ALOGE(" %s : X, mPreviewState = %d", __FUNCTION__, mPreviewState);
    return retVal;
!!!44380727.cpp!!!	setCallbacks(in notify_cb : camera_notify_callback, in data_cb : camera_data_callback, in data_cb_timestamp : camera_data_timestamp_callback, in get_memory : camera_request_memory, inout user : void) : void
    ALOGE("setCallbacks: E");
    Mutex::Autolock lock(mLock);
    mNotifyCb        = notify_cb;
    mDataCb          = data_cb;
    mDataCbTimestamp = data_cb_timestamp;
    mGetMemory       = get_memory;
    mCallbackCookie  = user;
    ALOGI("setCallbacks: X");
!!!44380855.cpp!!!	enableMsgType(in msgType : int32_t) : void
    ALOGI("enableMsgType: E, msgType =0x%x", msgType);
    Mutex::Autolock lock(mLock);
    mMsgEnabled |= msgType;
    ALOGI("enableMsgType: X, msgType =0x%x, mMsgEnabled=0x%x", msgType, mMsgEnabled);
!!!44380983.cpp!!!	disableMsgType(in msgType : int32_t) : void
    ALOGI("disableMsgType: E");
    Mutex::Autolock lock(mLock);
    mMsgEnabled &= ~msgType;
    ALOGI("disableMsgType: X, msgType =0x%x, mMsgEnabled=0x%x", msgType, mMsgEnabled);
!!!44381111.cpp!!!	msgTypeEnabled(in msgType : int32_t) : int
    ALOGI("msgTypeEnabled: E");
    Mutex::Autolock lock(mLock);
    return (mMsgEnabled & msgType);
    ALOGI("msgTypeEnabled: X");
!!!44381239.cpp!!!	startPreview() : int
    status_t retVal = NO_ERROR;

    ALOGE("%s: mPreviewState =%d", __func__, mPreviewState);
    Mutex::Autolock lock(mLock);

    switch(mPreviewState) {
    case QCAMERA_HAL_TAKE_PICTURE:
        /* cancel pic internally */
        cancelPictureInternal();
        mPreviewState = QCAMERA_HAL_PREVIEW_STOPPED;
        /* then continue with start preview */
    case QCAMERA_HAL_PREVIEW_STOPPED:
        mPreviewState = QCAMERA_HAL_PREVIEW_START;
        ALOGE("%s:  HAL::startPreview begin", __func__);

        if(QCAMERA_HAL_PREVIEW_START == mPreviewState &&
           (mPreviewWindow || isNoDisplayMode())) {
            ALOGE("%s:  start preview now", __func__);
            retVal = startPreview2();
            if(retVal == NO_ERROR)
                mPreviewState = QCAMERA_HAL_PREVIEW_STARTED;
        } else {
            ALOGE("%s:  received startPreview, but preview window = null", __func__);
        }
        break;
    case QCAMERA_HAL_PREVIEW_START:
    case QCAMERA_HAL_PREVIEW_STARTED:
    break;
    case QCAMERA_HAL_RECORDING_STARTED:
        ALOGE("%s: cannot start preview in recording state", __func__);
        break;
    default:
        ALOGE("%s: unknow state %d received", __func__, mPreviewState);
        retVal = UNKNOWN_ERROR;
        break;
    }
    return retVal;
!!!44381367.cpp!!!	startPreview2() : int
    ALOGV("startPreview2: E");
    status_t ret = NO_ERROR;

    cam_ctrl_dimension_t dim;
    mm_camera_dimension_t maxDim;
    uint32_t stream[2];
    mm_camera_bundle_attr_t attr;

    if (mPreviewState == QCAMERA_HAL_PREVIEW_STARTED) { //isPreviewRunning()){
        ALOGE("%s:Preview already started  mPreviewState = %d!", __func__, mPreviewState);
        ALOGE("%s: X", __func__);
        return NO_ERROR;
    }

    /* config the parmeters and see if we need to re-init the stream*/
    ret = setDimension();
    if (MM_CAMERA_OK != ret) {
      ALOGE("%s: error - can't Set Dimensions!", __func__);
      return BAD_VALUE;
    }

    memset(&mHdrInfo, 0, sizeof(snap_hdr_record_t));

    if(isZSLMode()) {
        ALOGE("<DEBUGMODE>In ZSL mode");
        ALOGE("Setting OP MODE to MM_CAMERA_OP_MODE_VIDEO");
        mm_camera_op_mode_type_t op_mode=MM_CAMERA_OP_MODE_ZSL;
        ret = mCameraHandle->ops->set_parm(
                             mCameraHandle->camera_handle,
                             MM_CAMERA_PARM_OP_MODE,
                             &op_mode);
        ALOGE("OP Mode Set");
        /* Start preview streaming */
        /*now init all the buffers and send to steam object*/
        ret = mStreams[MM_CAMERA_PREVIEW]->initStream(FALSE, TRUE);
        if (MM_CAMERA_OK != ret){
            ALOGE("%s: error - can't init Preview channel!", __func__);
            return BAD_VALUE;
        }

        /* Start ZSL stream */
        ret = mStreams[MM_CAMERA_SNAPSHOT_MAIN]->initStream(TRUE, TRUE);
        if (MM_CAMERA_OK != ret){
            ALOGE("%s: error - can't init Snapshot stream!", __func__);
            mStreams[MM_CAMERA_PREVIEW]->deinitStream();
            return BAD_VALUE;
        }

        stream[0] = mStreams[MM_CAMERA_PREVIEW]->mStreamId;
        stream[1] = mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mStreamId;

        attr.notify_mode = MM_CAMERA_SUPER_BUF_NOTIFY_BURST;
        attr.burst_num = getNumOfSnapshots();
        attr.look_back = getZSLBackLookCount();
        attr.post_frame_skip = getZSLBurstInterval();
        attr.water_mark = getZSLQueueDepth();
        ALOGE("%s: burst_num=%d, look_back=%d, frame_skip=%d, water_mark=%d",
              __func__, attr.burst_num, attr.look_back,
              attr.post_frame_skip, attr.water_mark);

        ret = mCameraHandle->ops->init_stream_bundle(
                  mCameraHandle->camera_handle,
                  mChannelId,
                  superbuf_cb_routine,
                  this,
                  &attr,
                  2,
                  stream);
        if (MM_CAMERA_OK != ret){
            ALOGE("%s: error - can't init zsl preview streams!", __func__);
            mStreams[MM_CAMERA_PREVIEW]->deinitStream();
            mStreams[MM_CAMERA_SNAPSHOT_MAIN]->deinitStream();
            return BAD_VALUE;
        }

        ret = mStreams[MM_CAMERA_PREVIEW]->streamOn();
        if (MM_CAMERA_OK != ret){
            ALOGE("%s: error - can't start preview stream!", __func__);
            mStreams[MM_CAMERA_PREVIEW]->deinitStream();
            mStreams[MM_CAMERA_SNAPSHOT_MAIN]->deinitStream();
            return BAD_VALUE;
        }

        ret = mStreams[MM_CAMERA_SNAPSHOT_MAIN]->streamOn();
        if (MM_CAMERA_OK != ret){
            ALOGE("%s: error - can't start snapshot stream!", __func__);
            mStreams[MM_CAMERA_PREVIEW]->streamOff(0);
            mStreams[MM_CAMERA_PREVIEW]->deinitStream();
            mStreams[MM_CAMERA_SNAPSHOT_MAIN]->deinitStream();
            return BAD_VALUE;
        }
    }else{
        /*now init all the buffers and send to steam object*/
        ALOGE("Setting OP MODE to MM_CAMERA_OP_MODE_VIDEO");
        mm_camera_op_mode_type_t op_mode = MM_CAMERA_OP_MODE_VIDEO;
        ret = mCameraHandle->ops->set_parm(
                         mCameraHandle->camera_handle,
                         MM_CAMERA_PARM_OP_MODE,
                         &op_mode);
        ALOGE("OP Mode Set");

        if (MM_CAMERA_OK != ret){
            ALOGE("%s: X :set mode MM_CAMERA_OP_MODE_VIDEO err=%d\n", __func__, ret);
            return BAD_VALUE;
        }
        if(rdiMode == STREAM_RAW) {
            if(mStreams[MM_CAMERA_RDI] == NULL) {
                createRdi();
            }
            mStreams[MM_CAMERA_RDI]->initStream(FALSE, TRUE);
            ret = mStreams[MM_CAMERA_RDI]->streamOn();
            return ret;
        }
        /*now init all the buffers and send to steam object*/
        ret = mStreams[MM_CAMERA_PREVIEW]->initStream(FALSE, TRUE);
        ALOGE("%s : called initStream from Preview and ret = %d", __func__, ret);
        if (MM_CAMERA_OK != ret){
            ALOGE("%s: error - can't init Preview channel!", __func__);
            return BAD_VALUE;
        }
        if(mRecordingHint == true) {
            ret = mStreams[MM_CAMERA_VIDEO]->initStream(FALSE, TRUE);
            if (MM_CAMERA_OK != ret){
                 ALOGE("%s: error - can't init Record channel!", __func__);
                 mStreams[MM_CAMERA_PREVIEW]->deinitStream();
                 return BAD_VALUE;
            }
            if (!canTakeFullSizeLiveshot()) {
                // video-size live snapshot, config same as video
                mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mFormat = mStreams[MM_CAMERA_VIDEO]->mFormat;
                mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mWidth = mStreams[MM_CAMERA_VIDEO]->mWidth;
                mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mHeight = mStreams[MM_CAMERA_VIDEO]->mHeight;
                ret = mStreams[MM_CAMERA_SNAPSHOT_MAIN]->initStream(FALSE, FALSE);
            } else {
                ret = mStreams[MM_CAMERA_SNAPSHOT_MAIN]->initStream(FALSE, TRUE);
            }
            if (MM_CAMERA_OK != ret){
                 ALOGE("%s: error - can't init Snapshot Main!", __func__);
                 mStreams[MM_CAMERA_PREVIEW]->deinitStream();
                 mStreams[MM_CAMERA_VIDEO]->deinitStream();
                 return BAD_VALUE;
            }

        }
        ret = mStreams[MM_CAMERA_PREVIEW]->streamOn();
        if (MM_CAMERA_OK != ret){
            ALOGE("%s: error - can't start preview stream!", __func__);
            if (mRecordingHint == true) {
                mStreams[MM_CAMERA_SNAPSHOT_MAIN]->deinitStream();
                mStreams[MM_CAMERA_VIDEO]->deinitStream();
                mStreams[MM_CAMERA_PREVIEW]->deinitStream();
            }
            return BAD_VALUE;
        }
    }

    ALOGV("startPreview: X");
    return ret;
!!!44381495.cpp!!!	stopPreview() : void
    ALOGI("%s: stopPreview: E", __func__);
    Mutex::Autolock lock(mLock);
    //mm_camera_util_profile("HAL: stopPreview(): E");
    mFaceDetectOn = false;

    // reset recording hint to the value passed from Apps
    const char * str = mParameters.get(QCameraParameters::KEY_RECORDING_HINT);
    if((str != NULL) && !strcmp(str, "true")){
        mRecordingHint = TRUE;
    } else {
        mRecordingHint = FALSE;
    }

    switch(mPreviewState) {
        case QCAMERA_HAL_PREVIEW_START:
            //mPreviewWindow = NULL;
            mPreviewState = QCAMERA_HAL_PREVIEW_STOPPED;
            break;
        case QCAMERA_HAL_PREVIEW_STARTED:
            cancelPictureInternal();
            stopPreviewInternal();
            mPreviewState = QCAMERA_HAL_PREVIEW_STOPPED;
            break;
        case QCAMERA_HAL_RECORDING_STARTED:
            cancelPictureInternal();
            stopRecordingInternal();
            stopPreviewInternal();
            mPreviewState = QCAMERA_HAL_PREVIEW_STOPPED;
            break;
        case QCAMERA_HAL_TAKE_PICTURE:
            cancelPictureInternal();
            mPreviewState = QCAMERA_HAL_PREVIEW_STOPPED;
            break;
        case QCAMERA_HAL_PREVIEW_STOPPED:
        default:
            break;
    }
    ALOGI("stopPreview: X, mPreviewState = %d", mPreviewState);
!!!44381623.cpp!!!	previewEnabled() : int
    ALOGI("previewEnabled: E");
    Mutex::Autolock lock(mLock);
    ALOGE("%s: mPreviewState = %d", __func__, mPreviewState);
    switch(mPreviewState) {
    case QCAMERA_HAL_PREVIEW_START:
    case QCAMERA_HAL_PREVIEW_STARTED:
    case QCAMERA_HAL_RECORDING_STARTED:
        return true;
    default:
        return false;
    }
!!!44381751.cpp!!!	storeMetaDataInBuffers(in enable : int) : int
    /* this is a dummy func now. fix me later */
    mStoreMetaDataInFrame = enable;
    return 0;
!!!44381879.cpp!!!	startRecording() : int
    ALOGI("startRecording: E");
    status_t ret = NO_ERROR;
    Mutex::Autolock lock(mLock);

    switch(mPreviewState) {
    case QCAMERA_HAL_PREVIEW_STOPPED:
        ALOGE("%s: preview has not been started", __func__);
        ret = UNKNOWN_ERROR;
        break;
    case QCAMERA_HAL_PREVIEW_START:
        ALOGE("%s: no preview native window", __func__);
        ret = UNKNOWN_ERROR;
        break;
    case QCAMERA_HAL_PREVIEW_STARTED:
        if (mRecordingHint == FALSE) {
            ALOGE("%s: start recording when hint is false, stop preview first", __func__);
            stopPreviewInternal();
            mPreviewState = QCAMERA_HAL_PREVIEW_STOPPED;

            // Set recording hint to TRUE
            mRecordingHint = TRUE;
            setRecordingHintValue(mRecordingHint);

            // start preview again
            mPreviewState = QCAMERA_HAL_PREVIEW_START;
            if (startPreview2() == NO_ERROR)
                mPreviewState = QCAMERA_HAL_PREVIEW_STARTED;
        }
        ret =  mStreams[MM_CAMERA_VIDEO]->streamOn();
        if (MM_CAMERA_OK != ret){
            ALOGE("%s: error - mStreamRecord->start!", __func__);
            ret = BAD_VALUE;
            break;
        }
        mPreviewState = QCAMERA_HAL_RECORDING_STARTED;

        if (mPowerModule) {
            if (mPowerModule->powerHint) {
                mPowerModule->powerHint(mPowerModule, POWER_HINT_VIDEO_ENCODE, (void *)"state=1");
            }
        }
        break;
    case QCAMERA_HAL_RECORDING_STARTED:
        ALOGE("%s: ", __func__);
        break;
    case QCAMERA_HAL_TAKE_PICTURE:
    default:
       ret = BAD_VALUE;
       break;
    }
    ALOGI("startRecording: X");
    return ret;
!!!44382007.cpp!!!	stopRecording() : void
    ALOGI("stopRecording: E");
    Mutex::Autolock lock(mLock);
    switch(mPreviewState) {
    case QCAMERA_HAL_PREVIEW_STOPPED:
    case QCAMERA_HAL_PREVIEW_START:
    case QCAMERA_HAL_PREVIEW_STARTED:
        break;
    case QCAMERA_HAL_RECORDING_STARTED:
        cancelPictureInternal();
        stopRecordingInternal();
        mPreviewState = QCAMERA_HAL_PREVIEW_STARTED;

        if (mPowerModule) {
            if (mPowerModule->powerHint) {
	            mPowerModule->powerHint(mPowerModule, POWER_HINT_VIDEO_ENCODE, (void *)"state=0");
            }
        }
        break;
    case QCAMERA_HAL_TAKE_PICTURE:
    default:
        break;
    }
    ALOGI("stopRecording: X");

!!!44382135.cpp!!!	recordingEnabled() : int
    int ret = 0;
    Mutex::Autolock lock(mLock);
    ALOGV("%s: E", __func__);
    switch(mPreviewState) {
    case QCAMERA_HAL_PREVIEW_STOPPED:
    case QCAMERA_HAL_PREVIEW_START:
    case QCAMERA_HAL_PREVIEW_STARTED:
        break;
    case QCAMERA_HAL_RECORDING_STARTED:
        ret = 1;
        break;
    case QCAMERA_HAL_TAKE_PICTURE:
    default:
        break;
    }
    ALOGV("%s: X, ret = %d", __func__, ret);
    return ret;   //isRecordingRunning();
!!!44382263.cpp!!!	releaseRecordingFrame(in opaque : void) : void
    ALOGV("%s : BEGIN",__func__);
    if(mStreams[MM_CAMERA_VIDEO] == NULL) {
        ALOGE("Record stream Not Initialized");
        return;
    }
    mStreams[MM_CAMERA_VIDEO]->releaseRecordingFrame(opaque);
    ALOGV("%s : END",__func__);
    return;
!!!44382391.cpp!!!	autoFocus() : int
    ALOGI("autoFocus: E");
    status_t ret = NO_ERROR;

    Mutex::Autolock lock(mLock);
    ALOGI("autoFocus: Got lock");
    bool status = true;
    isp3a_af_mode_t afMode = getAutoFocusMode(mParameters);

    if(mAutoFocusRunning==true){
      ALOGE("%s:AF already running should not have got this call",__func__);
      return NO_ERROR;
    }

    if (afMode == AF_MODE_MAX) {
      /* This should never happen. We cannot send a
       * callback notifying error from this place because
       * the CameraService has called this function after
       * acquiring the lock. So if we try to issue a callback
       * from this place, the callback will try to acquire
       * the same lock in CameraService and it will result
       * in deadlock. So, let the call go in to the lower
       * layer. The lower layer will anyway return error if
       * the autofocus is not supported or if the focus
       * value is invalid.
       * Just print out the error. */
      ALOGE("%s:Invalid AF mode (%d)", __func__, afMode);
    }

    ALOGI("%s:AF start (mode %d)", __func__, afMode);
    if(MM_CAMERA_OK != mCameraHandle->ops->start_focus(mCameraHandle->camera_handle,
               mChannelId,0,(uint32_t)&afMode)){
      ALOGE("%s: AF command failed err:%d error %s",
           __func__, errno, strerror(errno));
      return UNKNOWN_ERROR;
    }

    mAutoFocusRunning = true;
    ALOGE("autoFocus: X");
    return ret;
!!!44382519.cpp!!!	cancelAutoFocus() : int
    ALOGE("cancelAutoFocus: E");
    status_t ret = NO_ERROR;
    Mutex::Autolock lock(mLock);

/**************************************************************
  BEGIN MUTEX CODE
*************************************************************/

    mAutofocusLock.lock();
    if(mAutoFocusRunning || mNeedToUnlockCaf) {

      mAutoFocusRunning = false;
      mNeedToUnlockCaf = false;
      mAutofocusLock.unlock();

    }else/*(!mAutoFocusRunning)*/{

      mAutofocusLock.unlock();
      ALOGE("%s:Af not running",__func__);
      return NO_ERROR;
    }
/**************************************************************
  END MUTEX CODE
*************************************************************/

    if(MM_CAMERA_OK!= mCameraHandle->ops->abort_focus(mCameraHandle->camera_handle,
               mChannelId,0)){
        ALOGE("%s: AF command failed err:%d error %s",__func__, errno,strerror(errno));
    }
    ALOGE("cancelAutoFocus: X");
    return NO_ERROR;
!!!44382647.cpp!!!	takePicture() : int
    ALOGE("takePicture: E");
    status_t ret = MM_CAMERA_OK;
    uint32_t stream_info;
    uint32_t stream[2];
    mm_camera_bundle_attr_t attr;
    mm_camera_op_mode_type_t op_mode=MM_CAMERA_OP_MODE_CAPTURE;
    int num_streams = 0;
    Mutex::Autolock lock(mLock);

    /* set rawdata proc thread and jpeg notify thread to active state */
    mNotifyTh->sendCmd(CAMERA_CMD_TYPE_START_DATA_PROC, FALSE, FALSE);
    mDataProcTh->sendCmd(CAMERA_CMD_TYPE_START_DATA_PROC, FALSE, FALSE);

    switch(mPreviewState) {
    case QCAMERA_HAL_PREVIEW_STARTED:
        {
            if (isZSLMode()) {
                ALOGE("ZSL: takePicture");

                ret = mCameraHandle->ops->request_super_buf(
                          mCameraHandle->camera_handle,
                          mChannelId,
                          getNumOfSnapshots());
                if (MM_CAMERA_OK != ret){
                    ALOGE("%s: error - can't start Snapshot streams!", __func__);
                    return BAD_VALUE;
                }
                return ret;
            }

            /*prepare snapshot, e.g LED*/
            takePicturePrepareHardware( );

            /* stop preview */
            stopPreviewInternal();
            /*Currently concurrent streaming is not enabled for snapshot
            So in snapshot mode, we turn of the RDI channel and configure backend
            for only pixel stream*/

            if (!isRawSnapshot()) {
                op_mode=MM_CAMERA_OP_MODE_CAPTURE;
            } else {
                ALOGV("%s: Raw snapshot so setting op mode to raw", __func__);
                op_mode=MM_CAMERA_OP_MODE_RAW;
            }
            ret = mCameraHandle->ops->set_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_OP_MODE, &op_mode);

            if(MM_CAMERA_OK != ret) {
                ALOGE("%s: X :set mode MM_CAMERA_OP_MODE_CAPTURE err=%d\n", __func__, ret);
                return BAD_VALUE;
            }

            ret = setDimension();
            if (MM_CAMERA_OK != ret) {
                ALOGE("%s: error - can't Set Dimensions!", __func__);
                return BAD_VALUE;
            }

            //added to support hdr
            bool hdr;
            int frm_num = 1;
            int exp[MAX_HDR_EXP_FRAME_NUM];
            hdr = getHdrInfoAndSetExp(MAX_HDR_EXP_FRAME_NUM, &frm_num, exp);
            initHdrInfoForSnapshot(hdr, frm_num, exp); // - for hdr figure out equivalent of mStreamSnap
            memset(&attr, 0, sizeof(mm_camera_bundle_attr_t));
            attr.notify_mode = MM_CAMERA_SUPER_BUF_NOTIFY_CONTINUOUS;

            num_streams = 0;
            mStreams[MM_CAMERA_SNAPSHOT_MAIN]->initStream(TRUE, TRUE);
            if (NO_ERROR!=ret) {
                ALOGE("%s E: can't init native camera snapshot main ch\n",__func__);
                return ret;
            }
            stream[num_streams++] = mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mStreamId;

            if (!isRawSnapshot()) {
                mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->initStream(TRUE, TRUE);
                if (NO_ERROR!=ret) {
                   ALOGE("%s E: can't init native camera snapshot thumb ch\n",__func__);
                   return ret;
                }
                stream[num_streams++] = mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->mStreamId;
            }
            ret = mCameraHandle->ops->init_stream_bundle(
                      mCameraHandle->camera_handle,
                      mChannelId,
                      superbuf_cb_routine,
                      this,
                      &attr,
                      num_streams,
                      stream);
            if (MM_CAMERA_OK != ret){
                ALOGE("%s: error - can't init Snapshot streams!", __func__);
                return BAD_VALUE;
            }
            ret = mStreams[MM_CAMERA_SNAPSHOT_MAIN]->streamOn();
            if (MM_CAMERA_OK != ret){
                ALOGE("%s: error - can't start Snapshot streams!", __func__);
                mCameraHandle->ops->destroy_stream_bundle(
                   mCameraHandle->camera_handle,
                   mChannelId);
                mStreams[MM_CAMERA_SNAPSHOT_MAIN]->deinitStream();
                mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->deinitStream();
                return BAD_VALUE;
            }
            if (!isRawSnapshot()) {
                ret = mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->streamOn();
                if (MM_CAMERA_OK != ret){
                    ALOGE("%s: error - can't start Thumbnail streams!", __func__);
                    mStreams[MM_CAMERA_SNAPSHOT_MAIN]->streamOff(0);
                    mCameraHandle->ops->destroy_stream_bundle(
                       mCameraHandle->camera_handle,
                       mChannelId);
                    mStreams[MM_CAMERA_SNAPSHOT_MAIN]->deinitStream();
                    mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->deinitStream();
                    return BAD_VALUE;
                }
            }
            mPreviewState = QCAMERA_HAL_TAKE_PICTURE;
        }
        break;
    case QCAMERA_HAL_TAKE_PICTURE:
          break;
    case QCAMERA_HAL_PREVIEW_STOPPED:
    case QCAMERA_HAL_PREVIEW_START:
        ret = UNKNOWN_ERROR;
        break;
    case QCAMERA_HAL_RECORDING_STARTED:
        stream[0] = mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mStreamId;
        memset(&attr, 0, sizeof(mm_camera_bundle_attr_t));
        attr.notify_mode = MM_CAMERA_SUPER_BUF_NOTIFY_CONTINUOUS;
        ret = mCameraHandle->ops->init_stream_bundle(
                  mCameraHandle->camera_handle,
                  mChannelId,
                  superbuf_cb_routine,
                  this,
                  &attr,
                  1,
                  stream);
        if (MM_CAMERA_OK != ret){
            ALOGE("%s: error - can't init Snapshot streams!", __func__);
            return BAD_VALUE;
        }
        ret = mStreams[MM_CAMERA_SNAPSHOT_MAIN]->streamOn();
        if (MM_CAMERA_OK != ret){
            ALOGE("%s: error - can't start Snapshot streams!", __func__);
            mCameraHandle->ops->destroy_stream_bundle(
               mCameraHandle->camera_handle,
               mChannelId);
            return BAD_VALUE;
        }
        break;
    default:
        ret = UNKNOWN_ERROR;
        break;
    }
    ALOGI("takePicture: X");
    return ret;
!!!44382775.cpp!!!	cancelPicture() : int
    ALOGI("cancelPicture: E, mPreviewState = %d", mPreviewState);
    status_t ret = MM_CAMERA_OK;
    Mutex::Autolock lock(mLock);

    switch(mPreviewState) {
        case QCAMERA_HAL_PREVIEW_STOPPED:
        case QCAMERA_HAL_PREVIEW_START:
        case QCAMERA_HAL_PREVIEW_STARTED:
        default:
            break;
        case QCAMERA_HAL_TAKE_PICTURE:
            ret = cancelPictureInternal();
            mPreviewState = QCAMERA_HAL_PREVIEW_STOPPED;
            break;
        case QCAMERA_HAL_RECORDING_STARTED:
            ret = cancelPictureInternal();
            break;
    }
    ALOGI("cancelPicture: X");
    return ret;
!!!44382903.cpp!!!	setParameters(in parms : char) : int
    QCameraParameters param;
    String8 str = String8(parms);
    param.unflatten(str);
    status_t ret = setParameters(param);
	if(ret == NO_ERROR)
		return 0;
	else
		return -1;
!!!44383031.cpp!!!	getParameters(inout parms : char) : int
    char* rc = NULL;
    String8 str;
    QCameraParameters param = getParameters();
    //param.dump();
    str = param.flatten( );
    rc = (char *)malloc(sizeof(char)*(str.length()+1));
    if(rc != NULL){
        memset(rc, 0, sizeof(char)*(str.length()+1));
        strncpy(rc, str.string(), str.length());
	rc[str.length()] = 0;
	*parms = rc;
    }
    return 0;
!!!44383159.cpp!!!	putParameters(inout rc : char) : void
    free(rc);
    rc = NULL;
!!!44383287.cpp!!!	sendCommand(in command : int32_t, in arg1 : int32_t, in arg2 : int32_t) : int
    ALOGI("sendCommand: E");
    status_t rc = NO_ERROR;
    Mutex::Autolock l(&mLock);

    switch (command) {
        case CAMERA_CMD_HISTOGRAM_ON:
            ALOGE("histogram set to on");
            rc = setHistogram(1);
            break;
        case CAMERA_CMD_HISTOGRAM_OFF:
            ALOGE("histogram set to off");
            rc = setHistogram(0);
            break;
        case CAMERA_CMD_HISTOGRAM_SEND_DATA:
            ALOGE("histogram send data");
            mSendData = true;
            rc = NO_ERROR;
            break;
        case CAMERA_CMD_START_FACE_DETECTION:
           if(supportsFaceDetection() == false){
                ALOGE("Face detection support is not available");
                return NO_ERROR;
           }
           setFaceDetection("on");
           return runFaceDetection();
        case CAMERA_CMD_STOP_FACE_DETECTION:
           if(supportsFaceDetection() == false){
                ALOGE("Face detection support is not available");
                return NO_ERROR;
           }
           setFaceDetection("off");
           return runFaceDetection();
        default:
            break;
    }
    ALOGI("sendCommand: X");
    return rc;
!!!44383543.cpp!!!	dump(in fd : int) : int
    ALOGE("%s: not supported yet", __func__);
    return -1;
!!!44383671.cpp!!!	getPictureSize(inout picture_width : int, inout picture_height : int) : void
    mParameters.getPictureSize(picture_width, picture_height);
!!!44383799.cpp!!!	getPreviewSize(inout preview_width : int, inout preview_height : int) : void
    mParameters.getPreviewSize(preview_width, preview_height);
!!!44383927.cpp!!!	getVideoSize(inout video_width : int, inout video_height : int) : void
    mParameters.getVideoSize(video_width, video_height);
!!!44384055.cpp!!!	getThumbnailSize(inout thumb_width : int, inout thumb_height : int) : void
    *thumb_width = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
    *thumb_height = mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
!!!44384183.cpp!!!	getPreviewFormat() : cam_format_t
    cam_format_t foramt = CAMERA_YUV_420_NV21;
    const char *str = mParameters.getPreviewFormat();
    int32_t value = attr_lookup(preview_formats,
                                sizeof(preview_formats)/sizeof(str_map),
                                str);

    if(value != NOT_FOUND) {
        int num = sizeof(preview_format_info_list)/sizeof(preview_format_info_t);
        int i;
        for (i = 0; i < num; i++) {
          if (preview_format_info_list[i].Hal_format == value) {
            foramt = preview_format_info_list[i].mm_cam_format;
            break;
          }
        }
    }

    return foramt;
!!!44384311.cpp!!!	getPreviewPadding() : cam_pad_format_t
  return mPreviewFormatInfo.padding;
!!!44384439.cpp!!!	processEvent(inout event : mm_camera_event_t) : void
    app_notify_cb_t app_cb;
    ALOGE("processEvent: type :%d E",event->event_type);
    if(mPreviewState == QCAMERA_HAL_PREVIEW_STOPPED){
	ALOGE("Stop recording issued. Return from process Event");
        return;
    }
    memset(&app_cb, 0, sizeof(app_notify_cb_t));
    switch(event->event_type)
    {
        case MM_CAMERA_EVT_TYPE_CH:
            processChannelEvent(&event->e.ch, &app_cb);
            break;
        case MM_CAMERA_EVT_TYPE_CTRL:
            processCtrlEvent(&event->e.ctrl, &app_cb);
            break;
        case MM_CAMERA_EVT_TYPE_STATS:
            processStatsEvent(&event->e.stats, &app_cb);
            break;
        case MM_CAMERA_EVT_TYPE_INFO:
            processInfoEvent(&event->e.info, &app_cb);
            break;
        default:
            break;
    }
    ALOGE(" App_cb Notify %p, datacb=%p", app_cb.notifyCb, app_cb.dataCb);
    if (app_cb.notifyCb) {
      app_cb.notifyCb(app_cb.argm_notify.msg_type,
        app_cb.argm_notify.ext1, app_cb.argm_notify.ext2,
        app_cb.argm_notify.cookie);
    }
    if (app_cb.dataCb) {
      app_cb.dataCb(app_cb.argm_data_cb.msg_type,
        app_cb.argm_data_cb.data, app_cb.argm_data_cb.index,
        app_cb.argm_data_cb.metadata, app_cb.argm_data_cb.cookie);
    }
    ALOGI("processEvent: X");
    return;
!!!44384567.cpp!!!	getJpegQuality() : int
    return mJpegQuality;
!!!44384695.cpp!!!	getNumOfSnapshots(in  : void) : int
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.snapshot.number", prop, "0");
    ALOGI("%s: prop enable/disable = %d", __func__, atoi(prop));
    if (atoi(prop)) {
        ALOGE("%s: Reading maximum no of snapshots = %d"
             "from properties", __func__, atoi(prop));
        return atoi(prop);
    } else {
        return mParameters.getInt("num-snaps-per-shutter");
    }
!!!44384823.cpp!!!	getNumOfSnapshots(in params : QCameraParameters) : int
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.snapshot.number", prop, "0");
    ALOGI("%s: prop enable/disable = %d", __func__, atoi(prop));
    if (atoi(prop)) {
        ALOGI("%s: Reading maximum no of snapshots = %d"
             "from properties", __func__, atoi(prop));
        return atoi(prop);
    } else {
        return params.getInt("num-snaps-per-shutter");
    }

!!!44384951.cpp!!!	getThumbSizesFromAspectRatio(in aspect_ratio : uint32_t, inout picture_width : int, inout picture_height : int) : int
    for(unsigned int i = 0; i < THUMBNAIL_SIZE_COUNT; i++ ){
        if(thumbnail_sizes[i].aspect_ratio == aspect_ratio)
        {
            *picture_width = thumbnail_sizes[i].width;
            *picture_height = thumbnail_sizes[i].height;
            return NO_ERROR;
        }
    }

    return BAD_VALUE;
!!!44385079.cpp!!!	isRawSnapshot() : bool
  const char *format = mParameters.getPictureFormat();
    if( format!= NULL &&
       !strcmp(format, QCameraParameters::PIXEL_FORMAT_RAW)){
        return true;
    }
    else{
        return false;
    }
!!!44385207.cpp!!!	dumpFrameToFile(inout newFrame : mm_camera_buf_def_t, in frm_type : HAL_cam_dump_frm_type_t) : void
  ALOGV("%s: E", __func__);
  int32_t enabled = 0;
  int frm_num;
  uint32_t  skip_mode;
  char value[PROPERTY_VALUE_MAX];
  char buf[32];
  int main_422 = 1;
  property_get("persist.camera.dumpimg", value, "0");
  enabled = atoi(value);

  ALOGV(" newFrame =%p, frm_type = %x, enabled=%x", newFrame, frm_type, enabled);
  if(enabled & HAL_DUMP_FRM_MASK_ALL) {
    if((enabled & frm_type) && newFrame) {
      frm_num = ((enabled & 0xffff0000) >> 16);
      if(frm_num == 0) frm_num = 10; /*default 10 frames*/
      if(frm_num > 256) frm_num = 256; /*256 buffers cycle around*/
      skip_mode = ((enabled & 0x0000ff00) >> 8);
      if(skip_mode == 0) skip_mode = 1; /*no -skip */

      if( mDumpSkipCnt % skip_mode == 0) {
        if (mDumpFrmCnt >= 0 && mDumpFrmCnt <= frm_num) {
          int w, h;
          int file_fd;
          switch (frm_type) {
          case  HAL_DUMP_FRM_PREVIEW:
            w = mDimension.display_width;
            h = mDimension.display_height;
            snprintf(buf, sizeof(buf), "/data/%dp_%dx%d_%d.yuv", mDumpFrmCnt, w, h, newFrame->frame_idx);
            file_fd = open(buf, O_RDWR | O_CREAT, 0777);
            break;
          case HAL_DUMP_FRM_VIDEO:
            w = mDimension.video_width;
            h = mDimension.video_height;
            snprintf(buf, sizeof(buf),"/data/%dv_%dx%d_%d.yuv", mDumpFrmCnt, w, h, newFrame->frame_idx);
            file_fd = open(buf, O_RDWR | O_CREAT, 0777);
            break;
          case HAL_DUMP_FRM_MAIN:
            w = mDimension.picture_width;
            h = mDimension.picture_height;
            snprintf(buf, sizeof(buf), "/data/%dm_%dx%d_%d.yuv", mDumpFrmCnt, w, h, newFrame->frame_idx);
            file_fd = open(buf, O_RDWR | O_CREAT, 0777);
            if (mDimension.main_img_format == CAMERA_YUV_422_NV16 ||
                mDimension.main_img_format == CAMERA_YUV_422_NV61)
              main_422 = 2;
            break;
          case HAL_DUMP_FRM_THUMBNAIL:
            w = mDimension.ui_thumbnail_width;
            h = mDimension.ui_thumbnail_height;
            snprintf(buf, sizeof(buf),"/data/%dt_%dx%d_%d.yuv", mDumpFrmCnt, w, h, newFrame->frame_idx);
            file_fd = open(buf, O_RDWR | O_CREAT, 0777);
            break;
          case HAL_DUMP_FRM_RDI:
              w = mRdiWidth;
              h = mRdiHeight;
              snprintf(buf, sizeof(buf),"/data/%dr_%dx%d.raw", mDumpFrmCnt, w, h);
              file_fd = open(buf, O_RDWR | O_CREAT, 0777);
              break;
          default:
            w = h = 0;
            file_fd = -1;
            break;
          }

          if (file_fd < 0) {
            ALOGE("%s: cannot open file:type=%d\n", __func__, frm_type);
          } else {
            write(file_fd, (const void *)(newFrame->buffer), w * h);
            write(file_fd, (const void *)
              (newFrame->buffer), w * h / 2 * main_422);
            close(file_fd);
            ALOGE("dump %s", buf);
          }
        } else if(frm_num == 256){
          mDumpFrmCnt = 0;
        }
        mDumpFrmCnt++;
      }
      mDumpSkipCnt++;
    }
  }  else {
    mDumpFrmCnt = 0;
  }
  ALOGV("%s: X", __func__);
!!!44385335.cpp!!!	createInstance(in cameraId : int, in mode : int) : QCameraHardwareInterface
    ALOGI("createInstance: E");
    QCameraHardwareInterface *cam = new QCameraHardwareInterface(cameraId, mode);
    if (cam ) {
      if (cam->mCameraState != CAMERA_STATE_READY) {
        ALOGE("createInstance: Failed");
        delete cam;
        cam = NULL;
      }
    }

    if (cam) {
      ALOGI("createInstance: X");
      return cam;
    } else {
      return NULL;
    }
!!!44385463.cpp!!!	setZSLBurstLookBack(in params : QCameraParameters) : status_t
  const char *v = params.get("capture-burst-retroactive");
  if (v) {
    int look_back = atoi(v);
    ALOGI("%s: look_back =%d", __func__, look_back);
    mParameters.set("capture-burst-retroactive", look_back);
  }
  return NO_ERROR;
!!!44385591.cpp!!!	setZSLBurstInterval(in params : QCameraParameters) : status_t
  mZslInterval = BURST_INTREVAL_DEFAULT;
  const char *v = params.get("capture-burst-interval");
  if (v) {
    int interval = atoi(v);
    ALOGI("%s: Interval =%d", __func__, interval);
    if(interval < BURST_INTREVAL_MIN ||interval > BURST_INTREVAL_MAX ) {
      return BAD_VALUE;
    }
    mZslInterval =  interval;
  }
  return NO_ERROR;
!!!44385719.cpp!!!	getZSLBurstInterval(in  : void) : int
  int val;

  if (mZslInterval == BURST_INTREVAL_DEFAULT) {
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.zsl.interval", prop, "1");
    val = atoi(prop);
    ALOGD("%s: prop interval = %d", __func__, val);
  } else {
    val = mZslInterval;
  }
  return val;
!!!44385847.cpp!!!	getZSLQueueDepth(in  : void) : int
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.zsl.queuedepth", prop, "2");
    ALOGI("%s: prop = %d", __func__, atoi(prop));
    return atoi(prop);
!!!44385975.cpp!!!	getZSLBackLookCount(in  : void) : int
    int look_back;
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.zsl.backlookcnt", prop, "0");
    ALOGI("%s: prop = %d", __func__, atoi(prop));
    look_back = atoi(prop);
    if (look_back == 0 ) {
      look_back = mParameters.getInt("capture-burst-retroactive");
      ALOGE("%s: look_back = %d", __func__, look_back);
    }
    return look_back;
!!!44386103.cpp!!!	~QCameraHardwareInterface()
    mCameraHandle->ops->camera_close(mCameraHandle->camera_handle);
!!!44386231.cpp!!!	initHeapMem(inout heap : QCameraHalHeap_t, in num_of_buf : int, in buf_len : uint32_t, in pmem_type : int, inout offset : mm_camera_frame_len_offset, inout buf_def : mm_camera_buf_def_t) : int
    int rc = 0;
    int i;
    int path;
    ALOGE("Init Heap =%p. pmem_type =%d, num_of_buf=%d. buf_len=%d",
         heap,  pmem_type, num_of_buf, buf_len);
    if(num_of_buf > MM_CAMERA_MAX_NUM_FRAMES || heap == NULL ||
       mGetMemory == NULL ) {
        ALOGE("Init Heap error");
        rc = -1;
        return rc;
    }

    memset(heap, 0, sizeof(QCameraHalHeap_t));
    heap->buffer_count = num_of_buf;
    for(i = 0; i < num_of_buf; i++) {
        heap->mem_info[i].size = buf_len;
#ifdef USE_ION
        if (isZSLMode()) {
            rc = allocate_ion_memory(&heap->mem_info[i],
                                     ((0x1 << CAMERA_ZSL_ION_HEAP_ID) | (0x1 << CAMERA_ZSL_ION_FALLBACK_HEAP_ID)));
        }
        else {
            rc = allocate_ion_memory(&heap->mem_info[i],
                                     ((0x1 << CAMERA_ION_HEAP_ID) | (0x1 << CAMERA_ION_FALLBACK_HEAP_ID)));
        }

        if (rc < 0) {
            ALOGE("%s: ION allocation failed\n", __func__);
            break;
        }
#else
        if (pmem_type == MSM_PMEM_MAX){
            ALOGE("%s : USE_ION not defined, pmemtype == MSM_PMEM_MAX, so ret -1", __func__);
            rc = -1;
            break;
        }
        else {
            heap->mem_info[i].fd = open("/dev/pmem_adsp", O_RDWR|O_SYNC);
            if ( heap->mem_info[i].fd <= 0) {
                ALOGE("Open fail: heap->fd[%d] =%d", i, heap->mem_info[i].fd);
                rc = -1;
                break;
            }
        }
#endif
        heap->camera_memory[i] = mGetMemory(heap->mem_info[i].fd,
                                            heap->mem_info[i].size,
                                            1,
                                            (void *)this);

        if (heap->camera_memory[i] == NULL ) {
            ALOGE("Getmem fail %d: ", i);
            rc = -1;
            break;
        }

        if(buf_def != NULL && offset != NULL) {
            buf_def[i].fd = heap->mem_info[i].fd;
            buf_def[i].frame_len = heap->mem_info[i].size;
            buf_def[i].buffer = heap->camera_memory[i]->data;
            buf_def[i].mem_info = (void *)&heap->mem_info[i];
            buf_def[i].num_planes = offset->num_planes;
            /* Plane 0 needs to be set seperately. Set other planes
             * in a loop. */
            buf_def[i].planes[0].length = offset->mp[0].len;
            buf_def[i].planes[0].m.userptr = heap->mem_info[i].fd;
            buf_def[i].planes[0].data_offset = offset->mp[0].offset;
            buf_def[i].planes[0].reserved[0] = 0;
            for (int j = 1; j < buf_def[i].num_planes; j++) {
                 buf_def[i].planes[j].length = offset->mp[j].len;
                 buf_def[i].planes[j].m.userptr = heap->mem_info[i].fd;
                 buf_def[i].planes[j].data_offset = offset->mp[j].offset;
                 buf_def[i].planes[j].reserved[0] =
                     buf_def[i].planes[j-1].reserved[0] +
                     buf_def[i].planes[j-1].length;
            }
        }

        ALOGE("heap->fd[%d] =%d, camera_memory=%p", i,
              heap->mem_info[i].fd, heap->camera_memory[i]);
        heap->local_flag[i] = 1;
    }
    if( rc < 0) {
        releaseHeapMem(heap);
    }
    return rc;
!!!44386359.cpp!!!	releaseHeapMem(inout heap : QCameraHalHeap_t) : int
	int rc = 0;
	ALOGE("Release %p", heap);
	if (heap != NULL) {
		for (int i = 0; i < heap->buffer_count; i++) {
			if(heap->camera_memory[i] != NULL) {
				heap->camera_memory[i]->release( heap->camera_memory[i] );
				heap->camera_memory[i] = NULL;
			} else if (heap->mem_info[i].fd <= 0) {
				ALOGE("impossible: camera_memory[%d] = %p, fd = %d",
				i, heap->camera_memory[i], heap->mem_info[i].fd);
			}

#ifdef USE_ION
            deallocate_ion_memory(&heap->mem_info[i]);
#endif
		}
        memset(heap, 0, sizeof(QCameraHalHeap_t));
	}
	return rc;
!!!44386487.cpp!!!	allocate_ion_memory(inout mem_info : QCameraHalMemInfo_t, in ion_type : int) : int
    int rc = 0;
    struct ion_handle_data handle_data;
    struct ion_allocation_data alloc;
    struct ion_fd_data ion_info_fd;
    int main_ion_fd = 0;

    main_ion_fd = open("/dev/ion", O_RDONLY);
    if (main_ion_fd <= 0) {
        ALOGE("Ion dev open failed %s\n", strerror(errno));
        goto ION_OPEN_FAILED;
    }

    memset(&alloc, 0, sizeof(alloc));
    alloc.len = mem_info->size;
    /* to make it page size aligned */
    alloc.len = (alloc.len + 4095) & (~4095);
    alloc.align = 4096;
    alloc.flags = ION_FLAG_CACHED;
    alloc.heap_mask = ion_type;
    rc = ioctl(main_ion_fd, ION_IOC_ALLOC, &alloc);
    if (rc < 0) {
        ALOGE("ION allocation failed\n");
        goto ION_ALLOC_FAILED;
    }

    memset(&ion_info_fd, 0, sizeof(ion_info_fd));
    ion_info_fd.handle = alloc.handle;
    rc = ioctl(main_ion_fd, ION_IOC_SHARE, &ion_info_fd);
    if (rc < 0) {
        ALOGE("ION map failed %s\n", strerror(errno));
        goto ION_MAP_FAILED;
    }

    mem_info->main_ion_fd = main_ion_fd;
    mem_info->fd = ion_info_fd.fd;
    mem_info->handle = ion_info_fd.handle;
    mem_info->size = alloc.len;
    return 0;

ION_MAP_FAILED:
    memset(&handle_data, 0, sizeof(handle_data));
    handle_data.handle = ion_info_fd.handle;
    ioctl(main_ion_fd, ION_IOC_FREE, &handle_data);
ION_ALLOC_FAILED:
    close(main_ion_fd);
ION_OPEN_FAILED:
    return -1;
!!!44386615.cpp!!!	deallocate_ion_memory(inout mem_info : QCameraHalMemInfo_t) : int
  struct ion_handle_data handle_data;
  int rc = 0;

  if (mem_info->fd > 0) {
      close(mem_info->fd);
      mem_info->fd = 0;
  }

  if (mem_info->main_ion_fd > 0) {
      memset(&handle_data, 0, sizeof(handle_data));
      handle_data.handle = mem_info->handle;
      ioctl(mem_info->main_ion_fd, ION_IOC_FREE, &handle_data);
      close(mem_info->main_ion_fd);
      mem_info->main_ion_fd = 0;
  }
  return rc;
!!!44386743.cpp!!!	cache_ops(inout mem_info : QCameraHalMemInfo_t, inout buf_ptr : void, in cmd : uint) : int
    struct ion_flush_data cache_inv_data;
    struct ion_custom_data custom_data;
    int ret = MM_CAMERA_OK;

#ifdef USE_ION
    if (NULL == mem_info) {
        ALOGE("%s: mem_info is NULL, return here", __func__);
        return -1;
    }

    memset(&cache_inv_data, 0, sizeof(cache_inv_data));
    memset(&custom_data, 0, sizeof(custom_data));
    cache_inv_data.vaddr = buf_ptr;
    cache_inv_data.fd = mem_info->fd;
    cache_inv_data.handle = mem_info->handle;
    cache_inv_data.length = mem_info->size;
    custom_data.cmd = cmd;
    custom_data.arg = (unsigned long)&cache_inv_data;

    ALOGD("addr = %p, fd = %d, handle = %p length = %d, ION Fd = %d",
         cache_inv_data.vaddr, cache_inv_data.fd,
         cache_inv_data.handle, cache_inv_data.length,
         mem_info->main_ion_fd);
    if(mem_info->main_ion_fd > 0) {
        if(ioctl(mem_info->main_ion_fd, ION_IOC_CUSTOM, &custom_data) < 0) {
            ALOGE("%s: Cache Invalidate failed\n", __func__);
            ret = -1;
        }
    }
#endif

    return ret;
!!!44386871.cpp!!!	dumpFrameToFile(in data : void, in size : uint32_t, inout name : char, inout ext : char, in index : int) : void
    char buf[32];
    int file_fd;
    if ( data != NULL) {
        char * str;
        snprintf(buf, sizeof(buf), "/data/%s_%d.%s", name, index, ext);
        ALOGE("marvin, %s size =%d", buf, size);
        file_fd = open(buf, O_RDWR | O_CREAT, 0777);
        write(file_fd, data, size);
        close(file_fd);
    }
!!!44386999.cpp!!!	getPreviewFormatInfo() : preview_format_info_t
  return mPreviewFormatInfo;
!!!44387127.cpp!!!	isCameraReady() : bool
    return true;
!!!44387255.cpp!!!	isNoDisplayMode() : bool
  return (mNoDisplayMode != 0);
!!!44387383.cpp!!!	getBuf(in camera_handle : uint32_t, in ch_id : uint32_t, in mm_stream_id : uint32_t, inout user_data : void, inout frame_offset_info : mm_camera_frame_len_offset, in num_bufs : uint8_t, inout initial_reg_flag : uint8_t, inout bufs : mm_camera_buf_def_t) : int
    status_t ret=NO_ERROR;
    ALOGE("%s: E, stream_id = %d\n", __func__, mm_stream_id);
    QCameraStream_preview *stream = (QCameraStream_preview *)
                        QCameraStream::getStreamAtMmId(mm_stream_id);

    ALOGE("%s: len:%d, y_off:%d, cbcr:%d num buffers: %d planes:%d streamid:%d",
        __func__,
        frame_offset_info->frame_len,
	frame_offset_info->mp[0].len,
	frame_offset_info->mp[1].len,
        num_bufs,frame_offset_info->num_planes,
        mm_stream_id);
    /*************Preiew Stream*****************/
    ALOGE("Interface requesting Preview Buffers");
    stream->mFrameOffsetInfo=*frame_offset_info;
    if(NO_ERROR!=stream->initBuffers()){
        return BAD_VALUE;
    } 
    ALOGE("Debug : %s : initDisplayBuffers",__func__);
    for(int i=0;i<num_bufs;i++) {
        bufs[i] = stream->mDisplayBuf[i];
        initial_reg_flag[i] =
            (stream->mPreviewMemory.local_flag[i] == BUFFER_OWNED);
        ALOGE("initial_reg_flag[%d]:%d",i,initial_reg_flag[i]);
    }
    return 0;
!!!44387511.cpp!!!	putBuf(in camera_handle : uint32_t, in ch_id : uint32_t, in mm_stream_id : uint32_t, inout user_data : void, in num_bufs : uint8_t, inout bufs : mm_camera_buf_def_t) : int
    ALOGE("%s:E, stream_id = %d",__func__, mm_stream_id);
    QCameraStream_preview *stream = (QCameraStream_preview *)
                        QCameraStream::getStreamAtMmId(mm_stream_id);
    stream->deinitBuffers();
    return 0;
!!!44387639.cpp!!!	loadTables() : void

    bool ret = NO_ERROR;
    ALOGV("%s: E", __func__);

    ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
            MM_CAMERA_PARM_PREVIEW_SIZES_CNT, &preview_sizes_count);

    default_sizes_tbl_t preview_sizes_tbl;
    preview_sizes_tbl.tbl_size=preview_sizes_count;
    preview_sizes_tbl.sizes_tbl=&default_preview_sizes[0];
    if(mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                            MM_CAMERA_PARM_DEF_PREVIEW_SIZES, &preview_sizes_tbl)<0){
        ALOGE("%s:Failed to get default preview sizes",__func__);
    }
    ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                MM_CAMERA_PARM_VIDEO_SIZES_CNT, &video_sizes_count);

    default_sizes_tbl_t video_sizes_tbl;
    video_sizes_tbl.tbl_size=video_sizes_count;
    video_sizes_tbl.sizes_tbl=&default_video_sizes[0];
    if(mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                            MM_CAMERA_PARM_DEF_VIDEO_SIZES, &video_sizes_tbl)<0){
        ALOGE("%s:Failed to get default video sizes",__func__);
    }

    ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                MM_CAMERA_PARM_THUMB_SIZES_CNT, &thumbnail_sizes_count);

    default_sizes_tbl_t thumbnail_sizes_tbl;
    thumbnail_sizes_tbl.tbl_size=thumbnail_sizes_count;
    thumbnail_sizes_tbl.sizes_tbl=&default_thumbnail_sizes[0];
    if(mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                            MM_CAMERA_PARM_DEF_THUMB_SIZES, &thumbnail_sizes_tbl)<0){
        ALOGE("%s:Failed to get default thumbnail sizes",__func__);
    }

    ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                MM_CAMERA_PARM_HFR_SIZES_CNT, &hfr_sizes_count);

    default_sizes_tbl_t hfr_sizes_tbl;
    hfr_sizes_tbl.tbl_size=hfr_sizes_count;
    hfr_sizes_tbl.sizes_tbl=&default_hfr_sizes[0];
    if(mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                            MM_CAMERA_PARM_DEF_HFR_SIZES, &hfr_sizes_tbl)<0){
        ALOGE("%s:Failed to get default HFR  sizes",__func__);
    }
    ALOGE("%s: X", __func__);
!!!44387767.cpp!!!	initDefaultParameters() : void
    bool ret;
    char prop[PROPERTY_VALUE_MAX];
    mm_camera_dimension_t maxDim;
    int rc = 0;
    ALOGI("%s: E", __func__);
    uint8_t supported;

    memset(&maxDim, 0, sizeof(mm_camera_dimension_t));
    ret = getMaxPictureDimension(&maxDim);

    if (ret != NO_ERROR) {
        ALOGE("%s: Cannot get Max picture size supported", __func__);
        return;
    }
    if (!maxDim.width || !maxDim.height) {
        maxDim.width = DEFAULT_LIVESHOT_WIDTH;
        maxDim.height = DEFAULT_LIVESHOT_HEIGHT;
    }

    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.snap.format", prop, "0");
    mSnapshotFormat = atoi(prop);
    ALOGV("%s: prop =(%s), snap_format=%d", __func__, prop, mSnapshotFormat);

    //cam_ctrl_dimension_t dim;
    mHFRLevel = 0;
    memset(&mDimension, 0, sizeof(cam_ctrl_dimension_t));
    memset(&mPreviewFormatInfo, 0, sizeof(preview_format_info_t));
    mDimension.video_width     = DEFAULT_VIDEO_WIDTH;
    mDimension.video_height    = DEFAULT_VIDEO_HEIGHT;
    mDimension.picture_width   = maxDim.width;
    mDimension.picture_height  = maxDim.height;
    mDimension.display_width   = DEFAULT_STREAM_WIDTH;
    mDimension.display_height  = DEFAULT_STREAM_HEIGHT;
    mDimension.orig_picture_dx = mDimension.picture_width;
    mDimension.orig_picture_dy = mDimension.picture_height;
    mDimension.ui_thumbnail_width = DEFAULT_STREAM_WIDTH;
    mDimension.ui_thumbnail_height = DEFAULT_STREAM_HEIGHT;
    mDimension.orig_video_width = DEFAULT_STREAM_WIDTH;
    mDimension.orig_video_height = DEFAULT_STREAM_HEIGHT;

    mDimension.prev_format     = CAMERA_YUV_420_NV21;
    mDimension.enc_format      = CAMERA_YUV_420_NV12;
    if (mSnapshotFormat == 1) {
      mDimension.main_img_format = CAMERA_YUV_422_NV61;
    } else {
      mDimension.main_img_format = CAMERA_YUV_420_NV21;
    }
    mDimension.thumb_format    = CAMERA_YUV_420_NV21;
    ALOGV("%s: main_img_format =%d, thumb_format=%d", __func__,
         mDimension.main_img_format, mDimension.thumb_format);
    mDimension.prev_padding_format = CAMERA_PAD_TO_WORD;

    ret = native_set_parms(MM_CAMERA_PARM_DIMENSION,
                              sizeof(cam_ctrl_dimension_t), (void *) &mDimension);
    if(!ret) {
      ALOGE("MM_CAMERA_PARM_DIMENSION Failed.");
      return;
    }

    hasAutoFocusSupport();

    // Initialize constant parameter strings. This will happen only once in the
    // lifetime of the mediaserver process.
    if (true/*!mParamStringInitialized*/) {
        //filter picture sizes
        filterPictureSizes();
        mPictureSizeValues = create_sizes_str(
                mPictureSizesPtr, mSupportedPictureSizesCount);
        mPreviewSizeValues = create_sizes_str(
                mPreviewSizes,  mPreviewSizeCount);
        mVideoSizeValues = create_sizes_str(
                mVideoSizes,  mVideoSizeCount);

        //Query for max HFR value
        camera_hfr_mode_t maxHFR;
        mCameraHandle->ops->get_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_MAX_HFR_MODE, (void *)&maxHFR);
        //Filter HFR values and build parameter string
        String8 str;
        for(int i=0; i<HFR_VALUES_COUNT; i++){
            if(hfr[i].val <= maxHFR){
                if(i>0)	str.append(",");
                str.append(hfr[i].desc);
            }
        }
        mHfrValues = str;
        mHfrSizeValues = create_sizes_str(
                default_hfr_sizes, hfr_sizes_count);

        //Query for min and max fps values from lower layer
        if(MM_CAMERA_OK != mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                                     MM_CAMERA_PARM_FPS_RANGE, (void *)&mSensorFpsRange)){
            ALOGE("error: failed to get fps range from sensor");
            return;
        } else {
            ALOGD("sensor fps range = (%f, %f)", mSensorFpsRange.min_fps,
                            mSensorFpsRange.max_fps);

            mSupportedFpsRanges = new android::FPSRange[ALL_FPS_RANGES_COUNT+1];

            //min and max fps in android format
            int minFps = (int)(mSensorFpsRange.min_fps * 1000);
            int maxFps = (int)(mSensorFpsRange.max_fps * 1000);
            int idx=0;
            //filter supported fps ranges according to sensor fps range
            for(int i=0; i<(int)ALL_FPS_RANGES_COUNT; i++) {
                if(allFpsRanges[i].maxFPS <= maxFps && allFpsRanges[i].minFPS >= minFps) {
                    memcpy(&mSupportedFpsRanges[idx], &allFpsRanges[i], sizeof(android::FPSRange));
                    idx++;
                }
            }
            mSupportedFpsRangesCount = idx;
            //insert sensor absolute fps range as one entry, if
            //its not already there in table
            //find insertion point
            int insertIndex = mSupportedFpsRangesCount;
            for(int i=0; i<mSupportedFpsRangesCount; i++) {
                if(mSupportedFpsRanges[i].maxFPS < maxFps) {
                   continue;
                } else if (mSupportedFpsRanges[i].maxFPS == maxFps) {
                    if(mSupportedFpsRanges[i].minFPS > minFps) {
                        insertIndex = i;
                        break;
                    } else if (mSupportedFpsRanges[i].minFPS == minFps) {
                        //entry already exists, no need to insert
                        insertIndex = -1;
                        break;
                    }
                }
            }
            if(insertIndex != -1) {
                for(int i=mSupportedFpsRangesCount; i>=0; i--) {
                    if(insertIndex == i) {
                        mSupportedFpsRanges[i].maxFPS = maxFps;
                        mSupportedFpsRanges[i].minFPS = minFps;
                        mSupportedFpsRangesCount++;
                        break;
                    }
                    mSupportedFpsRanges[i].maxFPS = mSupportedFpsRanges[i-1].maxFPS;
                    mSupportedFpsRanges[i].minFPS = mSupportedFpsRanges[i-1].minFPS;
                }
            }
            mFpsRangesSupportedValues = create_fps_str(mSupportedFpsRanges, mSupportedFpsRangesCount);

            ALOGD("supported fps ranges = %s", mFpsRangesSupportedValues.string());
            mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE,
                mFpsRangesSupportedValues);
            mParameters.setPreviewFpsRange(minFps, maxFps);
        }

        mFlashValues = create_values_str(
            flash, sizeof(flash) / sizeof(str_map));
        mLensShadeValues = create_values_str(
            lensshade,sizeof(lensshade)/sizeof(str_map));
        mMceValues = create_values_str(
            mce,sizeof(mce)/sizeof(str_map));
        mEffectValues = create_values_str(effects, sizeof(effects) / sizeof(str_map));
        mAntibandingValues = create_values_str(
            antibanding, sizeof(antibanding) / sizeof(str_map));
        mIsoValues = create_values_str(iso,sizeof(iso)/sizeof(str_map));
        mAutoExposureValues = create_values_str(
            autoexposure, sizeof(autoexposure) / sizeof(str_map));
        mWhitebalanceValues = create_values_str(
            whitebalance, sizeof(whitebalance) / sizeof(str_map));

        if(mHasAutoFocusSupport){
            mFocusModeValues = create_values_str(
                    focus_modes, sizeof(focus_modes) / sizeof(str_map));
        }

        mSceneModeValues = create_values_str(scenemode, sizeof(scenemode) / sizeof(str_map));

        if(mHasAutoFocusSupport){
            mTouchAfAecValues = create_values_str(
                touchafaec,sizeof(touchafaec)/sizeof(str_map));
        }
        //Currently Enabling Histogram for 8x60
        mHistogramValues = create_values_str(
            histogram,sizeof(histogram)/sizeof(str_map));

        mSkinToneEnhancementValues = create_values_str(
            skinToneEnhancement,sizeof(skinToneEnhancement)/sizeof(str_map));

        mPictureFormatValues = create_values_str(
            picture_formats, sizeof(picture_formats)/sizeof(str_map));

        mZoomSupported=false;
        mMaxZoom=0;
        mm_camera_zoom_tbl_t zmt;
        if( mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                             MM_CAMERA_PARM_MAXZOOM, &mMaxZoom)<0){
            ALOGE("%s:Failed to get max zoom",__func__);
        }else{

            ALOGE("Max Zoom:%d",mMaxZoom);
            /* Kernel driver limits the max amount of data that can be retreived through a control
            command to 260 bytes hence we conservatively limit to 110 zoom ratios */
            if(mMaxZoom>MAX_ZOOM_RATIOS) {
                ALOGE("%s:max zoom is larger than sizeof zoomRatios table",__func__);
                mMaxZoom=MAX_ZOOM_RATIOS-1;
            }
            zmt.size=mMaxZoom;
            zmt.zoom_ratio_tbl=&zoomRatios[0];
            if( mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                                 MM_CAMERA_PARM_ZOOM_RATIO, &zmt)<0){
                ALOGE("%s:Failed to get max zoom ratios",__func__);
            }else{
                mZoomSupported=true;
                mZoomRatioValues =  create_str(zoomRatios, mMaxZoom);
            }
        }

        ALOGE("Zoom supported:%d",mZoomSupported);

        denoise_value = create_values_str(
            denoise, sizeof(denoise) / sizeof(str_map));

       if(supportsFaceDetection()) {
            mFaceDetectionValues = create_values_str(
                facedetection, sizeof(facedetection) / sizeof(str_map));
        }

        if(mHasAutoFocusSupport){
            mSelectableZoneAfValues = create_values_str(
                selectable_zone_af, sizeof(selectable_zone_af) / sizeof(str_map));
        }

        mSceneDetectValues = create_values_str(scenedetect, sizeof(scenedetect) / sizeof(str_map));

        mRedeyeReductionValues = create_values_str(
            redeye_reduction, sizeof(redeye_reduction) / sizeof(str_map));

        mZslValues = create_values_str(
            zsl_modes,sizeof(zsl_modes)/sizeof(str_map));

        mParamStringInitialized = true;
    }

    //set supported video sizes
    mParameters.set(QCameraParameters::KEY_SUPPORTED_VIDEO_SIZES, mVideoSizeValues.string());

    //set default video size to first one in supported table
    String8 vSize = create_sizes_str(&mVideoSizes[0], 1);
    mParameters.set(QCameraParameters::KEY_VIDEO_SIZE, vSize.string());

    //Set Preview size
    int default_preview_width, default_preview_height;
    mCameraHandle->ops->get_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_DEFAULT_PREVIEW_WIDTH,
            &default_preview_width);
    mCameraHandle->ops->get_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_DEFAULT_PREVIEW_HEIGHT,
            &default_preview_height);
    mParameters.setPreviewSize(default_preview_width, default_preview_height);
    mParameters.set(QCameraParameters::KEY_SUPPORTED_PREVIEW_SIZES,
                    mPreviewSizeValues.string());
    mDimension.display_width = default_preview_width;
    mDimension.display_height = default_preview_height;

    mPreviewFrameRateValues = create_values_range_str(
        MINIMUM_FPS, MAXIMUM_FPS);


    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle, MM_CAMERA_PARM_FPS,&supported,&supported);
    if (supported) {
        mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES,
                        mPreviewFrameRateValues.string());
     } else {
        mParameters.set(
            QCameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES,
            DEFAULT_FIXED_FPS);
    }
    //Set Preview Format
    //mParameters.setPreviewFormat("yuv420sp"); // informative
    mParameters.setPreviewFormat(QCameraParameters::PIXEL_FORMAT_YUV420SP);

    mPreviewFormatValues = create_values_str(
        preview_formats, sizeof(preview_formats) / sizeof(str_map));
    mParameters.set(QCameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS,
            mPreviewFormatValues.string());

    //Set Overlay Format
    mParameters.set("overlay-format", HAL_PIXEL_FORMAT_YCbCr_420_SP);
    mParameters.set("max-num-detected-faces-hw", "2");

    // Set supported max faces
    int maxNumFaces = 0;
    if (supportsFaceDetection()) {
        //Query the maximum number of faces supported by hardware.
        if(MM_CAMERA_OK != mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                               MM_CAMERA_PARM_MAX_NUM_FACES_DECT, &maxNumFaces)){
            ALOGE("%s:Failed to get max number of faces supported",__func__);
        }
    }
    mParameters.set(CameraParameters::KEY_MAX_NUM_DETECTED_FACES_HW, maxNumFaces);
    //This paramtere is set to default here. This will be changed by application
    //if it needs to support specific number of faces. See also setParameters.
    mParameters.set(QCameraParameters::KEY_QC_MAX_NUM_REQUESTED_FACES, 2);

    // Set camera features supported flag
    int32_t featureFlag = 0;
    if (supportsFaceDetection()) {
        featureFlag |= 0x00000001; // bit 0 indicate faciral feature
    }
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_CAMERA_FEATURES, featureFlag);

    //Set Picture Size
    mParameters.setPictureSize(DEFAULT_PICTURE_WIDTH, DEFAULT_PICTURE_HEIGHT);
    mParameters.set(QCameraParameters::KEY_SUPPORTED_PICTURE_SIZES,
                    mPictureSizeValues.string());

    //Set Preview Frame Rate
    if(mFps >= MINIMUM_FPS && mFps <= MAXIMUM_FPS) {
        mParameters.setPreviewFrameRate(mFps);
    }else{
        mParameters.setPreviewFrameRate(DEFAULT_FIXED_FPS);
    }

    //Set Picture Format
    mParameters.setPictureFormat("jpeg"); // informative
    mParameters.set(QCameraParameters::KEY_SUPPORTED_PICTURE_FORMATS,
                    mPictureFormatValues);

    mParameters.set(QCameraParameters::KEY_JPEG_QUALITY, "85"); // max quality
    mJpegQuality = 85;
    //Set Video Format
    mParameters.set(QCameraParameters::KEY_VIDEO_FRAME_FORMAT, "yuv420sp");

    //Set Thumbnail parameters
    mParameters.set(QCameraParameters::KEY_JPEG_THUMBNAIL_WIDTH,
                    THUMBNAIL_WIDTH_STR); // informative
    mParameters.set(QCameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT,
                    THUMBNAIL_HEIGHT_STR); // informative
    mDimension.ui_thumbnail_width =
            thumbnail_sizes[DEFAULT_THUMBNAIL_SETTING].width;
    mDimension.ui_thumbnail_height =
            thumbnail_sizes[DEFAULT_THUMBNAIL_SETTING].height;
    mParameters.set(QCameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "90");
    String8 valuesStr = create_sizes_str(default_thumbnail_sizes, thumbnail_sizes_count);
    mParameters.set(QCameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES,
                valuesStr.string());
    // Define CAMERA_SMOOTH_ZOOM in Android.mk file , to enable smoothzoom
#ifdef CAMERA_SMOOTH_ZOOM
    mParameters.set(QCameraParameters::KEY_SMOOTH_ZOOM_SUPPORTED, "true");
#endif
    if(mZoomSupported){
        mParameters.set(QCameraParameters::KEY_ZOOM_SUPPORTED, "true");
        ALOGE("max zoom is %d", mMaxZoom-1);
        /* mMaxZoom value that the query interface returns is the size
        ALOGV("max zoom is %d", mMaxZoom-1);
        * mMaxZoom value that the query interface returns is the size
         * of zoom table. So the actual max zoom value will be one
         * less than that value.          */

        mParameters.set("max-zoom",mMaxZoom-1);
        mParameters.set(QCameraParameters::KEY_ZOOM_RATIOS,
                            mZoomRatioValues);
    } else
        {
        mParameters.set(QCameraParameters::KEY_ZOOM_SUPPORTED, "false");
    }

    /* Enable zoom support for video application if VPE enabled */
    if(mZoomSupported) {
        mParameters.set("video-zoom-support", "true");
    } else {
        mParameters.set("video-zoom-support", "false");
    }

    //8960 supports Power modes : Low power, Normal Power.
    mParameters.set("power-mode-supported", "true");
    //Set Live shot support
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_LIVESHOT_MAIN,
                                          &supported,&supported);
    if(!supported) {
        ALOGE("%s:LIVESHOT is  not supported", __func__);
        mParameters.set("video-snapshot-supported", "false");
        mFullLiveshotEnabled = rc;
    } else {
        mParameters.set("video-snapshot-supported", "true");
    }

    //Set default power mode
    mParameters.set(QCameraParameters::KEY_QC_POWER_MODE,"Normal_Power");

    //Set Camera Mode
    mParameters.set(QCameraParameters::KEY_QC_CAMERA_MODE,0);
    mParameters.set(QCameraParameters::KEY_QC_AE_BRACKET_HDR,"Off");

    //Set Antibanding
    mParameters.set(QCameraParameters::KEY_ANTIBANDING,
                    QCameraParameters::ANTIBANDING_OFF);
    mParameters.set(QCameraParameters::KEY_SUPPORTED_ANTIBANDING,
                    mAntibandingValues);

    //Set Effect
    mParameters.set(QCameraParameters::KEY_EFFECT,
                    QCameraParameters::EFFECT_NONE);
    mParameters.set(QCameraParameters::KEY_SUPPORTED_EFFECTS, mEffectValues);

    //Set Auto Exposure
    mParameters.set(QCameraParameters::KEY_QC_AUTO_EXPOSURE,
                    QCameraParameters::AUTO_EXPOSURE_FRAME_AVG);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_AUTO_EXPOSURE, mAutoExposureValues);

    //Set WhiteBalance
    mParameters.set(QCameraParameters::KEY_WHITE_BALANCE,
                    QCameraParameters::WHITE_BALANCE_AUTO);
    mParameters.set(QCameraParameters::KEY_SUPPORTED_WHITE_BALANCE,mWhitebalanceValues);

    //Set AEC_LOCK
    mParameters.set(CameraParameters::KEY_AUTO_EXPOSURE_LOCK, "false");
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_AEC_LOCK,&supported,&supported);
    if(supported){
        mParameters.set(CameraParameters::KEY_AUTO_EXPOSURE_LOCK_SUPPORTED, "true");
    } else {
        mParameters.set(QCameraParameters::KEY_AUTO_EXPOSURE_LOCK_SUPPORTED, "false");
    }
    //Set AWB_LOCK
    mParameters.set(CameraParameters::KEY_AUTO_WHITEBALANCE_LOCK, "false");
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_AWB_LOCK,&supported,&supported);
    if(supported)
        mParameters.set(CameraParameters::KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED, "true");
    else
        mParameters.set(QCameraParameters::KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED, "false");

    //Set Focus Mode
    if(mHasAutoFocusSupport){
       mParameters.set(QCameraParameters::KEY_FOCUS_MODE,
                          QCameraParameters::FOCUS_MODE_AUTO);
       mFocusMode = AF_MODE_AUTO;
       mParameters.set(QCameraParameters::KEY_SUPPORTED_FOCUS_MODES,
                          mFocusModeValues);
       mParameters.set(QCameraParameters::KEY_MAX_NUM_FOCUS_AREAS, "1");
       mParameters.set(QCameraParameters::KEY_MAX_NUM_METERING_AREAS, "1");
   } else {
       mParameters.set(QCameraParameters::KEY_FOCUS_MODE,
       QCameraParameters::FOCUS_MODE_INFINITY);
       mFocusMode = DONT_CARE;
       mParameters.set(QCameraParameters::KEY_SUPPORTED_FOCUS_MODES,
       QCameraParameters::FOCUS_MODE_INFINITY);
       mParameters.set(QCameraParameters::KEY_MAX_NUM_FOCUS_AREAS, "0");
       mParameters.set(QCameraParameters::KEY_MAX_NUM_METERING_AREAS, "0");
   }

    mParameters.set(QCameraParameters::KEY_FOCUS_AREAS, DEFAULT_CAMERA_AREA);
    mParameters.set(QCameraParameters::KEY_METERING_AREAS, DEFAULT_CAMERA_AREA);

    //Set Flash
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_LED_MODE,&supported,&supported);
    if(supported){
        mParameters.set(CameraParameters::KEY_FLASH_MODE,
                        CameraParameters::FLASH_MODE_OFF);
        mParameters.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES,
                        mFlashValues);
    }

    //Set Sharpness
    mParameters.set(QCameraParameters::KEY_QC_MAX_SHARPNESS,
            CAMERA_MAX_SHARPNESS);
    mParameters.set(QCameraParameters::KEY_QC_SHARPNESS,
                    CAMERA_DEF_SHARPNESS);

    //Set Contrast
    mParameters.set(QCameraParameters::KEY_QC_MAX_CONTRAST,
            CAMERA_MAX_CONTRAST);
    mParameters.set(QCameraParameters::KEY_QC_CONTRAST,
                    CAMERA_DEF_CONTRAST);

    //Set Saturation
    mParameters.set(QCameraParameters::KEY_QC_MAX_SATURATION,
            CAMERA_MAX_SATURATION);
    mParameters.set(QCameraParameters::KEY_QC_SATURATION,
                    CAMERA_DEF_SATURATION);

    //Set Brightness/luma-adaptaion
    mParameters.set("luma-adaptation", "3");

    mParameters.set(QCameraParameters::KEY_PICTURE_FORMAT,
                    QCameraParameters::PIXEL_FORMAT_JPEG);

    //Set Lensshading
    mParameters.set(QCameraParameters::KEY_QC_LENSSHADE,
                    QCameraParameters::LENSSHADE_ENABLE);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_LENSSHADE_MODES,
                    mLensShadeValues);

    //Set ISO Mode
    mParameters.set(QCameraParameters::KEY_QC_ISO_MODE,
                    QCameraParameters::ISO_AUTO);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_ISO_MODES,
                    mIsoValues);

    //Set MCE
    mParameters.set(QCameraParameters::KEY_QC_MEMORY_COLOR_ENHANCEMENT,
                    QCameraParameters::MCE_ENABLE);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_MEM_COLOR_ENHANCE_MODES,
                    mMceValues);

    //Set HFR
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_HFR,&supported,&supported);
    if(supported){
        mParameters.set(QCameraParameters::KEY_QC_VIDEO_HIGH_FRAME_RATE,
                    QCameraParameters::VIDEO_HFR_OFF);
        mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_HFR_SIZES,
                    mHfrSizeValues.string());
        mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES,
                    mHfrValues);
    } else{
        mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_HFR_SIZES,"");
    }

    //Set Histogram
    mParameters.set(QCameraParameters::KEY_QC_HISTOGRAM,
                    QCameraParameters::HISTOGRAM_DISABLE);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_HISTOGRAM_MODES,
                    mHistogramValues);

    //Set SkinTone Enhancement
    mParameters.set(QCameraParameters::KEY_QC_SKIN_TONE_ENHANCEMENT,
                    QCameraParameters::SKIN_TONE_ENHANCEMENT_DISABLE);
    mParameters.set("skinToneEnhancement", "0");
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES,
                    mSkinToneEnhancementValues);

    //Set Scene Mode
    mParameters.set(QCameraParameters::KEY_SCENE_MODE,
                    QCameraParameters::SCENE_MODE_AUTO);
    mParameters.set(QCameraParameters::KEY_SUPPORTED_SCENE_MODES,
                    mSceneModeValues);

    //Set Streaming Textures
    mParameters.set("strtextures", "OFF");

    //Set Denoise
    mParameters.set(QCameraParameters::KEY_QC_DENOISE,
                    QCameraParameters::DENOISE_OFF);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_DENOISE,
                        denoise_value);
    //Set Touch AF/AEC
    mParameters.set(QCameraParameters::KEY_QC_TOUCH_AF_AEC,
                    QCameraParameters::TOUCH_AF_AEC_OFF);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_TOUCH_AF_AEC,
                    mTouchAfAecValues);
    mParameters.set("touchAfAec-dx","100");
    mParameters.set("touchAfAec-dy","100");

    //Set Scene Detection
    mParameters.set(QCameraParameters::KEY_QC_SCENE_DETECT,
                   QCameraParameters::SCENE_DETECT_OFF);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_SCENE_DETECT,
                    mSceneDetectValues);

    //Set Selectable Zone AF
    mParameters.set(QCameraParameters::KEY_QC_SELECTABLE_ZONE_AF,
                    QCameraParameters::SELECTABLE_ZONE_AF_AUTO);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_SELECTABLE_ZONE_AF,
                    mSelectableZoneAfValues);

    //Set Face Detection
    mParameters.set(QCameraParameters::KEY_QC_FACE_DETECTION,
                    QCameraParameters::FACE_DETECTION_OFF);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_FACE_DETECTION,
                    mFaceDetectionValues);

    //Set Red Eye Reduction
    mParameters.set(QCameraParameters::KEY_QC_REDEYE_REDUCTION,
                    QCameraParameters::REDEYE_REDUCTION_DISABLE);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_REDEYE_REDUCTION,
                    mRedeyeReductionValues);

    //Set ZSL
    mParameters.set(QCameraParameters::KEY_QC_ZSL,
                    QCameraParameters::ZSL_OFF);
    mParameters.set(QCameraParameters::KEY_QC_SUPPORTED_ZSL_MODES,
                    mZslValues);

    //Set Focal length, horizontal and vertical view angles
    float focalLength = 0.0f;
    float horizontalViewAngle = 0.0f;
    float verticalViewAngle = 0.0f;
    mCameraHandle->ops->get_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_FOCAL_LENGTH,
            (void *)&focalLength);
    mParameters.setFloat(QCameraParameters::KEY_FOCAL_LENGTH,
                    focalLength);
    mCameraHandle->ops->get_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_HORIZONTAL_VIEW_ANGLE,
            (void *)&horizontalViewAngle);
    mParameters.setFloat(QCameraParameters::KEY_HORIZONTAL_VIEW_ANGLE,
                    horizontalViewAngle);
    mCameraHandle->ops->get_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_VERTICAL_VIEW_ANGLE,
            (void *)&verticalViewAngle);
    mParameters.setFloat(QCameraParameters::KEY_VERTICAL_VIEW_ANGLE,
                    verticalViewAngle);

    //Set Exposure Compensation
    mParameters.set(
            QCameraParameters::KEY_MAX_EXPOSURE_COMPENSATION,
            EXPOSURE_COMPENSATION_MAXIMUM_NUMERATOR);
    mParameters.set(
            QCameraParameters::KEY_MIN_EXPOSURE_COMPENSATION,
            EXPOSURE_COMPENSATION_MINIMUM_NUMERATOR);
    mParameters.set(
            QCameraParameters::KEY_EXPOSURE_COMPENSATION,
            EXPOSURE_COMPENSATION_DEFAULT_NUMERATOR);
    mParameters.setFloat(
            QCameraParameters::KEY_EXPOSURE_COMPENSATION_STEP,
            EXPOSURE_COMPENSATION_STEP);

    mParameters.set("num-snaps-per-shutter", 1);

    mParameters.set("capture-burst-captures-values", getZSLQueueDepth());
    mParameters.set("capture-burst-interval-supported", "true");
    mParameters.set("capture-burst-interval-max", BURST_INTREVAL_MAX); /*skip frames*/
    mParameters.set("capture-burst-interval-min", BURST_INTREVAL_MIN); /*skip frames*/
    mParameters.set("capture-burst-interval", BURST_INTREVAL_DEFAULT); /*skip frames*/
    mParameters.set("capture-burst-retroactive", 0);
    mParameters.set("capture-burst-retroactive-max", getZSLQueueDepth());
    mParameters.set("capture-burst-exposures", "");
    mParameters.set("capture-burst-exposures-values",
      "-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12");
    {
      String8 CamModeStr;
      char buffer[32];
      int flag = 0;

      for (int i = 0; i < HAL_CAM_MODE_MAX; i++) {
        if ( 0 ) { /*exclude some conflicting case*/
        } else {
          if (flag == 0) { /*first item*/
          snprintf(buffer, sizeof(buffer), "%d", i);
          } else {
            snprintf(buffer, sizeof(buffer), ",%d", i);
          }
          flag = 1;
          CamModeStr.append(buffer);
        }
      }
      mParameters.set("camera-mode-values", CamModeStr);
    }

    mParameters.set("ae-bracket-hdr-values",
      create_values_str(hdr_bracket, sizeof(hdr_bracket)/sizeof(str_map) ));

    mParameters.set("no-display-mode", 0);
    mParameters.set("zoom", 0);

    int mNuberOfVFEOutputs;
    ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                                       MM_CAMERA_PARM_VFE_OUTPUT_ENABLE, &mNuberOfVFEOutputs);
    if(ret < 0) {
        ALOGE("get parm MM_CAMERA_PARM_VFE_OUTPUT_ENABLE  failed");
        ret = BAD_VALUE;
    }
    if(mNuberOfVFEOutputs == 1)
    {
       mParameters.set(QCameraParameters::KEY_QC_SINGLE_ISP_OUTPUT_ENABLED, "true");
    } else {
       mParameters.set(QCameraParameters::KEY_QC_SINGLE_ISP_OUTPUT_ENABLED, "false");
    }

    if (setParameters(mParameters) != NO_ERROR) {
        ALOGE("Failed to set default parameters?!");
    }
    mInitialized = true;
    strTexturesOn = false;

    ALOGI("%s: X", __func__);
    return;
!!!44387895.cpp!!!	getMaxPictureDimension(inout maxDim : mm_camera_dimension_t) : bool
    bool ret = NO_ERROR;
    mm_camera_dimension_t dim;

    ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                              MM_CAMERA_PARM_MAX_PICTURE_SIZE, &dim);
    if (ret != NO_ERROR)
        return ret;

    /* Find the first dimension in the mPictureSizes
     * array which is smaller than the max dimension.
     * This will be the valid max picture resolution */
    for (unsigned int i = 0; i < mPictureSizeCount; i++) {
        if ((mPictureSizes[i].width <= dim.width) &&
            (mPictureSizes[i].height <= dim.height)) {
            maxDim->height = mPictureSizes[i].height;
            maxDim->width  = mPictureSizes[i].width;
            break;
        }
    }
    ALOGD("%s: Found Max Picture dimension: %d x %d", __func__,
          maxDim->width, maxDim->height);
    return ret;
!!!44388023.cpp!!!	updateFocusDistances() : status_t
    ALOGV("%s: IN", __FUNCTION__);
    focus_distances_info_t focusDistances;
    if(mCameraHandle->ops->get_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_FOCUS_DISTANCES,
      &focusDistances) >= 0) {
        String8 str;
        char buffer[32] = {0};
        //set all distances to infinity if focus mode is infinity
        if(mFocusMode == AF_MODE_INFINITY) {
            snprintf(buffer, sizeof(buffer), "Infinity,");
            str.append(buffer);
            snprintf(buffer, sizeof(buffer), "Infinity,");
            str.append(buffer);
            snprintf(buffer, sizeof(buffer), "Infinity");
            str.append(buffer);
        } else {
            snprintf(buffer, sizeof(buffer), "%f", focusDistances.focus_distance[0]);
            str.append(buffer);
            snprintf(buffer, sizeof(buffer), ",%f", focusDistances.focus_distance[1]);
            str.append(buffer);
            snprintf(buffer, sizeof(buffer), ",%f", focusDistances.focus_distance[2]);
            str.append(buffer);
        }
        ALOGE("%s: setting KEY_FOCUS_DISTANCES as %s", __FUNCTION__, str.string());
        mFocusDistance = str;
        return NO_ERROR;
    }
    ALOGV("%s: get CAMERA_PARM_FOCUS_DISTANCES failed!!!", __FUNCTION__);
    return BAD_VALUE;
!!!44388151.cpp!!!	native_set_parms(in type : mm_camera_parm_type_t, in length : uint16_t, inout value : void) : bool
    ALOGV("%s : type : %d Value : %d",__func__,type,*((int *)value));
    if(mCameraHandle->ops->set_parm(mCameraHandle->camera_handle, type,value ) < 0) {
        ALOGE("native_set_parms failed: type %d length %d error %s",
            type, length, strerror(errno));
        return false;
    }

    return true;

!!!44388279.cpp!!!	native_set_parms(in type : mm_camera_parm_type_t, in length : uint16_t, inout value : void, inout result : int) : bool
    *result= mCameraHandle->ops->set_parm(mCameraHandle->camera_handle, type,value );
    if( *result >=0 ) {
        ALOGE("native_set_parms: succeeded : %d", *result);
        return true;
    }

    ALOGV("native_set_parms failed: type %d length %d error str %s error# %d",
        type, length, strerror(errno), errno);
    return false;
!!!44388407.cpp!!!	hasAutoFocusSupport() : void

    ALOGV("%s",__func__);
    mHasAutoFocusSupport = false;

    if(isZSLMode()){
        mHasAutoFocusSupport = false;
        return;
    }

    if(mCameraHandle->ops->is_op_supported(mCameraHandle->camera_handle, MM_CAMERA_OPS_FOCUS)) {
        mHasAutoFocusSupport = true;
    }
    else {
        ALOGE("AutoFocus is not supported");
        mHasAutoFocusSupport = false;
    }
    ALOGV("%s:rc= %d",__func__, mHasAutoFocusSupport);

!!!44388535.cpp!!!	debugShowPreviewFPS() : void
    static int mFrameCount;
    static int mLastFrameCount = 0;
    static nsecs_t mLastFpsTime = 0;
    static float mFps = 0;
    mFrameCount++;
    nsecs_t now = systemTime();
    nsecs_t diff = now - mLastFpsTime;
    if (diff > ms2ns(250)) {
        mFps =  ((mFrameCount - mLastFrameCount) * float(s2ns(1))) / diff;
        ALOGE("Preview Frames Per Second: %.4f", mFps);
        mLastFpsTime = now;
        mLastFrameCount = mFrameCount;
    }
!!!44388663.cpp!!!	isPreviewRunning() : bool
    ALOGI("isPreviewRunning: E");
    bool ret = false;

    switch(mPreviewState) {
    case QCAMERA_HAL_PREVIEW_START:
    case QCAMERA_HAL_PREVIEW_STARTED:
    case QCAMERA_HAL_RECORDING_STARTED:
        ret = true;
        break;
    default:
        break;
    }
    ALOGI("isPreviewRunning: X");
    return ret;
!!!44388791.cpp!!!	isRecordingRunning() : bool
    ALOGE("isRecordingRunning: E");
    bool ret = false;
    if(QCAMERA_HAL_RECORDING_STARTED == mPreviewState)
      ret = true;
    ALOGE("isRecordingRunning: X");
    return ret;
!!!44388919.cpp!!!	isSnapshotRunning() : bool
    ALOGE("isSnapshotRunning: E");
    bool ret = false;
    switch(mPreviewState) {
    case QCAMERA_HAL_PREVIEW_STOPPED:
    case QCAMERA_HAL_PREVIEW_START:
    case QCAMERA_HAL_PREVIEW_STARTED:
    case QCAMERA_HAL_RECORDING_STARTED:
    default:
        break;
    case QCAMERA_HAL_TAKE_PICTURE:
        ret = true;
        break;
    }
    ALOGI("isSnapshotRunning: X");
    return ret;
!!!44389047.cpp!!!	processChannelEvent(inout event : mm_camera_ch_event_t, inout app_cb : app_notify_cb_t) : void
    ALOGI("processChannelEvent: E");
    Mutex::Autolock lock(mLock);
    switch(event->ch) {
        case MM_CAMERA_PREVIEW:
            processPreviewChannelEvent(event->evt, app_cb);
            break;
        case MM_CAMERA_RDI:
            processRdiChannelEvent(event->evt, app_cb);
            break;
        case MM_CAMERA_VIDEO:
            processRecordChannelEvent(event->evt, app_cb);
            break;
        case MM_CAMERA_SNAPSHOT_MAIN:
        case MM_CAMERA_SNAPSHOT_THUMBNAIL:
            processSnapshotChannelEvent(event->evt, app_cb);
            break;
        default:
            break;
    }
    ALOGI("processChannelEvent: X");
    return;
!!!44389175.cpp!!!	processRdiChannelEvent(in channelEvent : mm_camera_ch_event_type_t, inout app_cb : app_notify_cb_t) : void
    ALOGI("processRdiChannelEvent: E evt=%d state=%d", channelEvent,
      mCameraState);
    switch(channelEvent) {
        case MM_CAMERA_CH_EVT_STREAMING_ON:
            break;
        case MM_CAMERA_CH_EVT_STREAMING_OFF:
            break;
        case MM_CAMERA_CH_EVT_DATA_DELIVERY_DONE:
            break;
        case MM_CAMERA_CH_EVT_DATA_REQUEST_MORE:
            break;
        default:
            break;
    }
    ALOGI("processRdiChannelEvent: X");
    return;
!!!44389303.cpp!!!	processPreviewChannelEvent(in channelEvent : mm_camera_ch_event_type_t, inout app_cb : app_notify_cb_t) : void
    ALOGI("processPreviewChannelEvent: E");
    switch(channelEvent) {
        case MM_CAMERA_CH_EVT_STREAMING_ON:
            break;
        case MM_CAMERA_CH_EVT_STREAMING_OFF:
            break;
        case MM_CAMERA_CH_EVT_DATA_DELIVERY_DONE:
            break;
        default:
            break;
    }
    ALOGI("processPreviewChannelEvent: X");
    return;
!!!44389431.cpp!!!	processRecordChannelEvent(in channelEvent : mm_camera_ch_event_type_t, inout app_cb : app_notify_cb_t) : void
    ALOGI("processRecordChannelEvent: E");
    switch(channelEvent) {
        case MM_CAMERA_CH_EVT_STREAMING_ON:
            break;
        case MM_CAMERA_CH_EVT_STREAMING_OFF:
            break;
        case MM_CAMERA_CH_EVT_DATA_DELIVERY_DONE:
            break;
        default:
            break;
    }
    ALOGI("processRecordChannelEvent: X");
    return;
!!!44389559.cpp!!!	processSnapshotChannelEvent(in channelEvent : mm_camera_ch_event_type_t, inout app_cb : app_notify_cb_t) : void
    ALOGI("processSnapshotChannelEvent: E evt=%d state=%d", channelEvent,
      mCameraState);
    switch(channelEvent) {
        case MM_CAMERA_CH_EVT_STREAMING_ON:
            break;
        case MM_CAMERA_CH_EVT_STREAMING_OFF:
            break;
        case MM_CAMERA_CH_EVT_DATA_DELIVERY_DONE:
            break;
        case MM_CAMERA_CH_EVT_DATA_REQUEST_MORE:
            break;
        default:
            break;
    }
    ALOGI("processSnapshotChannelEvent: X");
    return;
!!!44389687.cpp!!!	processCtrlEvent(inout event : mm_camera_ctrl_event_t, inout app_cb : app_notify_cb_t) : void
    ALOGI("processCtrlEvent: %d, E",event->evt);
    ALOGE("processCtrlEvent: MM_CAMERA_CTRL_EVT_HDR_DONE is %d", MM_CAMERA_CTRL_EVT_HDR_DONE);
    if(rdiMode == STREAM_RAW) {
        return;
    }
    Mutex::Autolock lock(mLock);
    switch(event->evt)
    {
        case MM_CAMERA_CTRL_EVT_ZOOM_DONE:
            ALOGI("processCtrlEvent: MM_CAMERA_CTRL_EVT_ZOOM_DONE");
            zoomEvent(&event->status, app_cb);
            break;
        case MM_CAMERA_CTRL_EVT_AUTO_FOCUS_DONE:
            ALOGI("processCtrlEvent: MM_CAMERA_CTRL_EVT_AUTO_FOCUS_DONE");
            autoFocusEvent(&event->status, app_cb);
            break;
        case MM_CAMERA_CTRL_EVT_PREP_SNAPSHOT:
            ALOGI("processCtrlEvent: MM_CAMERA_CTRL_EVT_ZOOM_DONE");
            break;
        case MM_CAMERA_CTRL_EVT_WDN_DONE:
            ALOGI("processCtrlEvent: MM_CAMERA_CTRL_EVT_WDN_DONE");
            wdenoiseEvent(event->status, (void *)(event->cookie));
            break;
        case MM_CAMERA_CTRL_EVT_HDR_DONE:
            ALOGI("processCtrlEvent:MM_CAMERA_CTRL_EVT_HDR_DONE");
            notifyHdrEvent(event->status, (void*)(event->cookie));
            break;
        case MM_CAMERA_CTRL_EVT_ERROR:
            ALOGI("processCtrlEvent: MM_CAMERA_CTRL_EVT_ERROR");
            app_cb->notifyCb  = mNotifyCb;
            app_cb->argm_notify.msg_type = CAMERA_MSG_ERROR;
            app_cb->argm_notify.ext1 = CAMERA_ERROR_UNKNOWN;
            app_cb->argm_notify.cookie =  mCallbackCookie;
            break;
        case MM_CAMERA_CTRL_EVT_SNAPSHOT_CONFIG_DONE:
            ALOGV("%s: MM_CAMERA_CTRL_EVT_SNAPSHOT_CONFIG_DONE", __func__);
            app_cb->notifyCb  = mNotifyCb;
            app_cb->argm_notify.msg_type = CAMERA_MSG_SHUTTER;
            app_cb->argm_notify.ext1 = 0;
            app_cb->argm_notify.ext2 = TRUE;
            app_cb->argm_notify.cookie =  mCallbackCookie;
            mShutterSoundPlayed = TRUE;
       default:
            break;
    }
    ALOGI("processCtrlEvent: X");
    return;
!!!44389815.cpp!!!	processStatsEvent(inout event : mm_camera_stats_event_t, inout app_cb : app_notify_cb_t) : void
    ALOGI("processStatsEvent: E");
    if (!isPreviewRunning( )) {
        ALOGE("preview is not running");
        return;
    }

    switch (event->event_id) {

        case MM_CAMERA_STATS_EVT_HISTO:
        {
            ALOGE("HAL process Histo: mMsgEnabled=0x%x, mStatsOn=%d, mSendData=%d, mDataCb=%p ",
                  (mMsgEnabled & CAMERA_MSG_STATS_DATA), mStatsOn, mSendData, mDataCb);
            int msgEnabled = mMsgEnabled;
            /*get stats buffer based on index*/
            camera_preview_histogram_info* hist_info =
                (camera_preview_histogram_info*) mHistServer.camera_memory[event->e.stats_histo.index]->data;

            if(mStatsOn == QCAMERA_PARM_ENABLE && mSendData &&
                            mDataCb && (msgEnabled & CAMERA_MSG_STATS_DATA) ) {
                uint32_t *dest;
                mSendData = false;
                mCurrentHisto = (mCurrentHisto + 1) % 3;
                // The first element of the array will contain the maximum hist value provided by driver.
                *(uint32_t *)((unsigned int)(mStatsMapped[mCurrentHisto]->data)) = hist_info->max_value;
                memcpy((uint32_t *)((unsigned int)mStatsMapped[mCurrentHisto]->data + sizeof(int32_t)),
                                                    (uint32_t *)hist_info->buffer,(sizeof(int32_t) * 256));

                app_cb->dataCb  = mDataCb;
                app_cb->argm_data_cb.msg_type = CAMERA_MSG_STATS_DATA;
                app_cb->argm_data_cb.data = mStatsMapped[mCurrentHisto];
                app_cb->argm_data_cb.index = 0;
                app_cb->argm_data_cb.metadata = NULL;
                app_cb->argm_data_cb.cookie =  mCallbackCookie;
            }
            break;

        }
        default:
        break;
    }
  ALOGV("receiveCameraStats X");
!!!44389943.cpp!!!	processInfoEvent(inout event : mm_camera_info_event_t, inout app_cb : app_notify_cb_t) : void
    ALOGI("processInfoEvent: %d, E",event->event_id);
    switch(event->event_id)
    {
        case MM_CAMERA_INFO_EVT_ROI:
            roiEvent(event->e.roi, app_cb);
            break;
        default:
            break;
    }
    ALOGI("processInfoEvent: X");
    return;
!!!44390071.cpp!!!	processprepareSnapshotEvent(inout status : cam_ctrl_status_t) : void
    ALOGI("processprepareSnapshotEvent: E");
    pthread_mutex_lock(&mAsyncCmdMutex);
    pthread_cond_signal(&mAsyncCmdWait);
    pthread_mutex_unlock(&mAsyncCmdMutex);
    ALOGI("processprepareSnapshotEvent: X");
!!!44390199.cpp!!!	roiEvent(in roi : fd_roi_t, inout app_cb : app_notify_cb_t) : void
    ALOGE("roiEvent: E");

    if(mStreams[MM_CAMERA_PREVIEW]) {
        mStreams[MM_CAMERA_PREVIEW]->notifyROIEvent(roi);
    }
    ALOGE("roiEvent: X");
!!!44390327.cpp!!!	zoomEvent(inout status : cam_ctrl_status_t, inout app_cb : app_notify_cb_t) : void
    ALOGI("zoomEvent: state:%d E",mPreviewState);
    switch (mPreviewState) {
    case QCAMERA_HAL_PREVIEW_STOPPED:
        break;
    case QCAMERA_HAL_PREVIEW_START:
        break;
    case QCAMERA_HAL_PREVIEW_STARTED:
        handleZoomEventForPreview(app_cb);
        if (isZSLMode())
          handleZoomEventForSnapshot();
        break;
    case QCAMERA_HAL_RECORDING_STARTED:
        handleZoomEventForPreview(app_cb);
        if (mFullLiveshotEnabled)
            handleZoomEventForSnapshot();
        break;
    case QCAMERA_HAL_TAKE_PICTURE:
        if(isZSLMode())
            handleZoomEventForPreview(app_cb);
        handleZoomEventForSnapshot();
        break;
    default:
        break;
    }
    ALOGI("zoomEvent: X");
!!!44390583.cpp!!!	handleZoomEventForPreview(inout app_cb : app_notify_cb_t) : void
    ALOGI("%s: E", __func__);

    /*regular zooming or smooth zoom stopped*/
    if (mStreams[MM_CAMERA_PREVIEW] != NULL) {
        ALOGI("%s: Fetching crop info", __func__);
        mStreams[MM_CAMERA_PREVIEW]->setCrop();
        ALOGI("%s: Currrent zoom :%d",__func__, mCurrentZoom);
    }

    ALOGI("%s: X", __func__);
!!!44390711.cpp!!!	handleZoomEventForSnapshot(in  : void) : void
    ALOGI("%s: E", __func__);

    if (mStreams[MM_CAMERA_SNAPSHOT_MAIN] != NULL) {
        mStreams[MM_CAMERA_SNAPSHOT_MAIN]->setCrop();
    }
    if (mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL] != NULL) {
        mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->setCrop();
    }
    ALOGI("%s: X", __func__);
!!!44390839.cpp!!!	autoFocusEvent(inout status : cam_ctrl_status_t, inout app_cb : app_notify_cb_t) : status_t
    ALOGE("autoFocusEvent: E");
    int ret = NO_ERROR;
/************************************************************
  BEGIN MUTEX CODE
*************************************************************/

    ALOGE("%s:%d: Trying to acquire AF bit lock",__func__,__LINE__);
    mAutofocusLock.lock();
    ALOGE("%s:%d: Acquired AF bit lock",__func__,__LINE__);

    if(mAutoFocusRunning==false) {
      ALOGE("%s:AF not running, discarding stale event",__func__);
      mAutofocusLock.unlock();
      return ret;
    }

    /* If autofocus call has been made during CAF, CAF will be locked.
	* We specifically need to call cancelAutoFocus to unlock CAF.
    * In that sense, AF is still running.*/
    isp3a_af_mode_t afMode = getAutoFocusMode(mParameters);
    if (afMode == AF_MODE_CAF) {
       mNeedToUnlockCaf = true;
    }
    mAutoFocusRunning = false;
    mAutofocusLock.unlock();

/************************************************************
  END MUTEX CODE
*************************************************************/
    if(status==NULL) {
      ALOGE("%s:NULL ptr received for status",__func__);
      return BAD_VALUE;
    }

    /* update focus distances after autofocus is done */
    if(updateFocusDistances() != NO_ERROR) {
       ALOGE("%s: updateFocusDistances failed for %d", __FUNCTION__, mFocusMode);
    }

    /*(Do?) we need to make sure that the call back is the
      last possible step in the execution flow since the same
      context might be used if a fail triggers another round
      of AF then the mAutoFocusRunning flag and other state
      variables' validity will be under question*/

    if (mNotifyCb && ( mMsgEnabled & CAMERA_MSG_FOCUS)){
      ALOGE("%s:Issuing callback to service",__func__);

      /* "Accepted" status is not appropriate it should be used for
        initial cmd, event reporting should only give use SUCCESS/FAIL
        */

      app_cb->notifyCb  = mNotifyCb;
      app_cb->argm_notify.msg_type = CAMERA_MSG_FOCUS;
      app_cb->argm_notify.ext2 = 0;
      app_cb->argm_notify.cookie =  mCallbackCookie;

      ALOGE("Auto foucs state =%d", *status);
      if(*status==CAM_CTRL_SUCCESS) {
        app_cb->argm_notify.ext1 = true;
      }
      else if(*status==CAM_CTRL_FAILED){
        app_cb->argm_notify.ext1 = false;
      }
      else{
        app_cb->notifyCb  = NULL;
        ALOGE("%s:Unknown AF status (%d) received",__func__,*status);
      }

    }/*(mNotifyCb && ( mMsgEnabled & CAMERA_MSG_FOCUS))*/
    else{
      ALOGE("%s:Call back not enabled",__func__);
    }

    ALOGE("autoFocusEvent: X");
    return ret;

!!!44390967.cpp!!!	filterPictureSizes() : void
    unsigned int i;
    if(mPictureSizeCount <= 0)
        return;
    maxSnapshotWidth = mPictureSizes[0].width;
    maxSnapshotHeight = mPictureSizes[0].height;
   // Iterate through all the width and height to find the max value
    for(i =0; i<mPictureSizeCount;i++){
        if(((maxSnapshotWidth < mPictureSizes[i].width) &&
            (maxSnapshotHeight <= mPictureSizes[i].height))){
            maxSnapshotWidth = mPictureSizes[i].width;
            maxSnapshotHeight = mPictureSizes[i].height;
        }
    }
    if(myMode & CAMERA_ZSL_MODE){
        // due to lack of PMEM we restrict to lower resolution
        mPictureSizesPtr = zsl_picture_sizes;
        mSupportedPictureSizesCount = 7;
    }else{
        mPictureSizesPtr = mPictureSizes;
        mSupportedPictureSizesCount = mPictureSizeCount;
    }
!!!44391095.cpp!!!	supportsSceneDetection() : bool
   bool rc ;
   mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,MM_CAMERA_PARM_ASD_ENABLE,(uint8_t*)&rc,(uint8_t*)&rc);
   return rc;
!!!44391223.cpp!!!	supportsSelectableZoneAf() : bool
   bool rc ;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,MM_CAMERA_PARM_FOCUS_RECT,(uint8_t*)&rc,(uint8_t*)&rc);
   return rc;
!!!44391351.cpp!!!	supportsFaceDetection() : bool
    bool rc ;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,MM_CAMERA_PARM_FD,(uint8_t*)&rc,(uint8_t*)&rc);
    return rc;
!!!44391479.cpp!!!	supportsRedEyeReduction() : bool
   bool rc ;
   mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,MM_CAMERA_PARM_REDEYE_REDUCTION,(uint8_t*)&rc,(uint8_t*)&rc);
   return rc;
!!!44391607.cpp!!!	stopPreviewInternal() : void
    ALOGI("stopPreviewInternal: E");
    status_t ret = NO_ERROR;

    if(!mStreams[MM_CAMERA_PREVIEW]) {
        ALOGE("mStreamDisplay is null");
        return;
    }

    if(isZSLMode()) {
        mStreams[MM_CAMERA_PREVIEW]->streamOff(0);
        mStreams[MM_CAMERA_SNAPSHOT_MAIN]->streamOff(0);
        ret = mCameraHandle->ops->destroy_stream_bundle(mCameraHandle->camera_handle,mChannelId);
        if(ret != MM_CAMERA_OK) {
            ALOGE("%s : ZSL destroy_stream_bundle Error",__func__);
        }
    }else{
        if(rdiMode == STREAM_RAW) {
            mStreams[MM_CAMERA_RDI]->streamOff(0);
            mStreams[MM_CAMERA_RDI]->deinitStream();
            return;
        }
        mStreams[MM_CAMERA_PREVIEW]->streamOff(0);
    }
    if (mStreams[MM_CAMERA_VIDEO])
        mStreams[MM_CAMERA_VIDEO]->deinitStream();
    if (mStreams[MM_CAMERA_SNAPSHOT_MAIN])
        mStreams[MM_CAMERA_SNAPSHOT_MAIN]->deinitStream();
    mStreams[MM_CAMERA_PREVIEW]->deinitStream();

    ALOGI("stopPreviewInternal: X");
!!!44391735.cpp!!!	stopRecordingInternal() : void
    ALOGI("stopRecordingInternal: E");
    status_t ret = NO_ERROR;

    if(!mStreams[MM_CAMERA_VIDEO]) {
        ALOGE("mStreamRecord is null");
        return;
    }

    /*
    * call QCameraStream_record::stop()
    * Unregister Callback, action stop
    */
    mStreams[MM_CAMERA_VIDEO]->streamOff(0);
    mPreviewState = QCAMERA_HAL_PREVIEW_STARTED;
    ALOGI("stopRecordingInternal: X");
    return;
!!!44391863.cpp!!!	cancelPictureInternal() : status_t
    ALOGI("%s: E mPreviewState=%d", __func__ , mPreviewState);
    status_t ret = MM_CAMERA_OK;

    /* set rawdata proc thread and jpeg notify thread to inactive state */
    /* no need for notify thread as a sync call for stop cmd */
    mNotifyTh->sendCmd(CAMERA_CMD_TYPE_STOP_DATA_PROC, FALSE, TRUE);
    /* dataProc Thread need to process "stop" as sync call because abort jpeg job should be a sync call*/
    mDataProcTh->sendCmd(CAMERA_CMD_TYPE_STOP_DATA_PROC, TRUE, TRUE);

    if (isZSLMode()) {
        ret = mCameraHandle->ops->cancel_super_buf_request(mCameraHandle->camera_handle, mChannelId);
    } else {
        mStreams[MM_CAMERA_SNAPSHOT_MAIN]->streamOff(0);
        mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->streamOff(0);
        ret = mCameraHandle->ops->destroy_stream_bundle(mCameraHandle->camera_handle, mChannelId);
        if(ret != MM_CAMERA_OK) {
            ALOGE("%s : destroy_stream_bundle Error",__func__);
        }
        if(mPreviewState != QCAMERA_HAL_RECORDING_STARTED) {
            mStreams[MM_CAMERA_SNAPSHOT_MAIN]->deinitStream();
            mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->deinitStream();
        }
    }
    ALOGI("cancelPictureInternal: X");
    return ret;
!!!44392119.cpp!!!	restartPreview() : void
    if (QCAMERA_HAL_PREVIEW_STARTED == mPreviewState) {
        stopPreviewInternal();
        mPreviewState = QCAMERA_HAL_PREVIEW_STOPPED;
    }
    startPreview2();
    mPreviewState = QCAMERA_HAL_PREVIEW_STARTED;
!!!44392247.cpp!!!	runFaceDetection() : status_t
    bool ret = true;

    const char *str = mParameters.get(QCameraParameters::KEY_QC_FACE_DETECTION);
    if (str != NULL) {
        int value = attr_lookup(facedetection,
                sizeof(facedetection) / sizeof(str_map), str);
        fd_set_parm_t fd_set_parm;
        int requested_faces = mParameters.getInt(QCameraParameters::KEY_QC_MAX_NUM_REQUESTED_FACES);
        fd_set_parm.fd_mode = value;
        fd_set_parm.num_fd = requested_faces;
        ret = native_set_parms(MM_CAMERA_PARM_FD, sizeof(int8_t), (void *)&value);
        return ret ? NO_ERROR : UNKNOWN_ERROR;
    }
    ALOGE("Invalid Face Detection value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44392375.cpp!!!	setParameters(in params : QCameraParameters) : status_t
    status_t ret = NO_ERROR;

    ALOGI("%s: E", __func__);
//    Mutex::Autolock l(&mLock);
    status_t rc, final_rc = NO_ERROR;
    mRestartPreview = false;

    if ((rc = setCameraMode(params)))                   final_rc = rc;
//    if ((rc = setChannelInterfaceMask(params)))         final_rc = rc;
    if ((rc = setPowerMode(params)))                    final_rc = rc;
    if ((rc = setPreviewSize(params)))                  final_rc = rc;
    if ((rc = setVideoSize(params)))                    final_rc = rc;
    if ((rc = setPictureSize(params)))                  final_rc = rc;
    if ((rc = setJpegThumbnailSize(params)))            final_rc = rc;
    if ((rc = setJpegQuality(params)))                  final_rc = rc;
    if ((rc = setEffect(params)))                       final_rc = rc;
    if ((rc = setGpsLocation(params)))                  final_rc = rc;
    if ((rc = setRotation(params)))                     final_rc = rc;
    if ((rc = setZoom(params)))                         final_rc = rc;
    if ((rc = setOrientation(params)))                  final_rc = rc;
    if ((rc = setLensshadeValue(params)))               final_rc = rc;
    if ((rc = setMCEValue(params)))                     final_rc = rc;
    if ((rc = setPictureFormat(params)))                final_rc = rc;
    if ((rc = setSharpness(params)))                    final_rc = rc;
    if ((rc = setSaturation(params)))                   final_rc = rc;
    if ((rc = setSceneMode(params)))                    final_rc = rc;
    if ((rc = setContrast(params)))                     final_rc = rc;
    if ((rc = setFaceDetect(params)))                   final_rc = rc;
    if ((rc = setStrTextures(params)))                  final_rc = rc;
    if ((rc = setPreviewFormat(params)))                final_rc = rc;
    if ((rc = setSkinToneEnhancement(params)))          final_rc = rc;
    if ((rc = setWaveletDenoise(params)))               final_rc = rc;
    if ((rc = setAntibanding(params)))                  final_rc = rc;
    //    if ((rc = setOverlayFormats(params)))         final_rc = rc;
    if ((rc = setRedeyeReduction(params)))              final_rc = rc;
    if ((rc = setCaptureBurstExp()))                    final_rc = rc;
    if ((rc = setRDIMode(params)))                      final_rc = rc;

    const char *str_val = params.get("capture-burst-exposures");
    if ( str_val == NULL || strlen(str_val)==0 ) {
        char burst_exp[PROPERTY_VALUE_MAX];
        memset(burst_exp, 0, sizeof(burst_exp));
        property_get("persist.capture.burst.exposures", burst_exp, "");
        if ( strlen(burst_exp)>0 ) {
            mParameters.set("capture-burst-exposures", burst_exp);
        }
    } else {
      mParameters.set("capture-burst-exposures", str_val);
    }
    mParameters.set("num-snaps-per-shutter", params.get("num-snaps-per-shutter"));

    if ((rc = setAEBracket(params)))              final_rc = rc;
    //    if ((rc = setDenoise(params)))                final_rc = rc;
    if ((rc = setPreviewFpsRange(params)))              final_rc = rc;
    if((rc = setRecordingHint(params)))                 final_rc = rc;
    if ((rc = setNumOfSnapshot(params)))                final_rc = rc;
    if ((rc = setAecAwbLock(params)))                   final_rc = rc;

    const char *str = params.get(QCameraParameters::KEY_SCENE_MODE);
    int32_t value = attr_lookup(scenemode, sizeof(scenemode) / sizeof(str_map), str);

    if((value != NOT_FOUND) && (value == CAMERA_BESTSHOT_OFF )) {
        //if ((rc = setPreviewFrameRateMode(params)))     final_rc = rc;
        if ((rc = setPreviewFrameRate(params)))         final_rc = rc;
        if ((rc = setAutoExposure(params)))             final_rc = rc;
        if ((rc = setExposureCompensation(params)))     final_rc = rc;
        if ((rc = setWhiteBalance(params)))             final_rc = rc;
        if ((rc = setFlash(params)))                    final_rc = rc;
        if ((rc = setFocusMode(params)))                final_rc = rc;
        if ((rc = setBrightness(params)))               final_rc = rc;
        if ((rc = setISOValue(params)))                 final_rc = rc;
        if ((rc = setFocusAreas(params)))               final_rc = rc;
        if ((rc = setMeteringAreas(params)))            final_rc = rc;
    }
    //selectableZoneAF needs to be invoked after continuous AF
    if ((rc = setSelectableZoneAf(params)))             final_rc = rc;
    // setHighFrameRate needs to be done at end, as there can
    // be a preview restart, and need to use the updated parameters
    if ((rc = setHighFrameRate(params)))  final_rc = rc;
    if ((rc = setZSLBurstLookBack(params))) final_rc = rc;
    if ((rc = setZSLBurstInterval(params))) final_rc = rc;
    if ((rc = setNoDisplayMode(params))) final_rc = rc;
    if ((rc = setMobiCat(params)))       final_rc = rc;

    //Update Exiftag values.
    setExifTags();

    if (mRestartPreview) {
        ALOGI("%s: need to restart preview", __func__);
        restartPreview();
        mRestartPreview = false;
    }

    ALOGI("%s: X", __func__);
    return final_rc;
!!!44392503.cpp!!!	getParameters() : QCameraParameters
    Mutex::Autolock lock(mLock);
    mParameters.set(QCameraParameters::KEY_FOCUS_DISTANCES, mFocusDistance.string());
    return mParameters;
!!!44392631.cpp!!!	setCameraMode(in params : QCameraParameters) : status_t
    int32_t value = params.getInt(QCameraParameters::KEY_QC_CAMERA_MODE);
    mParameters.set(QCameraParameters::KEY_QC_CAMERA_MODE,value);

    ALOGI("ZSL is enabled  %d", value);
    if (value == 1) {
        myMode = (camera_mode_t)(myMode | CAMERA_ZSL_MODE);
    } else {
        myMode = (camera_mode_t)(myMode & ~CAMERA_ZSL_MODE);
    }
    return NO_ERROR;
!!!44392759.cpp!!!	setPictureSizeTable(in  : void) : status_t
    status_t ret = NO_ERROR;
    mm_camera_dimension_t dim;
    struct camera_size_type* picture_size_table;
    int picture_table_size;
    int i = 0, count = 0;

    /* Initialize table with default values */
    picture_table_size = sizeof(default_picture_sizes)/
        sizeof(default_picture_sizes[0]);
    picture_size_table = default_picture_sizes;
    mPictureSizes =
        ( struct camera_size_type *)malloc(picture_table_size *
                                           sizeof(struct camera_size_type));
    if (mPictureSizes == NULL) {
        ALOGE("%s: Failre allocating memory to store picture size table",__func__);
        goto end;
    }

    /* Get maximum picture size supported by sensor*/
    memset(&dim, 0, sizeof(mm_camera_dimension_t));
    ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                              MM_CAMERA_PARM_MAX_PICTURE_SIZE, &dim);
    if (ret != NO_ERROR) {
        ALOGE("%s: Failure getting Max Picture Size supported by camera",
             __func__);
        ret = NO_MEMORY;
        free(mPictureSizes);
        mPictureSizes = NULL;
        goto end;
    }

    ALOGD("%s: Max Picture Sizes Supported: %d X %d", __func__,
         dim.width, dim.height);

    for (i = 0; i < picture_table_size; i++) {
        /* We'll store those dimensions whose width AND height
           are less than or equal to maximum supported */
        if ((picture_size_table->width <= dim.width) &&
            (picture_size_table->height <= dim.height)) {
            ALOGD("%s: Camera Picture Size Table "
                 "Max width: %d height %d table_size: %d",
                 __func__, picture_size_table->width,
                 picture_size_table->height, count+1);
            mPictureSizes[count].height = picture_size_table->height;
            mPictureSizes[count].width = picture_size_table->width;
            count++;
        }
        picture_size_table++;
    }
    mPictureSizeCount = count;

end:
     /* In case of error, we use default picture sizes */
     if (ret != NO_ERROR) {
        mPictureSizes = default_picture_sizes;
        mPictureSizeCount = picture_table_size;
    }
    return ret;
!!!44392887.cpp!!!	setPreviewSizeTable(in  : void) : status_t
    status_t ret = NO_ERROR;
    mm_camera_dimension_t dim;
    struct camera_size_type* preview_size_table;
    int preview_table_size;
    int i = 0;
    char str[10] = {0};

    /* Initialize table with default values */
    preview_size_table = default_preview_sizes;
    preview_table_size = preview_sizes_count;


    /* Get maximum preview size supported by sensor*/
    memset(&dim, 0, sizeof(mm_camera_dimension_t));
    ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                              MM_CAMERA_PARM_MAX_PREVIEW_SIZE, &dim);
    if (ret != NO_ERROR) {
        ALOGE("%s: Failure getting Max Preview Size supported by camera",
             __func__);
        goto end;
    }

    ALOGD("%s: Max Preview Sizes Supported: %d X %d", __func__,
         dim.width, dim.height);

    for (i = 0; i < preview_table_size; i++) {
        if ((preview_size_table->width <= dim.width) &&
            (preview_size_table->height <= dim.height)) {
            ALOGD("%s: Camera Preview Size Table "
                 "Max width: %d height %d table_size: %d",
                 __func__, preview_size_table->width,
                 preview_size_table->height, preview_table_size - i);
            break;
        }
        preview_size_table++;
    }
    //set preferred preview size to maximum preview size
    sprintf(str, "%dx%d", preview_size_table->width, preview_size_table->height);
    mParameters.set(QCameraParameters::KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO, str);
    ALOGD("KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO = %s", str);

end:
    /* Save the table in global member*/
    mPreviewSizes = preview_size_table;
    mPreviewSizeCount = preview_table_size - i;

    return ret;
!!!44393015.cpp!!!	setVideoSizeTable(in  : void) : status_t
    status_t ret = NO_ERROR;
    mm_camera_dimension_t dim;
    struct camera_size_type* video_size_table;
    int video_table_size;
    int i = 0, count = 0;
    ALOGE("%s: E", __func__);

    /* Initialize table with default values */
    video_table_size = video_sizes_count;
    video_size_table = default_video_sizes;
    mVideoSizes =
        (struct camera_size_type *)malloc(video_table_size *
                                           sizeof(struct camera_size_type));
    if(mVideoSizes == NULL) {
        ALOGE("%s: error allocating memory to store video size table",__func__);
        ret = BAD_VALUE;
        goto end;
    }

    /* Get maximum video size supported by sensor*/
    memset(&dim, 0, sizeof(mm_camera_dimension_t));
    ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                              MM_CAMERA_PARM_MAX_VIDEO_SIZE, &dim);
    if(ret != NO_ERROR) {
        ALOGE("%s: error getting Max Video Size supported by camera",
             __func__);
        ret = NO_MEMORY;
        free(mVideoSizes);
        mVideoSizes = NULL;
        ret = BAD_VALUE;
        goto end;
    }

    ALOGD("%s: Max Video Size Supported: %d X %d", __func__,
         dim.width, dim.height);

    for(i=0; i < video_table_size; i++) {
        /* We'll store those dimensions whose width AND height
           are less than or equal to maximum supported */
        if((video_size_table->width <= dim.width) &&
            (video_size_table->height <= dim.height)) {
            ALOGD("%s: Supported Video Size [%d] = %dx%d", __func__, count, video_size_table->width,
                                    video_size_table->height);
            mVideoSizes[count].height = video_size_table->height;
            mVideoSizes[count].width = video_size_table->width;
            count++;
        }
        video_size_table++;
    }
    mVideoSizeCount = count;

end:
    ALOGE("%s: X", __func__);
    return ret;
!!!44393143.cpp!!!	setPreviewSize(in params : QCameraParameters) : status_t
    int width, height;
    params.getPreviewSize(&width, &height);
    ALOGV("################requested preview size %d x %d", width, height);

    // Validate the preview size
    for (size_t i = 0; i <  mPreviewSizeCount; ++i) {
        if (width ==  mPreviewSizes[i].width
           && height ==  mPreviewSizes[i].height) {
            mParameters.setPreviewSize(width, height);
            ALOGE("setPreviewSize:  width: %d   heigh: %d", width, height);
            mPreviewWidth = width;
            mPreviewHeight = height;
            mDimension.display_width = width;
            mDimension.display_height = height;
            return NO_ERROR;
        }
    }
    ALOGE("Invalid preview size requested: %dx%d", width, height);
    return BAD_VALUE;
!!!44393271.cpp!!!	setJpegThumbnailSize(in params : QCameraParameters) : status_t
    int width = params.getInt(QCameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
    int height = params.getInt(QCameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);

    ALOGV("requested jpeg thumbnail size %d x %d", width, height);

    // Validate the picture size
    for (unsigned int i = 0; i < thumbnail_sizes_count; ++i) {
       if (width == default_thumbnail_sizes[i].width
         && height == default_thumbnail_sizes[i].height) {
           thumbnailWidth = width;
           thumbnailHeight = height;
           mParameters.set(QCameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, width);
           mParameters.set(QCameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, height);
           return NO_ERROR;
       }
    }
    ALOGE("error: setting jpeg thumbnail size");
    return BAD_VALUE;
!!!44393399.cpp!!!	setPreviewFpsRange(in params : QCameraParameters) : status_t
    ALOGV("%s: E", __func__);
    int minFps,maxFps;
    int prevMinFps, prevMaxFps;
    int rc = NO_ERROR;
    bool found = false;

    mParameters.getPreviewFpsRange(&prevMinFps, &prevMaxFps);
    ALOGV("%s: Existing FpsRange Values:(%d, %d)", __func__, prevMinFps, prevMaxFps);
    params.getPreviewFpsRange(&minFps,&maxFps);
    ALOGV("%s: Requested FpsRange Values:(%d, %d)", __func__, minFps, maxFps);

    if(mInitialized && (minFps == prevMinFps && maxFps == prevMaxFps)) {
        ALOGE("%s: No change in FpsRange", __func__);
        rc = NO_ERROR;
        goto end;
    }
    for(int i=0; i<mSupportedFpsRangesCount; i++) {
        // if the value is in the supported list
        if(minFps >= mSupportedFpsRanges[i].minFPS && maxFps <= mSupportedFpsRanges[i].maxFPS) {
            found = true;
            ALOGE("FPS: i=%d : minFps = %d, maxFps = %d ", i, minFps, maxFps);
            mParameters.setPreviewFpsRange(minFps,maxFps);
            // validate the values
            bool valid = true;
            // FPS can not be negative
            if(minFps < 0 || maxFps < 0) valid = false;
            // minFps must be >= maxFps
            if(minFps > maxFps) valid = false;

            if(valid) {
                //Set the FPS mode
                const char *str = (minFps == maxFps) ?
                    QCameraParameters::KEY_QC_PREVIEW_FRAME_RATE_FIXED_MODE:
                    QCameraParameters::KEY_QC_PREVIEW_FRAME_RATE_AUTO_MODE;
                ALOGE("%s FPS_MODE = %s", __func__, str);
                int32_t frameRateMode = attr_lookup(frame_rate_modes,
                        sizeof(frame_rate_modes) / sizeof(str_map),str);
                bool ret;
                ret = native_set_parms(MM_CAMERA_PARM_FPS_MODE, sizeof(int32_t),
                            (void *)&frameRateMode);

                //set FPS values
                uint32_t fps;  //lower 2 bytes specify maxFps and higher 2 bytes specify minFps
                fps = ((uint32_t)(minFps/1000) << 16) + ((uint16_t)(maxFps/1000));

                ret = native_set_parms(MM_CAMERA_PARM_FPS, sizeof(uint32_t), (void *)&fps);
                mParameters.setPreviewFpsRange(minFps, maxFps);
                if(ret)
                    rc = NO_ERROR;
                else {
                    rc = BAD_VALUE;
                    ALOGE("%s: error: native_set_params failed", __func__);
                }
            } else {
                ALOGE("%s: error: invalid FPS range value", __func__);
                rc = BAD_VALUE;
            }
        }
    }
    if(found == false){
            ALOGE("%s: error: FPS range value not supported", __func__);
            rc = BAD_VALUE;
    }
end:
    ALOGV("%s: X", __func__);
    return rc;
!!!44393527.cpp!!!	setPreviewFrameRate(in params : QCameraParameters) : status_t
    ALOGV("%s: E",__func__);
    status_t rc = NO_ERROR;
    uint16_t fps = (uint16_t)params.getPreviewFrameRate();
    ALOGV("%s: requested preview frame rate  is %d", __func__, fps);

    mParameters.setPreviewFrameRate(fps);
    ALOGV("%s: X",__func__);
    return NO_ERROR;
!!!44393655.cpp!!!	setPreviewFrameRateMode(in params : QCameraParameters) : status_t

    ALOGV("%s",__func__);
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_FPS,&supported,&supported);
    if(!supported) {
       ALOGE(" CAMERA FPS mode is not supported for this sensor");
       return NO_ERROR;
    }
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_FPS_MODE,&supported,&supported);
    if(!supported) {
       ALOGE("CAMERA FPS MODE mode is not supported for this sensor");
       return NO_ERROR;
    }

    const char *previousMode = mParameters.getPreviewFrameRateMode();
    const char *str = params.getPreviewFrameRateMode();
    if (NULL == previousMode) {
        ALOGE("Preview Frame Rate Mode is NULL\n");
        return NO_ERROR;
    }
    if (NULL == str) {
        ALOGE("Preview Frame Rate Mode is NULL\n");
        return NO_ERROR;
    }
    if( mInitialized && !strcmp(previousMode, str)) {
        ALOGE("frame rate mode same as previous mode %s", previousMode);
        return NO_ERROR;
    }
    int32_t frameRateMode = attr_lookup(frame_rate_modes, sizeof(frame_rate_modes) / sizeof(str_map),str);
    if(frameRateMode != NOT_FOUND) {
        ALOGV("setPreviewFrameRateMode: %s ", str);
        mParameters.setPreviewFrameRateMode(str);
        bool ret = native_set_parms(MM_CAMERA_PARM_FPS_MODE, sizeof(frameRateMode), (void *)&frameRateMode);
        if(!ret) return ret;
        //set the fps value when chaging modes
        int16_t fps = (uint16_t)params.getPreviewFrameRate();
        if(MINIMUM_FPS <= fps && fps <=MAXIMUM_FPS){
            mParameters.setPreviewFrameRate(fps);
            ret = native_set_parms(MM_CAMERA_PARM_FPS,
                                        sizeof(fps), (void *)&fps);
            return ret ? NO_ERROR : UNKNOWN_ERROR;
        }
        ALOGE("Invalid preview frame rate value: %d", fps);
        return BAD_VALUE;
    }
    ALOGE("Invalid preview frame rate mode value: %s", (str == NULL) ? "NULL" : str);

    return BAD_VALUE;
!!!44393783.cpp!!!	setVideoSize(in params : QCameraParameters) : status_t
    const char *str= NULL;
    const char *str_t= NULL;
    int old_vid_w = 0, old_vid_h = 0;
    ALOGV("%s: E", __func__);
    str = params.get(QCameraParameters::KEY_VIDEO_SIZE);
    str_t = mParameters.get(CameraParameters::KEY_VIDEO_SIZE);
    if(!str) {
        mParameters.set(QCameraParameters::KEY_VIDEO_SIZE, "");
        //If application didn't set this parameter string, use the values from
        //getPreviewSize() as video dimensions.
        ALOGE("No Record Size requested, use the preview dimensions");
        videoWidth = mPreviewWidth;
        videoHeight = mPreviewHeight;
    } else {
        //Extract the record witdh and height that application requested.
        ALOGI("%s: requested record size %s", __func__, str);
        if(!parse_size(str, videoWidth, videoHeight)) {
            parse_size(str_t, old_vid_w, old_vid_h);
            mParameters.set(QCameraParameters::KEY_VIDEO_SIZE, str);
            if((QCAMERA_HAL_PREVIEW_STARTED == mPreviewState) &&
               (old_vid_w != videoWidth || old_vid_h != videoHeight)) {
                ALOGE("%s: Video sizes changes to %s, Restart preview...", __func__, str);
                mRestartPreview = true;
            }
        } else {
            mParameters.set(QCameraParameters::KEY_VIDEO_SIZE, "");
            ALOGE("%s: error :failed to parse parameter record-size (%s)", __func__, str);
            return BAD_VALUE;
        }
    }
    ALOGV("%s: preview dimensions: %dx%d", __func__, mPreviewWidth, mPreviewHeight);
    ALOGV("%s: video dimensions: %dx%d", __func__, videoWidth, videoHeight);
    mDimension.orig_video_width = videoWidth;
    mDimension.orig_video_height = videoHeight;
    mDimension.video_width = videoWidth;
    mDimension.video_height = videoHeight;

    ALOGV("%s: X", __func__);
    return NO_ERROR;
!!!44393911.cpp!!!	setPictureSize(in params : QCameraParameters) : status_t
    int width, height;
    ALOGV("QualcommCameraHardware::setPictureSize E");
    params.getPictureSize(&width, &height);
    ALOGE("requested picture size %d x %d", width, height);

    // Validate the picture size
    for (int i = 0; i < mSupportedPictureSizesCount; ++i) {
        if (width == mPictureSizesPtr[i].width
          && height == mPictureSizesPtr[i].height) {
            int old_width, old_height;
            mParameters.getPictureSize(&old_width,&old_height);
            mParameters.setPictureSize(width, height);
            mDimension.picture_width = width;
            mDimension.picture_height = height;
            if((QCAMERA_HAL_PREVIEW_STARTED == mPreviewState) &&
               (width != old_width || height != old_height)) {
                mRestartPreview = true;
            }
            return NO_ERROR;
        }
    }
    /* Dimension not among the ones in the list. Check if
     * its a valid dimension, if it is, then configure the
     * camera accordingly. else reject it.
     */
    if( isValidDimension(width, height) ) {
        mParameters.setPictureSize(width, height);
        mDimension.picture_width = width;
        mDimension.picture_height = height;
        return NO_ERROR;
    } else
        ALOGE("Invalid picture size requested: %dx%d", width, height);
    return BAD_VALUE;
!!!44394039.cpp!!!	setJpegQuality(in params : QCameraParameters) : status_t
    status_t rc = NO_ERROR;
    int quality = params.getInt(QCameraParameters::KEY_JPEG_QUALITY);
    ALOGV("setJpegQuality E");
    if (quality >= 0 && quality <= 100) {
        mParameters.set(QCameraParameters::KEY_JPEG_QUALITY, quality);
        mJpegQuality = quality;
    } else {
        ALOGE("Invalid jpeg quality=%d", quality);
        rc = BAD_VALUE;
    }

    quality = params.getInt(QCameraParameters::KEY_JPEG_THUMBNAIL_QUALITY);
    if (quality >= 0 && quality <= 100) {
        mParameters.set(QCameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, quality);
    } else {
        ALOGE("Invalid jpeg thumbnail quality=%d", quality);
        rc = BAD_VALUE;
    }
    ALOGV("setJpegQuality X");
    return rc;
!!!44394167.cpp!!!	setNumOfSnapshot(in params : QCameraParameters) : status_t
    status_t rc = NO_ERROR;

    int num_of_snapshot = getNumOfSnapshots(params);

    if (num_of_snapshot <= 0) {
        num_of_snapshot = 1;
    }
    ALOGI("number of snapshots = %d", num_of_snapshot);
    mParameters.set("num-snaps-per-shutter", num_of_snapshot);

    bool result = native_set_parms(MM_CAMERA_PARM_SNAPSHOT_BURST_NUM,
                                   sizeof(int),
                                   (void *)&num_of_snapshot);
    if(!result)
        ALOGI("%s:Failure setting number of snapshots!!!", __func__);
    return rc;
!!!44394295.cpp!!!	setJpegRotation(in isZsl : int) : status_t
//    return mm_jpeg_encoder_setRotation(mRotation, isZsl);
      return NO_ERROR;
!!!44394423.cpp!!!	getJpegRotation(in  : void) : int
    ALOGE("%s : rotation is %d", __func__, mRotation);
    return mRotation;
!!!44394551.cpp!!!	getISOSpeedValue() : int
    const char *iso_str = mParameters.get(QCameraParameters::KEY_QC_ISO_MODE);
    int iso_index = attr_lookup(iso, sizeof(iso) / sizeof(str_map), iso_str);
    int iso_value = iso_speed_values[iso_index];
    return iso_value;
!!!44394679.cpp!!!	getAutoFlickerMode() : int
    /* Enable Advanced Auto Antibanding where we can set
       any of the following option
       ie. CAMERA_ANTIBANDING_AUTO
           CAMERA_ANTIBANDING_AUTO_50HZ
           CAMERA_ANTIBANDING_AUTO_60HZ
      Currently setting it to default    */
    return CAMERA_ANTIBANDING_AUTO;
!!!44394807.cpp!!!	setAntibanding(in params : QCameraParameters) : status_t
    int result;

    ALOGV("%s",__func__);
    status_t rc = NO_ERROR;
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_ANTIBANDING,&supported,&supported);
    if(!supported) {
       ALOGE("ANTIBANDING mode is not supported for this sensor");
       return NO_ERROR;
    }
    const char *str = params.get(QCameraParameters::KEY_ANTIBANDING);
    if (str != NULL) {
        int value = (camera_antibanding_type)attr_lookup(
          antibanding, sizeof(antibanding) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            camera_antibanding_type temp = (camera_antibanding_type) value;
            ALOGE("Antibanding Value : %d",value);
            mParameters.set(QCameraParameters::KEY_ANTIBANDING, str);
            if(value == CAMERA_ANTIBANDING_AUTO) {
                 value = getAutoFlickerMode();
            }
            bool ret = native_set_parms(MM_CAMERA_PARM_ANTIBANDING,
                       sizeof(camera_antibanding_type), (void *)&value ,(int *)&result);
            if(result != MM_CAMERA_OK) {
                ALOGI("AntiBanding Value: %s is not supported for the given BestShot Mode", str);
            }
            return ret ? NO_ERROR : UNKNOWN_ERROR;
        }
    }
    ALOGE("Invalid antibanding value: %s", (str == NULL) ? "NULL" : str);

    return BAD_VALUE;
!!!44394935.cpp!!!	setEffect(in params : QCameraParameters) : status_t
    ALOGV("%s",__func__);
    uint8_t supported;
    const char *str = params.get(CameraParameters::KEY_EFFECT);
    int result;
    mColorEffects = CAMERA_EFFECT_OFF;
    if (str != NULL) {
        ALOGE("Setting effect %s",str);
        int32_t value = attr_lookup(effects, sizeof(effects) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                                  MM_CAMERA_PARM_EFFECT,&supported,&supported);
           if(!supported) {
               ALOGE("Camera Effect - %s mode is not supported for this sensor",str);
               return NO_ERROR;
           }else {
               mParameters.set(QCameraParameters::KEY_EFFECT, str);
               ALOGE("Setting effect to lower HAL : %d",value);
               mColorEffects = value;
               bool ret = native_set_parms(MM_CAMERA_PARM_EFFECT, sizeof(value),
                                           (void *)&value,(int *)&result);
                if(result != 0) {
                    ALOGI("Camera Effect: %s is not set as the selected value is not supported ", str);
                }
                int bestshot_reconfigure;
                mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                                             MM_CAMERA_PARM_BESTSHOT_RECONFIGURE,
                                    &bestshot_reconfigure);
                if(bestshot_reconfigure) {
                     if (mEffects != value) {
                         mEffects = value;
                         if (mPreviewState == QCAMERA_HAL_PREVIEW_STARTED && ret) {
                               mRestartPreview = true;
                          }
                   }
               }
               return ret ? NO_ERROR : UNKNOWN_ERROR;
          }
        }
    }
    ALOGE("Invalid effect value: %s", (str == NULL) ? "NULL" : str);
    ALOGV("setEffect X");
    return BAD_VALUE;
!!!44395063.cpp!!!	setExposureCompensation(in params : QCameraParameters) : status_t
    ALOGV("%s",__func__);
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_EXPOSURE_COMPENSATION,&supported,&supported);
    if(!supported) {
       ALOGE("MM_CAMERA_PARM_EXPOSURE_COMPENSATION mode is not supported for this sensor");
       return NO_ERROR;
    }
    int numerator = params.getInt(QCameraParameters::KEY_EXPOSURE_COMPENSATION);
    if(EXPOSURE_COMPENSATION_MINIMUM_NUMERATOR <= numerator &&
            numerator <= EXPOSURE_COMPENSATION_MAXIMUM_NUMERATOR){
        int16_t  numerator16 = (int16_t)(numerator & 0x0000ffff);
        uint16_t denominator16 = EXPOSURE_COMPENSATION_DENOMINATOR;
        uint32_t  value = 0;
        value = numerator16 << 16 | denominator16;

        mParameters.set(QCameraParameters::KEY_EXPOSURE_COMPENSATION,
                            numerator);
       bool ret = native_set_parms(MM_CAMERA_PARM_EXPOSURE_COMPENSATION,
                                    sizeof(value), (void *)&value);
        return ret ? NO_ERROR : UNKNOWN_ERROR;
    }
    ALOGE("Invalid Exposure Compensation");
    return BAD_VALUE;
!!!44395191.cpp!!!	setAutoExposure(in params : QCameraParameters) : status_t

    ALOGV("%s",__func__);
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_EXPOSURE,&supported,&supported);
   if(!supported) {
       ALOGE("MM_CAMERA_PARM_EXPOSURE mode is not supported for this sensor");
       return NO_ERROR;
   }
   const char *str = params.get(QCameraParameters::KEY_QC_AUTO_EXPOSURE);
    if (str != NULL) {
        int32_t value = attr_lookup(autoexposure, sizeof(autoexposure) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            mParameters.set(QCameraParameters::KEY_QC_AUTO_EXPOSURE, str);
            bool ret = native_set_parms(MM_CAMERA_PARM_EXPOSURE, sizeof(value),
                                       (void *)&value);
            return ret ? NO_ERROR : UNKNOWN_ERROR;
        }
    }
    ALOGE("Invalid auto exposure value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44395319.cpp!!!	setWhiteBalance(in params : QCameraParameters) : status_t

    ALOGV("%s",__func__);
    status_t rc = NO_ERROR;
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_WHITE_BALANCE,&supported,&supported);
    if(!supported) {
       ALOGE("MM_CAMERA_PARM_WHITE_BALANCE mode is not supported for this sensor");
       return NO_ERROR;
    }
     int result;

    const char *str = params.get(QCameraParameters::KEY_WHITE_BALANCE);
    if (str != NULL) {
        int32_t value = attr_lookup(whitebalance, sizeof(whitebalance) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            mParameters.set(QCameraParameters::KEY_WHITE_BALANCE, str);
            bool ret = native_set_parms(MM_CAMERA_PARM_WHITE_BALANCE, sizeof(value),
                                       (void *)&value, (int *)&result);
            if(result != MM_CAMERA_OK) {
                ALOGI("WhiteBalance Value: %s is not set as the selected value is not supported ", str);
            }
            return ret ? NO_ERROR : UNKNOWN_ERROR;
        }
    }
    ALOGE("Invalid whitebalance value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44395447.cpp!!!	setFlash(in params : QCameraParameters) : status_t
    ALOGI("%s: E",__func__);
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_LED_MODE,&supported,&supported);
    if(!supported) {
        ALOGE("%s:LED FLASH not supported", __func__);
        return NO_ERROR;
    }

    const char *str = params.get(QCameraParameters::KEY_FLASH_MODE);
    if (str != NULL) {
        int32_t value = attr_lookup(flash, sizeof(flash) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            mParameters.set(QCameraParameters::KEY_FLASH_MODE, str);
            bool ret = native_set_parms(MM_CAMERA_PARM_LED_MODE,
                                       sizeof(value), (void *)&value);
            return ret ? NO_ERROR : UNKNOWN_ERROR;
        }
    }
    ALOGE("Invalid flash mode value: %s", (str == NULL) ? "NULL" : str);

    return BAD_VALUE;
!!!44395575.cpp!!!	setGpsLocation(in params : QCameraParameters) : status_t
    const char *method = params.get(QCameraParameters::KEY_GPS_PROCESSING_METHOD);
    if (method) {
        mParameters.set(QCameraParameters::KEY_GPS_PROCESSING_METHOD, method);
    }else {
         mParameters.remove(QCameraParameters::KEY_GPS_PROCESSING_METHOD);
    }

    const char *latitude = params.get(QCameraParameters::KEY_GPS_LATITUDE);
    if (latitude) {
        ALOGE("latitude %s",latitude);
        mParameters.set(QCameraParameters::KEY_GPS_LATITUDE, latitude);
    }else {
         mParameters.remove(QCameraParameters::KEY_GPS_LATITUDE);
    }

    const char *latitudeRef = params.get(QCameraParameters::KEY_QC_GPS_LATITUDE_REF);
    if (latitudeRef) {
        mParameters.set(QCameraParameters::KEY_QC_GPS_LATITUDE_REF, latitudeRef);
    }else {
         mParameters.remove(QCameraParameters::KEY_QC_GPS_LATITUDE_REF);
    }

    const char *longitude = params.get(QCameraParameters::KEY_GPS_LONGITUDE);
    if (longitude) {
        mParameters.set(QCameraParameters::KEY_GPS_LONGITUDE, longitude);
    }else {
         mParameters.remove(QCameraParameters::KEY_GPS_LONGITUDE);
    }

    const char *longitudeRef = params.get(QCameraParameters::KEY_QC_GPS_LONGITUDE_REF);
    if (longitudeRef) {
        mParameters.set(QCameraParameters::KEY_QC_GPS_LONGITUDE_REF, longitudeRef);
    }else {
         mParameters.remove(QCameraParameters::KEY_QC_GPS_LONGITUDE_REF);
    }

    const char *altitudeRef = params.get(QCameraParameters::KEY_QC_GPS_ALTITUDE_REF);
    if (altitudeRef) {
        mParameters.set(QCameraParameters::KEY_QC_GPS_ALTITUDE_REF, altitudeRef);
    }else {
         mParameters.remove(QCameraParameters::KEY_QC_GPS_ALTITUDE_REF);
    }

    const char *altitude = params.get(QCameraParameters::KEY_GPS_ALTITUDE);
    if (altitude) {
        mParameters.set(QCameraParameters::KEY_GPS_ALTITUDE, altitude);
    }else {
         mParameters.remove(QCameraParameters::KEY_GPS_ALTITUDE);
    }

    const char *status = params.get(QCameraParameters::KEY_QC_GPS_STATUS);
    if (status) {
        mParameters.set(QCameraParameters::KEY_QC_GPS_STATUS, status);
    }

    const char *dateTime = params.get(QCameraParameters::KEY_QC_EXIF_DATETIME);
    if (dateTime) {
        mParameters.set(QCameraParameters::KEY_QC_EXIF_DATETIME, dateTime);
    }else {
         mParameters.remove(QCameraParameters::KEY_QC_EXIF_DATETIME);
    }

    const char *timestamp = params.get(QCameraParameters::KEY_GPS_TIMESTAMP);
    if (timestamp) {
        mParameters.set(QCameraParameters::KEY_GPS_TIMESTAMP, timestamp);
    }else {
         mParameters.remove(QCameraParameters::KEY_GPS_TIMESTAMP);
    }
    ALOGE("setGpsLocation X");
    return NO_ERROR;
!!!44395703.cpp!!!	setRotation(in params : QCameraParameters) : status_t
    status_t rc = NO_ERROR;
    int rotation = params.getInt(QCameraParameters::KEY_ROTATION);
    if (rotation != NOT_FOUND) {
        if (rotation == 0 || rotation == 90 || rotation == 180
            || rotation == 270) {
          mParameters.set(QCameraParameters::KEY_ROTATION, rotation);
          mRotation = rotation;
        } else {
            ALOGE("Invalid rotation value: %d", rotation);
            rc = BAD_VALUE;
        }
    }
    ALOGE("setRotation");
    return rc;
!!!44395831.cpp!!!	setZoom(in params : QCameraParameters) : status_t
    status_t rc = NO_ERROR;

    ALOGV("%s: E",__func__);
    uint8_t supported;

    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_ZOOM,&supported,&supported);
    if(!supported){
        ALOGE("%s:MM_CAMERA_PARM_ZOOM not supported", __func__);
        return NO_ERROR;
    }
    // No matter how many different zoom values the driver can provide, HAL
    // provides applictations the same number of zoom levels. The maximum driver
    // zoom value depends on sensor output (VFE input) and preview size (VFE
    // output) because VFE can only crop and cannot upscale. If the preview size
    // is bigger, the maximum zoom ratio is smaller. However, we want the
    // zoom ratio of each zoom level is always the same whatever the preview
    // size is. Ex: zoom level 1 is always 1.2x, zoom level 2 is 1.44x, etc. So,
    // we need to have a fixed maximum zoom value and do read it from the
    // driver.
    static const int ZOOM_STEP = 1;
    int32_t zoom_level = params.getInt("zoom");
    if(zoom_level >= 0 && zoom_level <= mMaxZoom-1) {
        mParameters.set("zoom", zoom_level);
        int32_t zoom_value = ZOOM_STEP * zoom_level;
        bool ret = native_set_parms(MM_CAMERA_PARM_ZOOM,
            sizeof(zoom_value), (void *)&zoom_value);
        if(ret) {
            mCurrentZoom=zoom_level;
        }
        rc = ret ? NO_ERROR : UNKNOWN_ERROR;
    } else {
        rc = BAD_VALUE;
    }
    ALOGV("%s X",__func__);
    return rc;

!!!44395959.cpp!!!	setFocusMode(in params : QCameraParameters) : status_t
    const char *str = params.get(QCameraParameters::KEY_FOCUS_MODE);
    const char *prev_str = mParameters.get(QCameraParameters::KEY_FOCUS_MODE);
    ALOGV("%s",__func__);
    if (str != NULL) {
        ALOGE("Focus mode %s",str);
        int32_t value = attr_lookup(focus_modes,
                                    sizeof(focus_modes) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            mParameters.set(QCameraParameters::KEY_FOCUS_MODE, str);
            mFocusMode = value;

            if(updateFocusDistances() != NO_ERROR) {
               ALOGE("%s: updateFocusDistances failed for %s", __FUNCTION__, str);
               return UNKNOWN_ERROR;
            }
            mParameters.set(QCameraParameters::KEY_FOCUS_DISTANCES, mFocusDistance.string());
            if(mHasAutoFocusSupport){
                bool ret = native_set_parms(MM_CAMERA_PARM_FOCUS_MODE,
                                      sizeof(value),
                                      (void *)&value);

                int cafSupport = FALSE;
                if(!strcmp(str, QCameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO) ||
                   !strcmp(str, QCameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE)){
                    cafSupport = TRUE;
                }
                ALOGE("Continuous Auto Focus %d", cafSupport);
                ret = native_set_parms(MM_CAMERA_PARM_CONTINUOUS_AF, sizeof(cafSupport),
                                       (void *)&cafSupport);
            }

            return NO_ERROR;
        }
        ALOGE("%s:Could not look up str value",__func__);
    }
    ALOGE("Invalid focus mode value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44396087.cpp!!!	setBrightness(in params : QCameraParameters) : status_t

    ALOGV("%s",__func__);
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_BRIGHTNESS,&supported,&supported);
   if(!supported) {
       ALOGE("MM_CAMERA_PARM_BRIGHTNESS mode is not supported for this sensor");
       return NO_ERROR;
   }
   int brightness = params.getInt("luma-adaptation");
   if (mBrightness !=  brightness) {
       ALOGV(" new brightness value : %d ", brightness);
       mBrightness =  brightness;
       mParameters.set("luma-adaptation", brightness);
       bool ret = native_set_parms(MM_CAMERA_PARM_BRIGHTNESS, sizeof(mBrightness),
                                   (void *)&mBrightness);
        return ret ? NO_ERROR : UNKNOWN_ERROR;
   }

    return NO_ERROR;
!!!44396215.cpp!!!	setSkinToneEnhancement(in params : QCameraParameters) : status_t
    ALOGV("%s",__func__);
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_SCE_FACTOR,&supported,&supported);
    if(!supported) {
       ALOGE("SkinToneEnhancement is not supported for this sensor");
       return NO_ERROR;
    }
     int skinToneValue = params.getInt("skinToneEnhancement");
     if (mSkinToneEnhancement != skinToneValue) {
          ALOGV(" new skinTone correction value : %d ", skinToneValue);
          mSkinToneEnhancement = skinToneValue;
          mParameters.set("skinToneEnhancement", skinToneValue);
          bool ret = native_set_parms(MM_CAMERA_PARM_SCE_FACTOR, sizeof(mSkinToneEnhancement),
                        (void *)&mSkinToneEnhancement);
          return ret ? NO_ERROR : UNKNOWN_ERROR;
    }
    return NO_ERROR;
!!!44396343.cpp!!!	setOrientation(in params : QCameraParameters) : status_t
    const char *str = params.get("orientation");

    if (str != NULL) {
        if (strcmp(str, "portrait") == 0 || strcmp(str, "landscape") == 0) {
            // Camera service needs this to decide if the preview frames and raw
            // pictures should be rotated.
            mParameters.set("orientation", str);
        } else {
            ALOGE("Invalid orientation value: %s", str);
            return BAD_VALUE;
        }
    }
    return NO_ERROR;
!!!44396471.cpp!!!	setLensshadeValue(in params : QCameraParameters) : status_t

    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_ROLLOFF,&supported,&supported);
    if(!supported) {
        ALOGE("%s:LENS SHADING not supported", __func__);
        return NO_ERROR;
    }

    const char *str = params.get(QCameraParameters::KEY_QC_LENSSHADE);
    if (str != NULL) {
        int value = attr_lookup(lensshade,
                                    sizeof(lensshade) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            int8_t temp = (int8_t)value;
            mParameters.set(QCameraParameters::KEY_QC_LENSSHADE, str);
            native_set_parms(MM_CAMERA_PARM_ROLLOFF, sizeof(int8_t), (void *)&temp);
            return NO_ERROR;
        }
    }
    ALOGE("Invalid lensShade value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44396599.cpp!!!	setMCEValue(in params : QCameraParameters) : status_t
    ALOGE("%s",__func__);
    uint8_t supported;

    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_MCE,&supported,&supported);
   if(!supported) {
       ALOGE("MM_CAMERA_PARM_MCE mode is not supported for this sensor");
       return NO_ERROR;
   }
   const char *str = params.get(QCameraParameters::KEY_QC_MEMORY_COLOR_ENHANCEMENT);
    if (str != NULL) {
        int value = attr_lookup(mce, sizeof(mce) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            int temp = (int8_t)value;
            ALOGI("%s: setting MCE value of %s", __FUNCTION__, str);
            mParameters.set(QCameraParameters::KEY_QC_MEMORY_COLOR_ENHANCEMENT, str);

            native_set_parms(MM_CAMERA_PARM_MCE, sizeof(int8_t), (void *)&temp);
            return NO_ERROR;
        }
    }
    ALOGE("Invalid MCE value: %s", (str == NULL) ? "NULL" : str);

    return NO_ERROR;
!!!44396727.cpp!!!	setISOValue(in params : QCameraParameters) : status_t

    ALOGV("%s",__func__);
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_ISO,&supported,&supported);
    if(!supported) {
        ALOGE("%s:MM_CAMERA_PARM_ISO not supported", __func__);
        return NO_ERROR;
    }
    const char *str = params.get(QCameraParameters::KEY_QC_ISO_MODE);
    ALOGV("ISO string : %s",str);
    int8_t temp_hjr;
    if (str != NULL) {
        int value = (camera_iso_mode_type)attr_lookup(
          iso, sizeof(iso) / sizeof(str_map), str);
        ALOGE("ISO Value : %d",value);
        if (value != NOT_FOUND) {
            camera_iso_mode_type temp = (camera_iso_mode_type) value;
            if (value == CAMERA_ISO_DEBLUR) {
               temp_hjr = true;
               native_set_parms(MM_CAMERA_PARM_HJR, sizeof(int8_t), (void*)&temp_hjr);
               mHJR = value;
            }
            else {
               if (mHJR == CAMERA_ISO_DEBLUR) {
                   temp_hjr = false;
                   native_set_parms(MM_CAMERA_PARM_HJR, sizeof(int8_t), (void*)&temp_hjr);
                   mHJR = value;
               }
            }

            mParameters.set(QCameraParameters::KEY_QC_ISO_MODE, str);
            native_set_parms(MM_CAMERA_PARM_ISO, sizeof(camera_iso_mode_type), (void *)&temp);
            return NO_ERROR;
        }
    }
    return BAD_VALUE;
!!!44396855.cpp!!!	setPictureFormat(in params : QCameraParameters) : status_t
    const char * str = params.get(QCameraParameters::KEY_PICTURE_FORMAT);
    if(str != NULL){
        int32_t value = attr_lookup(picture_formats,
                                    sizeof(picture_formats) / sizeof(str_map), str);
        if(value != NOT_FOUND){
            if (isZSLMode() && !strcmp(str, "raw")) {
                mParameters.set(QCameraParameters::KEY_PICTURE_FORMAT, "jpeg");
            } else {
                mParameters.set(QCameraParameters::KEY_PICTURE_FORMAT, str);
            }
        } else {
            ALOGE("Invalid Picture Format value: %s", str);
            return BAD_VALUE;
        }
    }
    return NO_ERROR;
!!!44396983.cpp!!!	setSharpness(in params : QCameraParameters) : status_t
    bool ret = false;
    int rc = MM_CAMERA_OK;
    ALOGV("%s",__func__);
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_SHARPNESS,(uint8_t*)&rc,(uint8_t*)&rc);
    if(!rc) {
        ALOGE("%s:CONTRAST not supported", __func__);
        return NO_ERROR;
    }
    int sharpness = params.getInt(QCameraParameters::KEY_QC_SHARPNESS);
    if((sharpness < CAMERA_MIN_SHARPNESS
            || sharpness > CAMERA_MAX_SHARPNESS))
        return UNKNOWN_ERROR;

    ALOGV("setting sharpness %d", sharpness);
    mParameters.set(QCameraParameters::KEY_QC_SHARPNESS, sharpness);
    ret = native_set_parms(MM_CAMERA_PARM_SHARPNESS, sizeof(sharpness),
                               (void *)&sharpness);
    return ret ? NO_ERROR : UNKNOWN_ERROR;
!!!44397111.cpp!!!	setContrast(in params : QCameraParameters) : status_t
   ALOGV("%s E", __func__ );
   int rc = MM_CAMERA_OK;
   mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                         MM_CAMERA_PARM_CONTRAST,(uint8_t*)&rc,(uint8_t*)&rc);
   if(!rc) {
        ALOGE("%s:CONTRAST not supported", __func__);
        return NO_ERROR;
    }
   const char *str = params.get(QCameraParameters::KEY_SCENE_MODE);
   ALOGE("Contrast : %s",str);
   int32_t value = attr_lookup(scenemode, sizeof(scenemode) / sizeof(str_map), str);
   if(value == CAMERA_BESTSHOT_OFF) {
        int contrast = params.getInt(QCameraParameters::KEY_QC_CONTRAST);
        if((contrast < CAMERA_MIN_CONTRAST)
                || (contrast > CAMERA_MAX_CONTRAST))
        {
            ALOGE("Contrast Value not matching");
            return UNKNOWN_ERROR;
        }
        ALOGV("setting contrast %d", contrast);
        mParameters.set(QCameraParameters::KEY_QC_CONTRAST, contrast);
        ALOGE("Calling Contrast set on Lower layer");
        bool ret = native_set_parms(MM_CAMERA_PARM_CONTRAST, sizeof(contrast),
                                   (void *)&contrast);
        ALOGE("Lower layer returned %d", ret);
        int bestshot_reconfigure;
        mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                                     MM_CAMERA_PARM_BESTSHOT_RECONFIGURE,
                            &bestshot_reconfigure);
        if(bestshot_reconfigure) {
             if (mContrast != contrast) {
                  mContrast = contrast;
                 if (mPreviewState == QCAMERA_HAL_PREVIEW_STARTED && ret) {
                      mRestartPreview = true;
                  }
             }
        }
        return ret ? NO_ERROR : UNKNOWN_ERROR;
    } else {
          ALOGI(" Contrast value will not be set " \
          "when the scenemode selected is %s", str);
          return NO_ERROR;
    }
    return BAD_VALUE;
!!!44397239.cpp!!!	setSaturation(in params : QCameraParameters) : status_t
    bool ret = false;
    int rc = MM_CAMERA_OK;
    ALOGV("%s",__func__);
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_SATURATION,(uint8_t*)&rc,(uint8_t*)&rc);
    if(!rc) {
        ALOGE("%s:MM_CAMERA_PARM_SATURATION not supported", __func__);
        return NO_ERROR;
    }
    int result;
    int saturation = params.getInt(QCameraParameters::KEY_QC_SATURATION);

    if((saturation < CAMERA_MIN_SATURATION)
        || (saturation > CAMERA_MAX_SATURATION))
    return UNKNOWN_ERROR;

    ALOGV("Setting saturation %d", saturation);
    mParameters.set(QCameraParameters::KEY_QC_SATURATION, saturation);
    ret = native_set_parms(MM_CAMERA_PARM_SATURATION, sizeof(saturation),
        (void *)&saturation, (int *)&result);
    if(result != MM_CAMERA_OK)
        ALOGI("Saturation Value: %d is not set as the selected value is not supported", saturation);
    return ret ? NO_ERROR : UNKNOWN_ERROR;
!!!44397367.cpp!!!	setWaveletDenoise(in params : QCameraParameters) : status_t
    ALOGV("%s",__func__);
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_WAVELET_DENOISE,&supported,&supported);
    if( !supported ) {
        ALOGE("Wavelet Denoise is not supported for this sensor");
        /* TO DO */
//        return NO_ERROR;
    }
    const char *str = params.get(QCameraParameters::KEY_QC_DENOISE);
    if (str != NULL) {
        int value = attr_lookup(denoise,
                sizeof(denoise) / sizeof(str_map), str);
        if ((value != NOT_FOUND) &&  (mDenoiseValue != value)) {
            mDenoiseValue =  value;
            mParameters.set(QCameraParameters::KEY_QC_DENOISE, str);

            char prop[PROPERTY_VALUE_MAX];
            memset(prop, 0, sizeof(prop));
            property_get("persist.denoise.process.plates", prop, "0");

            denoise_param_t temp;
            memset(&temp, 0, sizeof(denoise_param_t));
            temp.denoise_enable = value;
            switch(atoi(prop)) {
                case 0:
                    temp.process_plates = WAVELET_DENOISE_YCBCR_PLANE;
                    break;
                case 1:
                    temp.process_plates = WAVELET_DENOISE_CBCR_ONLY;
                    break;
                case 2:
                    temp.process_plates = WAVELET_DENOISE_STREAMLINE_YCBCR;
                    break;
                case 3:
                    temp.process_plates = WAVELET_DENOISE_STREAMLINED_CBCR;
                    break;
                default:
                    temp.process_plates = WAVELET_DENOISE_STREAMLINE_YCBCR;
                    break;
                }
            ALOGE("Denoise enable=%d, plates=%d", temp.denoise_enable, temp.process_plates);
            bool ret = native_set_parms(MM_CAMERA_PARM_WAVELET_DENOISE, sizeof(temp),
                    (void *)&temp);
            return ret ? NO_ERROR : UNKNOWN_ERROR;
        }
        return NO_ERROR;
    }
    ALOGE("Invalid Denoise value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44397495.cpp!!!	setSceneMode(in params : QCameraParameters) : status_t
    ALOGV("%s",__func__);
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_BESTSHOT_MODE,&supported,&supported);
    if(!supported) {
        ALOGE("%s:Parameter Scenemode is not supported for this sensor", __func__);
        return NO_ERROR;
    }
    const char *str = params.get(QCameraParameters::KEY_SCENE_MODE);
    ALOGE("Scene Mode string : %s",str);

    if (str != NULL) {
        int32_t value = attr_lookup(scenemode, sizeof(scenemode) / sizeof(str_map), str);
        ALOGE("Setting Scenemode value = %d",value );
        if (value != NOT_FOUND) {
            if((value != CAMERA_BESTSHOT_OFF ) && (mColorEffects != CAMERA_EFFECT_OFF )) {
               int result;
               mColorEffects = CAMERA_EFFECT_OFF;
               native_set_parms(MM_CAMERA_PARM_EFFECT, sizeof(mColorEffects),
                                (void *)&mColorEffects,(int *)&result);
               if(result != MM_CAMERA_OK) {
                  ALOGI("Camera Effect is not set as the EFFECT_NONE and result is not OK");
               }
            }
            mParameters.set(QCameraParameters::KEY_SCENE_MODE, str);
            bool ret = native_set_parms(MM_CAMERA_PARM_BESTSHOT_MODE, sizeof(value),
                                       (void *)&value);
            int bestshot_reconfigure;
            mCameraHandle->ops->get_parm(mCameraHandle->camera_handle,
                                         MM_CAMERA_PARM_BESTSHOT_RECONFIGURE,
                                &bestshot_reconfigure);
            if(bestshot_reconfigure) {
                if (mBestShotMode != value) {
                     mBestShotMode = value;
                     if (mPreviewState == QCAMERA_HAL_PREVIEW_STARTED && ret) {
                           mRestartPreview = true;
                      }
                 }
            }
            return ret ? NO_ERROR : UNKNOWN_ERROR;
        }
    }
    ALOGE("Invalid scenemode value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44397751.cpp!!!	setFaceDetection(in str : char) : status_t
    if(supportsFaceDetection() == false){
        ALOGE("Face detection is not enabled");
        return NO_ERROR;
    }
    if (str != NULL) {
        int requested_faces = mParameters.getInt(QCameraParameters::KEY_QC_MAX_NUM_REQUESTED_FACES);
        int value = attr_lookup(facedetection,
                                    sizeof(facedetection) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            fd_set_parm_t fd_set_parm;
            mFaceDetectOn = value;
            fd_set_parm.fd_mode = value;
            fd_set_parm.num_fd = requested_faces;
            ALOGE("%s Face detection value = %d, num_fd = %d",__func__, value, requested_faces);
            native_set_parms(MM_CAMERA_PARM_FD, sizeof(fd_set_parm_t), (void *)&fd_set_parm);
            mParameters.set(QCameraParameters::KEY_QC_FACE_DETECTION, str);
            return NO_ERROR;
        }
    }
    ALOGE("Invalid Face Detection value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44397879.cpp!!!	setSceneDetect(in params : QCameraParameters) : status_t
    ALOGV("%s",__func__);
    bool retParm;
    int rc = 0;

    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_ASD_ENABLE,(uint8_t*)&rc,(uint8_t*)&rc);
    if(!rc) {
        ALOGE("%s:MM_CAMERA_PARM_ASD_ENABLE not supported", __func__);
        return NO_ERROR;
    }

    const char *str = params.get(QCameraParameters::KEY_QC_SCENE_DETECT);
    ALOGE("Scene Detect string : %s",str);
    if (str != NULL) {
        int32_t value = attr_lookup(scenedetect, sizeof(scenedetect) / sizeof(str_map), str);
        ALOGE("Scenedetect Value : %d",value);
        if (value != NOT_FOUND) {
            mParameters.set(QCameraParameters::KEY_QC_SCENE_DETECT, str);

            retParm = native_set_parms(MM_CAMERA_PARM_ASD_ENABLE, sizeof(value),
                                       (void *)&value);

            return retParm ? NO_ERROR : UNKNOWN_ERROR;
        }
    }
   return BAD_VALUE;
!!!44398007.cpp!!!	setStrTextures(in params : QCameraParameters) : status_t
    const char *str = params.get("strtextures");
    const char *prev_str = mParameters.get("strtextures");

    if(str != NULL) {
        if(!strcmp(str,prev_str)) {
            return NO_ERROR;
        }
        int str_size = strlen(str);
        mParameters.set("strtextures", str);
        if(str_size == 2) {
            if(!strncmp(str, "on", str_size) || !strncmp(str, "ON", str_size)){
                ALOGI("Resetting mUseOverlay to false");
                strTexturesOn = true;
                mUseOverlay = false;
            }
        }else if(str_size == 3){
            if (!strncmp(str, "off", str_size) || !strncmp(str, "OFF", str_size)) {
                strTexturesOn = false;
                mUseOverlay = true;
            }
        }

    }
    return NO_ERROR;
!!!44398135.cpp!!!	setPreviewFormat(in params : QCameraParameters) : status_t
    const char *str = params.getPreviewFormat();
    int32_t previewFormat = attr_lookup(preview_formats, sizeof(preview_formats) / sizeof(str_map), str);
    if(previewFormat != NOT_FOUND) {
        int num = sizeof(preview_format_info_list)/sizeof(preview_format_info_t);
        int i;

        for (i = 0; i < num; i++) {
          if (preview_format_info_list[i].Hal_format == previewFormat) {
            mPreviewFormatInfo = preview_format_info_list[i];
            break;
          }
        }

        if (i == num) {
          mPreviewFormatInfo.mm_cam_format = CAMERA_YUV_420_NV21;
          mPreviewFormatInfo.padding = CAMERA_PAD_TO_WORD;
          return BAD_VALUE;
        }
        bool ret = native_set_parms(MM_CAMERA_PARM_PREVIEW_FORMAT, sizeof(cam_format_t),
                                   (void *)&mPreviewFormatInfo.mm_cam_format);
        mParameters.set(QCameraParameters::KEY_PREVIEW_FORMAT, str);
        mPreviewFormat = mPreviewFormatInfo.mm_cam_format;
        ALOGI("Setting preview format to %d, i =%d, num=%d, hal_format=%d",
             mPreviewFormat, i, num, mPreviewFormatInfo.Hal_format);
        return NO_ERROR;
    } else if ( strTexturesOn ) {
      mPreviewFormatInfo.mm_cam_format = CAMERA_YUV_420_NV21;
      mPreviewFormatInfo.padding = CAMERA_PAD_TO_4K;
    } else {
      mPreviewFormatInfo.mm_cam_format = CAMERA_YUV_420_NV21;
      mPreviewFormatInfo.padding = CAMERA_PAD_TO_WORD;
    }
    ALOGE("Invalid preview format value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44398263.cpp!!!	setSelectableZoneAf(in params : QCameraParameters) : status_t
    ALOGV("%s",__func__);
    uint8_t supported;
    if(mHasAutoFocusSupport) {
        const char *str = params.get(QCameraParameters::KEY_QC_SELECTABLE_ZONE_AF);
        if (str != NULL) {
            int32_t value = attr_lookup(selectable_zone_af, sizeof(selectable_zone_af) / sizeof(str_map), str);
            if (value != NOT_FOUND) {
                 mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                                       MM_CAMERA_PARM_FOCUS_RECT,&supported,&supported);
                 if(!supported) {
                    ALOGE("SelectableZoneAF  is not supported for this sensor");
                    return NO_ERROR;
                 }else {
                    mParameters.set(QCameraParameters::KEY_QC_SELECTABLE_ZONE_AF, str);
                    bool ret = native_set_parms(MM_CAMERA_PARM_FOCUS_RECT, sizeof(value),
                            (void *)&value);
                    return ret ? NO_ERROR : UNKNOWN_ERROR;
                 }
            }
        }
        ALOGE("Invalid selectable zone af value: %s", (str == NULL) ? "NULL" : str);
        return BAD_VALUE;

    }
    return NO_ERROR;
!!!44398391.cpp!!!	setOverlayFormats(in params : QCameraParameters) : status_t
    mParameters.set("overlay-format", HAL_PIXEL_FORMAT_YCbCr_420_SP);
    if(mIs3DModeOn == true) {
       int ovFormat = HAL_PIXEL_FORMAT_YCrCb_420_SP|HAL_3D_IN_SIDE_BY_SIDE_L_R|HAL_3D_OUT_SIDE_BY_SIDE;
        mParameters.set("overlay-format", ovFormat);
    }
    return NO_ERROR;
!!!44398519.cpp!!!	setHighFrameRate(in params : QCameraParameters) : status_t
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_HFR,&supported,&supported);
    if(!supported) {
        ALOGE("%s: MM_CAMERA_PARM_HFR not supported", __func__);
        return NO_ERROR;
    }

    const char *str = params.get(QCameraParameters::KEY_QC_VIDEO_HIGH_FRAME_RATE);
    if (str != NULL) {
        int value = attr_lookup(hfr, sizeof(hfr) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            mHFRLevel = (int32_t)value;
            //Check for change in HFR value
            const char *oldHfr = mParameters.get(QCameraParameters::KEY_QC_VIDEO_HIGH_FRAME_RATE);
            if(strcmp(oldHfr, str)){
                mParameters.set(QCameraParameters::KEY_QC_VIDEO_HIGH_FRAME_RATE, str);
                if(QCAMERA_HAL_PREVIEW_STARTED == mPreviewState) {
                    stopPreviewInternal();
                    mPreviewState = QCAMERA_HAL_PREVIEW_STOPPED;
                    native_set_parms(MM_CAMERA_PARM_HFR, sizeof(int32_t), (void *)&mHFRLevel);
                    mRestartPreview = true;
                    return NO_ERROR;
                }
            }
            native_set_parms(MM_CAMERA_PARM_HFR, sizeof(int32_t), (void *)&mHFRLevel);
            return NO_ERROR;
        }
    }
    ALOGE("Invalid HFR value: %s", (str == NULL) ? "NULL" : str);
    return NO_ERROR;
!!!44398647.cpp!!!	setRedeyeReduction(in params : QCameraParameters) : status_t
    if(supportsRedEyeReduction() == false) {
        ALOGE("Parameter Redeye Reduction is not supported for this sensor");
        return NO_ERROR;
    }

    const char *str = params.get(QCameraParameters::KEY_QC_REDEYE_REDUCTION);
    if (str != NULL) {
        int value = attr_lookup(redeye_reduction, sizeof(redeye_reduction) / sizeof(str_map), str);
        if (value != NOT_FOUND) {
            int8_t temp = (int8_t)value;
            ALOGI("%s: setting Redeye Reduction value of %s", __FUNCTION__, str);
            mParameters.set(QCameraParameters::KEY_QC_REDEYE_REDUCTION, str);

            native_set_parms(MM_CAMERA_PARM_REDEYE_REDUCTION, sizeof(int8_t), (void *)&temp);
            return NO_ERROR;
        }
    }
    ALOGE("Invalid Redeye Reduction value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44398775.cpp!!!	setAEBracket(in params : QCameraParameters) : status_t
    uint8_t supported;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_HDR,&supported,&supported);
    if(!supported || (myMode & CAMERA_ZSL_MODE)) {
        ALOGI("Parameter HDR is not supported for this sensor/ ZSL mode");

        if (myMode & CAMERA_ZSL_MODE) {
            ALOGE("In ZSL mode, reset AEBBracket to HDR_OFF mode");
            exp_bracketing_t temp;
            memset(&temp, 0, sizeof(temp));
            mHdrMode = HDR_BRACKETING_OFF;
            temp.hdr_enable= FALSE;
            temp.mode = HDR_BRACKETING_OFF;
            native_set_parms(MM_CAMERA_PARM_HDR, sizeof(exp_bracketing_t), (void *)&temp);
        }
        return NO_ERROR;
    }
    const char *str = params.get(QCameraParameters::KEY_QC_AE_BRACKET_HDR);

    if (str != NULL) {
        int value = attr_lookup(hdr_bracket,
                                    sizeof(hdr_bracket) / sizeof(str_map), str);
        exp_bracketing_t temp;
        memset(&temp, 0, sizeof(temp));
        switch (value) {
            case HDR_MODE:
                {
                    mHdrMode = HDR_MODE;
                    ALOGE("%s, mHdrMode == HDR_MODE", __func__);
                  /*  temp.hdr_enable= TRUE;
                    temp.mode = HDR_MODE;
                    temp.total_frames = 3;
                    temp.total_hal_frames = getNumOfSnapshots();
                    ALOGI("%s: setting HDR frames (%d)", __FUNCTION__, temp.total_hal_frames);
                    native_set_parms(MM_CAMERA_PARM_HDR, sizeof(exp_bracketing_t), (void *)&temp); */
                }
                break;
            case EXP_BRACKETING_MODE:
                {
                    ALOGE("%s, mHdrMode == EXP_BRACKETING_MODE", __func__);
                    int numFrames = getNumOfSnapshots();
                    const char *str_val = params.get("capture-burst-exposures");
                    if ((str_val != NULL) && (strlen(str_val)>0)) {
                        ALOGI("%s: capture-burst-exposures %s", __FUNCTION__, str_val);

                        mHdrMode = EXP_BRACKETING_MODE;
                        temp.hdr_enable = FALSE;
                        temp.mode = EXP_BRACKETING_MODE;
                        temp.total_frames = (numFrames >  MAX_SNAPSHOT_BUFFERS -2) ? MAX_SNAPSHOT_BUFFERS -2 : numFrames;
                        temp.total_hal_frames = temp.total_frames;
                        strlcpy(temp.values, str_val, MAX_EXP_BRACKETING_LENGTH);
                        ALOGI("%s: setting Exposure Bracketing value of %s, frame (%d)", __FUNCTION__, temp.values, temp.total_hal_frames);
                        native_set_parms(MM_CAMERA_PARM_HDR, sizeof(exp_bracketing_t), (void *)&temp);
                    }
                    else {
                        /* Apps not set capture-burst-exposures, error case fall into bracketing off mode */
                        ALOGI("%s: capture-burst-exposures not set, back to HDR OFF mode", __FUNCTION__);
                        mHdrMode = HDR_BRACKETING_OFF;
                        temp.hdr_enable= FALSE;
                        temp.mode = HDR_BRACKETING_OFF;
                        native_set_parms(MM_CAMERA_PARM_HDR, sizeof(exp_bracketing_t), (void *)&temp);
                    }
                }
                break;
            case HDR_BRACKETING_OFF:
                ALOGE("%s, mHdrMode == HDR_BRACKETING_OFF", __func__);
            default:
                {
                    ALOGE("%s, mHdrMode == HDR_BRACKETING_OFF", __func__);
                    mHdrMode = HDR_BRACKETING_OFF;
                    temp.hdr_enable= FALSE;
                    temp.mode = HDR_BRACKETING_OFF;
                    native_set_parms(MM_CAMERA_PARM_HDR, sizeof(exp_bracketing_t), (void *)&temp);
                }
                break;
        }

        /* save the value*/
        mParameters.set(QCameraParameters::KEY_QC_AE_BRACKET_HDR, str);
    }
    return NO_ERROR;
!!!44398903.cpp!!!	setFaceDetect(in params : QCameraParameters) : status_t
    int requested_faces = params.getInt(QCameraParameters::KEY_QC_MAX_NUM_REQUESTED_FACES);
    int hardware_supported_faces = mParameters.getInt(CameraParameters::KEY_MAX_NUM_DETECTED_FACES_HW);
    if (requested_faces > hardware_supported_faces) {
        requested_faces = hardware_supported_faces;
    }
    mParameters.set(QCameraParameters::KEY_QC_MAX_NUM_REQUESTED_FACES, requested_faces);
    const char *str = params.get(QCameraParameters::KEY_QC_FACE_DETECTION);
    ALOGE("setFaceDetect: %s", str);
    if (str != NULL) {
        fd_set_parm_t fd_set_parm;
        int value = attr_lookup(facedetection,
                sizeof(facedetection) / sizeof(str_map), str);
        mFaceDetectOn = value;
        fd_set_parm.fd_mode = value;
        fd_set_parm.num_fd = requested_faces;
        ALOGE("%s Face detection value = %d, num_fd = %d",__func__, value, requested_faces);
        native_set_parms(MM_CAMERA_PARM_FD, sizeof(fd_set_parm_t), (void *)&fd_set_parm);
        mParameters.set(QCameraParameters::KEY_QC_FACE_DETECTION, str);
        return NO_ERROR;
    }
    ALOGE("Invalid Face Detection value: %s", (str == NULL) ? "NULL" : str);
    return BAD_VALUE;
!!!44399031.cpp!!!	setDenoise(in params : QCameraParameters) : status_t
    return BAD_VALUE;
!!!44399159.cpp!!!	setAecAwbLock(in params : QCameraParameters) : status_t
    ALOGD("%s : E", __func__);
    status_t rc = NO_ERROR;
    int32_t value;
    const char* str;

    //for AEC lock
    str = params.get(QCameraParameters::KEY_AUTO_EXPOSURE_LOCK);
    value = (strcmp(str, "true") == 0)? 1 : 0;
    mParameters.set(QCameraParameters::KEY_AUTO_EXPOSURE_LOCK, str);
    rc = (native_set_parms(MM_CAMERA_PARM_AEC_LOCK, sizeof(int32_t), (void *)(&value))) ?
                            NO_ERROR : UNKNOWN_ERROR;

    //for AWB lock
    str = params.get(QCameraParameters::KEY_AUTO_WHITEBALANCE_LOCK);
    value = (strcmp(str, "true") == 0)? 1 : 0;
    mParameters.set(QCameraParameters::KEY_AUTO_WHITEBALANCE_LOCK, str);
    rc = (native_set_parms(MM_CAMERA_PARM_AWB_LOCK, sizeof(int32_t), (void *)(&value))) ?
                        NO_ERROR : UNKNOWN_ERROR;
    ALOGD("%s : X", __func__);
    return rc;
!!!44399287.cpp!!!	setHistogram(in histogram_en : int) : status_t
    status_t ret = NO_ERROR;

    ALOGV("setHistogram: E");
    if(mStatsOn == histogram_en) {
        return ret;
    }

    status_t rc = NO_ERROR;
    mCameraHandle->ops->is_parm_supported(mCameraHandle->camera_handle,
                                          MM_CAMERA_PARM_HISTOGRAM,
                                          (uint8_t*)&rc,(uint8_t*)&rc);
    if(!rc) {
        ALOGE(" Histogram is not supported for this");
        return NO_ERROR;
    }
    mSendData = histogram_en;
    mStatsOn = histogram_en;

    if (histogram_en == QCAMERA_PARM_ENABLE) {
        ret = initHistogramBuffers();
        if (ret != NO_ERROR) {
          ALOGE("%s Error initializing Histogram buffers ", __func__);
          return ret;
        }
    }
    ALOGI(" Histogram -> %s", histogram_en ? "Enabled" : "Disabled");
    native_set_parms(MM_CAMERA_PARM_HISTOGRAM, sizeof(int), &histogram_en);
    if(histogram_en == QCAMERA_PARM_DISABLE) {
        ret = deInitHistogramBuffers();
        if (ret != NO_ERROR) {
          ALOGE("%s Error deInitializing Histogram buffers ", __func__);
          return ret;
        }
    }
    ALOGV("setHistogram: X");
    return ret;
!!!44399415.cpp!!!	setRecordingHint(in params : QCameraParameters) : status_t

  const char * str = params.get(QCameraParameters::KEY_RECORDING_HINT);

  if(str != NULL){
      int32_t value = attr_lookup(recording_Hints,
                                  sizeof(recording_Hints) / sizeof(str_map), str);
      if(value != NOT_FOUND){
          mRecordingHint = value;
          setRecordingHintValue(mRecordingHint);
          mParameters.set(QCameraParameters::KEY_RECORDING_HINT, str);
          return NO_ERROR;
      } else {
          ALOGE("Invalid Picture Format value: %s", str);
          setDISMode();
          setFullLiveshot();
          return BAD_VALUE;
      }
  }
  setDISMode();
  setFullLiveshot();
  return NO_ERROR;
!!!44399543.cpp!!!	setRecordingHintValue(in value : int32_t) : status_t
    native_set_parms(MM_CAMERA_PARM_RECORDING_HINT, sizeof(value),
                                           (void *)&value);
    if (value == TRUE){
        native_set_parms(MM_CAMERA_PARM_CAF_ENABLE, sizeof(value),
                                           (void *)&value);
    }
    setDISMode();
    setFullLiveshot();
    return NO_ERROR;
!!!44399671.cpp!!!	setFocusAreas(in params : QCameraParameters) : status_t
    ALOGV("%s: E", __func__);
    status_t rc;
    int max_num_af_areas = mParameters.getInt(QCameraParameters::KEY_MAX_NUM_FOCUS_AREAS);
    if(max_num_af_areas == 0) {
        return NO_ERROR;
    }
    const char *str = params.get(QCameraParameters::KEY_FOCUS_AREAS);
    if (str == NULL) {
        ALOGE("%s: Parameter string is null", __func__);
        rc = NO_ERROR;
    } else {
        camera_area_t *areas = new camera_area_t[max_num_af_areas];
        int num_areas_found=0;
        if(parseCameraAreaString(str, max_num_af_areas, areas, &num_areas_found) < 0) {
            ALOGE("%s: Failed to parse the string: %s", __func__, str);
            delete areas;
            return BAD_VALUE;
        }
        for(int i=0; i<num_areas_found; i++) {
            ALOGD("FocusArea[%d] = (%d, %d, %d, %d, %d)", i, (areas[i].x1), (areas[i].y1),
                        (areas[i].x2), (areas[i].y2), (areas[i].weight));
        }
        if(validateCameraAreas(areas, num_areas_found) == false) {
            ALOGE("%s: invalid areas specified : %s", __func__, str);
            delete areas;
            return BAD_VALUE;
        }
        mParameters.set(QCameraParameters::KEY_FOCUS_AREAS, str);
        num_areas_found = 1; //temp; need to change after the multi-roi is enabled

        //if the native_set_parms is called when preview is not started, it
        //crashes in lower layer, so return of preview is not started
        if(mPreviewState == QCAMERA_HAL_PREVIEW_STOPPED) {
            delete areas;
            return NO_ERROR;
        }

        //for special area string (0, 0, 0, 0, 0), set the num_areas_found to 0,
        //so no action is takenby the lower layer
        if(num_areas_found == 1 && (areas[0].x1 == 0) && (areas[0].y1 == 0)
            && (areas[0].x2 == 0) && (areas[0].y2 == 0) && (areas[0].weight == 0)) {
            num_areas_found = 0;
        }
        roi_info_t af_roi_value;
        memset(&af_roi_value, 0, sizeof(roi_info_t));
        uint16_t x1, x2, y1, y2, dx, dy;
        int previewWidth, previewHeight;
        this->getPreviewSize(&previewWidth, &previewHeight);
        //transform the coords from (-1000, 1000) to (0, previewWidth or previewHeight)
        x1 = (uint16_t)((areas[0].x1 + 1000.0f)*(previewWidth/2000.0f));
        y1 = (uint16_t)((areas[0].y1 + 1000.0f)*(previewHeight/2000.0f));
        x2 = (uint16_t)((areas[0].x2 + 1000.0f)*(previewWidth/2000.0f));
        y2 = (uint16_t)((areas[0].y2 + 1000.0f)*(previewHeight/2000.0f));
        dx = x2 - x1;
        dy = y2 - y1;

        af_roi_value.num_roi = num_areas_found;
        af_roi_value.roi[0].x = x1;
        af_roi_value.roi[0].y = y1;
        af_roi_value.roi[0].dx = dx;
        af_roi_value.roi[0].dy = dy;
        af_roi_value.is_multiwindow = 0;
        if (native_set_parms(MM_CAMERA_PARM_AF_ROI, sizeof(roi_info_t), (void*)&af_roi_value))
            rc = NO_ERROR;
        else
            rc = BAD_VALUE;
        delete areas;
    }
    ALOGE("%s: X", __func__);
    return rc;
!!!44399799.cpp!!!	setMeteringAreas(in params : QCameraParameters) : status_t
    ALOGV("%s: E", __func__);
    status_t rc;
    int max_num_mtr_areas = mParameters.getInt(QCameraParameters::KEY_MAX_NUM_METERING_AREAS);
    if(max_num_mtr_areas == 0) {
        return NO_ERROR;
    }

    const char *str = params.get(QCameraParameters::KEY_METERING_AREAS);
    if (str == NULL) {
        ALOGE("%s: Parameter string is null", __func__);
        rc = NO_ERROR;
    } else {
        camera_area_t *areas = new camera_area_t[max_num_mtr_areas];
        int num_areas_found=0;
        if(parseCameraAreaString(str, max_num_mtr_areas, areas, &num_areas_found) < 0) {
            ALOGE("%s: Failed to parse the string: %s", __func__, str);
            delete areas;
            return BAD_VALUE;
        }
        for(int i=0; i<num_areas_found; i++) {
            ALOGD("MeteringArea[%d] = (%d, %d, %d, %d, %d)", i, (areas[i].x1), (areas[i].y1),
                        (areas[i].x2), (areas[i].y2), (areas[i].weight));
        }
        if(validateCameraAreas(areas, num_areas_found) == false) {
            ALOGE("%s: invalid areas specified : %s", __func__, str);
            delete areas;
            return BAD_VALUE;
        }
        mParameters.set(QCameraParameters::KEY_METERING_AREAS, str);

        //if the native_set_parms is called when preview is not started, it
        //crashes in lower layer, so return of preview is not started
        if(mPreviewState == QCAMERA_HAL_PREVIEW_STOPPED) {
            delete areas;
            return NO_ERROR;
        }

        num_areas_found = 1; //temp; need to change after the multi-roi is enabled

        //for special area string (0, 0, 0, 0, 0), set the num_areas_found to 0,
        //so no action is takenby the lower layer
        if(num_areas_found == 1 && (areas[0].x1 == 0) && (areas[0].y1 == 0)
             && (areas[0].x2 == 0) && (areas[0].y2 == 0) && (areas[0].weight == 0)) {
            num_areas_found = 0;
        }
        cam_set_aec_roi_t aec_roi_value;
        uint16_t x1, x2, y1, y2;
        int previewWidth, previewHeight;
        this->getPreviewSize(&previewWidth, &previewHeight);
        //transform the coords from (-1000, 1000) to (0, previewWidth or previewHeight)
        x1 = (uint16_t)((areas[0].x1 + 1000.0f)*(previewWidth/2000.0f));
        y1 = (uint16_t)((areas[0].y1 + 1000.0f)*(previewHeight/2000.0f));
        x2 = (uint16_t)((areas[0].x2 + 1000.0f)*(previewWidth/2000.0f));
        y2 = (uint16_t)((areas[0].y2 + 1000.0f)*(previewHeight/2000.0f));
        delete areas;

        if(num_areas_found == 1) {
            aec_roi_value.aec_roi_enable = AEC_ROI_ON;
            aec_roi_value.aec_roi_type = AEC_ROI_BY_COORDINATE;
            aec_roi_value.aec_roi_position.coordinate.x = (x1+x2)/2;
            aec_roi_value.aec_roi_position.coordinate.y = (y1+y2)/2;
        } else {
            aec_roi_value.aec_roi_enable = AEC_ROI_OFF;
            aec_roi_value.aec_roi_type = AEC_ROI_BY_COORDINATE;
            aec_roi_value.aec_roi_position.coordinate.x = DONT_CARE_COORDINATE;
            aec_roi_value.aec_roi_position.coordinate.y = DONT_CARE_COORDINATE;
        }

        if(native_set_parms(MM_CAMERA_PARM_AEC_ROI, sizeof(cam_set_aec_roi_t), (void *)&aec_roi_value))
            rc = NO_ERROR;
        else
            rc = BAD_VALUE;
    }
    ALOGV("%s: X", __func__);
    return rc;
!!!44400311.cpp!!!	setPowerMode(in params : QCameraParameters) : status_t
    uint32_t value = NORMAL_POWER;
    const char *powermode = NULL;

    powermode = params.get(QCameraParameters::KEY_QC_POWER_MODE);
    if (powermode != NULL) {
        value = attr_lookup(power_modes,
                sizeof(power_modes) / sizeof(str_map), powermode);
        if((value == LOW_POWER) || mHFRLevel > 1) {
            ALOGI("Enable Low Power Mode");
            value = LOW_POWER;
            mPowerMode = value;
            mParameters.set(QCameraParameters::KEY_QC_POWER_MODE,"Low_Power");
        } else {
            ALOGE("Enable Normal Power Mode");
            mPowerMode = value;
            mParameters.set(QCameraParameters::KEY_QC_POWER_MODE,"Normal_Power");
        }
    }

    ALOGI("%s Low power mode %s value = %d", __func__,
          value ? "Enabled" : "Disabled", value);
    native_set_parms(MM_CAMERA_PARM_LOW_POWER_MODE, sizeof(value),
                                               (void *)&value);
    return NO_ERROR;
!!!44400439.cpp!!!	takePicturePrepareHardware() : void
    ALOGV("%s: E", __func__);

    /* Prepare snapshot*/
    mCameraHandle->ops->prepare_snapshot(mCameraHandle->camera_handle,
                  mChannelId,
                  0);
    ALOGV("%s: X", __func__);
!!!44400567.cpp!!!	setNoDisplayMode(in params : QCameraParameters) : status_t
  char prop[PROPERTY_VALUE_MAX];
  memset(prop, 0, sizeof(prop));
  property_get("persist.camera.nodisplay", prop, "0");
  int prop_val = atoi(prop);

  if (prop_val == 0) {
    const char *str_val  = params.get("no-display-mode");
    if(str_val && strlen(str_val) > 0) {
      mNoDisplayMode = atoi(str_val);
    } else {
      mNoDisplayMode = 0;
    }
    ALOGD("Param mNoDisplayMode =%d", mNoDisplayMode);
  } else {
    mNoDisplayMode = prop_val;
    ALOGD("prop mNoDisplayMode =%d", mNoDisplayMode);
  }
  return NO_ERROR;
!!!44400695.cpp!!!	setDimension() : status_t
    ALOGV("%s: E", __func__);
    cam_ctrl_dimension_t dim;
    int ret = MM_CAMERA_OK;
    int postviewWidth,postviewHeight;

    memset(&dim, 0, sizeof(cam_ctrl_dimension_t));
    ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_DIMENSION,&dim);

    if (MM_CAMERA_OK != ret) {
      ALOGE("%s: error - can't get preview dimension!", __func__);
      ALOGE("%s: X", __func__);
      return BAD_VALUE;
    }

    getPreviewSize(&mPreviewWidth,  &mPreviewHeight);
    dim.display_width  = mPreviewWidth;
    dim.display_height = mPreviewHeight;

    cam_format_t value = getPreviewFormat();
    if(value != NOT_FOUND && value != dim.prev_format ) {
        //Setting to Parameter requested by the Upper layer
        dim.prev_format = value;
    }else{
        //Setting to default Format.
        dim.prev_format = CAMERA_YUV_420_NV21;
    }
    dim.prev_padding_format =  getPreviewPadding( );

    getVideoSize(&videoWidth,  &videoHeight);
    dim.enc_format = CAMERA_YUV_420_NV12;
    dim.orig_video_width = videoWidth;
    dim.orig_video_height = videoHeight;
    dim.video_width = videoWidth;
    dim.video_height = videoHeight;
    dim.video_chroma_width = videoWidth;
    dim.video_chroma_height  = videoHeight;

    getPictureSize(&mPictureWidth, &mPictureHeight);
    dim.picture_width = mPictureWidth;
    dim.picture_height  = mPictureHeight;

    getThumbnailSize(&thumbnailWidth,&thumbnailHeight);
    dim.ui_thumbnail_width = thumbnailWidth;
    dim.ui_thumbnail_height = thumbnailHeight;

    /* Reset the Main image and thumbnail formats here,
     * since they might have been changed when video size
     * livesnapshot was taken. */
    if (mSnapshotFormat == 1)
      dim.main_img_format = CAMERA_YUV_422_NV61;
    else
      dim.main_img_format = CAMERA_YUV_420_NV21;
    dim.thumb_format = CAMERA_YUV_420_NV21;

    //RDI Format
    dim.rdi0_format = CAMERA_BAYER_SBGGR10;

    /*Code to handle different limitations*/
    if (mRecordingHint && mFullLiveshotEnabled){
        dim.ui_thumbnail_height = dim.display_height;
        dim.ui_thumbnail_width = dim.display_width;
    }
    if (isZSLMode()){
        postviewWidth = mPreviewWidth;
        postviewHeight = mPreviewHeight;
    } else {
        postviewWidth = thumbnailWidth;
        postviewHeight = thumbnailHeight;
    }
    if (mPictureWidth < postviewWidth || mPictureHeight < postviewHeight)
    {
        //Changes to handle VFE limitation when primary o/p is main image
        dim.picture_width = postviewWidth;
        dim.picture_height = postviewHeight;
    }

    //VFE output1 shouldn't be greater than VFE output2.
    if( (dim.display_width > dim.video_width) ||
        (dim.display_height > dim.video_height)) {
        //Set preview sizes as record sizes.
        dim.display_width = dim.video_width;
        dim.display_height = dim.video_height;
    }
    if (mRecordingHint && mFullLiveshotEnabled){
        if( (dim.picture_width < dim.video_width) ||
            (dim.picture_height < dim.video_height)) {
            dim.picture_width = dim.video_width;
            dim.picture_height = dim.video_height;
        }
    }

    if(mIs3DModeOn == true) {
        /* As preview and video frames are same in 3D mode,
         * preview size should be same as video size. This
         * cahnge is needed to take of video resolutions
         * like 720P and 1080p where the application can
         * request different preview sizes like 768x432
         */
        ALOGE("3D mod is on");
        dim.display_width = dim.video_width;
        dim.display_height = dim.video_height;
    }

    /*End of limitation code*/

    ret = mCameraHandle->ops->set_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_DIMENSION,&dim);
    if (MM_CAMERA_OK != ret) {
      ALOGE("%s X: error - can't config preview parms!", __func__);
      return BAD_VALUE;
    }
    if(mStreams[MM_CAMERA_PREVIEW]) {
        mStreams[MM_CAMERA_PREVIEW]->mFormat = dim.prev_format;
        mStreams[MM_CAMERA_PREVIEW]->mWidth = dim.display_width;
        mStreams[MM_CAMERA_PREVIEW]->mHeight = dim.display_height;
    }
    if(mStreams[MM_CAMERA_VIDEO]) {
        mStreams[MM_CAMERA_VIDEO]->mFormat = dim.enc_format;
        mStreams[MM_CAMERA_VIDEO]->mWidth = dim.video_width;
        mStreams[MM_CAMERA_VIDEO]->mHeight = dim.video_height;
    }
    if(mStreams[MM_CAMERA_SNAPSHOT_MAIN]) {
        mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mFormat = dim.main_img_format;
        if (!isRawSnapshot()) {
                mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mWidth = dim.picture_width;
                mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mHeight = dim.picture_height;
        } else {
            cam_frame_resolution_t raw_res;

            /* the raw_picture_width in dimension is for RDI dump.
             * here, raw snapshot size is from camif. */
            memset(&raw_res, 0,  sizeof(raw_res));
            raw_res.image_mode = MSM_V4L2_EXT_CAPTURE_MODE_RAW;
            raw_res.padding_format = CAMERA_PAD_TO_WORD;
            ret = mCameraHandle->ops->get_parm(
               mCameraHandle->camera_handle,
               MM_CAMERA_PARM_FRAME_RESOLUTION,&raw_res);
            if (MM_CAMERA_OK != ret) {
              ALOGE("%s error - config raw snapshot parms, rc = %d",
                    __func__, ret);
              return BAD_VALUE;
            }
            mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mWidth = raw_res.width;
            mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mHeight = raw_res.height;
            mStreams[MM_CAMERA_SNAPSHOT_MAIN]->mFormat = raw_res.format;
        }
    }
    if(mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]) {
        mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->mFormat = dim.thumb_format;
        mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->mWidth = dim.ui_thumbnail_width;
        mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->mHeight = dim.ui_thumbnail_height;
    }

    memcpy(&mDimension, &dim, sizeof(mDimension));
    ALOGV("%s: X", __func__);
    return NO_ERROR;
!!!44400823.cpp!!!	setRDIMode(in params : QCameraParameters) : status_t
    char prop[PROPERTY_VALUE_MAX];
    memset(prop, 0, sizeof(prop));
    property_get("persist.camera.rdi.mode", prop, "0");
    int prop_val = atoi(prop);
    rdiMode = prop_val;
    ALOGE("RDI Mode = %d",rdiMode);
    return NO_ERROR;
!!!44400951.cpp!!!	setMobiCat(in params : QCameraParameters) : status_t
    mm_cam_mobicat_info_t mbc_info;
    char mbc_prop[PROPERTY_VALUE_MAX];
    int propval;
    memset(mbc_prop, 0, sizeof(mbc_prop));
    property_get("persist.camera.mobicat", mbc_prop, "0");
    propval = atoi(mbc_prop);
    mbc_info.enable = (mParameters.getInt("mobicat") == 1) ? 1 : 0;
    ALOGV("%s:%d] prop %d %d", __func__, __LINE__, mbc_info.enable, propval);
    mbc_info.enable |= propval;

    if (mbc_info.enable != mMobiCatEnabled) {
        ALOGV("%s:%d] enable %d", __func__, __LINE__, mbc_info.enable);
        native_set_parms(MM_CAMERA_PARM_MOBICAT, sizeof(mm_cam_mobicat_info_t),
                        (void *)&mbc_info);
         mMobiCatEnabled = mbc_info.enable;
    }
    return NO_ERROR;
!!!44401079.cpp!!!	getAutoFocusMode(in params : QCameraParameters) : isp3a_af_mode_t
  isp3a_af_mode_t afMode = AF_MODE_MAX;
  afMode = (isp3a_af_mode_t)mFocusMode;
  return afMode;
!!!44401207.cpp!!!	isValidDimension(in width : int, in height : int) : bool
    bool retVal = FALSE;
    /* This function checks if a given resolution is valid or not.
     * A particular resolution is considered valid if it satisfies
     * the following conditions:
     * 1. width & height should be multiple of 16.
     * 2. width & height should be less than/equal to the dimensions
     *    supported by the camera sensor.
     * 3. the aspect ratio is a valid aspect ratio and is among the
     *    commonly used aspect ratio as determined by the thumbnail_sizes
     *    data structure.
     */

    if( (width == CEILING16(width)) && (height == CEILING16(height))
     && (width <= maxSnapshotWidth)
    && (height <= maxSnapshotHeight) )
    {
        uint32_t pictureAspectRatio = (uint32_t)((width * Q12)/height);
        for(uint32_t i = 0; i < THUMBNAIL_SIZE_COUNT; i++ ) {
            if(thumbnail_sizes[i].aspect_ratio == pictureAspectRatio) {
                retVal = TRUE;
                break;
            }
        }
    }
    return retVal;
!!!44401335.cpp!!!	create_values_str(in values : str_map, in len : int) : String8
    String8 str;

    if (len > 0) {
        str.append(values[0].desc);
    }
    for (int i = 1; i < len; i++) {
        str.append(",");
        str.append(values[i].desc);
    }
    return str;
!!!44401463.cpp!!!	setMyMode(in mode : int) : void
    ALOGI("setMyMode: E");
    if (mode & CAMERA_SUPPORT_MODE_3D) {
        myMode = CAMERA_MODE_3D;
    }else {
        /* default mode is 2D */
        myMode = CAMERA_MODE_2D;
    }

    if (mode & CAMERA_SUPPORT_MODE_ZSL) {
        myMode = (camera_mode_t)(myMode |CAMERA_ZSL_MODE);
    }else {
       myMode = (camera_mode_t) (myMode | CAMERA_NONZSL_MODE);
    }
    ALOGI("setMyMode: Set mode to %d (passed mode: %d)", myMode, mode);
    ALOGI("setMyMode: X");
!!!44401591.cpp!!!	isZSLMode() : bool
    return (myMode & CAMERA_ZSL_MODE);
!!!44401719.cpp!!!	isWDenoiseEnabled() : bool
    return mDenoiseValue;
!!!44401847.cpp!!!	wdenoiseEvent(in status : cam_ctrl_status_t, inout cookie : void) : void

!!!44401975.cpp!!!	isLowPowerCamcorder() : bool

    if (mPowerMode == LOW_POWER)
        return true;

    if(mHFRLevel > 1) /* hard code the value now. Need to move tgtcommon to camear.h */
      return true;

      return false;
!!!44402103.cpp!!!	freePictureTable(in  : void) : void
    /* If we couldn't allocate memory to store picture table
       we use the picture table pointer to point to default
       picture table array. In that case we cannot free it.*/
    if ((mPictureSizes != default_picture_sizes) && mPictureSizes) {
        free(mPictureSizes);
    }
!!!44402231.cpp!!!	freeVideoSizeTable(in  : void) : void
    if(mVideoSizes != NULL)
    {
        free(mVideoSizes);
    }
    mVideoSizeCount = 0;
!!!44402359.cpp!!!	createPreview() : int32_t
    int32_t ret = MM_CAMERA_OK;
    ALOGV("%s : BEGIN",__func__);

    ALOGE("Mymode Preview = %d",myMode);
    mStreams[MM_CAMERA_PREVIEW] = new QCameraStream_preview(
                                        mCameraHandle->camera_handle,
                                        mChannelId,
                                        640/*Width*/,
                                        480/*Height*/,
                                        0/*Format*/,
                                        7/*NumBuffers*/,
                                        mCameraHandle,
                                        MM_CAMERA_PREVIEW,
                                        myMode,
                                        this);
    if (!mStreams[MM_CAMERA_PREVIEW]) {
        ALOGE("%s: error - can't creat preview stream!", __func__);
        return BAD_VALUE;
    }

    ALOGV("%s : END",__func__);
    return ret;
!!!44402487.cpp!!!	createRecord() : int32_t
    int32_t ret = MM_CAMERA_OK;
    ALOGV("%s : BEGIN",__func__);

    /*
    * Creating Instance of record stream.
    */
    ALOGE("Mymode Record = %d",myMode);
    mStreams[MM_CAMERA_VIDEO] = new QCameraStream_record(
                                        mCameraHandle->camera_handle,
                                        mChannelId,
                                        640/*Width*/,
                                        480/*Height*/,
                                        0/*Format*/,
                                        VIDEO_BUFFER_COUNT/*NumBuffers*/,
                                        mCameraHandle,
                                        MM_CAMERA_VIDEO,
                                        myMode,
                                        this);

    if (!mStreams[MM_CAMERA_VIDEO]) {
        ALOGE("%s: error - can't creat record stream!", __func__);
        return BAD_VALUE;
    }

    /*Init Channel */
    ALOGV("%s : END",__func__);
    return ret;
!!!44402615.cpp!!!	createSnapshot() : int32_t
    int32_t ret = MM_CAMERA_OK;
    ALOGE("%s : BEGIN",__func__);
    uint8_t NumBuffers = 1;

    if(mHdrMode) {
        ALOGE("%s mHdrMode = %d, setting NumBuffers to 3", __func__, mHdrMode);
        NumBuffers = 3;
    }

    /*
    * Creating Instance of Snapshot Main stream.
    */
    ALOGE("Mymode Snap = %d",myMode);
    ALOGE("%s : before creating an instance of SnapshotMain, num buffers = %d", __func__, NumBuffers);
    mStreams[MM_CAMERA_SNAPSHOT_MAIN] = new QCameraStream_SnapshotMain(
                                                mCameraHandle->camera_handle,
                                                mChannelId,
                                                640,
                                                480,
                                                CAMERA_YUV_420_NV21,
                                                NumBuffers,
                                                mCameraHandle,
                                                MM_CAMERA_SNAPSHOT_MAIN,
                                                myMode,
                                                this);
    if (!mStreams[MM_CAMERA_SNAPSHOT_MAIN]) {
        ALOGE("%s: error - can't creat snapshot stream!", __func__);
        return BAD_VALUE;
    }

    /*
     * Creating Instance of Snapshot Thumb stream.
    */
    ALOGE("Mymode Snap = %d",myMode);
    mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL] = new QCameraStream_SnapshotThumbnail(
                                                    mCameraHandle->camera_handle,
                                                    mChannelId,
                                                    512,
                                                    384,
                                                    CAMERA_YUV_420_NV21,
                                                    NumBuffers,
                                                    mCameraHandle,
                                                    MM_CAMERA_SNAPSHOT_THUMBNAIL,
                                                    myMode,
                                                    this);
    if (!mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]) {
        ALOGE("%s: error - can't creat snapshot stream!", __func__);
        return BAD_VALUE;
    }

    ALOGV("%s : END",__func__);
    return ret;
!!!44402743.cpp!!!	createRdi() : int32_t
    int32_t ret = MM_CAMERA_OK;
    ALOGV("%s : BEGIN",__func__);
    mStreams[MM_CAMERA_RDI] = new QCameraStream_Rdi(mCameraHandle->camera_handle,
                                                    mChannelId,
                                                    640/*Width*/,
                                                    480/*Height*/,
                                                    CAMERA_BAYER_SBGGR10/*Format*/,
                                                    PREVIEW_BUFFER_COUNT/*NumBuffers*/,
                                                    mCameraHandle,
                                                    MM_CAMERA_RDI,
                                                    myMode,
                                                    this);
    if (!mStreams[MM_CAMERA_RDI]) {
        ALOGE("%s: error - can't creat RDI stream!", __func__);
        return BAD_VALUE;
    }

    ALOGV("%s : END",__func__);
    return ret;
!!!44402871.cpp!!!	getHDRMode() : int
    ALOGE("%s, mHdrMode = %d", __func__, mHdrMode);
    return mHdrMode;
!!!44402999.cpp!!!	addExifTag(in tagid : exif_tag_id_t, in type : exif_tag_type_t, in count : uint32_t, in copy : uint8_t, inout data : void) : void

    if(mExifTableNumEntries >= MAX_EXIF_TABLE_ENTRIES) {
        ALOGE("%s: Number of entries exceeded limit", __func__);
        return;
    }
    int index = mExifTableNumEntries;
    mExifData[index].tag_id = tagid;
    mExifData[index].tag_entry.type = type;
    mExifData[index].tag_entry.count = count;
    mExifData[index].tag_entry.copy = copy;
    if((type == EXIF_RATIONAL) && (count > 1))
        mExifData[index].tag_entry.data._rats = (rat_t *)data;
    if((type == EXIF_RATIONAL) && (count == 1))
        mExifData[index].tag_entry.data._rat = *(rat_t *)data;
    else if(type == EXIF_ASCII)
        mExifData[index].tag_entry.data._ascii = (char *)data;
    else if(type == EXIF_BYTE)
        mExifData[index].tag_entry.data._byte = *(uint8_t *)data;
    else if((type == EXIF_SHORT) && (count > 1))
        mExifData[index].tag_entry.data._shorts = (uint16_t *)data;
    else if((type == EXIF_SHORT) && (count == 1))
        mExifData[index].tag_entry.data._short = *(uint16_t *)data;
    // Increase number of entries
    mExifTableNumEntries++;
!!!44403127.cpp!!!	setExifTags() : void
    const char *str;

    //set TimeStamp
    str = mParameters.get(QCameraParameters::KEY_QC_EXIF_DATETIME);
    if(str != NULL) {
      strncpy(mExifValues.dateTime, str, 19);
      mExifValues.dateTime[19] = '\0';
    }

    //Set focal length
    int focalLengthValue = (int) (mParameters.getFloat(
                QCameraParameters::KEY_FOCAL_LENGTH) * FOCAL_LENGTH_DECIMAL_PRECISION);

    mExifValues.focalLength = getRational(focalLengthValue, FOCAL_LENGTH_DECIMAL_PRECISION);

    //Set ISO Speed
    mExifValues.isoSpeed = getISOSpeedValue();

    //get time and date from system
    time_t rawtime;
    struct tm * timeinfo;
    time(&rawtime);
    timeinfo = localtime (&rawtime);
    //Write datetime according to EXIF Spec
    //"YYYY:MM:DD HH:MM:SS" (20 chars including \0)
    snprintf(mExifValues.dateTime, 20, "%04d:%02d:%02d %02d:%02d:%02d",
                timeinfo->tm_year + 1900, timeinfo->tm_mon + 1,
                timeinfo->tm_mday, timeinfo->tm_hour,
                timeinfo->tm_min, timeinfo->tm_sec);

    //set gps tags
    setExifTagsGPS();
!!!44403255.cpp!!!	initExifData() : void
    if(mExifValues.dateTime) {
        addExifTag(EXIFTAGID_EXIF_DATE_TIME_ORIGINAL, EXIF_ASCII,
                  20, 1, (void *)mExifValues.dateTime);
    }
    addExifTag(EXIFTAGID_FOCAL_LENGTH, EXIF_RATIONAL, 1, 1, (void *)&(mExifValues.focalLength));
    addExifTag(EXIFTAGID_ISO_SPEED_RATING,EXIF_SHORT,1,1,(void *)&(mExifValues.isoSpeed));

    if(mExifValues.mGpsProcess) {
        addExifTag(EXIFTAGID_GPS_PROCESSINGMETHOD, EXIF_ASCII,
           EXIF_ASCII_PREFIX_SIZE + strlen(mExifValues.gpsProcessingMethod + EXIF_ASCII_PREFIX_SIZE) + 1,
           1, (void *)mExifValues.gpsProcessingMethod);
    }

    if(mExifValues.mLatitude) {
        addExifTag(EXIFTAGID_GPS_LATITUDE, EXIF_RATIONAL, 3, 1, (void *)mExifValues.latitude);

        if(mExifValues.latRef) {
            addExifTag(EXIFTAGID_GPS_LATITUDE_REF, EXIF_ASCII, 2,
                                    1, (void *)mExifValues.latRef);
        }
    }

    if(mExifValues.mLongitude) {
        addExifTag(EXIFTAGID_GPS_LONGITUDE, EXIF_RATIONAL, 3, 1, (void *)mExifValues.longitude);

        if(mExifValues.lonRef) {
            addExifTag(EXIFTAGID_GPS_LONGITUDE_REF, EXIF_ASCII, 2,
                                1, (void *)mExifValues.lonRef);
        }
    }

    if(mExifValues.mAltitude) {
        addExifTag(EXIFTAGID_GPS_ALTITUDE, EXIF_RATIONAL, 1,
                    1, (void *)&(mExifValues.altitude));

        addExifTag(EXIFTAGID_GPS_ALTITUDE_REF, EXIF_BYTE, 1, 1, (void *)&mExifValues.mAltitude_ref);
    }

    if(mExifValues.mTimeStamp) {
        time_t unixTime;
        struct tm *UTCTimestamp;

        unixTime = (time_t)mExifValues.mGPSTimestamp;
        UTCTimestamp = gmtime(&unixTime);

        strftime(mExifValues.gpsDateStamp, sizeof(mExifValues.gpsDateStamp), "%Y:%m:%d", UTCTimestamp);
        addExifTag(EXIFTAGID_GPS_DATESTAMP, EXIF_ASCII,
                          strlen(mExifValues.gpsDateStamp)+1 , 1, (void *)mExifValues.gpsDateStamp);

        mExifValues.gpsTimeStamp[0] = getRational(UTCTimestamp->tm_hour, 1);
        mExifValues.gpsTimeStamp[1] = getRational(UTCTimestamp->tm_min, 1);
        mExifValues.gpsTimeStamp[2] = getRational(UTCTimestamp->tm_sec, 1);

        addExifTag(EXIFTAGID_GPS_TIMESTAMP, EXIF_RATIONAL,
                  3, 1, (void *)mExifValues.gpsTimeStamp);
        ALOGE("EXIFTAGID_GPS_TIMESTAMP set");
    }

!!!44403383.cpp!!!	deinitExifData() : void
    ALOGD("Clearing EXIF data");
    memset(mExifData, 0, sizeof(exif_tags_info_t) * MAX_EXIF_TABLE_ENTRIES);
    mExifTableNumEntries = 0;
!!!44403511.cpp!!!	setExifTagsGPS() : void
    const char *str = NULL;

    //Set GPS processing method
    str = mParameters.get(QCameraParameters::KEY_GPS_PROCESSING_METHOD);
    if(str != NULL) {
       memcpy(mExifValues.gpsProcessingMethod, ExifAsciiPrefix, EXIF_ASCII_PREFIX_SIZE);
       strncpy(mExifValues.gpsProcessingMethod + EXIF_ASCII_PREFIX_SIZE, str,
           GPS_PROCESSING_METHOD_SIZE - 1);
       mExifValues.gpsProcessingMethod[EXIF_ASCII_PREFIX_SIZE + GPS_PROCESSING_METHOD_SIZE-1] = '\0';
       ALOGE("EXIFTAGID_GPS_PROCESSINGMETHOD = %s %s", mExifValues.gpsProcessingMethod,
                                                    mExifValues.gpsProcessingMethod+8);
       mExifValues.mGpsProcess  = true;
    }else{
        mExifValues.mGpsProcess = false;
    }
    str = NULL;

    //Set Latitude
    str = mParameters.get(QCameraParameters::KEY_GPS_LATITUDE);
    if(str != NULL) {
        parseGPSCoordinate(str, mExifValues.latitude);
        ALOGE("EXIFTAGID_GPS_LATITUDE = %s", str);

        //set Latitude Ref
        float latitudeValue = mParameters.getFloat(QCameraParameters::KEY_GPS_LATITUDE);
        if(latitudeValue < 0.0f) {
            mExifValues.latRef[0] = 'S';
        } else {
            mExifValues.latRef[0] = 'N';
        }
        mExifValues.latRef[1] = '\0';
        mExifValues.mLatitude = true;
        mParameters.set(QCameraParameters::KEY_QC_GPS_LATITUDE_REF,mExifValues.latRef);
        ALOGE("EXIFTAGID_GPS_LATITUDE_REF = %s", mExifValues.latRef);
    }else{
        mExifValues.mLatitude = false;
    }

    //set Longitude
    str = NULL;
    str = mParameters.get(QCameraParameters::KEY_GPS_LONGITUDE);
    if(str != NULL) {
        parseGPSCoordinate(str, mExifValues.longitude);
        ALOGE("EXIFTAGID_GPS_LONGITUDE = %s", str);

        //set Longitude Ref
        float longitudeValue = mParameters.getFloat(QCameraParameters::KEY_GPS_LONGITUDE);
        if(longitudeValue < 0.0f) {
            mExifValues.lonRef[0] = 'W';
        } else {
            mExifValues.lonRef[0] = 'E';
        }
        mExifValues.lonRef[1] = '\0';
        mExifValues.mLongitude = true;
        ALOGE("EXIFTAGID_GPS_LONGITUDE_REF = %s", mExifValues.lonRef);
        mParameters.set(QCameraParameters::KEY_QC_GPS_LONGITUDE_REF, mExifValues.lonRef);
    }else{
        mExifValues.mLongitude = false;
    }

    //set Altitude
    str = mParameters.get(QCameraParameters::KEY_GPS_ALTITUDE);
    if(str != NULL) {
        double value = atof(str);
        mExifValues.mAltitude_ref = 0;
        if(value < 0){
            mExifValues.mAltitude_ref = 1;
            value = -value;
        }
        mExifValues.altitude = getRational(value*1000, 1000);
        mExifValues.mAltitude = true;
        //set AltitudeRef
        mParameters.set(QCameraParameters::KEY_QC_GPS_ALTITUDE_REF, mExifValues.mAltitude_ref);
        ALOGE("EXIFTAGID_GPS_ALTITUDE = %f", value);
    }else{
        mExifValues.mAltitude = false;
    }

    //set Gps TimeStamp
    str = NULL;
    str = mParameters.get(QCameraParameters::KEY_GPS_TIMESTAMP);
    if(str != NULL) {
      mExifValues.mTimeStamp = true;
      mExifValues.mGPSTimestamp = atol(str);
    }else{
         mExifValues.mTimeStamp = false;
    }
!!!44403895.cpp!!!	parseGPSCoordinate(in latlonString : char, inout coord : rat_t) : void
    if(coord == NULL) {
        ALOGE("%s: error, invalid argument coord == NULL", __func__);
        return;
    }
    float degF = fabs(atof(latlonString));
    float minF = (degF- (int) degF) * 60;
    float secF = (minF - (int) minF) * 60;

    coord[0] = getRational((int) degF, 1);
    coord[1] = getRational((int) minF, 1);
    coord[2] = getRational((int) (secF * 10000), 10000);
!!!44404023.cpp!!!	getHdrInfoAndSetExp(in max_num_frm : int, inout num_frame : int, inout exp : int) : bool
    bool rc = FALSE;
    ALOGE("%s, mHdrMode = %d, HDR_MODE = %d", __func__, mHdrMode, HDR_MODE);
    if (mHdrMode == HDR_MODE && num_frame != NULL && exp != NULL &&
        mRecordingHint != TRUE &&
        mPreviewState != QCAMERA_HAL_RECORDING_STARTED ) {
        ALOGE("%s : mHdrMode == HDR_MODE", __func__);
        int ret = 0;
        *num_frame = 1;
        exp_bracketing_t temp;
        memset(&temp, 0, sizeof(exp_bracketing_t));
        ret = mCameraHandle->ops->get_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_HDR, (void *)&temp );
        ALOGE("hdr - %s : ret = %d", __func__, ret);
        if (ret == NO_ERROR && max_num_frm > 0) {
            ALOGE("%s ret == NO_ERROR and max_num_frm = %d", __func__, max_num_frm);
            /*set as AE Bracketing mode*/
            temp.hdr_enable = FALSE;
            temp.mode = HDR_MODE;
            temp.total_hal_frames = temp.total_frames;
            ret = native_set_parms(MM_CAMERA_PARM_HDR,
                                   sizeof(exp_bracketing_t), (void *)&temp);
            ALOGE("%s, ret from set_parm = %d", __func__, ret);
            if (ret) {
                char *val, *exp_value, *prev_value;
                int i;
                exp_value = (char *) temp.values;
                i = 0;
                val = strtok_r(exp_value,",", &prev_value);
                while (val != NULL ){
                    exp[i++] = atoi(val);
                    if(i >= max_num_frm )
                        break;
                    val = strtok_r(NULL, ",", &prev_value);
                }
                *num_frame =temp.total_frames;
                rc = TRUE;
            }
        } else {
            temp.total_frames = 1;
        }
        /* Application waits until this many snapshots before restarting preview */
        mParameters.set("num-snaps-per-shutter", 2);
    }
    ALOGE("%s, hdr - rc = %d, num_frame = %d", __func__, rc, *num_frame);
    return rc;
!!!44404151.cpp!!!	initHistogramBuffers() : status_t
    int page_size_minus_1 = getpagesize() - 1;
    int statSize = sizeof (camera_preview_histogram_info );
    int32_t mAlignedStatSize = ((statSize + page_size_minus_1)
                                & (~page_size_minus_1));
    mm_camera_frame_map_type map_buf;
    ALOGI("%s E ", __func__);

    if (mHistServer.active) {
        ALOGI("%s Previous buffers not deallocated yet. ", __func__);
        return BAD_VALUE;
    }

    mStatSize = sizeof(uint32_t) * HISTOGRAM_STATS_SIZE;
    mCurrentHisto = -1;

    memset(&map_buf, 0, sizeof(map_buf));
    for(int cnt = 0; cnt < NUM_HISTOGRAM_BUFFERS; cnt++) {
        mStatsMapped[cnt] = mGetMemory(-1, mStatSize, 1, mCallbackCookie);
        if(mStatsMapped[cnt] == NULL) {
            ALOGE("Failed to get camera memory for stats heap index: %d", cnt);
            return NO_MEMORY;
        } else {
           ALOGI("Received following info for stats mapped data:%p,handle:%p,"
                 " size:%d,release:%p", mStatsMapped[cnt]->data,
                 mStatsMapped[cnt]->handle, mStatsMapped[cnt]->size,
                 mStatsMapped[cnt]->release);
        }
        mHistServer.mem_info[cnt].size = sizeof(camera_preview_histogram_info);
#ifdef USE_ION
        int flag = (0x1 << ION_CP_MM_HEAP_ID | 0x1 << ION_IOMMU_HEAP_ID);
        if(allocate_ion_memory(&mHistServer.mem_info[cnt], flag) < 0) {
            ALOGE("%s ION alloc failed for %d\n", __func__, cnt);
            return NO_MEMORY;
        }
#else
        mHistServer.mem_info[cnt].fd = open("/dev/pmem_adsp", O_RDWR|O_SYNC);
        if(mHistServer.mem_info[cnt].fd <= 0) {
            ALOGE("%s: no pmem for frame %d", __func__, cnt);
            return NO_INIT;
        }
#endif
        mHistServer.camera_memory[cnt] = mGetMemory(mHistServer.mem_info[cnt].fd,
                                                    mHistServer.mem_info[cnt].size,
                                                    1,
                                                    mCallbackCookie);
        if(mHistServer.camera_memory[cnt] == NULL) {
            ALOGE("Failed to get camera memory for server side "
                  "histogram index: %d", cnt);
            return NO_MEMORY;
        } else {
            ALOGE("Received following info for server side histogram data:%p,"
                  " handle:%p, size:%d,release:%p",
                  mHistServer.camera_memory[cnt]->data,
                  mHistServer.camera_memory[cnt]->handle,
                  mHistServer.camera_memory[cnt]->size,
                  mHistServer.camera_memory[cnt]->release);
        }
        /*Register buffer at back-end*/
        map_buf.fd = mHistServer.mem_info[cnt].fd;
        map_buf.frame_idx = cnt;
        map_buf.size = mHistServer.mem_info[cnt].size;
        map_buf.ext_mode = 0;
        map_buf.is_hist = TRUE;
        mCameraHandle->ops->send_command(mCameraHandle->camera_handle,
                                         MM_CAMERA_CMD_TYPE_NATIVE,
                                         NATIVE_CMD_ID_SOCKET_MAP,
                                         sizeof(map_buf), &map_buf);
    }
    mHistServer.active = TRUE;
    ALOGI("%s X", __func__);
    return NO_ERROR;
!!!44404279.cpp!!!	deInitHistogramBuffers() : status_t
    mm_camera_frame_unmap_type unmap_buf;
    memset(&unmap_buf, 0, sizeof(unmap_buf));

    ALOGI("%s E", __func__);

    if (!mHistServer.active) {
        ALOGI("%s Histogram buffers not active. return. ", __func__);
        return NO_ERROR;
    }

    //release memory
    for(int i = 0; i < NUM_HISTOGRAM_BUFFERS; i++) {
        if(mStatsMapped[i] != NULL) {
            mStatsMapped[i]->release(mStatsMapped[i]);
        }

        unmap_buf.ext_mode = 0;
        unmap_buf.frame_idx = i;
        unmap_buf.is_hist = TRUE;
        mCameraHandle->ops->send_command(mCameraHandle->camera_handle,
                                         MM_CAMERA_CMD_TYPE_NATIVE,
                                         NATIVE_CMD_ID_SOCKET_UNMAP,
                                         sizeof(unmap_buf), &unmap_buf);

        if(mHistServer.camera_memory[i] != NULL) {
            mHistServer.camera_memory[i]->release(mHistServer.camera_memory[i]);
        }
#ifdef USE_ION
        deallocate_ion_memory(&mHistServer.mem_info[i]);
#endif
    }
    mHistServer.active = FALSE;
    ALOGI("%s X", __func__);
    return NO_ERROR;
!!!44404407.cpp!!!	getColorfmtFromImgFmt(in img_fmt : uint32_t) : mm_jpeg_color_format
    switch (img_fmt) {
    case CAMERA_YUV_420_NV21:
        return MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2;
    case CAMERA_YUV_420_NV21_ADRENO:
        return MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2;
    case CAMERA_YUV_420_NV12:
        return MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V2;
    case CAMERA_YUV_420_YV12:
        return MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V2;
    case CAMERA_YUV_422_NV61:
        return MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V1;
    case CAMERA_YUV_422_NV16:
        return MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V1;
    default:
        return MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2;
    }
!!!44404535.cpp!!!	notifyHdrEvent(in status : cam_ctrl_status_t, inout cookie : void) : void
    ALOGE("%s E", __func__);
    mm_camera_super_buf_t *frame;
    int i;
    ALOGI("%s: HDR Done status (%d) received",__func__,status);
    for (i = 0; i < 2; i++) {
        frame = mHdrInfo.recvd_frame[i];
        mSuperBufQueue.enqueue(frame);
        /* notify dataNotify thread that new super buf is avail
        * check if it's done with current JPEG notification and
        * a new encoding job could be conducted */
        mNotifyTh->sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);
        mHdrInfo.recvd_frame[i] = NULL;
    }
    /* qbuf the third frame */
    frame = mHdrInfo.recvd_frame[2];
    for(i = 0; i < frame->num_bufs; i++) {
        mCameraHandle->ops->qbuf(frame->camera_handle,
                                 frame->ch_id,
                                 frame->bufs[i]);
        cache_ops((QCameraHalMemInfo_t *)(frame->bufs[i]->mem_info),
                  frame->bufs[i]->buffer,
                  ION_IOC_INV_CACHES);
    }
    free(frame);
    mHdrInfo.recvd_frame[2] = NULL;

    ALOGE("%s X", __func__);
!!!44404663.cpp!!!	initHdrInfoForSnapshot(in Hdr_on : bool, in number_frames : int, inout exp : int) : void
    ALOGE("%s E hdr_on = %d", __func__, Hdr_on);
    mHdrInfo.hdr_on = Hdr_on;
    mHdrInfo.num_frame = number_frames;
    mHdrInfo.num_raw_received = 0;
    if(number_frames) {
        memcpy(mHdrInfo.exp, exp, sizeof(int)*number_frames);
    }
    memset(mHdrInfo.recvd_frame, 0,
           sizeof(mm_camera_super_buf_t *)*MAX_HDR_EXP_FRAME_NUM);
    ALOGE("%s X", __func__);
!!!44404791.cpp!!!	doHdrProcessing() : void
    cam_sock_packet_t packet;
    int i;
    memset(&packet, 0, sizeof(cam_sock_packet_t));
    packet.msg_type = CAM_SOCK_MSG_TYPE_HDR_START;

    packet.payload.hdr_pkg.cookie = (long unsigned int) this;
    packet.payload.hdr_pkg.num_hdr_frames = mHdrInfo.num_frame;
    ALOGI("%s num frames = %d ", __func__, mHdrInfo.num_frame);
    for (i = 0; i < mHdrInfo.num_frame; i++) {
        packet.payload.hdr_pkg.hdr_main_idx[i] =
            mHdrInfo.recvd_frame[i]->bufs[0]->buf_idx;
        packet.payload.hdr_pkg.hdr_thm_idx[i] =
            mHdrInfo.recvd_frame[i]->bufs[1]->buf_idx;
        packet.payload.hdr_pkg.exp[i] = mHdrInfo.exp[i];
        ALOGI("%s Adding buffer M %d T %d Exp %d into hdr pkg ", __func__,
              packet.payload.hdr_pkg.hdr_main_idx[i],
              packet.payload.hdr_pkg.hdr_thm_idx[i],
              packet.payload.hdr_pkg.exp[i]);
    }
    mCameraHandle->ops->send_command(mCameraHandle->camera_handle,
                                  MM_CAMERA_CMD_TYPE_NATIVE,
                                  NATIVE_CMD_ID_IOCTL_CTRL,
                                  sizeof(cam_sock_packet_t), &packet);
!!!44404919.cpp!!!	stream_cb_routine(inout bufs : mm_camera_super_buf_t, inout userdata : void) : void
    ALOGE("%s E ", __func__);
    QCameraStream *p_obj=(QCameraStream*) userdata;
    ALOGE("DEBUG4:ExtMode:%d,streamid:%d",p_obj->mExtImgMode,bufs->bufs[0]->stream_id);
    switch(p_obj->mExtImgMode) {
    case MM_CAMERA_PREVIEW:
        ALOGE("%s : callback for MM_CAMERA_PREVIEW", __func__);
        ((QCameraStream_preview *)p_obj)->dataCallback(bufs);
        break;
    case MM_CAMERA_VIDEO:
        ALOGE("%s : callback for MM_CAMERA_VIDEO", __func__);
        ((QCameraStream_preview *)p_obj)->dataCallback(bufs);
        break;
    case MM_CAMERA_SNAPSHOT_MAIN:
#if 0
                if(p_obj->mHalCamCtrl->getHDRMode()) {
                    ALOGE("%s: Skipping Q Buf for HDR mode",__func__);
                    break;
                }
#endif

                ALOGE("%s : callback for MM_CAMERA_SNAPSHOT_MAIN", __func__);
                p_obj->p_mm_ops->ops->qbuf(p_obj->mCameraHandle,
                                           p_obj->mChannelId,
                                           bufs->bufs[0]);
                break;
         case MM_CAMERA_SNAPSHOT_THUMBNAIL:
                break;
         default:
                break;
    
    }
    ALOGE("%s X ", __func__);
!!!44405047.cpp!!!	dataNotifyRoutine(inout data : void) : void
    int running = 1;
    int ret;
    QCameraHardwareInterface *pme = (QCameraHardwareInterface *)data;
    QCameraCmdThread *cmdThread = pme->mNotifyTh;
    uint8_t isEncoding = FALSE;
    uint8_t isActive = FALSE;
    uint32_t numOfSnapshotExpected = 0;
    uint32_t numOfSnapshotRcvd = 0;

    ALOGD("%s: E", __func__);
    do {
        do {
            ret = sem_wait(&cmdThread->cmd_sem);
            if (ret != 0 && errno != EINVAL) {
                ALOGE("%s: sem_wait error (%s)",
                           __func__, strerror(errno));
                return NULL;
            }
        } while (ret != 0);

        /* we got notified about new cmd avail in cmd queue */
        camera_cmd_type_t cmd = cmdThread->getCmd();
        ALOGD("%s: get cmd %d", __func__, cmd);
        switch (cmd) {
        case CAMERA_CMD_TYPE_START_DATA_PROC:
            isActive = TRUE;
            /* init flag to FALSE */
            isEncoding = FALSE;
            numOfSnapshotExpected = pme->getNumOfSnapshots();
            numOfSnapshotRcvd = 0;
            break;
        case CAMERA_CMD_TYPE_STOP_DATA_PROC:
            /* flush jpeg data queue */
            pme->mNotifyDataQueue.flush();

            isActive = FALSE;
            /* set flag to FALSE */
            isEncoding = FALSE;
            numOfSnapshotExpected = 0;
            numOfSnapshotRcvd = 0;
            break;
        case CAMERA_CMD_TYPE_DO_NEXT_JOB:
            {
                if (TRUE == isActive) {
                    /* first check if there is any pending jpeg notify */
                    app_notify_cb_t *app_cb =
                        (app_notify_cb_t *)pme->mNotifyDataQueue.dequeue();
                    if (NULL != app_cb) {
                        /* send notify to upper layer */
                        if (app_cb->notifyCb) {
                            ALOGE("%s: evt notify cb", __func__);
                            app_cb->notifyCb(app_cb->argm_notify.msg_type,
                                             app_cb->argm_notify.ext1,
                                             app_cb->argm_notify.ext2,
                                             app_cb->argm_notify.cookie);
                        }
                        if (app_cb->dataCb) {
                            ALOGE("%s: data notify cb", __func__);
                            app_cb->dataCb(app_cb->argm_data_cb.msg_type,
                                           app_cb->argm_data_cb.data,
                                           app_cb->argm_data_cb.index,
                                           app_cb->argm_data_cb.metadata,
                                           app_cb->argm_data_cb.cookie);
                            if (CAMERA_MSG_COMPRESSED_IMAGE == app_cb->argm_data_cb.msg_type) {
                                numOfSnapshotRcvd++;
                                isEncoding = FALSE;
                            }
                        }

                        /* free app_cb */
                        pme->releaseAppCBData(app_cb);
                        free(app_cb);
                    }

                    if ((FALSE == isEncoding) && !pme->mSuperBufQueue.is_empty()) {
                        isEncoding = TRUE;
                        /* notify processData thread to do next encoding job */
                        pme->mDataProcTh->sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);
                    }

                    if (numOfSnapshotExpected > 0 &&
                        numOfSnapshotExpected == numOfSnapshotRcvd) {
                        pme->cancelPictureInternal();
                    }
                } else {
                    /* do no op if not active */
                    app_notify_cb_t *app_cb =
                        (app_notify_cb_t *)pme->mNotifyDataQueue.dequeue();
                    if (NULL != app_cb) {
                        /* free app_cb */
                        pme->releaseAppCBData(app_cb);
                        free(app_cb);
                    }
                }
            }
            break;
        case CAMERA_CMD_TYPE_EXIT:
            {
                /* flush jpeg data queue */
                pme->mNotifyDataQueue.flush();
                running = 0;
            }
            break;
        default:
            break;
        }
    } while (running);
    ALOGD("%s: X", __func__);
    return NULL;
!!!44405175.cpp!!!	dataProcessRoutine(inout data : void) : void
    int running = 1;
    int ret;
    uint8_t is_active = FALSE;
    QCameraHardwareInterface *pme = (QCameraHardwareInterface *)data;
    QCameraCmdThread *cmdThread = pme->mDataProcTh;
    uint32_t current_jobId = 0;

    ALOGD("%s: E", __func__);
    do {
        do {
            ret = sem_wait(&cmdThread->cmd_sem);
            if (ret != 0 && errno != EINVAL) {
                ALOGE("%s: sem_wait error (%s)",
                           __func__, strerror(errno));
                return NULL;
            }
        } while (ret != 0);

        /* we got notified about new cmd avail in cmd queue */
        camera_cmd_type_t cmd = cmdThread->getCmd();
        ALOGD("%s: get cmd %d", __func__, cmd);
        switch (cmd) {
        case CAMERA_CMD_TYPE_START_DATA_PROC:
            is_active = TRUE;
            break;
        case CAMERA_CMD_TYPE_STOP_DATA_PROC:
            {
                is_active = FALSE;
                /* abort current job if it's running */
                if (current_jobId > 0) {
                    pme->mJpegHandle.abort_job(pme->mJpegClientHandle, current_jobId);
                    current_jobId = 0;
                }
                /* flush superBufQueue */
                pme->mSuperBufQueue.flush();
                /* signal cmd is completed */
                sem_post(&cmdThread->sync_sem);
            }
            break;
        case CAMERA_CMD_TYPE_DO_NEXT_JOB:
            {
                ALOGD("%s: active is %d", __func__, is_active);
                if (is_active == TRUE) {
                    /* first check if there is any pending jpeg notify */
                    mm_camera_super_buf_t *super_buf =
                        (mm_camera_super_buf_t *)pme->mSuperBufQueue.dequeue();
                    if (NULL != super_buf) {
                        //play shutter sound
                        if(!pme->mShutterSoundPlayed){
                            pme->notifyShutter(true);
                        }
                        pme->notifyShutter(false);
                        pme->mShutterSoundPlayed = false;

                        if (pme->isRawSnapshot()) {
                            receiveRawPicture(super_buf, pme);

                            /*free superbuf*/
                            pme->releaseSuperBuf(super_buf);
                            free(super_buf);
                        } else{
                            ret = pme->encodeData(super_buf, &current_jobId);

                             if (NO_ERROR != ret) {
                                 pme->releaseSuperBuf(super_buf);
                                 free(super_buf);
                                 pme->sendDataNotify(CAMERA_MSG_COMPRESSED_IMAGE,
                                                     NULL,
                                                     0,
                                                     NULL,
                                                     NULL);
                             }
                        }
                    }
                } else {
                    /* not active, simply return buf and do no op */
                    mm_camera_super_buf_t *super_buf =
                        (mm_camera_super_buf_t *)pme->mSuperBufQueue.dequeue();
                    if (NULL != super_buf) {
                        pme->releaseSuperBuf(super_buf);
                        free(super_buf);
                    }
                }
            }
            break;
        case CAMERA_CMD_TYPE_EXIT:
            /* abort current job if it's running */
            if (current_jobId > 0) {
                pme->mJpegHandle.abort_job(pme->mJpegClientHandle, current_jobId);
                current_jobId = 0;
            }
            /* flush super buf queue */
            pme->mSuperBufQueue.flush();
            running = 0;
            break;
        default:
            break;
        }
    } while (running);
    ALOGD("%s: X", __func__);
    return NULL;
!!!44405303.cpp!!!	snapshot_jpeg_cb(in status : jpeg_job_status_t, in thumbnailDroppedFlag : uint8_t, in client_hdl : uint32_t, in jobId : uint32_t, inout out_data : uint8_t, in data_size : uint32_t, inout userdata : void) : void
    ALOGE("%s: E", __func__);
    camera_jpeg_encode_cookie_t *cookie =
        (camera_jpeg_encode_cookie_t *)userdata;
    if(cookie == NULL){
       ALOGE("%s: userdata is null", __func__);
       return;
    }
    QCameraHardwareInterface *pme = (QCameraHardwareInterface *)cookie->userdata;
    if(pme == NULL){
       ALOGE("%s: pme is null", __func__);
       return;
    }

    /* no use of src frames, return them to kernel */
    for(int i = 0; i< cookie->src_frame->num_bufs; i++) {
        if (cookie->src_frame->bufs[i]->p_mobicat_info) {
            free(cookie->src_frame->bufs[i]->p_mobicat_info);
            cookie->src_frame->bufs[i]->p_mobicat_info = NULL;
        }
        pme->mCameraHandle->ops->qbuf(cookie->src_frame->camera_handle,
                                      cookie->src_frame->ch_id,
                                      cookie->src_frame->bufs[i]);
        pme->cache_ops((QCameraHalMemInfo_t *)(cookie->src_frame->bufs[i]->mem_info),
                      cookie->src_frame->bufs[i]->buffer,
                      ION_IOC_INV_CACHES);
    }
    free(cookie->src_frame);
    cookie->src_frame = NULL;

    receiveCompleteJpegPicture(status,
                               thumbnailDroppedFlag,
                               client_hdl,
                               jobId,
                               out_data,
                               data_size,
                               pme);

    /* free sink frame */
    free(out_data);
    /* free cookie */
    free(cookie);

    ALOGE("%s: X", __func__);
!!!44405431.cpp!!!	receiveCompleteJpegPicture(in status : jpeg_job_status_t, in thumbnailDroppedFlag : uint8_t, in client_hdl : uint32_t, in jobId : uint32_t, inout out_data : uint8_t, in data_size : uint32_t, inout pme : QCameraHardwareInterface) : void
    status_t rc = NO_ERROR;
    ALOGE("%s: E", __func__);

    pme->deinitExifData();

    if(status == JPEG_JOB_STATUS_ERROR) {
        ALOGE("Error event handled from jpeg");
        if(pme->mDataCb && (pme->mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)){
            pme->sendDataNotify(CAMERA_MSG_COMPRESSED_IMAGE,
                                NULL,
                                0,
                                NULL,
                                NULL);
        }
        return;
    }

    if(thumbnailDroppedFlag) {
        ALOGE("%s : Error in thumbnail encoding, no ops here", __func__);
    }

    pme->dumpFrameToFile(out_data,
                         data_size,
                         (char *)"debug",
                         (char *)"jpg",
                         jobId);

    ALOGE("%s: jpeg_size=%d", __func__, data_size);

    if(pme->mDataCb && (pme->mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)){
        if (pme->initHeapMem(&pme->mJpegMemory,
                             1,
                             data_size,
                             MSM_PMEM_MAX,
                             NULL,
                             NULL) < 0) {
            ALOGE("%s : initHeapMem for jpeg, ret = NO_MEMORY", __func__);
            if(pme->mDataCb && (pme->mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)){
                pme->sendDataNotify(CAMERA_MSG_COMPRESSED_IMAGE,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL);
            }
            return;
        }

        memcpy(pme->mJpegMemory.camera_memory[0]->data, out_data, data_size);

        ALOGE("%s : Calling upperlayer callback to store JPEG image", __func__);
        rc = pme->sendDataNotify(CAMERA_MSG_COMPRESSED_IMAGE,
                                 pme->mJpegMemory.camera_memory[0],
                                 0,
                                 NULL,
                                 &pme->mJpegMemory);
        if (rc != NO_ERROR) {
            pme->releaseHeapMem(&pme->mJpegMemory);
        }
    }

    ALOGE("%s: X", __func__);
!!!44405559.cpp!!!	superbuf_cb_routine(inout recvd_frame : mm_camera_super_buf_t, inout userdata : void) : void
    ALOGE("%s: E",__func__);
    QCameraHardwareInterface *pme = (QCameraHardwareInterface *)userdata;
    if(pme == NULL){
       ALOGE("%s: pme is null", __func__);
       return;
    }

    mm_camera_super_buf_t* frame =
           (mm_camera_super_buf_t *)malloc(sizeof(mm_camera_super_buf_t));
    if (frame == NULL) {
        ALOGE("%s: Error allocating memory to save received_frame structure.", __func__);
        for (int i=0; i<recvd_frame->num_bufs; i++) {
             if (recvd_frame->bufs[i] != NULL) {
                 if (recvd_frame->bufs[i]->p_mobicat_info) {
                    free(recvd_frame->bufs[i]->p_mobicat_info);
                    recvd_frame->bufs[i]->p_mobicat_info = NULL;
                 }
                 pme->mCameraHandle->ops->qbuf(recvd_frame->camera_handle,
                                               recvd_frame->ch_id,
                                               recvd_frame->bufs[i]);
                 pme->cache_ops((QCameraHalMemInfo_t *)(recvd_frame->bufs[i]->mem_info),
                                recvd_frame->bufs[i]->buffer,
                                ION_IOC_INV_CACHES);
             }
        }
        return;
    }
    memcpy(frame, recvd_frame, sizeof(mm_camera_super_buf_t));
    if(pme->mHdrInfo.hdr_on) {
        pme->mHdrInfo.recvd_frame[pme->mHdrInfo.num_raw_received] = frame;

        ALOGE("hdl %d, ch_id %d, buf_num %d, bufidx0 %d, bufidx1 %d",
              pme->mHdrInfo.recvd_frame[pme->mHdrInfo.num_raw_received]->
              camera_handle, pme->mHdrInfo.recvd_frame[pme->mHdrInfo.
              num_raw_received]->ch_id, pme->mHdrInfo.recvd_frame[pme->
              mHdrInfo.num_raw_received]->num_bufs, pme->mHdrInfo.
              recvd_frame[pme->mHdrInfo.num_raw_received]->bufs[0]->buf_idx,
              pme->mHdrInfo.recvd_frame[pme->mHdrInfo.num_raw_received]->
              bufs[1]->buf_idx);

        pme->mHdrInfo.num_raw_received++;

        ALOGE("%s Total %d Received %d frames, still need to receive %d frames",
              __func__, pme->mHdrInfo.num_frame, pme->mHdrInfo.num_raw_received,
              (pme->mHdrInfo.num_frame - pme->mHdrInfo.num_raw_received));

        if (pme->mHdrInfo.num_raw_received == pme->mHdrInfo.num_frame) {
            ALOGE(" Received all %d YUV frames, Invoke HDR",
                  pme->mHdrInfo.num_raw_received);
            pme->doHdrProcessing();
        }
    } else {
        /* enqueu to superbuf queue */
        pme->mSuperBufQueue.enqueue(frame);

        /* notify dataNotify thread that new super buf is avail
         * check if it's done with current JPEG notification and
         * a new encoding job could be conducted*/
        pme->mNotifyTh->sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);
    }
   ALOGE("%s: X", __func__);

!!!44405687.cpp!!!	receiveRawPicture(inout recvd_frame : mm_camera_super_buf_t, inout pme : QCameraHardwareInterface) : void
     ALOGV("%s : E", __func__);
     status_t rc = NO_ERROR;
     int buf_index = 0;

     ALOGV("%s: is a raw snapshot", __func__);
     /*RAW snapshot*/
     if (recvd_frame->bufs[0] == NULL) {
         ALOGE("%s: The main frame buffer is null", __func__);
         return;
     }

     if (pme->mDataCb && (pme->mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
         if (pme->initHeapMem(&pme->mRawMemory,
                              1,
                              recvd_frame->bufs[0]->frame_len,
                              MSM_PMEM_RAW_MAINIMG,
                              NULL,
                              NULL) < 0) {
             ALOGE("%s : initHeapMem for raw, ret = NO_MEMORY", __func__);
             return;
         }

         buf_index = recvd_frame->bufs[0]->buf_idx;
         memcpy(pme->mRawMemory.camera_memory[0]->data,
                pme->mSnapshotMemory.camera_memory[buf_index]->data,
                recvd_frame->bufs[0]->frame_len);

         rc = pme->sendDataNotify(CAMERA_MSG_COMPRESSED_IMAGE,
                                  pme->mRawMemory.camera_memory[0],
                                  0,
                                  NULL,
                                  &pme->mRawMemory);
         if (rc != NO_ERROR) {
             pme->releaseHeapMem(&pme->mRawMemory);
         }
     }
     ALOGV("%s : X", __func__);
!!!44405815.cpp!!!	encodeData(inout recvd_frame : mm_camera_super_buf_t, inout jobId : uint32_t) : status_t
    ALOGV("%s : E", __func__);
    int32_t ret = NO_ERROR;
    mm_jpeg_job jpg_job;
    mm_camera_buf_def_t *main_frame = NULL;
    mm_camera_buf_def_t *thumb_frame = NULL;
    src_image_buffer_info *main_buf_info = NULL;
    src_image_buffer_info *thumb_buf_info = NULL;
    QCameraHalMemInfo_t *main_mem_info = NULL;
    QCameraHalMemInfo_t *thumb_mem_info = NULL;

    uint8_t src_img_num = recvd_frame->num_bufs;
    int i;

    *jobId = 0;

    QCameraStream *main_stream = mStreams[MM_CAMERA_SNAPSHOT_MAIN];
    for (i = 0; i < recvd_frame->num_bufs; i++) {
        if (main_stream->mStreamId == recvd_frame->bufs[i]->stream_id) {
            main_frame = recvd_frame->bufs[i];
            break;
        }
    }
    if(main_frame == NULL){
       ALOGE("%s : Main frame is NULL", __func__);
       return ret;
    }
    main_mem_info = &mSnapshotMemory.mem_info[main_frame->buf_idx];

    // send upperlayer callback for raw image (data or notify, not both)
    app_notify_cb_t *app_cb = (app_notify_cb_t *)malloc(sizeof(app_notify_cb_t));
    if (app_cb != NULL) {
        memset(app_cb, 0, sizeof(app_notify_cb_t));

        if((mDataCb) && (mMsgEnabled & CAMERA_MSG_RAW_IMAGE)){
            app_cb->dataCb = mDataCb;
            app_cb->argm_data_cb.msg_type = CAMERA_MSG_RAW_IMAGE;
            app_cb->argm_data_cb.cookie = mCallbackCookie;
            app_cb->argm_data_cb.data = mSnapshotMemory.camera_memory[main_frame->buf_idx];
            app_cb->argm_data_cb.index = 1;
            app_cb->argm_data_cb.metadata = NULL;
            app_cb->argm_data_cb.user_data = NULL;
        }
        if((mNotifyCb) && (mMsgEnabled & CAMERA_MSG_RAW_IMAGE_NOTIFY)){
            app_cb->notifyCb = mNotifyCb;
            app_cb->argm_notify.msg_type = CAMERA_MSG_RAW_IMAGE_NOTIFY;
            app_cb->argm_notify.cookie = mCallbackCookie;
            app_cb->argm_notify.ext1 = 0;
            app_cb->argm_notify.ext2 = 0;
        }

        /* enqueue jpeg_data into jpeg data queue */
        if ((app_cb->dataCb || app_cb->notifyCb) && mNotifyDataQueue.enqueue((void *)app_cb)) {
            mNotifyTh->sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);
        } else {
            free(app_cb);
        }
    } else {
        ALOGE("%s: No mem for app_notify_cb_t", __func__);
    }

    camera_jpeg_encode_cookie_t *cookie =
        (camera_jpeg_encode_cookie_t *)malloc(sizeof(camera_jpeg_encode_cookie_t));
    if (NULL == cookie) {
        ALOGE("%s : no mem for cookie", __func__);
        return -1;
    }
    cookie->src_frame = recvd_frame;
    cookie->userdata = this;

    dumpFrameToFile(main_frame, HAL_DUMP_FRM_MAIN);

    QCameraStream *thumb_stream = NULL;
    if (recvd_frame->num_bufs > 1) {
        /* has thumbnail */
        if(!isZSLMode()) {
            thumb_stream = mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]; //mStreamSnapThumb;
        } else {
            thumb_stream = mStreams[MM_CAMERA_PREVIEW]; //mStreamDisplay;
        }
        for (i = 0; i < recvd_frame->num_bufs; i++) {
            if (thumb_stream->mStreamId == recvd_frame->bufs[i]->stream_id) {
                thumb_frame = recvd_frame->bufs[i];
                break;
            }
        }
        if (NULL != thumb_frame) {
            if(thumb_stream == mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]) {
                thumb_mem_info = &mThumbnailMemory.mem_info[thumb_frame->buf_idx];
            } else {
                if (isNoDisplayMode()) {
                    thumb_mem_info = &mNoDispPreviewMemory.mem_info[thumb_frame->buf_idx];
                } else {
                    thumb_mem_info = &mPreviewMemory.mem_info[thumb_frame->buf_idx];
                }
            }
        }
    }  else if(mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->mWidth &&
               mStreams[MM_CAMERA_SNAPSHOT_THUMBNAIL]->mHeight) {
        /*thumbnail is required, not YUV thumbnail, borrow main image*/
        thumb_stream = main_stream;
        thumb_frame = main_frame;
        src_img_num++;
    }

    if (thumb_stream) {
        dumpFrameToFile(thumb_frame, HAL_DUMP_FRM_THUMBNAIL);
    }

    int jpeg_quality = getJpegQuality();
    if (jpeg_quality <= 0) {
        jpeg_quality = 85;
    }

    memset(&jpg_job, 0, sizeof(mm_jpeg_job));
    jpg_job.job_type = JPEG_JOB_TYPE_ENCODE;
    jpg_job.encode_job.userdata = cookie;
    jpg_job.encode_job.jpeg_cb = QCameraHardwareInterface::snapshot_jpeg_cb;
    jpg_job.encode_job.encode_parm.exif_data = getExifData();
    jpg_job.encode_job.encode_parm.exif_numEntries = getExifTableNumEntries();
    jpg_job.encode_job.encode_parm.rotation = getJpegRotation();
    ALOGV("%s: jpeg rotation is set to %d", __func__, jpg_job.encode_job.encode_parm.rotation);
    jpg_job.encode_job.encode_parm.buf_info.src_imgs.src_img_num = src_img_num;
    jpg_job.encode_job.encode_parm.buf_info.src_imgs.is_video_frame = FALSE;

    if (mMobiCatEnabled) {
        main_frame->p_mobicat_info = (cam_exif_tags_t*)malloc(sizeof(cam_exif_tags_t));
        if ((main_frame->p_mobicat_info != NULL) &&
             mCameraHandle->ops->get_parm(mCameraHandle->camera_handle, MM_CAMERA_PARM_MOBICAT,
                 main_frame->p_mobicat_info)
                 == MM_CAMERA_OK) {
                 ALOGV("%s:%d] Mobicat enabled %p %d", __func__, __LINE__,
                       main_frame->p_mobicat_info->tags,
                       main_frame->p_mobicat_info->data_len);
        } else {
              ALOGE("MM_CAMERA_PARM_MOBICAT get failed");
        }
    }
    if (mMobiCatEnabled && main_frame->p_mobicat_info) {
        jpg_job.encode_job.encode_parm.hasmobicat = 1;
        jpg_job.encode_job.encode_parm.mobicat_data = (uint8_t *)main_frame->p_mobicat_info->tags;
        jpg_job.encode_job.encode_parm.mobicat_data_length = main_frame->p_mobicat_info->data_len;
     } else {
        jpg_job.encode_job.encode_parm.hasmobicat = 0;
     }

     // fill in the src_img info
    //main img
    main_buf_info = &jpg_job.encode_job.encode_parm.buf_info.src_imgs.src_img[JPEG_SRC_IMAGE_TYPE_MAIN];
    main_buf_info->type = JPEG_SRC_IMAGE_TYPE_MAIN;
    main_buf_info->color_format = getColorfmtFromImgFmt(main_stream->mFormat);
    main_buf_info->quality = jpeg_quality;
    main_buf_info->src_image[0].fd = main_frame->fd;
    main_buf_info->src_image[0].buf_vaddr = (uint8_t*) main_frame->buffer;
    main_buf_info->src_dim.width = main_stream->mWidth;
    main_buf_info->src_dim.height = main_stream->mHeight;
    main_buf_info->out_dim.width = mPictureWidth;
    main_buf_info->out_dim.height = mPictureHeight;
    memcpy(&main_buf_info->crop, &main_stream->mCrop, sizeof(image_crop_t));

    ALOGD("%s : Main Image :Input Dimension %d x %d output Dimension = %d X %d",
          __func__, main_buf_info->src_dim.width, main_buf_info->src_dim.height,
          main_buf_info->out_dim.width, main_buf_info->out_dim.height);
    ALOGD("%s : Main Image :Crop %d x %d, offset = (%d, %d)",
          __func__, main_buf_info->crop.width, main_buf_info->crop.height,
          main_buf_info->crop.offset_x, main_buf_info->crop.offset_y);
    main_buf_info->img_fmt = JPEG_SRC_IMAGE_FMT_YUV;
    main_buf_info->num_bufs = 1;
    main_buf_info->src_image[0].offset = main_stream->mFrameOffsetInfo;
    ALOGD("%s : setting main image offset info, len = %d, offset = %d",
          __func__, main_stream->mFrameOffsetInfo.mp[0].len,
          main_stream->mFrameOffsetInfo.mp[0].offset);

    cache_ops(main_mem_info, main_frame->buffer, ION_IOC_CLEAN_INV_CACHES);

    if (thumb_frame && thumb_stream) {
        /* fill in thumbnail src img encode param */
        thumb_buf_info = &jpg_job.encode_job.encode_parm.buf_info.src_imgs.src_img[JPEG_SRC_IMAGE_TYPE_THUMB];
        thumb_buf_info->type = JPEG_SRC_IMAGE_TYPE_THUMB;
        thumb_buf_info->color_format = getColorfmtFromImgFmt(thumb_stream->mFormat);
        //thumb_buf_info->quality = jpeg_quality;
        thumb_buf_info->quality = 75; //hardcoded for now, will be calculated in encoder code later
        thumb_buf_info->src_dim.width = thumb_stream->mWidth;
        thumb_buf_info->src_dim.height = thumb_stream->mHeight;
        thumb_buf_info->out_dim.width = thumbnailWidth;
        thumb_buf_info->out_dim.height = thumbnailHeight;
        memcpy(&thumb_buf_info->crop, &thumb_stream->mCrop, sizeof(image_crop_t));
        ALOGD("%s : Thumanail :Input Dimension %d x %d output Dimension = %d X %d",
          __func__, thumb_buf_info->src_dim.width, thumb_buf_info->src_dim.height,
              thumb_buf_info->out_dim.width,thumb_buf_info->out_dim.height);
        thumb_buf_info->img_fmt = JPEG_SRC_IMAGE_FMT_YUV;
        thumb_buf_info->num_bufs = 1;
        thumb_buf_info->src_image[0].fd = thumb_frame->fd;
        thumb_buf_info->src_image[0].buf_vaddr = (uint8_t*) thumb_frame->buffer;
        thumb_buf_info->src_image[0].offset = thumb_stream->mFrameOffsetInfo;
        ALOGD("%s : setting thumb image offset info, len = %d, offset = %d",
              __func__, thumb_stream->mFrameOffsetInfo.mp[0].len, thumb_stream->mFrameOffsetInfo.mp[0].offset);

        cache_ops(thumb_mem_info, thumb_frame->buffer, ION_IOC_CLEAN_INV_CACHES);
    }

    uint32_t buf_len = main_stream->mFrameOffsetInfo.frame_len;
    if (main_stream->m_flag_stream_on == FALSE) {
        //if video-sized livesnapshot
        jpg_job.encode_job.encode_parm.buf_info.src_imgs.is_video_frame = TRUE;

        //use the same output resolution as input
        main_buf_info->out_dim.width = main_buf_info->src_dim.width;
        main_buf_info->out_dim.height = main_buf_info->src_dim.height;

        if (thumb_buf_info->out_dim.width > thumb_buf_info->src_dim.width ||
            thumb_buf_info->out_dim.height > thumb_buf_info->src_dim.height ) {
            thumb_buf_info->out_dim.width = thumb_buf_info->src_dim.width;
            thumb_buf_info->out_dim.height = thumb_buf_info->src_dim.height;
        }

        uint32_t len = main_buf_info->out_dim.width * main_buf_info->out_dim.height * 1.5;
        if (len > buf_len) {
            buf_len = len;
        }
    }

    //fill in the sink img info
    jpg_job.encode_job.encode_parm.buf_info.sink_img.buf_len = buf_len;
    jpg_job.encode_job.encode_parm.buf_info.sink_img.buf_vaddr = (uint8_t *)malloc(buf_len);
    if (NULL == jpg_job.encode_job.encode_parm.buf_info.sink_img.buf_vaddr) {
        ALOGE("%s: ERROR: no memory for sink_img buf", __func__);
        free(cookie);
        cookie = NULL;
        return -1;
    }

    if (mJpegClientHandle > 0) {
        ret = mJpegHandle.start_job(mJpegClientHandle, &jpg_job, jobId);
    } else {
        ALOGE("%s: Error: bug here, mJpegClientHandle is 0", __func__);
        free(cookie);
        cookie = NULL;
        return -1;
    }

    ALOGV("%s : X", __func__);
    return ret;

!!!44405943.cpp!!!	notifyShutter(in play_shutter_sound : bool) : void
     ALOGV("%s : E", __func__);
     if(mNotifyCb){
         mNotifyCb(CAMERA_MSG_SHUTTER, 0, play_shutter_sound, mCallbackCookie);
     }
     ALOGV("%s : X", __func__);
!!!44406071.cpp!!!	sendDataNotify(in msg_type : int32_t, inout data : camera_memory_t, in index : uint8_t, inout metadata : camera_frame_metadata_t, inout heap : QCameraHalHeap_t) : status_t
    app_notify_cb_t *app_cb = (app_notify_cb_t *)malloc(sizeof(app_notify_cb_t));
    if (NULL == app_cb) {
        ALOGE("%s: no mem for app_notify_cb_t", __func__);
        return BAD_VALUE;
    }
    memset(app_cb, 0, sizeof(app_notify_cb_t));
    app_cb->dataCb = mDataCb;
    app_cb->argm_data_cb.msg_type = msg_type;
    app_cb->argm_data_cb.cookie = mCallbackCookie;
    app_cb->argm_data_cb.data = data;
    app_cb->argm_data_cb.index = index;
    app_cb->argm_data_cb.metadata = metadata;
    app_cb->argm_data_cb.user_data = (void *)heap;

    /* enqueue jpeg_data into jpeg data queue */
    if (mNotifyDataQueue.enqueue((void *)app_cb)) {
        mNotifyTh->sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB, FALSE, FALSE);
    } else {
        free(app_cb);
        return BAD_VALUE;
    }
    return NO_ERROR;
!!!44406199.cpp!!!	releaseSuperBuf(inout super_buf : mm_camera_super_buf_t) : void
    if (NULL != super_buf) {
        for(int i = 0; i< super_buf->num_bufs; i++) {
            if (super_buf->bufs[i]->p_mobicat_info) {
                free(super_buf->bufs[i]->p_mobicat_info);
                super_buf->bufs[i]->p_mobicat_info = NULL;
            }
            mCameraHandle->ops->qbuf(super_buf->camera_handle,
                                     super_buf->ch_id,
                                     super_buf->bufs[i]);
            cache_ops((QCameraHalMemInfo_t *)(super_buf->bufs[i]->mem_info),
                      super_buf->bufs[i]->buffer,
                      ION_IOC_INV_CACHES);
        }
    }
!!!44406327.cpp!!!	releaseAppCBData(inout app_cb : app_notify_cb_t) : void
    if (app_cb->argm_data_cb.user_data != NULL) {
        QCameraHalHeap_t *heap = (QCameraHalHeap_t *)app_cb->argm_data_cb.user_data;
        releaseHeapMem(heap);
    }
!!!44406455.cpp!!!	releaseNofityData(inout data : void, inout user_data : void) : void
    QCameraHardwareInterface *pme = (QCameraHardwareInterface *)user_data;
    if (NULL != pme) {
        pme->releaseAppCBData((app_notify_cb_t *)data);
    }
!!!44406583.cpp!!!	releaseProcData(inout data : void, inout user_data : void) : void
    QCameraHardwareInterface *pme = (QCameraHardwareInterface *)user_data;
    if (NULL != pme) {
        pme->releaseSuperBuf((mm_camera_super_buf_t *)data);
    }
!!!44406711.cpp!!!	canTakeFullSizeLiveshot() : uint8_t
    if (mFullLiveshotEnabled && !isLowPowerCamcorder()) {
        /* Full size liveshot enabled. */

        /* If Picture size is same as video size, switch to Video size
         * live snapshot */
        if ((mDimension.picture_width == mDimension.video_width) &&
            (mDimension.picture_height == mDimension.video_height)) {
            return FALSE;
        }

        if (mDisEnabled) {
            /* If DIS is enabled and Picture size is
             * less than (video size + 10% DIS Margin)
             * then fall back to Video size liveshot. */
            if ((mDimension.picture_width <
                 (int)(mDimension.video_width * 1.1)) ||
                (mDimension.picture_height <
                 (int)(mDimension.video_height * 1.1))) {
                return FALSE;
            } else {
                /* Go with Full size live snapshot. */
                return TRUE;
            }
        } else {
            /* DIS Disabled. Go with Full size live snapshot */
            return TRUE;
        }
    } else {
        /* Full size liveshot disabled. Fallback to Video size liveshot. */
        return FALSE;
    }
