class CameraContext
!!!44422455.cpp!!!	CameraContext(in cameraIndex : int)
    mRecorder = new MediaRecorder();
!!!44422583.cpp!!!	~CameraContext()
    stopPreview();
    closeCamera();
!!!44422711.cpp!!!	openCamera() : status_t
    useLock();

    if ( NULL != mCamera.get() ) {
        printf("Camera already open! \n");
        return NO_ERROR;
    }

    printf("openCamera(camera_index=%d)\n", mCameraIndex);

#ifndef USE_JB_MR1

    String16 packageName("CameraTest");

    mCamera = Camera::connect(mCameraIndex,
                              packageName,
                              Camera::USE_CALLING_UID);

#else

    mCamera = Camera::connect(mCameraIndex);

#endif

    if ( NULL == mCamera.get() ) {
        printf("Unable to connect to CameraService\n");
        return NO_INIT;
    }

    mParams = mCamera->getParameters();
    mParams.getSupportedPreviewSizes(mSupportedPreviewSizes);
    mParams.getSupportedPictureSizes(mSupportedPictureSizes);
    mParams.getSupportedVideoSizes(mSupportedVideoSizes);

    mCurrentPictureSizeIdx = mSupportedPictureSizes.size() / 2;
    mCurrentPreviewSizeIdx = mSupportedPreviewSizes.size() / 2;
    mCurrentVideoSizeIdx   = mSupportedVideoSizes.size() / 2;

    mCamera->setListener(this);
    mHardwareActive = true;

    mInterpr->setViVSize((Size) mSupportedVideoSizes.itemAt(
        mCurrentVideoSizeIdx),
        mCameraIndex);

    signalFinished();

    return NO_ERROR;
!!!44422839.cpp!!!	closeCamera() : status_t
    useLock();
    if ( NULL == mCamera.get() ) {
        return NO_INIT;
    }

    mCamera->disconnect();
    mCamera.clear();

    mRecorder->init();
    mRecorder->close();
    mRecorder->release();
    mRecorder.clear();

    mHardwareActive = false;
    mPreviewRunning = false;
    mRecordRunning = false;

    signalFinished();
    return NO_ERROR;
!!!44422967.cpp!!!	startPreview() : status_t
    useLock();

    int ret = NO_ERROR;
    int previewWidth, previewHeight;
    Size calculatedPreviewSize;
    Size currentPreviewSize = mSupportedPreviewSizes.itemAt(
        mCurrentPreviewSizeIdx);
    Size currentPictureSize = mSupportedPictureSizes.itemAt(
        mCurrentPictureSizeIdx);
    Size currentVideoSize   = mSupportedVideoSizes.itemAt(
        mCurrentVideoSizeIdx);

#ifndef USE_JB_MR1

    sp<IGraphicBufferProducer> gbp;

#endif

    if (!mHardwareActive ) {
        printf("Camera not active! \n");
        return NO_INIT;
    }

    if (mPreviewRunning) {
        printf("Preview is already running! \n");
        signalFinished();
        return NO_ERROR;
    }

    if (mResizePreview) {
        mPreviewRunning = false;

        if ( mRecordingHint ) {
            calculatedPreviewSize =
                getPreviewSizeFromVideoSizes(currentVideoSize);
            previewWidth = calculatedPreviewSize.width;
            previewHeight = calculatedPreviewSize.height;
        } else {
            previewWidth = currentPreviewSize.width;
            previewHeight = currentPreviewSize.height;
        }

        ret = createPreviewSurface(previewWidth,
                                   previewHeight,
                                   HAL_PIXEL_FORMAT_YCrCb_420_SP);
        if (  NO_ERROR != ret ) {
            printf("Error while creating preview surface\n");
            return ret;
        }

        // set rdi mode if system prop is set for front camera
        if (mCameraIndex == 1) {
            char value[32];
            property_get("persist.camera.rdimode", value, "0");
            int rdimode = atoi(value);
            printf("rdi mode = %d\n", rdimode);
            if (rdimode == 1) {
                mParams.set("rdi-mode", "enable");
            } else {
                mParams.set("rdi-mode", "disable");
            }
        } else {
            mParams.set("rdi-mode", "disable");
        }

        //mParams.set("rdi-mode", "enable");
        mParams.set("recording-hint", "true");
        mParams.setPreviewSize(previewWidth, previewHeight);
        mParams.setPictureSize(currentPictureSize.width,
            currentPictureSize.height);
        mParams.setVideoSize(
            currentVideoSize.width, currentVideoSize.height);

        ret |= mCamera->setParameters(mParams.flatten());

#ifndef USE_JB_MR1

        gbp = mPreviewSurface->getIGraphicBufferProducer();
        ret |= mCamera->setPreviewTarget(gbp);

#else

        ret |= mCamera->setPreviewDisplay(mPreviewSurface);

#endif
        mResizePreview = false;
    }

    if ( !mPreviewRunning ) {
        ret |= mCamera->startPreview();
        if ( NO_ERROR != ret ) {
            printf("Preview start failed! \n");
            return ret;
        }

        mPreviewRunning = true;
    }

    signalFinished();

    return ret;
!!!44423095.cpp!!!	stopPreview() : status_t
    useLock();
    status_t ret = NO_ERROR;

    if ( mHardwareActive ) {
        mCamera->stopPreview();
        ret = destroyPreviewSurface();
    }

    mPreviewRunning  = false;
    mResizePreview = true;

    signalFinished();

    return ret;
!!!44423223.cpp!!!	resumePreview() : status_t
    useLock();
    status_t ret = NO_ERROR;

    if ( mHardwareActive ) {
        ret = mCamera->startPreview();
        mPreviewRunning = true;
    } else {
        ret = NO_INIT;
    }

    signalFinished();
    return ret;
!!!44423351.cpp!!!	autoFocus() : status_t
    useLock();
    status_t ret = NO_ERROR;

    if ( mPreviewRunning ) {
        ret = mCamera->autoFocus();
    }

    signalFinished();
    return ret;
!!!44423479.cpp!!!	enablePreviewCallbacks() : status_t
    useLock();
    if ( mHardwareActive ) {
        mCamera->setPreviewCallbackFlags(
            CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK);
    }

    signalFinished();
    return NO_ERROR;
!!!44423607.cpp!!!	takePicture() : status_t
    status_t ret = NO_ERROR;

    useLock(); // Unlocked in jpeg callback

    if ( mPreviewRunning ) {
        ret = mCamera->takePicture(
            CAMERA_MSG_COMPRESSED_IMAGE|
            CAMERA_MSG_RAW_IMAGE);
        if (!mRecordingHint) {
            mPreviewRunning = false;
        }
    } else {
        printf("Please resume/start the preview before taking a picture!\n");
        signalFinished(); //Unlock in case preview is not running
    }
    return ret;
!!!44423735.cpp!!!	startRecording() : status_t
    useLock();
    status_t ret = NO_ERROR;


    if ( mPreviewRunning ) {

        mCamera->unlock();

        ret = mRecorder->prepare();
        if ( ret != NO_ERROR ) {
            ERROR("Could not prepare recorder");
            return ret;
        }

        ret = mRecorder->start();
        if ( ret != NO_ERROR ) {
            ERROR("Could not start recorder");
            return ret;
        }

        mRecordRunning = true;
    }
    signalFinished();
    return ret;
!!!44423863.cpp!!!	stopRecording() : status_t
    useLock();
    status_t ret = NO_ERROR;

    if ( mRecordRunning ) {
            mRecorder->stop();
            close(mVideoFd);
            mVideoFd = -1;

        mRecordRunning = false;
    }

    signalFinished();

    return ret;
!!!44423991.cpp!!!	startViVRecording() : status_t
    useLock();
    status_t ret;

    if (mInterpr->mViVVid.VideoSizes[0].width *
            mInterpr->mViVVid.VideoSizes[0].height >=
            mInterpr->mViVVid.VideoSizes[1].width *
            mInterpr->mViVVid.VideoSizes[1].height) {
        mInterpr->mViVBuff.buffSize = calcBufferSize(
            mInterpr->mViVVid.VideoSizes[1].width,
            mInterpr->mViVVid.VideoSizes[1].height);
        if (mInterpr->mViVBuff.buff == NULL) {
            mInterpr->mViVBuff.buff =
                (void *)malloc(mInterpr->mViVBuff.buffSize);
        }
        mInterpr->mViVVid.sourceCameraID = 1;
        mInterpr->mViVVid.destinationCameraID = 0;

    } else {
        mInterpr->mViVBuff.buffSize = calcBufferSize(
            mInterpr->mViVVid.VideoSizes[0].width,
            mInterpr->mViVVid.VideoSizes[0].height);
        if (mInterpr->mViVBuff.buff == NULL) {
            mInterpr->mViVBuff.buff =
                (void *)malloc(mInterpr->mViVBuff.buffSize);
        }
        mInterpr->mViVVid.sourceCameraID = 0;
        mInterpr->mViVVid.destinationCameraID = 1;
    }

    ret = mCamera->startRecording();

    signalFinished();
    return ret;
!!!44424119.cpp!!!	stopViVRecording() : status_t
    useLock();
    status_t ret = NO_ERROR;

    mCamera->stopRecording();

    signalFinished();
    return ret;
!!!44424247.cpp!!!	configureViVRecording() : status_t
    status_t ret = NO_ERROR;

    mResizePreview = true;
    mParams.set("recording-hint", "true");
    mRecordingHint = true;
    mCamera->setParameters(mParams.flatten());
    mCamera->setRecordingProxyListener(this);

    signalFinished();
    return ret;
!!!44424375.cpp!!!	nextPreviewSize() : status_t
    useLock();
    if ( mHardwareActive ) {
        mCurrentPreviewSizeIdx += 1;
        mCurrentPreviewSizeIdx %= mSupportedPreviewSizes.size();
        Size previewSize = mSupportedPreviewSizes.itemAt(
            mCurrentPreviewSizeIdx);
        mParams.setPreviewSize(previewSize.width,
                               previewSize.height);
        mResizePreview = true;

        if ( mPreviewRunning ) {
            mCamera->stopPreview();
            mCamera->setParameters(mParams.flatten());
            mCamera->startPreview();
        } else {
            mCamera->setParameters(mParams.flatten());
        }
    }

    signalFinished();
    return NO_ERROR;
!!!44424503.cpp!!!	setPreviewSize(in format : char) : status_t
    useLock();
    if ( mHardwareActive ) {
        int newHeight;
        int newWidth;
        sscanf(format, "%dx%d", &newWidth, &newHeight);

        unsigned int i;
        for (i = 0; i < mSupportedPreviewSizes.size(); ++i) {
            Size previewSize = mSupportedPreviewSizes.itemAt(i);
            if ( newWidth == previewSize.width &&
                 newHeight == previewSize.height )
            {
                break;
            }

        }
        if ( i == mSupportedPreviewSizes.size())
        {
            printf("Preview size %dx%d not supported !\n",
                newWidth, newHeight);
            return INVALID_OPERATION;
        }

        mParams.setPreviewSize(newWidth,
                               newHeight);
        mResizePreview = true;

        if ( mPreviewRunning ) {
            mCamera->stopPreview();
            mCamera->setParameters(mParams.flatten());
            mCamera->startPreview();
        } else {
            mCamera->setParameters(mParams.flatten());
        }
    }

    signalFinished();
    return NO_ERROR;
!!!44424631.cpp!!!	getCurrentPreviewSize(inout previewSize : Size) : status_t
    useLock();
    if ( mHardwareActive ) {
        previewSize = mSupportedPreviewSizes.itemAt(mCurrentPreviewSizeIdx);
    }
    signalFinished();
    return NO_ERROR;
!!!44424759.cpp!!!	nextPictureSize() : status_t
    useLock();
    if ( mHardwareActive ) {
        mCurrentPictureSizeIdx += 1;
        mCurrentPictureSizeIdx %= mSupportedPictureSizes.size();
        Size pictureSize = mSupportedPictureSizes.itemAt(
            mCurrentPictureSizeIdx);
        mParams.setPictureSize(pictureSize.width,
            pictureSize.height);
        mCamera->setParameters(mParams.flatten());
    }
    signalFinished();
    return NO_ERROR;
!!!44424887.cpp!!!	getCurrentPictureSize(inout pictureSize : Size) : status_t
    useLock();
    if ( mHardwareActive ) {
        pictureSize = mSupportedPictureSizes.itemAt(mCurrentPictureSizeIdx);
    }
    signalFinished();
    return NO_ERROR;
!!!44425015.cpp!!!	setPictureSize(in format : char) : status_t
    useLock();
    if ( mHardwareActive ) {
        int newHeight;
        int newWidth;
        sscanf(format, "%dx%d", &newWidth, &newHeight);

        unsigned int i;
        for (i = 0; i < mSupportedPictureSizes.size(); ++i) {
            Size PictureSize = mSupportedPictureSizes.itemAt(i);
            if ( newWidth == PictureSize.width &&
                 newHeight == PictureSize.height )
            {
                break;
            }

        }
        if ( i == mSupportedPictureSizes.size())
        {
            printf("Preview size %dx%d not supported !\n",
                newWidth, newHeight);
            return INVALID_OPERATION;
        }

        mParams.setPictureSize(newWidth,
                               newHeight);
        mCamera->setParameters(mParams.flatten());
    }

    signalFinished();
    return NO_ERROR;
!!!44425143.cpp!!!	nextVideoSize() : status_t
    useLock();
    if ( mHardwareActive ) {
        mCurrentVideoSizeIdx += 1;
        mCurrentVideoSizeIdx %= mSupportedVideoSizes.size();
        Size videoSize = mSupportedVideoSizes.itemAt(mCurrentVideoSizeIdx);
        mParams.setVideoSize(videoSize.width,
                             videoSize.height);
        mCamera->setParameters(mParams.flatten());
        mInterpr->setViVSize((Size) mSupportedVideoSizes.itemAt(
            mCurrentVideoSizeIdx), mCameraIndex);
    }
    signalFinished();
    return NO_ERROR;
!!!44425271.cpp!!!	setVideoSize(in format : char) : status_t
    useLock();
    if ( mHardwareActive ) {
        int newHeight;
        int newWidth;
        sscanf(format, "%dx%d", &newWidth, &newHeight);

        unsigned int i;
        for (i = 0; i < mSupportedVideoSizes.size(); ++i) {
            Size PictureSize = mSupportedVideoSizes.itemAt(i);
            if ( newWidth == PictureSize.width &&
                 newHeight == PictureSize.height )
            {
                break;
            }

        }
        if ( i == mSupportedVideoSizes.size())
        {
            printf("Preview size %dx%d not supported !\n",
                newWidth, newHeight);
            return INVALID_OPERATION;
        }

        mParams.setVideoSize(newWidth,
                             newHeight);
        mCamera->setParameters(mParams.flatten());
    }

    signalFinished();
    return NO_ERROR;
!!!44425399.cpp!!!	getCurrentVideoSize(inout videoSize : Size) : status_t
    useLock();
    if ( mHardwareActive ) {
        videoSize = mSupportedVideoSizes.itemAt(mCurrentVideoSizeIdx);
    }
    signalFinished();
    return NO_ERROR;
!!!44425527.cpp!!!	configureRecorder() : status_t
    useLock();
    status_t ret = NO_ERROR;

    mResizePreview = true;
    mParams.set("recording-hint", "true");
    mRecordingHint = true;
    mCamera->setParameters(mParams.flatten());

    Size videoSize = mSupportedVideoSizes.itemAt(mCurrentVideoSizeIdx);
    ret = mRecorder->setParameters(
        String8("video-param-encoding-bitrate=64000"));
    if ( ret != NO_ERROR ) {
        ERROR("Could not configure recorder (%d)", ret);
        return ret;
    }

    ret = mRecorder->setCamera(
        mCamera->remote(), mCamera->getRecordingProxy());
    if ( ret != NO_ERROR ) {
        ERROR("Could not set camera (%d)", ret);
        return ret;
    }
    ret = mRecorder->setVideoSource(VIDEO_SOURCE_CAMERA);
    if ( ret != NO_ERROR ) {
        ERROR("Could not set video soruce (%d)", ret);
        return ret;
    }
    ret = mRecorder->setAudioSource(AUDIO_SOURCE_DEFAULT);
    if ( ret != NO_ERROR ) {
        ERROR("Could not set audio source (%d)", ret);
        return ret;
    }
    ret = mRecorder->setOutputFormat(OUTPUT_FORMAT_DEFAULT);
    if ( ret != NO_ERROR ) {
        ERROR("Could not set output format (%d)", ret);
        return ret;
    }

    ret = mRecorder->setVideoEncoder(VIDEO_ENCODER_DEFAULT);
    if ( ret != NO_ERROR ) {
        ERROR("Could not set video encoder (%d)", ret);
        return ret;
    }

    char fileName[100];

    sprintf(fileName, "/sdcard/vid_cam%d_%dx%d_%d.mpeg", mCameraIndex,
            videoSize.width, videoSize.height, mVideoIdx++);

    if ( mVideoFd < 0 ) {
        mVideoFd = open(fileName, O_CREAT | O_RDWR );
    }

    if ( mVideoFd < 0 ) {
        ERROR("Could not open video file for writing %s!", fileName);
        return UNKNOWN_ERROR;
    }

    ret = mRecorder->setOutputFile(mVideoFd, 0, 0);
    if ( ret != NO_ERROR ) {
        ERROR("Could not set output file (%d)", ret);
        return ret;
    }

    ret = mRecorder->setVideoSize(videoSize.width, videoSize.height);
    if ( ret  != NO_ERROR ) {
        ERROR("Could not set video size %dx%d", videoSize.width,
            videoSize.height);
        return ret;
    }

    ret = mRecorder->setVideoFrameRate(30);
    if ( ret != NO_ERROR ) {
        ERROR("Could not set video frame rate (%d)", ret);
        return ret;
    }

    ret = mRecorder->setAudioEncoder(AUDIO_ENCODER_DEFAULT);
    if ( ret != NO_ERROR ) {
        ERROR("Could not set audio encoder (%d)", ret);
        return ret;
    }

    signalFinished();
    return ret;
!!!44425655.cpp!!!	unconfigureRecorder() : status_t
    useLock();

    if ( !mRecordRunning ) {
        mResizePreview = true;
        mParams.set("recording-hint", "false");
        mRecordingHint = false;
        mCamera->setParameters(mParams.flatten());
    }

    signalFinished();
    return NO_ERROR;
!!!44425783.cpp!!!	FindSection(in SectionType : int) : CameraContext::Sections_t
    int a;

    for (a = 0; a < mSectionsRead; a++){
        if (mSections[a].Type == SectionType){
            return &mSections[a];
        }
    }
    // Could not be found.
    return NULL;
!!!44425911.cpp!!!	ReadSectionsFromBuffer(inout buffer : byte, in buffer_size : uint, in ReadMode : CameraContext::ReadMode_t) : status_t
    int a;
    unsigned int pos = 0;
    int HaveCom = 0;
    mSectionsAllocated = 10;

    mSections = (Sections_t *)malloc(sizeof(Sections_t) * mSectionsAllocated);

    if (!buffer) {
        printf("Input buffer is null\n");
        return BAD_VALUE;
    }

    if (buffer_size < 1) {
        printf("Input size is 0\n");
        return BAD_VALUE;
    }

    a = (int) buffer[pos++];

    if (a != 0xff || buffer[pos++] != M_SOI){
        printf("No valid image\n");
        return BAD_VALUE;
    }

    for(;;){
        int itemlen;
        int marker = 0;
        int ll,lh;
        unsigned char * Data;

        CheckSectionsAllocated();

        for (a = 0; a <= 16; a++){
            marker = buffer[pos++];
            if (marker != 0xff) break;

            if (a >= 16){
                fprintf(stderr,"too many padding bytes\n");
                return BAD_VALUE;
            }
        }

        mSections[mSectionsRead].Type = marker;

        // Read the length of the section.
        lh = buffer[pos++];
        ll = buffer[pos++];

        itemlen = (lh << 8) | ll;

        if (itemlen < 2) {
            ALOGE("invalid marker");
            return BAD_VALUE;
        }

        mSections[mSectionsRead].Size = itemlen;

        Data = (unsigned char *)malloc(itemlen);
        if (Data == NULL) {
            ALOGE("Could not allocate memory");
            return NO_MEMORY;
        }
        mSections[mSectionsRead].Data = Data;

        // Store first two pre-read bytes.
        Data[0] = (unsigned char)lh;
        Data[1] = (unsigned char)ll;

        if (pos+itemlen-2 > buffer_size) {
           ALOGE("Premature end of file?");
          return BAD_VALUE;
        }

        memcpy(Data+2, buffer+pos, itemlen-2); // Read the whole section.
        pos += itemlen-2;

        mSectionsRead += 1;

        switch(marker){

            case M_SOS:   // stop before hitting compressed data
                // If reading entire image is requested, read the rest of the
                // data.
                if (ReadMode & READ_IMAGE){
                    int size;
                    // Determine how much file is left.
                    size = buffer_size - pos;

                    if (size < 1) {
                        ALOGE("could not read the rest of the image");
                        return BAD_VALUE;
                    }
                    Data = (unsigned char *)malloc(size);
                    if (Data == NULL) {
                        ALOGE("%d: could not allocate data for entire "
                            "image size: %d", __LINE__, size);
                        return BAD_VALUE;
                    }

                    memcpy(Data, buffer+pos, size);

                    CheckSectionsAllocated();
                    mSections[mSectionsRead].Data = Data;
                    mSections[mSectionsRead].Size = size;
                    mSections[mSectionsRead].Type = PSEUDO_IMAGE_MARKER;
                    mSectionsRead ++;
                    mHaveAll = 1;
                }
                return NO_ERROR;

            case M_EOI:   // in case it's a tables-only JPEG stream
                ALOGE("No image in jpeg!\n");
                return BAD_VALUE;

            case M_COM: // Comment section
                if (HaveCom || ((ReadMode & READ_METADATA) == 0)){
                    // Discard this section.
                    free(mSections[--mSectionsRead].Data);
                }
                break;

            case M_JFIF:
                // Regular jpegs always have this tag, exif images have the
                // exif marker instead, althogh ACDsee will write images
                // with both markers.
                // this program will re-create this marker on absence of exif
                // marker.
                // hence no need to keep the copy from the file.
                if (ReadMode & READ_METADATA){
                    if (memcmp(Data+2, "JFIF", 4) == 0) {
                        break;
                    }
                    free(mSections[--mSectionsRead].Data);
                }
                break;

            case M_EXIF:
                // There can be different section using the same marker.
                if (ReadMode & READ_METADATA){
                    if (memcmp(Data+2, "Exif", 4) == 0){
                        break;
                    }else if (memcmp(Data+2, "http:", 5) == 0){
                        // Change tag for internal purposes.
                        mSections[mSectionsRead-1].Type = M_XMP;
                        break;
                    }
                }
                // Oterwise, discard this section.
                free(mSections[--mSectionsRead].Data);
                break;

            case M_IPTC:
                if (ReadMode & READ_METADATA){
                    // Note: We just store the IPTC section.
                    // Its relatively straightforward
                    // and we don't act on any part of it,
                    // so just display it at parse time.
                }else{
                    free(mSections[--mSectionsRead].Data);
                }
                break;

            case M_SOF0:
            case M_SOF1:
            case M_SOF2:
            case M_SOF3:
            case M_SOF5:
            case M_SOF6:
            case M_SOF7:
            case M_SOF9:
            case M_SOF10:
            case M_SOF11:
            case M_SOF13:
            case M_SOF14:
            case M_SOF15:
                break;
            default:
                // Skip any other sections.
                break;
        }
    }
    return NO_ERROR;
!!!44426039.cpp!!!	onAsBinder() : IBinder
    return NULL;
!!!44426167.cpp!!!	setTestCtxInstance(inout instance : TestContext) : void
    mInterpr = instance;
!!!44426295.cpp!!!	printMenu(in currentCamera : sp<CameraContext>) : void
    if ( !mDoPrintMenu ) return;
    Size currentPictureSize, currentPreviewSize, currentVideoSize;

    assert(currentCamera.get());

    currentCamera->getCurrentPictureSize(currentPictureSize);
    currentCamera->getCurrentPreviewSize(currentPreviewSize);
    currentCamera->getCurrentVideoSize(currentVideoSize);

    printf("\n\n=========== FUNCTIONAL TEST MENU ===================\n\n");

    printf(" \n\nSTART / STOP / GENERAL SERVICES \n");
    printf(" -----------------------------\n");
    printf("   %c. Switch camera - Current Index: %d\n",
            Interpreter::SWITCH_CAMERA_CMD,
            currentCamera->getCameraIndex());
    printf("   %c. Resume Preview after capture \n",
            Interpreter::RESUME_PREVIEW_CMD);
    printf("   %c. Quit \n",
            Interpreter::EXIT_CMD);
    printf("   %c. Camera Capability Dump",
            Interpreter::DUMP_CAPS_CMD);

    printf(" \n\n PREVIEW SUB MENU \n");
    printf(" -----------------------------\n");
    printf("   %c. Start Preview\n",
            Interpreter::START_PREVIEW_CMD);
    printf("   %c. Stop Preview\n",
            Interpreter::STOP_PREVIEW_CMD);
    printf("   %c. Preview size:  %dx%d\n",
           Interpreter::CHANGE_PREVIEW_SIZE_CMD,
           currentPreviewSize.width,
           currentPreviewSize.height);
    printf("   %c. Video size:  %dx%d\n",
            Interpreter::CHANGE_VIDEO_SIZE_CMD,
            currentVideoSize.width,
            currentVideoSize.height);
    printf("   %c. Start Recording\n",
            Interpreter::START_RECORD_CMD);
    printf("   %c. Stop Recording\n",
            Interpreter::STOP_RECORD_CMD);
    printf("   %c. Start ViV Recording\n",
            Interpreter::START_VIV_RECORD_CMD);
    printf("   %c. Stop ViV Recording\n",
            Interpreter::STOP_VIV_RECORD_CMD);
    printf("   %c. Enable preview frames\n",
            Interpreter::ENABLE_PRV_CALLBACKS_CMD);
    printf("   %c. Trigger autofocus \n",
            Interpreter::AUTOFOCUS_CMD);

    printf(" \n\n IMAGE CAPTURE SUB MENU \n");
    printf(" -----------------------------\n");
    printf("   %c. Take picture/Full Press\n",
            Interpreter::TAKEPICTURE_CMD);
    printf("   %c. Take picture in picture\n",
            Interpreter::TAKEPICTURE_IN_PICTURE_CMD);
    printf("   %c. Picture size:  %dx%d\n",
           Interpreter::CHANGE_PICTURE_SIZE_CMD,
           currentPictureSize.width,
           currentPictureSize.height);

    printf("\n");
    printf("   Choice: ");
!!!44426423.cpp!!!	printSupportedParams() : void
    printf("\n\r\tSupported Cameras: %s",
           mParams.get("camera-indexes")?
               mParams.get("camera-indexes") : "NULL");
    printf("\n\r\tSupported Picture Sizes: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES)?
           mParams.get(
               CameraParameters::KEY_SUPPORTED_PICTURE_SIZES) : "NULL");
    printf("\n\r\tSupported Picture Formats: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS)?
           mParams.get(
               CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS) : "NULL");
    printf("\n\r\tSupported Preview Sizes: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES)?
           mParams.get(
               CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES) : "NULL");
    printf("\n\r\tSupported Video Sizes: %s",
            mParams.get(CameraParameters::KEY_SUPPORTED_VIDEO_SIZES)?
            mParams.get(
               CameraParameters::KEY_SUPPORTED_VIDEO_SIZES) : "NULL");
    printf("\n\r\tSupported Preview Formats: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS)?
           mParams.get(
               CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS) : "NULL");
    printf("\n\r\tSupported Preview Frame Rates: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES)?
           mParams.get(
               CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES) : "NULL");
    printf("\n\r\tSupported Thumbnail Sizes: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES)?
           mParams.get(
               CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES) : "NULL");
    printf("\n\r\tSupported Whitebalance Modes: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE)?
           mParams.get(
               CameraParameters::KEY_SUPPORTED_WHITE_BALANCE) : "NULL");
    printf("\n\r\tSupported Effects: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_EFFECTS)?
           mParams.get(CameraParameters::KEY_SUPPORTED_EFFECTS) : "NULL");
    printf("\n\r\tSupported Scene Modes: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_SCENE_MODES)?
           mParams.get(CameraParameters::KEY_SUPPORTED_SCENE_MODES) : "NULL");
    printf("\n\r\tSupported Focus Modes: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_FOCUS_MODES)?
           mParams.get(CameraParameters::KEY_SUPPORTED_FOCUS_MODES) : "NULL");
    printf("\n\r\tSupported Antibanding Options: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_ANTIBANDING)?
           mParams.get(CameraParameters::KEY_SUPPORTED_ANTIBANDING) : "NULL");
    printf("\n\r\tSupported Flash Modes: %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_FLASH_MODES)?
           mParams.get(CameraParameters::KEY_SUPPORTED_FLASH_MODES) : "NULL");
    printf("\n\r\tSupported Focus Areas: %d",
           mParams.getInt(CameraParameters::KEY_MAX_NUM_FOCUS_AREAS));
    printf("\n\r\tSupported FPS ranges : %s",
           mParams.get(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE)?
           mParams.get(
               CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE) : "NULL");
    printf("\n\r\tFocus Distances: %s \n",
           mParams.get(CameraParameters::KEY_FOCUS_DISTANCES)?
           mParams.get(CameraParameters::KEY_FOCUS_DISTANCES) : "NULL");
!!!44426679.cpp!!!	getNumberOfCameras() : int
    int ret = -1;

    if ( NULL != mCamera.get() ) {
        ret = mCamera->getNumberOfCameras();
    }

    return ret;
!!!44426807.cpp!!!	enablePrintPreview() : void
    mDoPrintMenu = true;
!!!44426935.cpp!!!	disablePrintPreview() : void
    mDoPrintMenu = false;
!!!44427063.cpp!!!	enablePiPCapture() : void
    mPiPCapture = true;
!!!44427191.cpp!!!	disablePiPCapture() : void
    mPiPCapture = false;
!!!44427447.cpp!!!	DiscardData() : void
    int a;

    for (a = 0; a < mSectionsRead; a++){
        free(mSections[a].Data);
    }

    mSectionsRead = 0;
    mHaveAll = 0;
!!!44427575.cpp!!!	DiscardSections() : void
    free(mSections);
    mSectionsAllocated = 0;
    mHaveAll = 0;
!!!44427703.cpp!!!	calcBufferSize(in width : int, in height : int) : size_t
    size_t size = 0;
    size_t UVAlignment;
    size_t YPlane, UVPlane, YStride, UVStride, YScanlines, UVScanlines;
    if (!width || !height) {
        return size;
    }
    UVAlignment = 4096;
    YStride = calcStride(width);
    UVStride = calcStride(width);
    YScanlines = calcYScanLines(height);
    UVScanlines = calcUVScanLines(height);
    YPlane = YStride * YScanlines;
    UVPlane = UVStride * UVScanlines + UVAlignment;
    size = YPlane + UVPlane;
    size = VIDEO_BUF_ALLIGN(size, 4096);

    return size;
!!!44427831.cpp!!!	calcStride(in width : int) : size_t
    size_t alignment, stride = 0;
    if (!width) {
        return stride;
    }
    alignment = 128;
    stride = VIDEO_BUF_ALLIGN(width, alignment);

    return stride;
!!!44427959.cpp!!!	calcYScanLines(in height : int) : size_t
    size_t alignment, scanlines = 0;
        if (!height) {
            return scanlines;
        }
    alignment = 32;
    scanlines = VIDEO_BUF_ALLIGN(height, alignment);

    return scanlines;
!!!44428087.cpp!!!	calcUVScanLines(in height : int) : size_t
    size_t alignment, scanlines = 0;
    if (!height) {
        return scanlines;
    }
    alignment = 16;
    scanlines = VIDEO_BUF_ALLIGN(((height + 1) >> 1), alignment);

    return scanlines;
!!!44428215.cpp!!!	notify(in msgType : int32_t, in ext1 : int32_t, in ext2 : int32_t) : void
    printf("Notify cb: %d %d %d\n", msgType, ext1, ext2);

    if (( msgType & CAMERA_MSG_PREVIEW_FRAME) && (ext1 == CAMERA_FRAME_DATA_FD)) {
        int fd = dup(ext2);
        printf("notify Preview Frame fd: %d dup fd: %d\n", ext2, fd);
        close(fd);
    }

    if ( msgType & CAMERA_MSG_FOCUS ) {
        printf("AutoFocus %s \n",
               (ext1) ? "OK" : "FAIL");
    }

    if ( msgType & CAMERA_MSG_SHUTTER ) {
        printf("Shutter done \n");
    }

    if ( msgType & CAMERA_MSG_ERROR) {
        printf("Camera Test CAMERA_MSG_ERROR\n");
        stopPreview();
        closeCamera();
    }
!!!44428343.cpp!!!	postData(in msgType : int32_t, in dataPtr : sp<IMemory>, inout metadata : camera_frame_metadata_t) : void
    Size currentPictureSize = mSupportedPictureSizes.itemAt(
        mCurrentPictureSizeIdx);
    unsigned char *buff = NULL;
    int size;
    status_t ret = 0;

    memset(&mJEXIFSection, 0, sizeof(mJEXIFSection)),

    printf("Data cb: %d\n", msgType);

    if ( msgType & CAMERA_MSG_PREVIEW_FRAME ) {
        previewCallback(dataPtr);
    }

    if ( msgType & CAMERA_MSG_RAW_IMAGE ) {
        printf("RAW done \n");
    }

    if (msgType & CAMERA_MSG_POSTVIEW_FRAME) {
        printf("Postview frame \n");
    }

    if (msgType & CAMERA_MSG_COMPRESSED_IMAGE ) {
        String8 jpegPath;
        jpegPath = jpegPath.format("/sdcard/img_%d.jpg", JpegIdx);
        if (!mPiPCapture) {
            // Normal capture case
            printf("JPEG done\n");
            saveFile(dataPtr, jpegPath);
            JpegIdx++;
        } else {
            // PiP capture case
            SkFILEWStream *wStream;
            skBMtmp[mPiPIdx] = decodeJPEG(dataPtr);

            mWidthTmp[mPiPIdx] = currentPictureSize.width;
            mHeightTmp[mPiPIdx] = currentPictureSize.height;
            PiPPtrTmp[mPiPIdx] = dataPtr;
            // If there are two jpeg buffers
            if (mPiPIdx == 1) {
                printf("PiP done\n");

                // Find the the capture with higher width and height and read
                // its jpeg sections
                if ((mWidthTmp[0]*mHeightTmp[0]) >
                        (mWidthTmp[1]*mHeightTmp[1])) {
                    buff = (unsigned char *)PiPPtrTmp[0]->pointer();
                    size = PiPPtrTmp[0]->size();
                } else if ((mWidthTmp[0]*mHeightTmp[0]) <
                        (mWidthTmp[1]*mHeightTmp[1])) {
                    buff = (unsigned char *)PiPPtrTmp[1]->pointer();
                    size = PiPPtrTmp[1]->size();
                } else {
                    printf("Cannot take PiP. Images are with the same width"
                            " and height size!!!\n");
                    return;
                }

                if (buff != NULL && size != 0) {
                    ret = ReadSectionsFromBuffer(buff, size, READ_ALL);
                    if (ret != NO_ERROR) {
                        printf("Cannot read sections from buffer\n");
                        DiscardData();
                        DiscardSections();
                        return;
                    }

                    mJEXIFTmp = FindSection(M_EXIF);
                    mJEXIFSection = *mJEXIFTmp;
                    mJEXIFSection.Data =
                        (unsigned char*)malloc(mJEXIFTmp->Size);
                    memcpy(mJEXIFSection.Data,
                        mJEXIFTmp->Data, mJEXIFTmp->Size);
                    DiscardData();
                    DiscardSections();

                    wStream = new SkFILEWStream(jpegPath.string());
                    skBMDec = PiPCopyToOneFile(skBMtmp[0], skBMtmp[1]);
                    if (encodeJPEG(wStream, skBMDec, jpegPath) != false) {
                        printf("%s():%d:: Failed during jpeg encode\n",
                            __FUNCTION__,__LINE__);
                        return;
                    }
                    mPiPIdx = 0;
                    JpegIdx++;
                    delete wStream;
                }
            } else {
                mPiPIdx++;
            }
            disablePiPCapture();
        }
    }

    if ( ( msgType & CAMERA_MSG_PREVIEW_METADATA ) &&
         ( NULL != metadata ) ) {
        printf("Face detected %d \n", metadata->number_of_faces);
    }

    signalFinished();
!!!44428471.cpp!!!	postDataTimestamp(in timestamp : nsecs_t, in msgType : int32_t, in dataPtr : sp<IMemory>) : void
    printf("Recording cb: %d %lld %p\n", msgType, timestamp, dataPtr.get());
!!!44428599.cpp!!!	dataCallbackTimestamp(in timestamp : nsecs_t, in msgType : int32_t, in dataPtr : sp<IMemory>) : void
    mutexLock();
    // Not needed check. Just avoiding warnings of not used variables.
    if (timestamp > 0)
        timestamp = 0;
    // Not needed check. Just avoiding warnings of not used variables.
    if (msgType > 0)
        msgType = 0;
    int i = 0;
    void * srcBuff = NULL;
    void * dstBuff = NULL;

    size_t srcYStride = 0, dstYStride = 0;
    size_t srcUVStride = 0, dstUVStride = 0;
    size_t srcYScanLines = 0, dstYScanLines = 0;
    size_t srcUVScanLines = 0, dstUVScanLines = 0;
    size_t srcOffset = 0, dstOffset = 0;
    size_t srcBaseOffset = 0;
    size_t dstBaseOffset = 0;
    Size currentVideoSize = mSupportedVideoSizes.itemAt(mCurrentVideoSizeIdx);
    status_t err = NO_ERROR;
    ANativeWindowBuffer* anb = NULL;

    dstBuff = (void *) dataPtr->pointer();

    if (mCameraIndex == mInterpr->mViVVid.sourceCameraID) {
        srcYStride = calcStride(currentVideoSize.width);
        srcUVStride = calcStride(currentVideoSize.width);
        srcYScanLines = calcYScanLines(currentVideoSize.height);
        srcUVScanLines = calcUVScanLines(currentVideoSize.height);
        mInterpr->mViVBuff.srcWidth = currentVideoSize.width;
        mInterpr->mViVBuff.srcHeight = currentVideoSize.height;


        mInterpr->mViVBuff.YStride = srcYStride;
        mInterpr->mViVBuff.UVStride = srcUVStride;
        mInterpr->mViVBuff.YScanLines = srcYScanLines;
        mInterpr->mViVBuff.UVScanLines = srcUVScanLines;

        memcpy( mInterpr->mViVBuff.buff, (void *) dataPtr->pointer(),
            mInterpr->mViVBuff.buffSize);

        mInterpr->mViVVid.isBuffValid = true;
    } else if (mCameraIndex == mInterpr->mViVVid.destinationCameraID) {
        if(mInterpr->mViVVid.isBuffValid == true) {
            dstYStride = calcStride(currentVideoSize.width);
            dstUVStride = calcStride(currentVideoSize.width);
            dstYScanLines = calcYScanLines(currentVideoSize.height);
            dstUVScanLines = calcUVScanLines(currentVideoSize.height);

            srcYStride = mInterpr->mViVBuff.YStride;
            srcUVStride = mInterpr->mViVBuff.UVStride;
            srcYScanLines = mInterpr->mViVBuff.YScanLines;
            srcUVScanLines = mInterpr->mViVBuff.UVScanLines;


            for (i=0; i<(int) mInterpr->mViVBuff.srcHeight; i++) {
                srcOffset = i*srcYStride;
                dstOffset = i*dstYStride;
                memcpy((unsigned char *) dstBuff + dstOffset,
                    (unsigned char *) mInterpr->mViVBuff.buff +
                    srcOffset, mInterpr->mViVBuff.srcWidth);
            }
            srcBaseOffset = srcYStride * srcYScanLines;
            dstBaseOffset = dstYStride * dstYScanLines;
            for (i=0;i<(int) mInterpr->mViVBuff.srcHeight/2;i++) {
                srcOffset = i*srcUVStride + srcBaseOffset;
                dstOffset = i*dstUVStride + dstBaseOffset;
                memcpy((unsigned char *) dstBuff + dstOffset,
                    (unsigned char *) mInterpr->mViVBuff.buff +
                    srcOffset, mInterpr->mViVBuff.srcWidth);
            }

            err = native_window_dequeue_buffer_and_wait(
                mInterpr->mViVVid.ANW.get(),&anb);
            if (err != NO_ERROR) {
                printf("Cannot dequeue anb for sensor %d!!!\n", mCameraIndex);
                return;
            }
            mInterpr->mViVVid.graphBuf = new GraphicBuffer(anb, false);
            if(NULL == mInterpr->mViVVid.graphBuf.get()) {
                printf("Invalid Graphic buffer\n");
                return;
            }
            err = mInterpr->mViVVid.graphBuf->lock(
                GRALLOC_USAGE_SW_WRITE_OFTEN,
                (void**)(&mInterpr->mViVVid.mappedBuff));
            if (err != NO_ERROR) {
                printf("Graphic buffer could not be locked %d!!!\n", err);
                return;
            }

            srcYStride = dstYStride;
            srcUVStride = dstUVStride;
            srcYScanLines = dstYScanLines;
            srcUVScanLines = dstUVScanLines;
            srcBuff = dstBuff;

            for (i=0; i<(int) currentVideoSize.height; i++) {
                srcOffset = i*srcYStride;
                dstOffset = i*dstYStride;
                memcpy((unsigned char *) mInterpr->mViVVid.mappedBuff +
                    dstOffset, (unsigned char *) srcBuff +
                    srcOffset, currentVideoSize.width);
            }

            srcBaseOffset = srcYStride * srcYScanLines;
            dstBaseOffset = dstUVStride * currentVideoSize.height;

            for (i=0;i<(int) currentVideoSize.height/2;i++) {
                srcOffset = i*srcUVStride + srcBaseOffset;
                dstOffset = i*dstUVStride + dstBaseOffset;
                memcpy((unsigned char *) mInterpr->mViVVid.mappedBuff +
                    dstOffset, (unsigned char *) srcBuff +
                    srcOffset, currentVideoSize.width);
            }


            mInterpr->mViVVid.graphBuf->unlock();

            err = mInterpr->mViVVid.ANW->queueBuffer(
                mInterpr->mViVVid.ANW.get(), anb, -1);
            if(err)
                printf("Failed to enqueue buffer to recorder!!!\n");
        }
    }
    mCamera->releaseRecordingFrame(dataPtr);

    mutexUnlock();
!!!44428983.cpp!!!	createPreviewSurface(in width : uint, in height : uint, in pixFormat : int32_t) : status_t
    int ret = NO_ERROR;
    DisplayInfo dinfo;
    sp<IBinder> display(SurfaceComposerClient::getBuiltInDisplay(
                        ISurfaceComposer::eDisplayIdMain));
    SurfaceComposerClient::getDisplayInfo(display, &dinfo);
    unsigned int previewWidth, previewHeight;

    if ( dinfo.w < width ) {
        previewWidth = dinfo.w;
    } else {
        previewWidth = width;
    }

    if ( dinfo.h < height ) {
        previewHeight = dinfo.h;
    } else {
        previewHeight = height;
    }

    mClient = new SurfaceComposerClient();

    if ( NULL == mClient.get() ) {
        printf("Unable to establish connection to Surface Composer \n");
        return NO_INIT;
    }

    mSurfaceControl = mClient->createSurface(String8("QCamera_Test"),
                                             previewWidth,
                                             previewHeight,
                                             pixFormat,
                                             0);
    if ( NULL == mSurfaceControl.get() ) {
        printf("Unable to create preview surface \n");
        return NO_INIT;
    }

    mPreviewSurface = mSurfaceControl->getSurface();
    if ( NULL != mPreviewSurface.get() ) {
        mClient->openGlobalTransaction();
        ret |= mSurfaceControl->setLayer(0x7fffffff);
        if ( mCameraIndex == 0 )
            ret |= mSurfaceControl->setPosition(0, 0);
        else
            ret |= mSurfaceControl->setPosition(
                dinfo.w - previewWidth, dinfo.h - previewHeight);

        ret |= mSurfaceControl->setSize(previewWidth, previewHeight);
        ret |= mSurfaceControl->show();
        mClient->closeGlobalTransaction();

        if ( NO_ERROR != ret ) {
            printf("Preview surface configuration failed! \n");
        }
    } else {
        ret = NO_INIT;
    }

    return ret;
!!!44429111.cpp!!!	destroyPreviewSurface() : status_t
    if ( NULL != mPreviewSurface.get() ) {
        mPreviewSurface.clear();
    }

    if ( NULL != mSurfaceControl.get() ) {
        mSurfaceControl->clear();
        mSurfaceControl.clear();
    }

    if ( NULL != mClient.get() ) {
        mClient->dispose();
        mClient.clear();
    }

    return NO_ERROR;
!!!44429239.cpp!!!	saveFile(in mem : sp<IMemory>, in path : String8) : status_t
    unsigned char *buff = NULL;
    int size;
    int fd = -1;

    if (mem == NULL) {
        return BAD_VALUE;
    }

    fd = open(path, O_CREAT | O_WRONLY | O_TRUNC, 0655);
    if(fd < 0) {
        printf("Unable to open file %s %s\n", path.string(), strerror(fd));
        return -errno;
    }

    size = mem->size();
    if (size <= 0) {
        printf("IMemory object is of zero size\n");
        close(fd);
        return BAD_VALUE;
    }

    buff = (unsigned char *)mem->pointer();
    if (!buff) {
        printf("Buffer pointer is invalid\n");
        close(fd);
        return BAD_VALUE;
    }

    if ( size != write(fd, buff, size) ) {
        printf("Bad Write error (%d)%s\n",
               errno,
               strerror(errno));
        close(fd);
        return INVALID_OPERATION;
    }

    printf("%s: buffer=%08X, size=%d stored at %s\n",
           __FUNCTION__, (int)buff, size, path.string());

    if (fd >= 0)
        close(fd);

    return NO_ERROR;
!!!44429367.cpp!!!	PiPCopyToOneFile(inout bitmap0 : SkBitmap, inout bitmap1 : SkBitmap) : SkBitmap
    int size0;
    int size1;
    SkBitmap *src;
    SkBitmap *dst;
    unsigned int dstOffset;
    unsigned int srcOffset;

    if (bitmap0 == NULL && bitmap1 == NULL) {
        return NULL;
    }

    size0 = bitmap0->getSize();
    if (size0 <= 0) {
        printf("Decoded image 0 is of zero size\n");
        return NULL;
    }

    size1 = bitmap1->getSize();
        if (size1 <= 0) {
            printf("Decoded image 1 is of zero size\n");
            return NULL;
        }

    if (size0 > size1) {
        dst = bitmap0;
        src = bitmap1;
    } else if (size1 > size0){
        dst = bitmap1;
        src = bitmap0;
    } else {
        printf("Picture size should be with different size!\n");
        return NULL;
    }

    for(int i=0; i<src->height(); i++) {
        dstOffset = i*(dst->width())*mfmtMultiplier;
        srcOffset = i*(src->width())*mfmtMultiplier;
        memcpy(((unsigned char *) dst->getPixels())+dstOffset,
            ((unsigned char *) src->getPixels())+srcOffset,
            src->width()*mfmtMultiplier);
    }

    return dst;
!!!44429495.cpp!!!	decodeJPEG(in mem : sp<IMemory>) : SkBitmap
    SkBitmap *skBM;
    skBM = new SkBitmap; //Deleted in encodeJPEG (skBMtmp[0] and skBMtmp[1])
    SkBitmap::Config prefConfig = SkBitmap::kARGB_8888_Config;
    const void *buff = NULL;
    int size;

    buff = (const void *)mem->pointer();
    size= mem->size();

    switch(prefConfig) {
        case SkBitmap::kARGB_8888_Config:
        {
            mfmtMultiplier = 4;
        }
            break;

        case SkBitmap::kARGB_4444_Config:
        {
            mfmtMultiplier = 2;
        }
        break;

        case SkBitmap::kRGB_565_Config:
        {
            mfmtMultiplier = 2;
        }
        break;

        case SkBitmap::kIndex8_Config:
        {
            mfmtMultiplier = 4;
        }
        break;

        case SkBitmap::kA8_Config:
        {
            mfmtMultiplier = 4;
        }
        break;

        default:
        {
            mfmtMultiplier = 0;
            printf("Decode format is not correct!\n");
        }
        break;
    }

    if (SkImageDecoder::DecodeMemory(buff, size, skBM, prefConfig,
            SkImageDecoder::kDecodePixels_Mode) == false) {
        printf("%s():%d:: Failed during jpeg decode\n",__FUNCTION__,__LINE__);
        return NULL;
    }

    return skBM;
!!!44429623.cpp!!!	encodeJPEG(inout stream : SkWStream, in bitmap : SkBitmap, in path : String8) : status_t
    int qFactor = 100;
    long len;
    status_t ret;
    unsigned char *buff;
    unsigned char temp;

    skJpegEnc = SkImageEncoder::Create(SkImageEncoder::kJPEG_Type);

    if (skJpegEnc->encodeStream(stream, *bitmap, qFactor) == false) {
        return BAD_VALUE;
    }
    printf("%s: buffer=%08X, size=%d stored at %s\n",
        __FUNCTION__, (int)bitmap->getPixels(),
        bitmap->getSize(), path.string());
    delete skBMtmp[0];
    delete skBMtmp[1];

    FILE *fh = fopen(path.string(), "r+");
    if ( !fh ) {
        printf("Could not open file %s\n", path.string());
        return BAD_VALUE;
    }

    fseek(fh, 0, SEEK_END);
    len = ftell(fh);
    rewind(fh);

    if( !len ) {
        printf("File %s is empty !\n", path.string());
        fclose(fh);
        return BAD_VALUE;
    }

    buff = (unsigned char*)malloc(len);
    if (!buff) {
        printf("Cannot allocate memory for buffer reading!\n");
        return BAD_VALUE;
    }

    ret = fread(buff, 1, len, fh);
    if (ret != len) {
        printf("Reading error\n");
        return BAD_VALUE;
    }

    ret = ReadSectionsFromBuffer(buff, len, READ_ALL);
    if (ret != NO_ERROR) {
        printf("Cannot read sections from buffer\n");
        DiscardData();
        DiscardSections();
        return BAD_VALUE;
    }
    free(buff);
    rewind(fh);

    temp = 0xff;
    ret = fwrite(&temp, sizeof(unsigned char), 1, fh);
    if (ret != 1) {
        printf("Writing error\n");
    }
    temp = 0xd8;
    fwrite(&temp, sizeof(unsigned char), 1, fh);

    for (int i=0; i<mSectionsRead; i++) {
        switch((mSections[i].Type)) {

        case 0x123:
            fwrite(mSections[i].Data, sizeof(unsigned char),
                mSections[i].Size, fh);
            break;

        case 0xe0:
            temp = 0xff;
            fwrite(&temp, sizeof(unsigned char), 1, fh);
            temp = 0xe1;
            fwrite(&temp, sizeof(unsigned char), 1, fh);
            fwrite(mJEXIFSection.Data, sizeof(unsigned char),
                mJEXIFSection.Size, fh);
            break;

        default:
            temp = 0xff;
            fwrite(&temp, sizeof(unsigned char), 1, fh);
            fwrite(&mSections[i].Type, sizeof(unsigned char), 1, fh);
            fwrite(mSections[i].Data, sizeof(unsigned char),
                mSections[i].Size, fh);
            break;
        }
    }
    free(mJEXIFSection.Data);
    DiscardData();
    DiscardSections();
    fclose(fh);

    ret = NO_ERROR;

    return ret;
!!!44429751.cpp!!!	previewCallback(in mem : sp<IMemory>) : void
    printf("PREVIEW Callback 0x%x", ( unsigned int ) mem->pointer());
    uint8_t *ptr = (uint8_t*) mem->pointer();
    printf("PRV_CB: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x",
           ptr[0],
           ptr[1],
           ptr[2],
           ptr[3],
           ptr[4],
           ptr[5],
           ptr[6],
           ptr[7],
           ptr[8],
           ptr[9]);
!!!44429879.cpp!!!	getPreviewSizeFromVideoSizes(in currentVideoSize : Size) : Size

    Size tmpPreviewSize;
    Size PreviewSize;
    Size PreviewSizes[mSupportedPreviewSizes.size()];
    float tolerance = 0.00001;
    float videoRatio;
    float previewRatio;
    size_t i = 0;
    size_t j = 0;
    int delta;

    // Find all the resolutions with the same aspect ratio and choose the
    // same or the closest resolution from them. Choose the closest resolution
    // in case same aspect ratio is not found
    if (currentVideoSize.width * currentVideoSize.height > 0 &&
            mSupportedPreviewSizes.size() > 0) {
        videoRatio = (float)currentVideoSize.width /
            (float)currentVideoSize.height;
        for (i=0; i<mSupportedPreviewSizes.size(); i++) {
            tmpPreviewSize = mSupportedPreviewSizes.itemAt(i);
            previewRatio = (float)tmpPreviewSize.width /
                (float)tmpPreviewSize.height;
            if (fabs(videoRatio - previewRatio) < tolerance) {
                PreviewSizes[j] = tmpPreviewSize;
                j++;
            }
        }

        if ( j > 0 ) {
            delta = abs((currentVideoSize.width *currentVideoSize.height)-
                (PreviewSizes[0].width * PreviewSizes[0].height));
            PreviewSize = PreviewSizes[0];
            for (i=0; i<j; i++) {
                if(abs(currentVideoSize.width * currentVideoSize.height) -
                    (PreviewSizes[i].width * PreviewSizes[i].height) <
                    delta) {
                    PreviewSize = PreviewSizes[i];
                    delta = abs((currentVideoSize.width *
                        currentVideoSize.height) -
                        (PreviewSizes[i].width * PreviewSizes[i].height));
                }
            }
        } else {
            // Choose the closest resolution in case same aspect ratio is
            // not found
            tmpPreviewSize = mSupportedPreviewSizes.itemAt(j);
            PreviewSize = tmpPreviewSize;
            delta = abs(
                    (currentVideoSize.width * currentVideoSize.height)-
                    (tmpPreviewSize.width * tmpPreviewSize.height));
            for (i=0; i<mSupportedPreviewSizes.size(); i++) {
                tmpPreviewSize = mSupportedPreviewSizes.itemAt(i);
                if(abs(
                        (currentVideoSize.width * currentVideoSize.height)-
                        (tmpPreviewSize.width * tmpPreviewSize.height)) <
                        delta) {
                    PreviewSize = tmpPreviewSize;
                    delta = abs(
                            (currentVideoSize.width * currentVideoSize.height)-
                            (tmpPreviewSize.width * tmpPreviewSize.height));
                }
            }
        }
    } else {
        memset(&PreviewSize, 0, sizeof(PreviewSize));
    }
    return PreviewSize;
!!!44430007.cpp!!!	useLock() : void
    Mutex::Autolock l(mLock);
    if ( mInUse ) {
        mCond.wait(mLock);
    } else {
        mInUse = true;
    }
!!!44430135.cpp!!!	signalFinished() : void
    Mutex::Autolock l(mLock);
    mInUse = false;
    mCond.signal();
!!!44430263.cpp!!!	mutexLock() : void
    Mutex::Autolock l(mViVLock);
    if (mViVinUse ) {
        mViVCond.wait(mViVLock);
    } else {
        mViVinUse = true;
    }
!!!44430391.cpp!!!	mutexUnlock() : void
    Mutex::Autolock l(mViVLock);
    mViVinUse = false;
    mViVCond.signal();
