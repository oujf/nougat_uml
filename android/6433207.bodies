class Allocation
!!!72596279.java!!!	validateObjectIsPrimitiveArray(inout d : Object, inout checkType : boolean) : Element::DataType
        final Class c = d.getClass();
        if (!c.isArray()) {
            throw new RSIllegalArgumentException("Object passed is not an array of primitives.");
        }
        final Class cmp = c.getComponentType();
        if (!cmp.isPrimitive()) {
            throw new RSIllegalArgumentException("Object passed is not an Array of primitives.");
        }

        if (cmp == Long.TYPE) {
            if (checkType) {
                validateIsInt64();
                return mType.mElement.mType;
            }
            return Element.DataType.SIGNED_64;
        }

        if (cmp == Integer.TYPE) {
            if (checkType) {
                validateIsInt32();
                return mType.mElement.mType;
            }
            return Element.DataType.SIGNED_32;
        }

        if (cmp == Short.TYPE) {
            if (checkType) {
                validateIsInt16OrFloat16();
                return mType.mElement.mType;
            }
            return Element.DataType.SIGNED_16;
        }

        if (cmp == Byte.TYPE) {
            if (checkType) {
                validateIsInt8();
                return mType.mElement.mType;
            }
            return Element.DataType.SIGNED_8;
        }

        if (cmp == Float.TYPE) {
            if (checkType) {
                validateIsFloat32();
            }
            return Element.DataType.FLOAT_32;
        }

        if (cmp == Double.TYPE) {
            if (checkType) {
                validateIsFloat64();
            }
            return Element.DataType.FLOAT_64;
        }

        throw new RSIllegalArgumentException("Parameter of type " + cmp.getSimpleName() +
            "[] is not compatible with data type " + mType.mElement.mType.name() +
            " of allocation");
!!!72596535.java!!!	getIDSafe() : long
        if (mAdaptedAllocation != null) {
            return mAdaptedAllocation.getID(mRS);
        }
        return getID(mRS);
!!!72596663.java!!!	getElement() : Element
        return mType.getElement();
!!!72596791.java!!!	getUsage() : int
        return mUsage;
!!!72596919.java!!!	getMipmap() : Allocation::MipmapControl
        return mMipmapControl;
!!!72597047.java!!!	setAutoPadding(inout useAutoPadding : boolean) : void
        mAutoPadding = useAutoPadding;
!!!72597175.java!!!	getBytesSize() : int
        if (mType.mDimYuv != 0) {
            return (int)Math.ceil(mType.getCount() * mType.getElement().getBytesSize() * 1.5);
        }
        return mType.getCount() * mType.getElement().getBytesSize();
!!!72597303.java!!!	updateCacheInfo(inout t : Type) : void
        mCurrentDimX = t.getX();
        mCurrentDimY = t.getY();
        mCurrentDimZ = t.getZ();
        mCurrentCount = mCurrentDimX;
        if (mCurrentDimY > 1) {
            mCurrentCount *= mCurrentDimY;
        }
        if (mCurrentDimZ > 1) {
            mCurrentCount *= mCurrentDimZ;
        }
!!!72597431.java!!!	setBitmap(inout b : Bitmap) : void
        mBitmap = b;
!!!72597559.java!!!	Allocation(in id : long, inout rs : RenderScript, inout t : Type, in usage : int)
        super(id, rs);
        if ((usage & ~(USAGE_SCRIPT |
                       USAGE_GRAPHICS_TEXTURE |
                       USAGE_GRAPHICS_VERTEX |
                       USAGE_GRAPHICS_CONSTANTS |
                       USAGE_GRAPHICS_RENDER_TARGET |
                       USAGE_IO_INPUT |
                       USAGE_IO_OUTPUT |
                       USAGE_SHARED)) != 0) {
            throw new RSIllegalArgumentException("Unknown usage specified.");
        }

        if ((usage & USAGE_IO_INPUT) != 0) {
            mWriteAllowed = false;

            if ((usage & ~(USAGE_IO_INPUT |
                           USAGE_GRAPHICS_TEXTURE |
                           USAGE_SCRIPT)) != 0) {
                throw new RSIllegalArgumentException("Invalid usage combination.");
            }
        }

        mType = t;
        mUsage = usage;

        if (t != null) {
            // TODO: A3D doesn't have Type info during creation, so we can't
            // calculate the size ahead of time. We can possibly add a method
            // to update the size in the future if it seems reasonable.
            mSize = mType.getCount() * mType.getElement().getBytesSize();
            updateCacheInfo(t);
        }
        try {
            RenderScript.registerNativeAllocation.invoke(RenderScript.sRuntime, mSize);
        } catch (Exception e) {
            Log.e(RenderScript.LOG_TAG, "Couldn't invoke registerNativeAllocation:" + e);
            throw new RSRuntimeException("Couldn't invoke registerNativeAllocation:" + e);
        }
        guard.open("destroy");
!!!72597687.java!!!	Allocation(in id : long, inout rs : RenderScript, inout t : Type, inout owningType : boolean, in usage : int, inout mips : Allocation::MipmapControl)
        this(id, rs, t, usage);
        mOwningType = owningType;
        mMipmapControl = mips;
!!!72597815.java!!!	finalize() : void
        RenderScript.registerNativeFree.invoke(RenderScript.sRuntime, mSize);
        super.finalize();
!!!72597943.java!!!	validateIsInt64() : void
        if ((mType.mElement.mType == Element.DataType.SIGNED_64) ||
            (mType.mElement.mType == Element.DataType.UNSIGNED_64)) {
            return;
        }
        throw new RSIllegalArgumentException(
            "64 bit integer source does not match allocation type " + mType.mElement.mType);
!!!72598071.java!!!	validateIsInt32() : void
        if ((mType.mElement.mType == Element.DataType.SIGNED_32) ||
            (mType.mElement.mType == Element.DataType.UNSIGNED_32)) {
            return;
        }
        throw new RSIllegalArgumentException(
            "32 bit integer source does not match allocation type " + mType.mElement.mType);
!!!72598199.java!!!	validateIsInt16OrFloat16() : void
        if ((mType.mElement.mType == Element.DataType.SIGNED_16) ||
            (mType.mElement.mType == Element.DataType.UNSIGNED_16) ||
            (mType.mElement.mType == Element.DataType.FLOAT_16)) {
            return;
        }
        throw new RSIllegalArgumentException(
            "16 bit integer source does not match allocation type " + mType.mElement.mType);
!!!72598327.java!!!	validateIsInt8() : void
        if ((mType.mElement.mType == Element.DataType.SIGNED_8) ||
            (mType.mElement.mType == Element.DataType.UNSIGNED_8)) {
            return;
        }
        throw new RSIllegalArgumentException(
            "8 bit integer source does not match allocation type " + mType.mElement.mType);
!!!72598455.java!!!	validateIsFloat32() : void
        if (mType.mElement.mType == Element.DataType.FLOAT_32) {
            return;
        }
        throw new RSIllegalArgumentException(
            "32 bit float source does not match allocation type " + mType.mElement.mType);
!!!72598583.java!!!	validateIsFloat64() : void
        if (mType.mElement.mType == Element.DataType.FLOAT_64) {
            return;
        }
        throw new RSIllegalArgumentException(
            "64 bit float source does not match allocation type " + mType.mElement.mType);
!!!72598711.java!!!	validateIsObject() : void
        if ((mType.mElement.mType == Element.DataType.RS_ELEMENT) ||
            (mType.mElement.mType == Element.DataType.RS_TYPE) ||
            (mType.mElement.mType == Element.DataType.RS_ALLOCATION) ||
            (mType.mElement.mType == Element.DataType.RS_SAMPLER) ||
            (mType.mElement.mType == Element.DataType.RS_SCRIPT) ||
            (mType.mElement.mType == Element.DataType.RS_MESH) ||
            (mType.mElement.mType == Element.DataType.RS_PROGRAM_FRAGMENT) ||
            (mType.mElement.mType == Element.DataType.RS_PROGRAM_VERTEX) ||
            (mType.mElement.mType == Element.DataType.RS_PROGRAM_RASTER) ||
            (mType.mElement.mType == Element.DataType.RS_PROGRAM_STORE)) {
            return;
        }
        throw new RSIllegalArgumentException(
            "Object source does not match allocation type " + mType.mElement.mType);
!!!72598839.java!!!	updateFromNative() : void
        super.updateFromNative();
        long typeID = mRS.nAllocationGetType(getID(mRS));
        if(typeID != 0) {
            mType = new Type(typeID, mRS);
            mType.updateFromNative();
            updateCacheInfo(mType);
        }
!!!72598967.java!!!	getType() : Type
        return mType;
!!!72599095.java!!!	syncAll(in srcLocation : int) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "syncAll");
            switch (srcLocation) {
                case USAGE_GRAPHICS_TEXTURE:
                case USAGE_SCRIPT:
                    if ((mUsage & USAGE_SHARED) != 0) {
                        copyFrom(mBitmap);
                    }
                    break;
                case USAGE_GRAPHICS_CONSTANTS:
                case USAGE_GRAPHICS_VERTEX:
                    break;
                case USAGE_SHARED:
                    if ((mUsage & USAGE_SHARED) != 0) {
                        copyTo(mBitmap);
                    }
                    break;
                default:
                    throw new RSIllegalArgumentException("Source must be exactly one usage type.");
            }
            mRS.validate();
            mRS.nAllocationSyncAll(getIDSafe(), srcLocation);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72599223.java!!!	ioSend() : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "ioSend");
            if ((mUsage & USAGE_IO_OUTPUT) == 0) {
                throw new RSIllegalArgumentException(
                    "Can only send buffer if IO_OUTPUT usage specified.");
            }
            mRS.validate();
            mRS.nAllocationIoSend(getID(mRS));
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72599351.java!!!	ioReceive() : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "ioReceive");
            if ((mUsage & USAGE_IO_INPUT) == 0) {
                throw new RSIllegalArgumentException(
                    "Can only receive if IO_INPUT usage specified.");
            }
            mRS.validate();
            mTimeStamp = mRS.nAllocationIoReceive(getID(mRS));
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72599479.java!!!	copyFrom(inout d : BaseObj [[]]) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copyFrom");
            mRS.validate();
            validateIsObject();
            if (d.length != mCurrentCount) {
                throw new RSIllegalArgumentException("Array size mismatch, allocation sizeX = " +
                                                      mCurrentCount + ", array length = " + d.length);
            }

            if (RenderScript.sPointerSize == 8) {
                long i[] = new long[d.length * 4];
                for (int ct=0; ct < d.length; ct++) {
                    i[ct * 4] = d[ct].getID(mRS);
                }
                copy1DRangeFromUnchecked(0, mCurrentCount, i);
            } else {
                int i[] = new int[d.length];
                for (int ct=0; ct < d.length; ct++) {
                    i[ct] = (int) d[ct].getID(mRS);
                }
                copy1DRangeFromUnchecked(0, mCurrentCount, i);
            }
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72599607.java!!!	validateBitmapFormat(inout b : Bitmap) : void
        Bitmap.Config bc = b.getConfig();
        if (bc == null) {
            throw new RSIllegalArgumentException("Bitmap has an unsupported format for this operation");
        }
        switch (bc) {
        case ALPHA_8:
            if (mType.getElement().mKind != Element.DataKind.PIXEL_A) {
                throw new RSIllegalArgumentException("Allocation kind is " +
                                                     mType.getElement().mKind + ", type " +
                                                     mType.getElement().mType +
                                                     " of " + mType.getElement().getBytesSize() +
                                                     " bytes, passed bitmap was " + bc);
            }
            break;
        case ARGB_8888:
            if ((mType.getElement().mKind != Element.DataKind.PIXEL_RGBA) ||
                (mType.getElement().getBytesSize() != 4)) {
                throw new RSIllegalArgumentException("Allocation kind is " +
                                                     mType.getElement().mKind + ", type " +
                                                     mType.getElement().mType +
                                                     " of " + mType.getElement().getBytesSize() +
                                                     " bytes, passed bitmap was " + bc);
            }
            break;
        case RGB_565:
            if ((mType.getElement().mKind != Element.DataKind.PIXEL_RGB) ||
                (mType.getElement().getBytesSize() != 2)) {
                throw new RSIllegalArgumentException("Allocation kind is " +
                                                     mType.getElement().mKind + ", type " +
                                                     mType.getElement().mType +
                                                     " of " + mType.getElement().getBytesSize() +
                                                     " bytes, passed bitmap was " + bc);
            }
            break;
        case ARGB_4444:
            if ((mType.getElement().mKind != Element.DataKind.PIXEL_RGBA) ||
                (mType.getElement().getBytesSize() != 2)) {
                throw new RSIllegalArgumentException("Allocation kind is " +
                                                     mType.getElement().mKind + ", type " +
                                                     mType.getElement().mType +
                                                     " of " + mType.getElement().getBytesSize() +
                                                     " bytes, passed bitmap was " + bc);
            }
            break;

        }
!!!72599735.java!!!	validateBitmapSize(inout b : Bitmap) : void
        if((mCurrentDimX != b.getWidth()) || (mCurrentDimY != b.getHeight())) {
            throw new RSIllegalArgumentException("Cannot update allocation from bitmap, sizes mismatch");
        }
!!!72599863.java!!!	copyFromUnchecked(inout array : Object, inout dt : Element::DataType, in arrayLen : int) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copyFromUnchecked");
            mRS.validate();
            if (mCurrentDimZ > 0) {
                copy3DRangeFromUnchecked(0, 0, 0, mCurrentDimX, mCurrentDimY, mCurrentDimZ, array, dt, arrayLen);
            } else if (mCurrentDimY > 0) {
                copy2DRangeFromUnchecked(0, 0, mCurrentDimX, mCurrentDimY, array, dt, arrayLen);
            } else {
                copy1DRangeFromUnchecked(0, mCurrentCount, array, dt, arrayLen);
            }
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72599991.java!!!	copyFromUnchecked(inout array : Object) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copyFromUnchecked");
            copyFromUnchecked(array, validateObjectIsPrimitiveArray(array, false),
                              java.lang.reflect.Array.getLength(array));
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72600119.java!!!	copyFromUnchecked(inout d : int [[]]) : void
        copyFromUnchecked(d, Element.DataType.SIGNED_32, d.length);
!!!72600247.java!!!	copyFromUnchecked(inout d : short [[]]) : void
        copyFromUnchecked(d, Element.DataType.SIGNED_16, d.length);
!!!72600375.java!!!	copyFromUnchecked(inout d : byte [[]]) : void
        copyFromUnchecked(d, Element.DataType.SIGNED_8, d.length);
!!!72600503.java!!!	copyFromUnchecked(inout d : float [[]]) : void
        copyFromUnchecked(d, Element.DataType.FLOAT_32, d.length);
!!!72600631.java!!!	copyFrom(inout array : Object) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copyFrom");
            copyFromUnchecked(array, validateObjectIsPrimitiveArray(array, true),
                              java.lang.reflect.Array.getLength(array));
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72600759.java!!!	copyFrom(inout d : int [[]]) : void
        validateIsInt32();
        copyFromUnchecked(d, Element.DataType.SIGNED_32, d.length);
!!!72600887.java!!!	copyFrom(inout d : short [[]]) : void
        validateIsInt16OrFloat16();
        copyFromUnchecked(d, Element.DataType.SIGNED_16, d.length);
!!!72601015.java!!!	copyFrom(inout d : byte [[]]) : void
        validateIsInt8();
        copyFromUnchecked(d, Element.DataType.SIGNED_8, d.length);
!!!72601143.java!!!	copyFrom(inout d : float [[]]) : void
        validateIsFloat32();
        copyFromUnchecked(d, Element.DataType.FLOAT_32, d.length);
!!!72601271.java!!!	copyFrom(inout b : Bitmap) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copyFrom");
            mRS.validate();
            if (b.getConfig() == null) {
                Bitmap newBitmap = Bitmap.createBitmap(b.getWidth(), b.getHeight(), Bitmap.Config.ARGB_8888);
                Canvas c = new Canvas(newBitmap);
                c.drawBitmap(b, 0, 0, null);
                copyFrom(newBitmap);
                return;
            }
            validateBitmapSize(b);
            validateBitmapFormat(b);
            mRS.nAllocationCopyFromBitmap(getID(mRS), b);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72601399.java!!!	copyFrom(inout a : Allocation) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copyFrom");
            mRS.validate();
            if (!mType.equals(a.getType())) {
                throw new RSIllegalArgumentException("Types of allocations must match.");
            }
            copy2DRangeFrom(0, 0, mCurrentDimX, mCurrentDimY, a, 0, 0);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72601527.java!!!	setFromFieldPacker(in xoff : int, inout fp : FieldPacker) : void
        mRS.validate();
        int eSize = mType.mElement.getBytesSize();
        final byte[] data = fp.getData();
        int data_length = fp.getPos();

        int count = data_length / eSize;
        if ((eSize * count) != data_length) {
            throw new RSIllegalArgumentException("Field packer length " + data_length +
                                               " not divisible by element size " + eSize + ".");
        }
        copy1DRangeFromUnchecked(xoff, count, data);
!!!72601655.java!!!	setFromFieldPacker(in xoff : int, in component_number : int, inout fp : FieldPacker) : void
        setFromFieldPacker(xoff, 0, 0, component_number, fp);
!!!72601783.java!!!	setFromFieldPacker(in xoff : int, in yoff : int, in zoff : int, in component_number : int, inout fp : FieldPacker) : void
        mRS.validate();
        if (component_number >= mType.mElement.mElements.length) {
            throw new RSIllegalArgumentException("Component_number " + component_number + " out of range.");
        }
        if(xoff < 0) {
            throw new RSIllegalArgumentException("Offset x must be >= 0.");
        }
        if(yoff < 0) {
            throw new RSIllegalArgumentException("Offset y must be >= 0.");
        }
        if(zoff < 0) {
            throw new RSIllegalArgumentException("Offset z must be >= 0.");
        }

        final byte[] data = fp.getData();
        int data_length = fp.getPos();
        int eSize = mType.mElement.mElements[component_number].getBytesSize();
        eSize *= mType.mElement.mArraySizes[component_number];

        if (data_length != eSize) {
            throw new RSIllegalArgumentException("Field packer sizelength " + data_length +
                                               " does not match component size " + eSize + ".");
        }

        mRS.nAllocationElementData(getIDSafe(), xoff, yoff, zoff, mSelectedLOD,
                                   component_number, data, data_length);
!!!72601911.java!!!	data1DChecks(in off : int, in count : int, in len : int, in dataSize : int, inout usePadding : boolean) : void
        mRS.validate();
        if(off < 0) {
            throw new RSIllegalArgumentException("Offset must be >= 0.");
        }
        if(count < 1) {
            throw new RSIllegalArgumentException("Count must be >= 1.");
        }
        if((off + count) > mCurrentCount) {
            throw new RSIllegalArgumentException("Overflow, Available count " + mCurrentCount +
                                               ", got " + count + " at offset " + off + ".");
        }
        if(usePadding) {
            if(len < dataSize / 4 * 3) {
                throw new RSIllegalArgumentException("Array too small for allocation type.");
            }
        } else {
            if(len < dataSize) {
                throw new RSIllegalArgumentException("Array too small for allocation type.");
            }
        }
!!!72602039.java!!!	generateMipmaps() : void
        mRS.nAllocationGenerateMipmaps(getID(mRS));
!!!72602167.java!!!	copy1DRangeFromUnchecked(in off : int, in count : int, inout array : Object, inout dt : Element::DataType, in arrayLen : int) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copy1DRangeFromUnchecked");
            final int dataSize = mType.mElement.getBytesSize() * count;
            // AutoPadding for Vec3 Element
            boolean usePadding = false;
            if (mAutoPadding && (mType.getElement().getVectorSize() == 3)) {
                usePadding = true;
            }
            data1DChecks(off, count, arrayLen * dt.mSize, dataSize, usePadding);
            mRS.nAllocationData1D(getIDSafe(), off, mSelectedLOD, count, array, dataSize, dt,
                                  mType.mElement.mType.mSize, usePadding);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72602295.java!!!	copy1DRangeFromUnchecked(in off : int, in count : int, inout array : Object) : void
        copy1DRangeFromUnchecked(off, count, array,
                                 validateObjectIsPrimitiveArray(array, false),
                                 java.lang.reflect.Array.getLength(array));
!!!72602423.java!!!	copy1DRangeFromUnchecked(in off : int, in count : int, inout d : int [[]]) : void
        copy1DRangeFromUnchecked(off, count, (Object)d, Element.DataType.SIGNED_32, d.length);
!!!72602551.java!!!	copy1DRangeFromUnchecked(in off : int, in count : int, inout d : short [[]]) : void
        copy1DRangeFromUnchecked(off, count, (Object)d, Element.DataType.SIGNED_16, d.length);
!!!72602679.java!!!	copy1DRangeFromUnchecked(in off : int, in count : int, inout d : byte [[]]) : void
        copy1DRangeFromUnchecked(off, count, (Object)d, Element.DataType.SIGNED_8, d.length);
!!!72602807.java!!!	copy1DRangeFromUnchecked(in off : int, in count : int, inout d : float [[]]) : void
        copy1DRangeFromUnchecked(off, count, (Object)d, Element.DataType.FLOAT_32, d.length);
!!!72602935.java!!!	copy1DRangeFrom(in off : int, in count : int, inout array : Object) : void
        copy1DRangeFromUnchecked(off, count, array,
                                 validateObjectIsPrimitiveArray(array, true),
                                 java.lang.reflect.Array.getLength(array));
!!!72603063.java!!!	copy1DRangeFrom(in off : int, in count : int, inout d : int [[]]) : void
        validateIsInt32();
        copy1DRangeFromUnchecked(off, count, d, Element.DataType.SIGNED_32, d.length);
!!!72603191.java!!!	copy1DRangeFrom(in off : int, in count : int, inout d : short [[]]) : void
        validateIsInt16OrFloat16();
        copy1DRangeFromUnchecked(off, count, d, Element.DataType.SIGNED_16, d.length);
!!!72603319.java!!!	copy1DRangeFrom(in off : int, in count : int, inout d : byte [[]]) : void
        validateIsInt8();
        copy1DRangeFromUnchecked(off, count, d, Element.DataType.SIGNED_8, d.length);
!!!72603447.java!!!	copy1DRangeFrom(in off : int, in count : int, inout d : float [[]]) : void
        validateIsFloat32();
        copy1DRangeFromUnchecked(off, count, d, Element.DataType.FLOAT_32, d.length);
!!!72603575.java!!!	copy1DRangeFrom(in off : int, in count : int, inout data : Allocation, in dataOff : int) : void
        Trace.traceBegin(RenderScript.TRACE_TAG, "copy1DRangeFrom");
        mRS.nAllocationData2D(getIDSafe(), off, 0,
                              mSelectedLOD, mSelectedFace.mID,
                              count, 1, data.getID(mRS), dataOff, 0,
                              data.mSelectedLOD, data.mSelectedFace.mID);
        Trace.traceEnd(RenderScript.TRACE_TAG);
!!!72603703.java!!!	validate2DRange(in xoff : int, in yoff : int, in w : int, in h : int) : void
        if (mAdaptedAllocation != null) {

        } else {

            if (xoff < 0 || yoff < 0) {
                throw new RSIllegalArgumentException("Offset cannot be negative.");
            }
            if (h < 0 || w < 0) {
                throw new RSIllegalArgumentException("Height or width cannot be negative.");
            }
            if (((xoff + w) > mCurrentDimX) || ((yoff + h) > mCurrentDimY)) {
                throw new RSIllegalArgumentException("Updated region larger than allocation.");
            }
        }
!!!72603831.java!!!	copy2DRangeFromUnchecked(in xoff : int, in yoff : int, in w : int, in h : int, inout array : Object, inout dt : Element::DataType, in arrayLen : int) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copy2DRangeFromUnchecked");
            mRS.validate();
            validate2DRange(xoff, yoff, w, h);
            final int dataSize = mType.mElement.getBytesSize() * w * h;
            // AutoPadding for Vec3 Element
            boolean usePadding = false;
            int sizeBytes = arrayLen * dt.mSize;
            if (mAutoPadding && (mType.getElement().getVectorSize() == 3)) {
                if (dataSize / 4 * 3 > sizeBytes) {
                    throw new RSIllegalArgumentException("Array too small for allocation type.");
                }
                usePadding = true;
                sizeBytes = dataSize;
            } else {
                if (dataSize > sizeBytes) {
                    throw new RSIllegalArgumentException("Array too small for allocation type.");
                }
            }
            mRS.nAllocationData2D(getIDSafe(), xoff, yoff, mSelectedLOD, mSelectedFace.mID, w, h,
                                  array, sizeBytes, dt,
                                  mType.mElement.mType.mSize, usePadding);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72603959.java!!!	copy2DRangeFrom(in xoff : int, in yoff : int, in w : int, in h : int, inout array : Object) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copy2DRangeFrom");
            copy2DRangeFromUnchecked(xoff, yoff, w, h, array,
                                     validateObjectIsPrimitiveArray(array, true),
                                     java.lang.reflect.Array.getLength(array));
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72604087.java!!!	copy2DRangeFrom(in xoff : int, in yoff : int, in w : int, in h : int, inout data : byte [[]]) : void
        validateIsInt8();
        copy2DRangeFromUnchecked(xoff, yoff, w, h, data,
                                 Element.DataType.SIGNED_8, data.length);
!!!72604215.java!!!	copy2DRangeFrom(in xoff : int, in yoff : int, in w : int, in h : int, inout data : short [[]]) : void
        validateIsInt16OrFloat16();
        copy2DRangeFromUnchecked(xoff, yoff, w, h, data,
                                 Element.DataType.SIGNED_16, data.length);
!!!72604343.java!!!	copy2DRangeFrom(in xoff : int, in yoff : int, in w : int, in h : int, inout data : int [[]]) : void
        validateIsInt32();
        copy2DRangeFromUnchecked(xoff, yoff, w, h, data,
                                 Element.DataType.SIGNED_32, data.length);
!!!72604471.java!!!	copy2DRangeFrom(in xoff : int, in yoff : int, in w : int, in h : int, inout data : float [[]]) : void
        validateIsFloat32();
        copy2DRangeFromUnchecked(xoff, yoff, w, h, data,
                                 Element.DataType.FLOAT_32, data.length);
!!!72604599.java!!!	copy2DRangeFrom(in xoff : int, in yoff : int, in w : int, in h : int, inout data : Allocation, in dataXoff : int, in dataYoff : int) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copy2DRangeFrom");
            mRS.validate();
            validate2DRange(xoff, yoff, w, h);
            mRS.nAllocationData2D(getIDSafe(), xoff, yoff,
                                  mSelectedLOD, mSelectedFace.mID,
                                  w, h, data.getID(mRS), dataXoff, dataYoff,
                                  data.mSelectedLOD, data.mSelectedFace.mID);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72604727.java!!!	copy2DRangeFrom(in xoff : int, in yoff : int, inout data : Bitmap) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copy2DRangeFrom");
            mRS.validate();
            if (data.getConfig() == null) {
                Bitmap newBitmap = Bitmap.createBitmap(data.getWidth(), data.getHeight(), Bitmap.Config.ARGB_8888);
                Canvas c = new Canvas(newBitmap);
                c.drawBitmap(data, 0, 0, null);
                copy2DRangeFrom(xoff, yoff, newBitmap);
                return;
            }
            validateBitmapFormat(data);
            validate2DRange(xoff, yoff, data.getWidth(), data.getHeight());
            mRS.nAllocationData2D(getIDSafe(), xoff, yoff, mSelectedLOD, mSelectedFace.mID, data);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72604855.java!!!	validate3DRange(in xoff : int, in yoff : int, in zoff : int, in w : int, in h : int, in d : int) : void
        if (mAdaptedAllocation != null) {

        } else {

            if (xoff < 0 || yoff < 0 || zoff < 0) {
                throw new RSIllegalArgumentException("Offset cannot be negative.");
            }
            if (h < 0 || w < 0 || d < 0) {
                throw new RSIllegalArgumentException("Height or width cannot be negative.");
            }
            if (((xoff + w) > mCurrentDimX) || ((yoff + h) > mCurrentDimY) || ((zoff + d) > mCurrentDimZ)) {
                throw new RSIllegalArgumentException("Updated region larger than allocation.");
            }
        }
!!!72604983.java!!!	copy3DRangeFromUnchecked(in xoff : int, in yoff : int, in zoff : int, in w : int, in h : int, in d : int, inout array : Object, inout dt : Element::DataType, in arrayLen : int) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copy3DRangeFromUnchecked");
            mRS.validate();
            validate3DRange(xoff, yoff, zoff, w, h, d);
            final int dataSize = mType.mElement.getBytesSize() * w * h * d;
            // AutoPadding for Vec3 Element
            boolean usePadding = false;
            int sizeBytes = arrayLen * dt.mSize;
            if (mAutoPadding && (mType.getElement().getVectorSize() == 3)) {
                if (dataSize / 4 * 3 > sizeBytes) {
                    throw new RSIllegalArgumentException("Array too small for allocation type.");
                }
                usePadding = true;
                sizeBytes = dataSize;
            } else {
                if (dataSize > sizeBytes) {
                    throw new RSIllegalArgumentException("Array too small for allocation type.");
                }
            }
            mRS.nAllocationData3D(getIDSafe(), xoff, yoff, zoff, mSelectedLOD, w, h, d,
                                  array, sizeBytes, dt,
                                  mType.mElement.mType.mSize, usePadding);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72605111.java!!!	copy3DRangeFrom(in xoff : int, in yoff : int, in zoff : int, in w : int, in h : int, in d : int, inout array : Object) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copy3DRangeFrom");
            copy3DRangeFromUnchecked(xoff, yoff, zoff, w, h, d, array,
                                     validateObjectIsPrimitiveArray(array, true),
                                     java.lang.reflect.Array.getLength(array));
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72605239.java!!!	copy3DRangeFrom(in xoff : int, in yoff : int, in zoff : int, in w : int, in h : int, in d : int, inout data : Allocation, in dataXoff : int, in dataYoff : int, in dataZoff : int) : void
        mRS.validate();
        validate3DRange(xoff, yoff, zoff, w, h, d);
        mRS.nAllocationData3D(getIDSafe(), xoff, yoff, zoff, mSelectedLOD,
                              w, h, d, data.getID(mRS), dataXoff, dataYoff, dataZoff,
                              data.mSelectedLOD);
!!!72605367.java!!!	copyTo(inout b : Bitmap) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copyTo");
            mRS.validate();
            validateBitmapFormat(b);
            validateBitmapSize(b);
            mRS.nAllocationCopyToBitmap(getID(mRS), b);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72605495.java!!!	copyTo(inout array : Object, inout dt : Element::DataType, in arrayLen : int) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copyTo");
            mRS.validate();
            boolean usePadding = false;
            if (mAutoPadding && (mType.getElement().getVectorSize() == 3)) {
                usePadding = true;
            }
            if (usePadding) {
                if (dt.mSize * arrayLen < mSize / 4 * 3) {
                    throw new RSIllegalArgumentException(
                        "Size of output array cannot be smaller than size of allocation.");
                }
            } else {
                if (dt.mSize * arrayLen < mSize) {
                    throw new RSIllegalArgumentException(
                        "Size of output array cannot be smaller than size of allocation.");
                }
            }
            mRS.nAllocationRead(getID(mRS), array, dt, mType.mElement.mType.mSize, usePadding);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72605623.java!!!	copyTo(inout array : Object) : void
        copyTo(array, validateObjectIsPrimitiveArray(array, true),
               java.lang.reflect.Array.getLength(array));
!!!72605751.java!!!	copyTo(inout d : byte [[]]) : void
        validateIsInt8();
        copyTo(d, Element.DataType.SIGNED_8, d.length);
!!!72605879.java!!!	copyTo(inout d : short [[]]) : void
        validateIsInt16OrFloat16();
        copyTo(d, Element.DataType.SIGNED_16, d.length);
!!!72606007.java!!!	copyTo(inout d : int [[]]) : void
        validateIsInt32();
        copyTo(d, Element.DataType.SIGNED_32, d.length);
!!!72606135.java!!!	copyTo(inout d : float [[]]) : void
        validateIsFloat32();
        copyTo(d, Element.DataType.FLOAT_32, d.length);
!!!72606263.java!!!	copyToFieldPacker(in xoff : int, in yoff : int, in zoff : int, in component_number : int, inout fp : FieldPacker) : void
        mRS.validate();
        if (component_number >= mType.mElement.mElements.length) {
            throw new RSIllegalArgumentException("Component_number " + component_number + " out of range.");
        }
        if(xoff < 0) {
            throw new RSIllegalArgumentException("Offset x must be >= 0.");
        }
        if(yoff < 0) {
            throw new RSIllegalArgumentException("Offset y must be >= 0.");
        }
        if(zoff < 0) {
            throw new RSIllegalArgumentException("Offset z must be >= 0.");
        }

        final byte[] data = fp.getData();
        int data_length = data.length;
        int eSize = mType.mElement.mElements[component_number].getBytesSize();
        eSize *= mType.mElement.mArraySizes[component_number];

        if (data_length != eSize) {
            throw new RSIllegalArgumentException("Field packer sizelength " + data_length +
                                               " does not match component size " + eSize + ".");
        }

        mRS.nAllocationElementRead(getIDSafe(), xoff, yoff, zoff, mSelectedLOD,
                                   component_number, data, data_length);
!!!72606391.java!!!	resize(in dimX : int) : void
        if (mRS.getApplicationContext().getApplicationInfo().targetSdkVersion >= 21) {
            throw new RSRuntimeException("Resize is not allowed in API 21+.");
        }
        if ((mType.getY() > 0)|| (mType.getZ() > 0) || mType.hasFaces() || mType.hasMipmaps()) {
            throw new RSInvalidStateException("Resize only support for 1D allocations at this time.");
        }
        mRS.nAllocationResize1D(getID(mRS), dimX);
        mRS.finish();  // Necessary because resize is fifoed and update is async.

        long typeID = mRS.nAllocationGetType(getID(mRS));
        // Sets zero the mID so that the finalizer of the old mType value won't
        // destroy the native object that is being reused.
        mType.setID(0);
        mType = new Type(typeID, mRS);
        mType.updateFromNative();
        updateCacheInfo(mType);
!!!72606519.java!!!	copy1DRangeToUnchecked(in off : int, in count : int, inout array : Object, inout dt : Element::DataType, in arrayLen : int) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copy1DRangeToUnchecked");
            final int dataSize = mType.mElement.getBytesSize() * count;
            // AutoPadding for Vec3 Element
            boolean usePadding = false;
            if (mAutoPadding && (mType.getElement().getVectorSize() == 3)) {
                usePadding = true;
            }
            data1DChecks(off, count, arrayLen * dt.mSize, dataSize, usePadding);
            mRS.nAllocationRead1D(getIDSafe(), off, mSelectedLOD, count, array, dataSize, dt,
                                  mType.mElement.mType.mSize, usePadding);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72606647.java!!!	copy1DRangeToUnchecked(in off : int, in count : int, inout array : Object) : void
        copy1DRangeToUnchecked(off, count, array,
                               validateObjectIsPrimitiveArray(array, false),
                               java.lang.reflect.Array.getLength(array));
!!!72606775.java!!!	copy1DRangeToUnchecked(in off : int, in count : int, inout d : int [[]]) : void
        copy1DRangeToUnchecked(off, count, (Object)d, Element.DataType.SIGNED_32, d.length);
!!!72606903.java!!!	copy1DRangeToUnchecked(in off : int, in count : int, inout d : short [[]]) : void
        copy1DRangeToUnchecked(off, count, (Object)d, Element.DataType.SIGNED_16, d.length);
!!!72607031.java!!!	copy1DRangeToUnchecked(in off : int, in count : int, inout d : byte [[]]) : void
        copy1DRangeToUnchecked(off, count, (Object)d, Element.DataType.SIGNED_8, d.length);
!!!72607159.java!!!	copy1DRangeToUnchecked(in off : int, in count : int, inout d : float [[]]) : void
        copy1DRangeToUnchecked(off, count, (Object)d, Element.DataType.FLOAT_32, d.length);
!!!72607287.java!!!	copy1DRangeTo(in off : int, in count : int, inout array : Object) : void
        copy1DRangeToUnchecked(off, count, array,
                               validateObjectIsPrimitiveArray(array, true),
                               java.lang.reflect.Array.getLength(array));
!!!72607415.java!!!	copy1DRangeTo(in off : int, in count : int, inout d : int [[]]) : void
        validateIsInt32();
        copy1DRangeToUnchecked(off, count, d, Element.DataType.SIGNED_32, d.length);
!!!72607543.java!!!	copy1DRangeTo(in off : int, in count : int, inout d : short [[]]) : void
        validateIsInt16OrFloat16();
        copy1DRangeToUnchecked(off, count, d, Element.DataType.SIGNED_16, d.length);
!!!72607671.java!!!	copy1DRangeTo(in off : int, in count : int, inout d : byte [[]]) : void
        validateIsInt8();
        copy1DRangeToUnchecked(off, count, d, Element.DataType.SIGNED_8, d.length);
!!!72607799.java!!!	copy1DRangeTo(in off : int, in count : int, inout d : float [[]]) : void
        validateIsFloat32();
        copy1DRangeToUnchecked(off, count, d, Element.DataType.FLOAT_32, d.length);
!!!72607927.java!!!	copy2DRangeToUnchecked(in xoff : int, in yoff : int, in w : int, in h : int, inout array : Object, inout dt : Element::DataType, in arrayLen : int) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copy2DRangeToUnchecked");
            mRS.validate();
            validate2DRange(xoff, yoff, w, h);
            final int dataSize = mType.mElement.getBytesSize() * w * h;
            // AutoPadding for Vec3 Element
            boolean usePadding = false;
            int sizeBytes = arrayLen * dt.mSize;
            if (mAutoPadding && (mType.getElement().getVectorSize() == 3)) {
                if (dataSize / 4 * 3 > sizeBytes) {
                    throw new RSIllegalArgumentException("Array too small for allocation type.");
                }
                usePadding = true;
                sizeBytes = dataSize;
            } else {
                if (dataSize > sizeBytes) {
                    throw new RSIllegalArgumentException("Array too small for allocation type.");
                }
            }
            mRS.nAllocationRead2D(getIDSafe(), xoff, yoff, mSelectedLOD, mSelectedFace.mID, w, h,
                                  array, sizeBytes, dt, mType.mElement.mType.mSize, usePadding);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72608055.java!!!	copy2DRangeTo(in xoff : int, in yoff : int, in w : int, in h : int, inout array : Object) : void
        copy2DRangeToUnchecked(xoff, yoff, w, h, array,
                               validateObjectIsPrimitiveArray(array, true),
                               java.lang.reflect.Array.getLength(array));
!!!72608183.java!!!	copy2DRangeTo(in xoff : int, in yoff : int, in w : int, in h : int, inout data : byte [[]]) : void
        validateIsInt8();
        copy2DRangeToUnchecked(xoff, yoff, w, h, data,
                               Element.DataType.SIGNED_8, data.length);
!!!72608311.java!!!	copy2DRangeTo(in xoff : int, in yoff : int, in w : int, in h : int, inout data : short [[]]) : void
        validateIsInt16OrFloat16();
        copy2DRangeToUnchecked(xoff, yoff, w, h, data,
                               Element.DataType.SIGNED_16, data.length);
!!!72608439.java!!!	copy2DRangeTo(in xoff : int, in yoff : int, in w : int, in h : int, inout data : int [[]]) : void
        validateIsInt32();
        copy2DRangeToUnchecked(xoff, yoff, w, h, data,
                               Element.DataType.SIGNED_32, data.length);
!!!72608567.java!!!	copy2DRangeTo(in xoff : int, in yoff : int, in w : int, in h : int, inout data : float [[]]) : void
        validateIsFloat32();
        copy2DRangeToUnchecked(xoff, yoff, w, h, data,
                               Element.DataType.FLOAT_32, data.length);
!!!72608695.java!!!	copy3DRangeToUnchecked(in xoff : int, in yoff : int, in zoff : int, in w : int, in h : int, in d : int, inout array : Object, inout dt : Element::DataType, in arrayLen : int) : void
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "copy3DRangeToUnchecked");
            mRS.validate();
            validate3DRange(xoff, yoff, zoff, w, h, d);
            final int dataSize = mType.mElement.getBytesSize() * w * h * d;
            // AutoPadding for Vec3 Element
            boolean usePadding = false;
            int sizeBytes = arrayLen * dt.mSize;
            if (mAutoPadding && (mType.getElement().getVectorSize() == 3)) {
                if (dataSize / 4 * 3 > sizeBytes) {
                    throw new RSIllegalArgumentException("Array too small for allocation type.");
                }
                usePadding = true;
                sizeBytes = dataSize;
            } else {
                if (dataSize > sizeBytes) {
                    throw new RSIllegalArgumentException("Array too small for allocation type.");
                }
            }
            mRS.nAllocationRead3D(getIDSafe(), xoff, yoff, zoff, mSelectedLOD, w, h, d,
                                  array, sizeBytes, dt, mType.mElement.mType.mSize, usePadding);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72608823.java!!!	copy3DRangeTo(in xoff : int, in yoff : int, in zoff : int, in w : int, in h : int, in d : int, inout array : Object) : void
        copy3DRangeToUnchecked(xoff, yoff, zoff, w, h, d, array,
                                 validateObjectIsPrimitiveArray(array, true),
                                 java.lang.reflect.Array.getLength(array));
!!!72608951.java!!!	createTyped(inout rs : RenderScript, inout type : Type, inout mips : Allocation::MipmapControl, in usage : int) : Allocation
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "createTyped");
            rs.validate();
            if (type.getID(rs) == 0) {
                throw new RSInvalidStateException("Bad Type");
            }
            // TODO: What if there is an exception after this? The native allocation would leak.
            long id = rs.nAllocationCreateTyped(type.getID(rs), mips.mID, usage, 0);
            if (id == 0) {
                throw new RSRuntimeException("Allocation creation failed.");
            }
            return new Allocation(id, rs, type, false, usage, mips);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72609079.java!!!	createTyped(inout rs : RenderScript, inout type : Type, in usage : int) : Allocation
        return createTyped(rs, type, MipmapControl.MIPMAP_NONE, usage);
!!!72609207.java!!!	createTyped(inout rs : RenderScript, inout type : Type) : Allocation
        return createTyped(rs, type, MipmapControl.MIPMAP_NONE, USAGE_SCRIPT);
!!!72609335.java!!!	createSized(inout rs : RenderScript, inout e : Element, in count : int, in usage : int) : Allocation
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "createSized");
            rs.validate();
            Type.Builder b = new Type.Builder(rs, e);
            b.setX(count);
            Type t = b.create();

            long id = rs.nAllocationCreateTyped(t.getID(rs), MipmapControl.MIPMAP_NONE.mID, usage, 0);
            if (id == 0) {
                throw new RSRuntimeException("Allocation creation failed.");
            }
            return new Allocation(id, rs, t, true, usage, MipmapControl.MIPMAP_NONE);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72609463.java!!!	createSized(inout rs : RenderScript, inout e : Element, in count : int) : Allocation
        return createSized(rs, e, count, USAGE_SCRIPT);
!!!72609591.java!!!	elementFromBitmap(inout rs : RenderScript, inout b : Bitmap) : Element
        final Bitmap.Config bc = b.getConfig();
        if (bc == Bitmap.Config.ALPHA_8) {
            return Element.A_8(rs);
        }
        if (bc == Bitmap.Config.ARGB_4444) {
            return Element.RGBA_4444(rs);
        }
        if (bc == Bitmap.Config.ARGB_8888) {
            return Element.RGBA_8888(rs);
        }
        if (bc == Bitmap.Config.RGB_565) {
            return Element.RGB_565(rs);
        }
        throw new RSInvalidStateException("Bad bitmap type: " + bc);
!!!72609719.java!!!	typeFromBitmap(inout rs : RenderScript, inout b : Bitmap, inout mip : Allocation::MipmapControl) : Type
        Element e = elementFromBitmap(rs, b);
        Type.Builder tb = new Type.Builder(rs, e);
        tb.setX(b.getWidth());
        tb.setY(b.getHeight());
        tb.setMipmaps(mip == MipmapControl.MIPMAP_FULL);
        return tb.create();
!!!72609847.java!!!	createFromBitmap(inout rs : RenderScript, inout b : Bitmap, inout mips : Allocation::MipmapControl, in usage : int) : Allocation
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "createFromBitmap");
            rs.validate();

            // WAR undocumented color formats
            if (b.getConfig() == null) {
                if ((usage & USAGE_SHARED) != 0) {
                    throw new RSIllegalArgumentException("USAGE_SHARED cannot be used with a Bitmap that has a null config.");
                }
                Bitmap newBitmap = Bitmap.createBitmap(b.getWidth(), b.getHeight(), Bitmap.Config.ARGB_8888);
                Canvas c = new Canvas(newBitmap);
                c.drawBitmap(b, 0, 0, null);
                return createFromBitmap(rs, newBitmap, mips, usage);
            }

            Type t = typeFromBitmap(rs, b, mips);

            // enable optimized bitmap path only with no mipmap and script-only usage
            if (mips == MipmapControl.MIPMAP_NONE &&
                 t.getElement().isCompatible(Element.RGBA_8888(rs)) &&
                 usage == (USAGE_SHARED | USAGE_SCRIPT | USAGE_GRAPHICS_TEXTURE)) {
                long id = rs.nAllocationCreateBitmapBackedAllocation(t.getID(rs), mips.mID, b, usage);
                if (id == 0) {
                    throw new RSRuntimeException("Load failed.");
                }

                // keep a reference to the Bitmap around to prevent GC
                Allocation alloc = new Allocation(id, rs, t, true, usage, mips);
                alloc.setBitmap(b);
                return alloc;
            }


            long id = rs.nAllocationCreateFromBitmap(t.getID(rs), mips.mID, b, usage);
            if (id == 0) {
                throw new RSRuntimeException("Load failed.");
            }
            return new Allocation(id, rs, t, true, usage, mips);
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72609975.java!!!	getByteBuffer() : ByteBuffer
        // Create a new ByteBuffer if it is not initialized or using IO_INPUT.
        if (mType.hasFaces()) {
            throw new RSInvalidStateException("Cubemap is not supported for getByteBuffer().");
        }
        if (mType.getYuv() == android.graphics.ImageFormat.NV21 ||
            mType.getYuv() == android.graphics.ImageFormat.YV12 ||
            mType.getYuv() == android.graphics.ImageFormat.YUV_420_888 ) {
            throw new RSInvalidStateException("YUV format is not supported for getByteBuffer().");
        }
        if (mByteBuffer == null || (mUsage & USAGE_IO_INPUT) != 0) {
            int xBytesSize = mType.getX() * mType.getElement().getBytesSize();
            long[] stride = new long[1];
            mByteBuffer = mRS.nAllocationGetByteBuffer(getID(mRS), stride, xBytesSize, mType.getY(), mType.getZ());
            mByteBufferStride = stride[0];
        }
        if ((mUsage & USAGE_IO_INPUT) != 0) {
            return mByteBuffer.asReadOnlyBuffer();
        }
        return mByteBuffer;
!!!72610103.java!!!	createAllocations(inout rs : RenderScript, inout t : Type, in usage : int, in numAlloc : int) : Allocation
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "createAllocations");
            rs.validate();
            if (t.getID(rs) == 0) {
                throw new RSInvalidStateException("Bad Type");
            }

            Allocation[] mAllocationArray = new Allocation[numAlloc];
            mAllocationArray[0] = createTyped(rs, t, usage);
            if ((usage & USAGE_IO_INPUT) != 0) {
                if (numAlloc > MAX_NUMBER_IO_INPUT_ALLOC) {
                    throw new RSIllegalArgumentException("Exceeds the max number of Allocations allowed: " +
                                                         MAX_NUMBER_IO_INPUT_ALLOC);
                }
                mAllocationArray[0].setupBufferQueue(numAlloc);;
            }

            for (int i=1; i<numAlloc; i++) {
                mAllocationArray[i] = createFromAllocation(rs, mAllocationArray[0]);
            }
            return mAllocationArray;
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72610231.java!!!	createFromAllocation(inout rs : RenderScript, inout alloc : Allocation) : Allocation
        try {
            Trace.traceBegin(RenderScript.TRACE_TAG, "createFromAllcation");
            rs.validate();
            if (alloc.getID(rs) == 0) {
                throw new RSInvalidStateException("Bad input Allocation");
            }

            Type type = alloc.getType();
            int usage = alloc.getUsage();
            MipmapControl mips = alloc.getMipmap();
            long id = rs.nAllocationCreateTyped(type.getID(rs), mips.mID, usage, 0);
            if (id == 0) {
                throw new RSRuntimeException("Allocation creation failed.");
            }
            Allocation outAlloc = new Allocation(id, rs, type, false, usage, mips);
            if ((usage & USAGE_IO_INPUT) != 0) {
                outAlloc.shareBufferQueue(alloc);
            }
            return outAlloc;
        } finally {
            Trace.traceEnd(RenderScript.TRACE_TAG);
        }
!!!72610359.java!!!	setupBufferQueue(in numAlloc : int) : void
        mRS.validate();
        if ((mUsage & USAGE_IO_INPUT) == 0) {
            throw new RSInvalidStateException("Allocation is not USAGE_IO_INPUT.");
        }
        mRS.nAllocationSetupBufferQueue(getID(mRS), numAlloc);
!!!72610487.java!!!	shareBufferQueue(inout alloc : Allocation) : void
        mRS.validate();
        if ((mUsage & USAGE_IO_INPUT) == 0) {
            throw new RSInvalidStateException("Allocation is not USAGE_IO_INPUT.");
        }
        mGetSurfaceSurface = alloc.getSurface();
        mRS.nAllocationShareBufferQueue(getID(mRS), alloc.getID(mRS));
!!!72610615.java!!!	getStride() : long
        if (mByteBufferStride == -1) {
            getByteBuffer();
        }
        return mByteBufferStride;
!!!72610743.java!!!	getTimeStamp() : long
        return mTimeStamp;
!!!72610871.java!!!	getSurface() : Surface
        if ((mUsage & USAGE_IO_INPUT) == 0) {
            throw new RSInvalidStateException("Allocation is not a surface texture.");
        }

        if (mGetSurfaceSurface == null) {
            mGetSurfaceSurface = mRS.nAllocationGetSurface(getID(mRS));
        }

        return mGetSurfaceSurface;
!!!72610999.java!!!	setSurface(inout sur : Surface) : void
        mRS.validate();
        if ((mUsage & USAGE_IO_OUTPUT) == 0) {
            throw new RSInvalidStateException("Allocation is not USAGE_IO_OUTPUT.");
        }

        mRS.nAllocationSetSurface(getID(mRS), sur);
!!!72611127.java!!!	createFromBitmap(inout rs : RenderScript, inout b : Bitmap) : Allocation
        if (rs.getApplicationContext().getApplicationInfo().targetSdkVersion >= 18) {
            return createFromBitmap(rs, b, MipmapControl.MIPMAP_NONE,
                                    USAGE_SHARED | USAGE_SCRIPT | USAGE_GRAPHICS_TEXTURE);
        }
        return createFromBitmap(rs, b, MipmapControl.MIPMAP_NONE,
                                USAGE_GRAPHICS_TEXTURE);
!!!72611255.java!!!	createCubemapFromBitmap(inout rs : RenderScript, inout b : Bitmap, inout mips : Allocation::MipmapControl, in usage : int) : Allocation
        rs.validate();

        int height = b.getHeight();
        int width = b.getWidth();

        if (width % 6 != 0) {
            throw new RSIllegalArgumentException("Cubemap height must be multiple of 6");
        }
        if (width / 6 != height) {
            throw new RSIllegalArgumentException("Only square cube map faces supported");
        }
        boolean isPow2 = (height & (height - 1)) == 0;
        if (!isPow2) {
            throw new RSIllegalArgumentException("Only power of 2 cube faces supported");
        }

        Element e = elementFromBitmap(rs, b);
        Type.Builder tb = new Type.Builder(rs, e);
        tb.setX(height);
        tb.setY(height);
        tb.setFaces(true);
        tb.setMipmaps(mips == MipmapControl.MIPMAP_FULL);
        Type t = tb.create();

        long id = rs.nAllocationCubeCreateFromBitmap(t.getID(rs), mips.mID, b, usage);
        if(id == 0) {
            throw new RSRuntimeException("Load failed for bitmap " + b + " element " + e);
        }
        return new Allocation(id, rs, t, true, usage, mips);
!!!72611383.java!!!	createCubemapFromBitmap(inout rs : RenderScript, inout b : Bitmap) : Allocation
        return createCubemapFromBitmap(rs, b, MipmapControl.MIPMAP_NONE,
                                       USAGE_GRAPHICS_TEXTURE);
!!!72611511.java!!!	createCubemapFromCubeFaces(inout rs : RenderScript, inout xpos : Bitmap, inout xneg : Bitmap, inout ypos : Bitmap, inout yneg : Bitmap, inout zpos : Bitmap, inout zneg : Bitmap, inout mips : Allocation::MipmapControl, in usage : int) : Allocation
        int height = xpos.getHeight();
        if (xpos.getWidth() != height ||
            xneg.getWidth() != height || xneg.getHeight() != height ||
            ypos.getWidth() != height || ypos.getHeight() != height ||
            yneg.getWidth() != height || yneg.getHeight() != height ||
            zpos.getWidth() != height || zpos.getHeight() != height ||
            zneg.getWidth() != height || zneg.getHeight() != height) {
            throw new RSIllegalArgumentException("Only square cube map faces supported");
        }
        boolean isPow2 = (height & (height - 1)) == 0;
        if (!isPow2) {
            throw new RSIllegalArgumentException("Only power of 2 cube faces supported");
        }

        Element e = elementFromBitmap(rs, xpos);
        Type.Builder tb = new Type.Builder(rs, e);
        tb.setX(height);
        tb.setY(height);
        tb.setFaces(true);
        tb.setMipmaps(mips == MipmapControl.MIPMAP_FULL);
        Type t = tb.create();
        Allocation cubemap = Allocation.createTyped(rs, t, mips, usage);

        AllocationAdapter adapter = AllocationAdapter.create2D(rs, cubemap);
        adapter.setFace(Type.CubemapFace.POSITIVE_X);
        adapter.copyFrom(xpos);
        adapter.setFace(Type.CubemapFace.NEGATIVE_X);
        adapter.copyFrom(xneg);
        adapter.setFace(Type.CubemapFace.POSITIVE_Y);
        adapter.copyFrom(ypos);
        adapter.setFace(Type.CubemapFace.NEGATIVE_Y);
        adapter.copyFrom(yneg);
        adapter.setFace(Type.CubemapFace.POSITIVE_Z);
        adapter.copyFrom(zpos);
        adapter.setFace(Type.CubemapFace.NEGATIVE_Z);
        adapter.copyFrom(zneg);

        return cubemap;
!!!72611639.java!!!	createCubemapFromCubeFaces(inout rs : RenderScript, inout xpos : Bitmap, inout xneg : Bitmap, inout ypos : Bitmap, inout yneg : Bitmap, inout zpos : Bitmap, inout zneg : Bitmap) : Allocation
        return createCubemapFromCubeFaces(rs, xpos, xneg, ypos, yneg,
                                          zpos, zneg, MipmapControl.MIPMAP_NONE,
                                          USAGE_GRAPHICS_TEXTURE);
!!!72611767.java!!!	createFromBitmapResource(inout rs : RenderScript, inout res : Resources, in id : int, inout mips : Allocation::MipmapControl, in usage : int) : Allocation

        rs.validate();
        if ((usage & (USAGE_SHARED | USAGE_IO_INPUT | USAGE_IO_OUTPUT)) != 0) {
            throw new RSIllegalArgumentException("Unsupported usage specified.");
        }
        Bitmap b = BitmapFactory.decodeResource(res, id);
        Allocation alloc = createFromBitmap(rs, b, mips, usage);
        b.recycle();
        return alloc;
!!!72611895.java!!!	createFromBitmapResource(inout rs : RenderScript, inout res : Resources, in id : int) : Allocation
        if (rs.getApplicationContext().getApplicationInfo().targetSdkVersion >= 18) {
            return createFromBitmapResource(rs, res, id,
                                            MipmapControl.MIPMAP_NONE,
                                            USAGE_SCRIPT | USAGE_GRAPHICS_TEXTURE);
        }
        return createFromBitmapResource(rs, res, id,
                                        MipmapControl.MIPMAP_NONE,
                                        USAGE_GRAPHICS_TEXTURE);
!!!72612023.java!!!	createFromString(inout rs : RenderScript, inout str : String, in usage : int) : Allocation
        rs.validate();
        byte[] allocArray = null;
        try {
            allocArray = str.getBytes("UTF-8");
            Allocation alloc = Allocation.createSized(rs, Element.U8(rs), allocArray.length, usage);
            alloc.copyFrom(allocArray);
            return alloc;
        }
        catch (Exception e) {
            throw new RSRuntimeException("Could not convert string to utf-8.");
        }
!!!72612279.java!!!	setOnBufferAvailableListener(inout callback : Allocation::OnBufferAvailableListener) : void
        synchronized(mAllocationMap) {
            mAllocationMap.put(new Long(getID(mRS)), this);
            mBufferNotifier = callback;
        }
!!!72612407.java!!!	sendBufferNotification(in id : long) : void
        synchronized(mAllocationMap) {
            Allocation a = mAllocationMap.get(new Long(id));

            if ((a != null) && (a.mBufferNotifier != null)) {
                a.mBufferNotifier.onBufferAvailable(a);
            }
        }
!!!72612535.java!!!	destroy() : void
        if((mUsage & USAGE_IO_OUTPUT) != 0) {
            setSurface(null);
        }

        if (mType != null && mOwningType) {
            mType.destroy();
        }

        super.destroy();
