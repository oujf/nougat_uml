class KeyStoreTest
!!!28128183.java!!!	KeyStoreTest()
        super(Activity.class);
!!!28128311.java!!!	hexToBytes(inout s : String) : byte
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(
                    s.charAt(i + 1), 16));
        }
        return data;
!!!28128439.java!!!	setUp() : void
        mKeyStore = KeyStore.getInstance();
        if (mKeyStore.state() != KeyStore.State.UNINITIALIZED) {
            mKeyStore.reset();
        }
        assertEquals("KeyStore should be in an uninitialized state",
                KeyStore.State.UNINITIALIZED, mKeyStore.state());
        super.setUp();
!!!28128567.java!!!	tearDown() : void
        mKeyStore.reset();
        super.tearDown();
!!!28128695.java!!!	testState() : void
        assertEquals(KeyStore.State.UNINITIALIZED, mKeyStore.state());
!!!28128823.java!!!	testPassword() : void
        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));
        assertEquals(KeyStore.State.UNLOCKED, mKeyStore.state());
!!!28128951.java!!!	testGet() : void
        assertNull(mKeyStore.get(TEST_KEYNAME));
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        assertNull(mKeyStore.get(TEST_KEYNAME));
        assertTrue(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, KeyStore.UID_SELF,
                KeyStore.FLAG_ENCRYPTED));
        assertTrue(Arrays.equals(TEST_KEYVALUE, mKeyStore.get(TEST_KEYNAME)));
!!!28129079.java!!!	testPut() : void
        assertNull(mKeyStore.get(TEST_KEYNAME));
        assertFalse(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, KeyStore.UID_SELF,
                KeyStore.FLAG_ENCRYPTED));
        assertFalse(mKeyStore.contains(TEST_KEYNAME));
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        assertTrue(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, KeyStore.UID_SELF,
                KeyStore.FLAG_ENCRYPTED));
        assertTrue(Arrays.equals(TEST_KEYVALUE, mKeyStore.get(TEST_KEYNAME)));
!!!28129207.java!!!	testPut_grantedUid_Wifi() : void
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
        assertFalse(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, Process.WIFI_UID,
                KeyStore.FLAG_ENCRYPTED));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        assertTrue(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, Process.WIFI_UID,
                KeyStore.FLAG_ENCRYPTED));
        assertTrue(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
!!!28129335.java!!!	testPut_ungrantedUid_Bluetooth() : void
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));
        assertFalse(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, Process.BLUETOOTH_UID,
                KeyStore.FLAG_ENCRYPTED));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        assertFalse(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, Process.BLUETOOTH_UID,
                KeyStore.FLAG_ENCRYPTED));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));
!!!28129463.java!!!	testI18n() : void
        assertFalse(mKeyStore.put(TEST_I18N_KEY, TEST_I18N_VALUE, KeyStore.UID_SELF,
                KeyStore.FLAG_ENCRYPTED));
        assertFalse(mKeyStore.contains(TEST_I18N_KEY));
        mKeyStore.onUserPasswordChanged(TEST_I18N_KEY);
        assertTrue(mKeyStore.put(TEST_I18N_KEY, TEST_I18N_VALUE, KeyStore.UID_SELF,
                KeyStore.FLAG_ENCRYPTED));
        assertTrue(mKeyStore.contains(TEST_I18N_KEY));
!!!28129591.java!!!	testDelete() : void
        assertFalse(mKeyStore.delete(TEST_KEYNAME));
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        assertFalse(mKeyStore.delete(TEST_KEYNAME));

        assertTrue(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, KeyStore.UID_SELF,
                KeyStore.FLAG_ENCRYPTED));
        assertTrue(Arrays.equals(TEST_KEYVALUE, mKeyStore.get(TEST_KEYNAME)));
        assertTrue(mKeyStore.delete(TEST_KEYNAME));
        assertNull(mKeyStore.get(TEST_KEYNAME));
!!!28129719.java!!!	testDelete_grantedUid_Wifi() : void
        assertFalse(mKeyStore.delete(TEST_KEYNAME, Process.WIFI_UID));
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        assertFalse(mKeyStore.delete(TEST_KEYNAME, Process.WIFI_UID));

        assertTrue(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, Process.WIFI_UID,
                KeyStore.FLAG_ENCRYPTED));
        assertTrue(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
        assertTrue(mKeyStore.delete(TEST_KEYNAME, Process.WIFI_UID));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
!!!28129847.java!!!	testDelete_ungrantedUid_Bluetooth() : void
        assertFalse(mKeyStore.delete(TEST_KEYNAME, Process.BLUETOOTH_UID));
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        assertFalse(mKeyStore.delete(TEST_KEYNAME, Process.BLUETOOTH_UID));

        assertFalse(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, Process.BLUETOOTH_UID,
                KeyStore.FLAG_ENCRYPTED));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));
        assertFalse(mKeyStore.delete(TEST_KEYNAME, Process.BLUETOOTH_UID));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));
!!!28129975.java!!!	testContains() : void
        assertFalse(mKeyStore.contains(TEST_KEYNAME));

        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));
        assertFalse(mKeyStore.contains(TEST_KEYNAME));

        assertTrue(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, KeyStore.UID_SELF,
                KeyStore.FLAG_ENCRYPTED));
        assertTrue(mKeyStore.contains(TEST_KEYNAME));
!!!28130103.java!!!	testContains_grantedUid_Wifi() : void
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));

        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));

        assertTrue(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, Process.WIFI_UID,
                KeyStore.FLAG_ENCRYPTED));
        assertTrue(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
!!!28130231.java!!!	testContains_grantedUid_Bluetooth() : void
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));

        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));

        assertFalse(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, Process.BLUETOOTH_UID,
                KeyStore.FLAG_ENCRYPTED));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));
!!!28130359.java!!!	testList() : void
        String[] emptyResult = mKeyStore.list(TEST_KEYNAME);
        assertNotNull(emptyResult);
        assertEquals(0, emptyResult.length);

        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        mKeyStore.put(TEST_KEYNAME1, TEST_KEYVALUE, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED);
        mKeyStore.put(TEST_KEYNAME2, TEST_KEYVALUE, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED);

        String[] results = mKeyStore.list(TEST_KEYNAME);
        assertEquals(new HashSet(Arrays.asList(TEST_KEYNAME1.substring(TEST_KEYNAME.length()),
                                               TEST_KEYNAME2.substring(TEST_KEYNAME.length()))),
                     new HashSet(Arrays.asList(results)));
!!!28130487.java!!!	testList_ungrantedUid_Bluetooth() : void
        String[] results1 = mKeyStore.list(TEST_KEYNAME, Process.BLUETOOTH_UID);
        assertEquals(0, results1.length);

        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        mKeyStore.put(TEST_KEYNAME1, TEST_KEYVALUE, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED);
        mKeyStore.put(TEST_KEYNAME2, TEST_KEYVALUE, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED);

        String[] results2 = mKeyStore.list(TEST_KEYNAME, Process.BLUETOOTH_UID);
        assertEquals(0, results2.length);
!!!28130615.java!!!	testList_grantedUid_Wifi() : void
        String[] results1 = mKeyStore.list(TEST_KEYNAME, Process.WIFI_UID);
        assertNotNull(results1);
        assertEquals(0, results1.length);

        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        mKeyStore.put(TEST_KEYNAME1, TEST_KEYVALUE, Process.WIFI_UID, KeyStore.FLAG_ENCRYPTED);
        mKeyStore.put(TEST_KEYNAME2, TEST_KEYVALUE, Process.WIFI_UID, KeyStore.FLAG_ENCRYPTED);

        String[] results2 = mKeyStore.list(TEST_KEYNAME, Process.WIFI_UID);
        assertEquals(new HashSet(Arrays.asList(TEST_KEYNAME1.substring(TEST_KEYNAME.length()),
                                               TEST_KEYNAME2.substring(TEST_KEYNAME.length()))),
                     new HashSet(Arrays.asList(results2)));
!!!28130743.java!!!	testList_grantedUid_Vpn() : void
        String[] results1 = mKeyStore.list(TEST_KEYNAME, Process.VPN_UID);
        assertNotNull(results1);
        assertEquals(0, results1.length);

        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        mKeyStore.put(TEST_KEYNAME1, TEST_KEYVALUE, Process.VPN_UID, KeyStore.FLAG_ENCRYPTED);
        mKeyStore.put(TEST_KEYNAME2, TEST_KEYVALUE, Process.VPN_UID, KeyStore.FLAG_ENCRYPTED);

        String[] results2 = mKeyStore.list(TEST_KEYNAME, Process.VPN_UID);
        assertEquals(new HashSet(Arrays.asList(TEST_KEYNAME1.substring(TEST_KEYNAME.length()),
                                               TEST_KEYNAME2.substring(TEST_KEYNAME.length()))),
                     new HashSet(Arrays.asList(results2)));
!!!28130871.java!!!	testLock() : void
        assertFalse(mKeyStore.lock());

        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        assertEquals(KeyStore.State.UNLOCKED, mKeyStore.state());

        assertTrue(mKeyStore.lock());
        assertEquals(KeyStore.State.LOCKED, mKeyStore.state());
!!!28130999.java!!!	testUnlock() : void
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        assertEquals(KeyStore.State.UNLOCKED, mKeyStore.state());
        mKeyStore.lock();

        assertFalse(mKeyStore.unlock(TEST_PASSWD2));
        assertTrue(mKeyStore.unlock(TEST_PASSWD));
!!!28131127.java!!!	testIsEmpty() : void
        assertTrue(mKeyStore.isEmpty());
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        assertTrue(mKeyStore.isEmpty());
        mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED);
        assertFalse(mKeyStore.isEmpty());
        mKeyStore.reset();
        assertTrue(mKeyStore.isEmpty());
!!!28131255.java!!!	testGenerate_NotInitialized_Fail() : void
        assertFalse("Should fail when keystore is not initialized",
                mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                        RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));
!!!28131383.java!!!	testGenerate_Locked_Fail() : void
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        mKeyStore.lock();
        assertFalse("Should fail when keystore is locked",
                mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                        RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));
!!!28131511.java!!!	testGenerate_Success() : void
        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to generate key when unlocked",
                mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                        RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));
        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
!!!28131639.java!!!	testGenerate_grantedUid_Wifi_Success() : void
        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to generate key when unlocked",
                mKeyStore.generate(TEST_KEYNAME, Process.WIFI_UID, NativeConstants.EVP_PKEY_RSA,
                        RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));
        assertTrue(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
        assertFalse(mKeyStore.contains(TEST_KEYNAME));
!!!28131767.java!!!	testGenerate_ungrantedUid_Bluetooth_Failure() : void
        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertFalse(mKeyStore.generate(TEST_KEYNAME, Process.BLUETOOTH_UID,
                    NativeConstants.EVP_PKEY_RSA, RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
        assertFalse(mKeyStore.contains(TEST_KEYNAME));
!!!28131895.java!!!	testImport_Success() : void
        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to import key when unlocked", mKeyStore.importKey(TEST_KEYNAME,
                PRIVKEY_BYTES, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED));
        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
!!!28132023.java!!!	testImport_grantedUid_Wifi_Success() : void
        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to import key when unlocked", mKeyStore.importKey(TEST_KEYNAME,
                PRIVKEY_BYTES, Process.WIFI_UID, KeyStore.FLAG_ENCRYPTED));
        assertTrue(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
        assertFalse(mKeyStore.contains(TEST_KEYNAME));
!!!28132151.java!!!	testImport_ungrantedUid_Bluetooth_Failure() : void
        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertFalse(mKeyStore.importKey(TEST_KEYNAME, PRIVKEY_BYTES, Process.BLUETOOTH_UID,
                KeyStore.FLAG_ENCRYPTED));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
        assertFalse(mKeyStore.contains(TEST_KEYNAME));
!!!28132279.java!!!	testImport_Failure_BadEncoding() : void
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);

        assertFalse("Invalid DER-encoded key should not be imported", mKeyStore.importKey(
                TEST_KEYNAME, TEST_DATA, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED));
        assertFalse(mKeyStore.contains(TEST_KEYNAME));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
!!!28132407.java!!!	testSign_Success() : void
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);

        assertTrue(mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                    RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));
        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        final byte[] signature = mKeyStore.sign(TEST_KEYNAME, TEST_DATA);

        assertNotNull("Signature should not be null", signature);
!!!28132535.java!!!	testVerify_Success() : void
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);

        assertTrue(mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                    RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));
        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        final byte[] signature = mKeyStore.sign(TEST_KEYNAME, TEST_DATA);

        assertNotNull("Signature should not be null", signature);

        assertTrue("Signature should verify with same data",
                mKeyStore.verify(TEST_KEYNAME, TEST_DATA, signature));
!!!28132663.java!!!	testSign_NotInitialized_Failure() : void
        assertNull("Should not be able to sign without first initializing the keystore",
                mKeyStore.sign(TEST_KEYNAME, TEST_DATA));
!!!28132791.java!!!	testSign_NotGenerated_Failure() : void
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);

        assertNull("Should not be able to sign without first generating keys",
                mKeyStore.sign(TEST_KEYNAME, TEST_DATA));
!!!28132919.java!!!	testGrant_Generated_Success() : void
        assertTrue("Password should work for keystore",
                mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to generate key for testcase",
                mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                        RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));

        assertTrue("Should be able to grant key to other user",
                mKeyStore.grant(TEST_KEYNAME, 0));
!!!28133047.java!!!	testGrant_Imported_Success() : void
        assertTrue("Password should work for keystore", mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to import key for testcase", mKeyStore.importKey(TEST_KEYNAME,
                PRIVKEY_BYTES, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED));

        assertTrue("Should be able to grant key to other user", mKeyStore.grant(TEST_KEYNAME, 0));
!!!28133175.java!!!	testGrant_NoKey_Failure() : void
        assertTrue("Should be able to unlock keystore for test",
                mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertFalse("Should not be able to grant without first initializing the keystore",
                mKeyStore.grant(TEST_KEYNAME, 0));
!!!28133303.java!!!	testGrant_NotInitialized_Failure() : void
        assertFalse("Should not be able to grant without first initializing the keystore",
                mKeyStore.grant(TEST_KEYNAME, 0));
!!!28133431.java!!!	testUngrant_Generated_Success() : void
        assertTrue("Password should work for keystore",
                mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to generate key for testcase",
                mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                        RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));

        assertTrue("Should be able to grant key to other user",
                mKeyStore.grant(TEST_KEYNAME, 0));

        assertTrue("Should be able to ungrant key to other user",
                mKeyStore.ungrant(TEST_KEYNAME, 0));
!!!28133559.java!!!	testUngrant_Imported_Success() : void
        assertTrue("Password should work for keystore",
                mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to import key for testcase", mKeyStore.importKey(TEST_KEYNAME,
                PRIVKEY_BYTES, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED));

        assertTrue("Should be able to grant key to other user",
                mKeyStore.grant(TEST_KEYNAME, 0));

        assertTrue("Should be able to ungrant key to other user",
                mKeyStore.ungrant(TEST_KEYNAME, 0));
!!!28133687.java!!!	testUngrant_NotInitialized_Failure() : void
        assertFalse("Should fail to ungrant key when keystore not initialized",
                mKeyStore.ungrant(TEST_KEYNAME, 0));
!!!28133815.java!!!	testUngrant_NoGrant_Failure() : void
        assertTrue("Password should work for keystore",
                mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to generate key for testcase",
                mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                        RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));

        assertFalse("Should not be able to revoke not existent grant",
                mKeyStore.ungrant(TEST_KEYNAME, 0));
!!!28133943.java!!!	testUngrant_DoubleUngrant_Failure() : void
        assertTrue("Password should work for keystore",
                mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to generate key for testcase",
                mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                        RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));

        assertTrue("Should be able to grant key to other user",
                mKeyStore.grant(TEST_KEYNAME, 0));

        assertTrue("Should be able to ungrant key to other user",
                mKeyStore.ungrant(TEST_KEYNAME, 0));

        assertFalse("Should fail to ungrant key to other user second time",
                mKeyStore.ungrant(TEST_KEYNAME, 0));
!!!28134071.java!!!	testUngrant_DoubleGrantUngrant_Failure() : void
        assertTrue("Password should work for keystore",
                mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to generate key for testcase",
                mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                        RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));

        assertTrue("Should be able to grant key to other user",
                mKeyStore.grant(TEST_KEYNAME, 0));

        assertTrue("Should be able to grant key to other user a second time",
                mKeyStore.grant(TEST_KEYNAME, 0));

        assertTrue("Should be able to ungrant key to other user",
                mKeyStore.ungrant(TEST_KEYNAME, 0));

        assertFalse("Should fail to ungrant key to other user second time",
                mKeyStore.ungrant(TEST_KEYNAME, 0));
!!!28134199.java!!!	testDuplicate_grantedUid_Wifi_Success() : void
        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertFalse(mKeyStore.contains(TEST_KEYNAME));

        assertTrue(mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                    RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));

        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));

        // source doesn't exist
        assertFalse(mKeyStore.duplicate(TEST_KEYNAME1, -1, TEST_KEYNAME1, Process.WIFI_UID));
        assertFalse(mKeyStore.contains(TEST_KEYNAME1, Process.WIFI_UID));

        // Copy from current UID to granted UID
        assertTrue(mKeyStore.duplicate(TEST_KEYNAME, -1, TEST_KEYNAME1, Process.WIFI_UID));
        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        assertFalse(mKeyStore.contains(TEST_KEYNAME1));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
        assertTrue(mKeyStore.contains(TEST_KEYNAME1, Process.WIFI_UID));
        assertFalse(mKeyStore.duplicate(TEST_KEYNAME, -1, TEST_KEYNAME1, Process.WIFI_UID));

        // Copy from granted UID to same granted UID
        assertTrue(mKeyStore.duplicate(TEST_KEYNAME1, Process.WIFI_UID, TEST_KEYNAME2,
                Process.WIFI_UID));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.WIFI_UID));
        assertTrue(mKeyStore.contains(TEST_KEYNAME1, Process.WIFI_UID));
        assertTrue(mKeyStore.contains(TEST_KEYNAME2, Process.WIFI_UID));
        assertFalse(mKeyStore.duplicate(TEST_KEYNAME1, Process.WIFI_UID, TEST_KEYNAME2,
                Process.WIFI_UID));

        assertTrue(mKeyStore.duplicate(TEST_KEYNAME, -1, TEST_KEYNAME2, -1));
        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        assertFalse(mKeyStore.contains(TEST_KEYNAME1));
        assertTrue(mKeyStore.contains(TEST_KEYNAME2));
        assertFalse(mKeyStore.duplicate(TEST_KEYNAME, -1, TEST_KEYNAME2, -1));
!!!28134327.java!!!	testDuplicate_ungrantedUid_Bluetooth_Failure() : void
        assertTrue(mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertFalse(mKeyStore.contains(TEST_KEYNAME));

        assertTrue(mKeyStore.generate(TEST_KEYNAME, KeyStore.UID_SELF, NativeConstants.EVP_PKEY_RSA,
                    RSA_KEY_SIZE, KeyStore.FLAG_ENCRYPTED, null));

        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));

        assertFalse(mKeyStore.duplicate(TEST_KEYNAME, -1, TEST_KEYNAME2, Process.BLUETOOTH_UID));
        assertFalse(mKeyStore.duplicate(TEST_KEYNAME, Process.BLUETOOTH_UID, TEST_KEYNAME2,
                Process.BLUETOOTH_UID));

        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        assertFalse(mKeyStore.contains(TEST_KEYNAME, Process.BLUETOOTH_UID));
!!!28134455.java!!!	testGetmtime_Success() : void
        assertTrue("Password should work for keystore",
                mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to import key when unlocked", mKeyStore.importKey(TEST_KEYNAME,
                PRIVKEY_BYTES, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED));

        long now = System.currentTimeMillis();
        long actual = mKeyStore.getmtime(TEST_KEYNAME);

        long expectedAfter = now - SLOP_TIME_MILLIS;
        long expectedBefore = now + SLOP_TIME_MILLIS;

        assertLessThan("Time should be close to current time", expectedBefore, actual);
        assertGreaterThan("Time should be close to current time", expectedAfter, actual);
!!!28134583.java!!!	assertLessThan(inout explanation : String, in expectedBefore : long, in actual : long) : void
        if (actual >= expectedBefore) {
            throw new AssertionFailedError(explanation + ": actual=" + actual
                    + ", expected before: " + expectedBefore);
        }
!!!28134711.java!!!	assertGreaterThan(inout explanation : String, in expectedAfter : long, in actual : long) : void
        if (actual <= expectedAfter) {
            throw new AssertionFailedError(explanation + ": actual=" + actual
                    + ", expected after: " + expectedAfter);
        }
!!!28134839.java!!!	testGetmtime_NonExist_Failure() : void
        assertTrue("Password should work for keystore",
                mKeyStore.onUserPasswordChanged(TEST_PASSWD));

        assertTrue("Should be able to import key when unlocked", mKeyStore.importKey(TEST_KEYNAME,
                PRIVKEY_BYTES, KeyStore.UID_SELF, KeyStore.FLAG_ENCRYPTED));

        assertEquals("-1 should be returned for non-existent key",
                -1L, mKeyStore.getmtime(TEST_KEYNAME2));
!!!28134967.java!!!	generateRsaKey(inout name : String) : KeyCharacteristics
        KeymasterArguments args = new KeymasterArguments();
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_ENCRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_DECRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, KeymasterDefs.KM_ALGORITHM_RSA);
        args.addEnum(KeymasterDefs.KM_TAG_PADDING, KeymasterDefs.KM_PAD_NONE);
        args.addBoolean(KeymasterDefs.KM_TAG_NO_AUTH_REQUIRED);
        args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE, 2048);
        args.addUnsignedLong(KeymasterDefs.KM_TAG_RSA_PUBLIC_EXPONENT, RSAKeyGenParameterSpec.F4);

        KeyCharacteristics outCharacteristics = new KeyCharacteristics();
        int result = mKeyStore.generateKey(name, args, null, 0, outCharacteristics);
        assertEquals("generateRsaKey should succeed", KeyStore.NO_ERROR, result);
        return outCharacteristics;
!!!28135095.java!!!	testGenerateKey() : void
        generateRsaKey("test");
        mKeyStore.delete("test");
!!!28135223.java!!!	testGenerateRsaWithEntropy() : void
        byte[] entropy = new byte[] {1,2,3,4,5};
        String name = "test";
        KeymasterArguments args = new KeymasterArguments();
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_ENCRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_DECRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, KeymasterDefs.KM_ALGORITHM_RSA);
        args.addEnum(KeymasterDefs.KM_TAG_PADDING, KeymasterDefs.KM_PAD_NONE);
        args.addBoolean(KeymasterDefs.KM_TAG_NO_AUTH_REQUIRED);
        args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE, 2048);
        args.addUnsignedLong(KeymasterDefs.KM_TAG_RSA_PUBLIC_EXPONENT, RSAKeyGenParameterSpec.F4);

        KeyCharacteristics outCharacteristics = new KeyCharacteristics();
        int result = mKeyStore.generateKey(name, args, entropy, 0, outCharacteristics);
        assertEquals("generateKey should succeed", KeyStore.NO_ERROR, result);
!!!28135351.java!!!	testGenerateAndDelete() : void
        generateRsaKey("test");
        assertTrue("delete should succeed", mKeyStore.delete("test"));
!!!28135479.java!!!	testGetKeyCharacteristicsSuccess() : void
        mKeyStore.onUserPasswordChanged(TEST_PASSWD);
        String name = "test";
        KeyCharacteristics gen = generateRsaKey(name);
        KeyCharacteristics call = new KeyCharacteristics();
        int result = mKeyStore.getKeyCharacteristics(name, null, null, call);
        assertEquals("getKeyCharacteristics should succeed", KeyStore.NO_ERROR, result);
        mKeyStore.delete("test");
!!!28135607.java!!!	testAppId() : void
        String name = "test";
        byte[] id = new byte[] {0x01, 0x02, 0x03};
        KeymasterArguments args = new KeymasterArguments();
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_ENCRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_DECRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, KeymasterDefs.KM_ALGORITHM_RSA);
        args.addEnum(KeymasterDefs.KM_TAG_PADDING, KeymasterDefs.KM_PAD_NONE);
        args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE, 2048);
        args.addEnum(KeymasterDefs.KM_TAG_BLOCK_MODE, KeymasterDefs.KM_MODE_ECB);
        args.addBoolean(KeymasterDefs.KM_TAG_NO_AUTH_REQUIRED);
        args.addBytes(KeymasterDefs.KM_TAG_APPLICATION_ID, id);
        args.addUnsignedLong(KeymasterDefs.KM_TAG_RSA_PUBLIC_EXPONENT, RSAKeyGenParameterSpec.F4);

        KeyCharacteristics outCharacteristics = new KeyCharacteristics();
        int result = mKeyStore.generateKey(name, args, null, 0, outCharacteristics);
        assertEquals("generateRsaKey should succeed", KeyStore.NO_ERROR, result);
        assertEquals("getKeyCharacteristics should fail without application ID",
                KeymasterDefs.KM_ERROR_INVALID_KEY_BLOB,
                mKeyStore.getKeyCharacteristics(name, null, null, outCharacteristics));
        assertEquals("getKeyCharacteristics should succeed with application ID",
                KeyStore.NO_ERROR,
                mKeyStore.getKeyCharacteristics(name, new KeymasterBlob(id), null,
                    outCharacteristics));
!!!28135735.java!!!	testExportRsa() : void
        String name = "test";
        generateRsaKey(name);
        ExportResult result = mKeyStore.exportKey(name, KeymasterDefs.KM_KEY_FORMAT_X509, null,
                null);
        assertEquals("Export success", KeyStore.NO_ERROR, result.resultCode);
        // TODO: Verify we have an RSA public key that's well formed.
!!!28135863.java!!!	testAesGcmEncryptSuccess() : void
        String name = "test";
        KeymasterArguments args = new KeymasterArguments();
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_ENCRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_DECRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, KeymasterDefs.KM_ALGORITHM_AES);
        args.addEnum(KeymasterDefs.KM_TAG_PADDING, KeymasterDefs.KM_PAD_NONE);
        args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE, 256);
        args.addEnum(KeymasterDefs.KM_TAG_BLOCK_MODE, KeymasterDefs.KM_MODE_GCM);
        args.addBoolean(KeymasterDefs.KM_TAG_NO_AUTH_REQUIRED);

        KeyCharacteristics outCharacteristics = new KeyCharacteristics();
        int rc = mKeyStore.generateKey(name, args, null, 0, outCharacteristics);
        assertEquals("Generate should succeed", KeyStore.NO_ERROR, rc);

        args = new KeymasterArguments();
        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, KeymasterDefs.KM_ALGORITHM_AES);
        args.addEnum(KeymasterDefs.KM_TAG_BLOCK_MODE, KeymasterDefs.KM_MODE_GCM);
        args.addEnum(KeymasterDefs.KM_TAG_PADDING, KeymasterDefs.KM_PAD_NONE);
        args.addUnsignedInt(KeymasterDefs.KM_TAG_MAC_LENGTH, 128);
        OperationResult result = mKeyStore.begin(name, KeymasterDefs.KM_PURPOSE_ENCRYPT,
                true, args, null);
        IBinder token = result.token;
        assertEquals("Begin should succeed", KeyStore.NO_ERROR, result.resultCode);
        result = mKeyStore.update(token, null, new byte[] {0x01, 0x02, 0x03, 0x04});
        assertEquals("Update should succeed", KeyStore.NO_ERROR, result.resultCode);
        assertEquals("Finish should succeed", KeyStore.NO_ERROR,
                mKeyStore.finish(token, null, null).resultCode);
        // TODO: Assert that an AEAD tag was returned by finish
!!!28135991.java!!!	testBadToken() : void
        IBinder token = new Binder();
        OperationResult result = mKeyStore.update(token, null, new byte[] {0x01});
        assertEquals("Update with invalid token should fail",
                KeymasterDefs.KM_ERROR_INVALID_OPERATION_HANDLE, result.resultCode);
!!!28136119.java!!!	importAesKey(inout name : String, inout key : byte, in size : int, in mode : int) : int
        KeymasterArguments args = new KeymasterArguments();
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_ENCRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_DECRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, KeymasterDefs.KM_ALGORITHM_AES);
        args.addEnum(KeymasterDefs.KM_TAG_PADDING, KeymasterDefs.KM_PAD_NONE);
        args.addEnum(KeymasterDefs.KM_TAG_BLOCK_MODE, mode);
        args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE, size);
        args.addBoolean(KeymasterDefs.KM_TAG_NO_AUTH_REQUIRED);
        return mKeyStore.importKey(name, args, KeymasterDefs.KM_KEY_FORMAT_RAW, key, 0,
                new KeyCharacteristics());
!!!28136247.java!!!	doOperation(inout name : String, in purpose : int, inout in : byte, inout beginArgs : KeymasterArguments) : byte
        OperationResult result = mKeyStore.begin(name, purpose,
                true, beginArgs, null);
        assertEquals("Begin should succeed", KeyStore.NO_ERROR, result.resultCode);
        IBinder token = result.token;
        result = mKeyStore.update(token, null, in);
        assertEquals("Update should succeed", KeyStore.NO_ERROR, result.resultCode);
        assertEquals("All data should be consumed", in.length, result.inputConsumed);
        assertEquals("Finish should succeed", KeyStore.NO_ERROR,
                mKeyStore.finish(token, null, null).resultCode);
        return result.output;
!!!28136375.java!!!	testImportAes() : void
        int result = importAesKey("aes", AES256_BYTES, 256, KeymasterDefs.KM_MODE_ECB);
        assertEquals("import should succeed", KeyStore.NO_ERROR, result);
        mKeyStore.delete("aes");
!!!28136503.java!!!	testAes256Ecb() : void
        byte[] key =
                hexToBytes("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4");
        String name = "aes";
        assertEquals(KeyStore.NO_ERROR, importAesKey(name, key, 256, KeymasterDefs.KM_MODE_ECB));
        byte[][] testVectors = new byte[][] {
            hexToBytes("6bc1bee22e409f96e93d7e117393172a"),
            hexToBytes("ae2d8a571e03ac9c9eb76fac45af8e51"),
            hexToBytes("30c81c46a35ce411e5fbc1191a0a52ef"),
            hexToBytes("f69f2445df4f9b17ad2b417be66c3710")};
        byte[][] cipherVectors = new byte[][] {
            hexToBytes("f3eed1bdb5d2a03c064b5a7e3db181f8"),
            hexToBytes("591ccb10d410ed26dc5ba74a31362870"),
            hexToBytes("b6ed21b99ca6f4f9f153e7b1beafed1d"),
            hexToBytes("23304b7a39f9f3ff067d8d8f9e24ecc7")};
        KeymasterArguments beginArgs = new KeymasterArguments();
        beginArgs.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, KeymasterDefs.KM_ALGORITHM_AES);
        beginArgs.addEnum(KeymasterDefs.KM_TAG_BLOCK_MODE, KeymasterDefs.KM_MODE_ECB);
        beginArgs.addEnum(KeymasterDefs.KM_TAG_PADDING, KeymasterDefs.KM_PAD_NONE);
        for (int i = 0; i < testVectors.length; i++) {
            byte[] cipherText = doOperation(name, KeymasterDefs.KM_PURPOSE_ENCRYPT, testVectors[i],
                    beginArgs);
            MoreAsserts.assertEquals(cipherVectors[i], cipherText);
        }
        for (int i = 0; i < testVectors.length; i++) {
            byte[] plainText = doOperation(name, KeymasterDefs.KM_PURPOSE_DECRYPT,
                    cipherVectors[i], beginArgs);
            MoreAsserts.assertEquals(testVectors[i], plainText);
        }
!!!28136631.java!!!	testOperationPruning() : void
        String name = "test";
        KeymasterArguments args = new KeymasterArguments();
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_ENCRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_DECRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, KeymasterDefs.KM_ALGORITHM_AES);
        args.addEnum(KeymasterDefs.KM_TAG_PADDING, KeymasterDefs.KM_PAD_NONE);
        args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE, 256);
        args.addEnum(KeymasterDefs.KM_TAG_BLOCK_MODE, KeymasterDefs.KM_MODE_CTR);
        args.addBoolean(KeymasterDefs.KM_TAG_NO_AUTH_REQUIRED);

        KeyCharacteristics outCharacteristics = new KeyCharacteristics();
        int rc = mKeyStore.generateKey(name, args, null, 0, outCharacteristics);
        assertEquals("Generate should succeed", KeyStore.NO_ERROR, rc);

        args = new KeymasterArguments();
        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, KeymasterDefs.KM_ALGORITHM_AES);
        args.addEnum(KeymasterDefs.KM_TAG_BLOCK_MODE, KeymasterDefs.KM_MODE_CTR);
        args.addEnum(KeymasterDefs.KM_TAG_PADDING, KeymasterDefs.KM_PAD_NONE);
        OperationResult result = mKeyStore.begin(name, KeymasterDefs.KM_PURPOSE_ENCRYPT,
                true, args, null);
        assertEquals("Begin should succeed", KeyStore.NO_ERROR, result.resultCode);
        IBinder first = result.token;
        // Implementation detail: softkeymaster supports 16 concurrent operations
        for (int i = 0; i < 16; i++) {
            result = mKeyStore.begin(name, KeymasterDefs.KM_PURPOSE_ENCRYPT, true, args, null);
            assertEquals("Begin should succeed", KeyStore.NO_ERROR, result.resultCode);
        }
        // At this point the first operation should be pruned.
        assertEquals("Operation should be pruned", KeymasterDefs.KM_ERROR_INVALID_OPERATION_HANDLE,
                mKeyStore.update(first, null, new byte[] {0x01}).resultCode);
!!!28136759.java!!!	testAuthNeeded() : void
        String name = "test";
        KeymasterArguments args = new KeymasterArguments();
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_ENCRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_PURPOSE, KeymasterDefs.KM_PURPOSE_DECRYPT);
        args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, KeymasterDefs.KM_ALGORITHM_AES);
        args.addEnum(KeymasterDefs.KM_TAG_PADDING, KeymasterDefs.KM_PAD_PKCS7);
        args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE, 256);
        args.addEnum(KeymasterDefs.KM_TAG_BLOCK_MODE, KeymasterDefs.KM_MODE_ECB);
        args.addEnum(KeymasterDefs.KM_TAG_USER_AUTH_TYPE, 1);

        KeyCharacteristics outCharacteristics = new KeyCharacteristics();
        int rc = mKeyStore.generateKey(name, args, null, 0, outCharacteristics);
        assertEquals("Generate should succeed", KeyStore.NO_ERROR, rc);
        OperationResult result = mKeyStore.begin(name, KeymasterDefs.KM_PURPOSE_ENCRYPT,
                true, args, null);
        assertEquals("Begin should expect authorization", KeyStore.OP_AUTH_NEEDED,
                result.resultCode);
        IBinder token = result.token;
        result = mKeyStore.update(token, null, new byte[] {0x01, 0x02, 0x03, 0x04});
        assertEquals("Update should require authorization",
                KeymasterDefs.KM_ERROR_KEY_USER_NOT_AUTHENTICATED, result.resultCode);
!!!28136887.java!!!	testPasswordRemovalEncryptedEntry() : void
        mKeyStore.onUserPasswordChanged("test");
        assertTrue(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, KeyStore.UID_SELF,
                KeyStore.FLAG_ENCRYPTED));
        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        assertTrue(Arrays.equals(TEST_KEYVALUE, mKeyStore.get(TEST_KEYNAME)));
        mKeyStore.onUserPasswordChanged("");
        // Removing the password should have deleted all entries using FLAG_ENCRYPTED
        assertNull(mKeyStore.get(TEST_KEYNAME));
        assertFalse(mKeyStore.contains(TEST_KEYNAME));
!!!28137015.java!!!	testPasswordRemovalUnencryptedEntry() : void
        mKeyStore.onUserPasswordChanged("test");
        assertTrue(mKeyStore.put(TEST_KEYNAME, TEST_KEYVALUE, KeyStore.UID_SELF,
                KeyStore.FLAG_NONE));
        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        assertTrue(Arrays.equals(TEST_KEYVALUE, mKeyStore.get(TEST_KEYNAME)));
        mKeyStore.onUserPasswordChanged("");
        // Removing the password should not delete unencrypted entries.
        assertTrue(mKeyStore.contains(TEST_KEYNAME));
        assertTrue(Arrays.equals(TEST_KEYVALUE, mKeyStore.get(TEST_KEYNAME)));
