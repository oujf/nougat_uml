class Activity
!!!365367.java!!!	getIntent() : Intent
        return mIntent;
!!!365495.java!!!	setIntent(inout newIntent : Intent) : void
        mIntent = newIntent;
!!!365623.java!!!	getApplication() : Application
        return mApplication;
!!!365751.java!!!	isChild() : boolean
        return mParent != null;
!!!365879.java!!!	getParent() : Activity
        return mParent;
!!!366007.java!!!	getWindowManager() : WindowManager
        return mWindowManager;
!!!366135.java!!!	getWindow() : Window
        return mWindow;
!!!366263.java!!!	getLoaderManager() : LoaderManager
        return mFragments.getLoaderManager();
!!!366391.java!!!	getCurrentFocus() : View
        return mWindow != null ? mWindow.getCurrentFocus() : null;
!!!366519.java!!!	onCreate(inout savedInstanceState : Bundle) : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onCreate " + this + ": " + savedInstanceState);
        if (mLastNonConfigurationInstances != null) {
            mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);
        }
        if (mActivityInfo.parentActivityName != null) {
            if (mActionBar == null) {
                mEnableDefaultActionBarUp = true;
            } else {
                mActionBar.setDefaultDisplayHomeAsUpEnabled(true);
            }
        }
        if (savedInstanceState != null) {
            Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);
            mFragments.restoreAllState(p, mLastNonConfigurationInstances != null
                    ? mLastNonConfigurationInstances.fragments : null);
        }
        mFragments.dispatchCreate();
        getApplication().dispatchActivityCreated(this, savedInstanceState);
        if (mVoiceInteractor != null) {
            mVoiceInteractor.attachActivity(this);
        }
        mCalled = true;
!!!366647.java!!!	onCreate(inout savedInstanceState : Bundle, inout persistentState : PersistableBundle) : void
        onCreate(savedInstanceState);
!!!366775.java!!!	performRestoreInstanceState(inout savedInstanceState : Bundle) : void
        onRestoreInstanceState(savedInstanceState);
        restoreManagedDialogs(savedInstanceState);
!!!366903.java!!!	performRestoreInstanceState(inout savedInstanceState : Bundle, inout persistentState : PersistableBundle) : void
        onRestoreInstanceState(savedInstanceState, persistentState);
        if (savedInstanceState != null) {
            restoreManagedDialogs(savedInstanceState);
        }
!!!367031.java!!!	onRestoreInstanceState(inout savedInstanceState : Bundle) : void
        if (mWindow != null) {
            Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);
            if (windowState != null) {
                mWindow.restoreHierarchyState(windowState);
            }
        }
!!!367159.java!!!	onRestoreInstanceState(inout savedInstanceState : Bundle, inout persistentState : PersistableBundle) : void
        if (savedInstanceState != null) {
            onRestoreInstanceState(savedInstanceState);
        }
!!!367287.java!!!	restoreManagedDialogs(inout savedInstanceState : Bundle) : void
        final Bundle b = savedInstanceState.getBundle(SAVED_DIALOGS_TAG);
        if (b == null) {
            return;
        }

        final int[] ids = b.getIntArray(SAVED_DIALOG_IDS_KEY);
        final int numDialogs = ids.length;
        mManagedDialogs = new SparseArray<ManagedDialog>(numDialogs);
        for (int i = 0; i < numDialogs; i++) {
            final Integer dialogId = ids[i];
            Bundle dialogState = b.getBundle(savedDialogKeyFor(dialogId));
            if (dialogState != null) {
                // Calling onRestoreInstanceState() below will invoke dispatchOnCreate
                // so tell createDialog() not to do it, otherwise we get an exception
                final ManagedDialog md = new ManagedDialog();
                md.mArgs = b.getBundle(savedDialogArgsKeyFor(dialogId));
                md.mDialog = createDialog(dialogId, dialogState, md.mArgs);
                if (md.mDialog != null) {
                    mManagedDialogs.put(dialogId, md);
                    onPrepareDialog(dialogId, md.mDialog, md.mArgs);
                    md.mDialog.onRestoreInstanceState(dialogState);
                }
            }
        }
!!!367415.java!!!	createDialog(inout dialogId : Integer, inout state : Bundle, inout args : Bundle) : Dialog
        final Dialog dialog = onCreateDialog(dialogId, args);
        if (dialog == null) {
            return null;
        }
        dialog.dispatchOnCreate(state);
        return dialog;
!!!367543.java!!!	savedDialogKeyFor(in key : int) : String
        return SAVED_DIALOG_KEY_PREFIX + key;
!!!367671.java!!!	savedDialogArgsKeyFor(in key : int) : String
        return SAVED_DIALOG_ARGS_KEY_PREFIX + key;
!!!367799.java!!!	onPostCreate(inout savedInstanceState : Bundle) : void
        if (!isChild()) {
            mTitleReady = true;
            onTitleChanged(getTitle(), getTitleColor());
        }

        mCalled = true;
!!!367927.java!!!	onPostCreate(inout savedInstanceState : Bundle, inout persistentState : PersistableBundle) : void
        onPostCreate(savedInstanceState);
!!!368055.java!!!	onStart() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onStart " + this);
        mCalled = true;

        mFragments.doLoaderStart();

        getApplication().dispatchActivityStarted(this);
!!!368183.java!!!	onRestart() : void
        mCalled = true;
!!!368439.java!!!	onResume() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onResume " + this);
        getApplication().dispatchActivityResumed(this);
        mActivityTransitionState.onResume(this, isTopOfTask());
        mCalled = true;
!!!368567.java!!!	onPostResume() : void
        final Window win = getWindow();
        if (win != null) win.makeActive();
        if (mActionBar != null) mActionBar.setShowHideAnimationEnabled(true);
        mCalled = true;
!!!368695.java!!!	setVoiceInteractor(inout voiceInteractor : IVoiceInteractor) : void
        if (mVoiceInteractor != null) {
            for (Request activeRequest: mVoiceInteractor.getActiveRequests()) {
                activeRequest.cancel();
                activeRequest.clear();
            }
        }
        if (voiceInteractor == null) {
            mVoiceInteractor = null;
        } else {
            mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,
                    Looper.myLooper());
        }
!!!368823.java!!!	isVoiceInteraction() : boolean
        return mVoiceInteractor != null;
!!!368951.java!!!	isVoiceInteractionRoot() : boolean
        try {
            return mVoiceInteractor != null
                    && ActivityManagerNative.getDefault().isRootVoiceInteraction(mToken);
        } catch (RemoteException e) {
        }
        return false;
!!!369079.java!!!	getVoiceInteractor() : VoiceInteractor
        return mVoiceInteractor;
!!!369207.java!!!	isLocalVoiceInteractionSupported() : boolean
        try {
            return ActivityManagerNative.getDefault().supportsLocalVoiceInteraction();
        } catch (RemoteException re) {
        }
        return false;
!!!369335.java!!!	startLocalVoiceInteraction(inout privateOptions : Bundle) : void
        try {
            ActivityManagerNative.getDefault().startLocalVoiceInteraction(mToken, privateOptions);
        } catch (RemoteException re) {
        }
!!!369719.java!!!	stopLocalVoiceInteraction() : void
        try {
            ActivityManagerNative.getDefault().stopLocalVoiceInteraction(mToken);
        } catch (RemoteException re) {
        }
!!!369975.java!!!	performSaveInstanceState(inout outState : Bundle) : void
        onSaveInstanceState(outState);
        saveManagedDialogs(outState);
        mActivityTransitionState.saveState(outState);
        storeHasCurrentPermissionRequest(outState);
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onSaveInstanceState " + this + ": " + outState);
!!!370103.java!!!	performSaveInstanceState(inout outState : Bundle, inout outPersistentState : PersistableBundle) : void
        onSaveInstanceState(outState, outPersistentState);
        saveManagedDialogs(outState);
        storeHasCurrentPermissionRequest(outState);
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onSaveInstanceState " + this + ": " + outState +
                ", " + outPersistentState);
!!!370231.java!!!	onSaveInstanceState(inout outState : Bundle) : void
        outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
        Parcelable p = mFragments.saveAllState();
        if (p != null) {
            outState.putParcelable(FRAGMENTS_TAG, p);
        }
        getApplication().dispatchActivitySaveInstanceState(this, outState);
!!!370359.java!!!	onSaveInstanceState(inout outState : Bundle, inout outPersistentState : PersistableBundle) : void
        onSaveInstanceState(outState);
!!!370487.java!!!	saveManagedDialogs(inout outState : Bundle) : void
        if (mManagedDialogs == null) {
            return;
        }

        final int numDialogs = mManagedDialogs.size();
        if (numDialogs == 0) {
            return;
        }

        Bundle dialogState = new Bundle();

        int[] ids = new int[mManagedDialogs.size()];

        // save each dialog's bundle, gather the ids
        for (int i = 0; i < numDialogs; i++) {
            final int key = mManagedDialogs.keyAt(i);
            ids[i] = key;
            final ManagedDialog md = mManagedDialogs.valueAt(i);
            dialogState.putBundle(savedDialogKeyFor(key), md.mDialog.onSaveInstanceState());
            if (md.mArgs != null) {
                dialogState.putBundle(savedDialogArgsKeyFor(key), md.mArgs);
            }
        }

        dialogState.putIntArray(SAVED_DIALOG_IDS_KEY, ids);
        outState.putBundle(SAVED_DIALOGS_TAG, dialogState);
!!!370615.java!!!	onPause() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onPause " + this);
        getApplication().dispatchActivityPaused(this);
        mCalled = true;
!!!370871.java!!!	onCreateThumbnail(inout outBitmap : Bitmap, inout canvas : Canvas) : boolean
        return false;
!!!370999.java!!!	onCreateDescription() : CharSequence
        return null;
!!!371383.java!!!	requestShowKeyboardShortcuts() : void
        Intent intent = new Intent(Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS);
        intent.setComponent(new ComponentName(KEYBOARD_SHORTCUTS_RECEIVER_PKG_NAME,
                KEYBOARD_SHORTCUTS_RECEIVER_CLASS_NAME));
        sendBroadcast(intent);
!!!371511.java!!!	dismissKeyboardShortcutsHelper() : void
        Intent intent = new Intent(Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS);
        intent.setComponent(new ComponentName(KEYBOARD_SHORTCUTS_RECEIVER_PKG_NAME,
                KEYBOARD_SHORTCUTS_RECEIVER_CLASS_NAME));
        sendBroadcast(intent);
!!!371639.java!!!	onProvideKeyboardShortcuts(inout data : List<KeyboardShortcutGroup>, inout menu : Menu, in deviceId : int) : void
        if (menu == null) {
          return;
        }
        KeyboardShortcutGroup group = null;
        int menuSize = menu.size();
        for (int i = 0; i < menuSize; ++i) {
            final MenuItem item = menu.getItem(i);
            final CharSequence title = item.getTitle();
            final char alphaShortcut = item.getAlphabeticShortcut();
            if (title != null && alphaShortcut != MIN_VALUE) {
                if (group == null) {
                    final int resource = mApplication.getApplicationInfo().labelRes;
                    group = new KeyboardShortcutGroup(resource != 0 ? getString(resource) : null);
                }
                group.addItem(new KeyboardShortcutInfo(
                    title, alphaShortcut, KeyEvent.META_CTRL_ON));
            }
        }
        if (group != null) {
            data.add(group);
        }
!!!371767.java!!!	showAssist(inout args : Bundle) : boolean
        try {
            return ActivityManagerNative.getDefault().showAssistFromActivity(mToken, args);
        } catch (RemoteException e) {
        }
        return false;
!!!371895.java!!!	onStop() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onStop " + this);
        if (mActionBar != null) mActionBar.setShowHideAnimationEnabled(false);
        mActivityTransitionState.onStop();
        getApplication().dispatchActivityStopped(this);
        mTranslucentCallback = null;
        mCalled = true;
!!!372023.java!!!	onDestroy() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onDestroy " + this);
        mCalled = true;

        // dismiss any dialogs we are managing.
        if (mManagedDialogs != null) {
            final int numDialogs = mManagedDialogs.size();
            for (int i = 0; i < numDialogs; i++) {
                final ManagedDialog md = mManagedDialogs.valueAt(i);
                if (md.mDialog.isShowing()) {
                    md.mDialog.dismiss();
                }
            }
            mManagedDialogs = null;
        }

        // close any cursors we are managing.
        synchronized (mManagedCursors) {
            int numCursors = mManagedCursors.size();
            for (int i = 0; i < numCursors; i++) {
                ManagedCursor c = mManagedCursors.get(i);
                if (c != null) {
                    c.mCursor.close();
                }
            }
            mManagedCursors.clear();
        }

        // Close any open search dialog
        if (mSearchManager != null) {
            mSearchManager.stopSearch();
        }

        if (mActionBar != null) {
            mActionBar.onDestroy();
        }

        getApplication().dispatchActivityDestroyed(this);
!!!372151.java!!!	reportFullyDrawn() : void
        if (mDoReportFullyDrawn) {
            mDoReportFullyDrawn = false;
            try {
                ActivityManagerNative.getDefault().reportActivityFullyDrawn(mToken);
            } catch (RemoteException e) {
            }
        }
!!!372279.java!!!	onMultiWindowModeChanged(inout isInMultiWindowMode : boolean) : void
        // Left deliberately empty. There should be no side effects if a direct
        // subclass of Activity does not call super.
!!!372407.java!!!	isInMultiWindowMode() : boolean
        try {
            return ActivityManagerNative.getDefault().isInMultiWindowMode(mToken);
        } catch (RemoteException e) {
        }
        return false;
!!!372535.java!!!	onPictureInPictureModeChanged(inout isInPictureInPictureMode : boolean) : void
        // Left deliberately empty. There should be no side effects if a direct
        // subclass of Activity does not call super.
!!!372663.java!!!	isInPictureInPictureMode() : boolean
        try {
            return ActivityManagerNative.getDefault().isInPictureInPictureMode(mToken);
        } catch (RemoteException e) {
        }
        return false;
!!!372791.java!!!	enterPictureInPictureMode() : void
        try {
            ActivityManagerNative.getDefault().enterPictureInPictureMode(mToken);
        } catch (RemoteException e) {
        }
!!!372919.java!!!	onConfigurationChanged(inout newConfig : Configuration) : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onConfigurationChanged " + this + ": " + newConfig);
        mCalled = true;

        mFragments.dispatchConfigurationChanged(newConfig);

        if (mWindow != null) {
            // Pass the configuration changed event to the window
            mWindow.onConfigurationChanged(newConfig);
        }

        if (mActionBar != null) {
            // Do this last; the action bar will need to access
            // view changes from above.
            mActionBar.onConfigurationChanged(newConfig);
        }
!!!373047.java!!!	getChangingConfigurations() : int
        return mConfigChangeFlags;
!!!373175.java!!!	getLastNonConfigurationInstance() : Object
        return mLastNonConfigurationInstances != null
                ? mLastNonConfigurationInstances.activity : null;
!!!373303.java!!!	onRetainNonConfigurationInstance() : Object
        return null;
!!!373431.java!!!	getLastNonConfigurationChildInstances() : String
        return mLastNonConfigurationInstances != null
                ? mLastNonConfigurationInstances.children : null;
!!!373559.java!!!	onRetainNonConfigurationChildInstances() : String
        return null;
!!!373687.java!!!	retainNonConfigurationInstances() : Activity::NonConfigurationInstances
        Object activity = onRetainNonConfigurationInstance();
        HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
        FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig();

        // We're already stopped but we've been asked to retain.
        // Our fragments are taken care of but we need to mark the loaders for retention.
        // In order to do this correctly we need to restart the loaders first before
        // handing them off to the next activity.
        mFragments.doLoaderStart();
        mFragments.doLoaderStop(true);
        ArrayMap<String, LoaderManager> loaders = mFragments.retainLoaderNonConfig();

        if (activity == null && children == null && fragments == null && loaders == null
                && mVoiceInteractor == null) {
            return null;
        }

        NonConfigurationInstances nci = new NonConfigurationInstances();
        nci.activity = activity;
        nci.children = children;
        nci.fragments = fragments;
        nci.loaders = loaders;
        if (mVoiceInteractor != null) {
            mVoiceInteractor.retainInstance();
            nci.voiceInteractor = mVoiceInteractor;
        }
        return nci;
!!!373815.java!!!	onLowMemory() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onLowMemory " + this);
        mCalled = true;
        mFragments.dispatchLowMemory();
!!!373943.java!!!	onTrimMemory(in level : int) : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onTrimMemory " + this + ": " + level);
        mCalled = true;
        mFragments.dispatchTrimMemory(level);
!!!374071.java!!!	getFragmentManager() : FragmentManager
        return mFragments.getFragmentManager();
!!!374327.java!!!	managedQuery(inout uri : Uri, inout projection : String, inout selection : String, inout sortOrder : String) : Cursor
        Cursor c = getContentResolver().query(uri, projection, selection, null, sortOrder);
        if (c != null) {
            startManagingCursor(c);
        }
        return c;
!!!374455.java!!!	managedQuery(inout uri : Uri, inout projection : String, inout selection : String, inout selectionArgs : String, inout sortOrder : String) : Cursor
        Cursor c = getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);
        if (c != null) {
            startManagingCursor(c);
        }
        return c;
!!!374583.java!!!	startManagingCursor(inout c : Cursor) : void
        synchronized (mManagedCursors) {
            mManagedCursors.add(new ManagedCursor(c));
        }
!!!374711.java!!!	stopManagingCursor(inout c : Cursor) : void
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i=0; i<N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mCursor == c) {
                    mManagedCursors.remove(i);
                    break;
                }
            }
        }
!!!374967.java!!!	findViewById(in id : int) : View
        return getWindow().findViewById(id);
!!!375095.java!!!	getActionBar() : ActionBar
        initWindowDecorActionBar();
        return mActionBar;
!!!375223.java!!!	setActionBar(inout toolbar : Toolbar) : void
        final ActionBar ab = getActionBar();
        if (ab instanceof WindowDecorActionBar) {
            throw new IllegalStateException("This Activity already has an action bar supplied " +
                    "by the window decor. Do not request Window.FEATURE_ACTION_BAR and set " +
                    "android:windowActionBar to false in your theme to use a Toolbar instead.");
        }

        // If we reach here then we're setting a new action bar
        // First clear out the MenuInflater to make sure that it is valid for the new Action Bar
        mMenuInflater = null;

        // If we have an action bar currently, destroy it
        if (ab != null) {
            ab.onDestroy();
        }

        if (toolbar != null) {
            final ToolbarActionBar tbab = new ToolbarActionBar(toolbar, getTitle(), this);
            mActionBar = tbab;
            mWindow.setCallback(tbab.getWrappedWindowCallback());
        } else {
            mActionBar = null;
            // Re-set the original window callback since we may have already set a Toolbar wrapper
            mWindow.setCallback(this);
        }

        invalidateOptionsMenu();
!!!375351.java!!!	initWindowDecorActionBar() : void
        Window window = getWindow();

        // Initializing the window decor can change window feature flags.
        // Make sure that we have the correct set before performing the test below.
        window.getDecorView();

        if (isChild() || !window.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != null) {
            return;
        }

        mActionBar = new WindowDecorActionBar(this);
        mActionBar.setDefaultDisplayHomeAsUpEnabled(mEnableDefaultActionBarUp);

        mWindow.setDefaultIcon(mActivityInfo.getIconResource());
        mWindow.setDefaultLogo(mActivityInfo.getLogoResource());
!!!375479.java!!!	setContentView(in layoutResID : int) : void
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
!!!375607.java!!!	setContentView(inout view : View) : void
        getWindow().setContentView(view);
        initWindowDecorActionBar();
!!!375735.java!!!	setContentView(inout view : View, inout params : ViewGroup::LayoutParams) : void
        getWindow().setContentView(view, params);
        initWindowDecorActionBar();
!!!375863.java!!!	addContentView(inout view : View, inout params : ViewGroup::LayoutParams) : void
        getWindow().addContentView(view, params);
        initWindowDecorActionBar();
!!!375991.java!!!	getContentTransitionManager() : TransitionManager
        return getWindow().getTransitionManager();
!!!376119.java!!!	setContentTransitionManager(inout tm : TransitionManager) : void
        getWindow().setTransitionManager(tm);
!!!376247.java!!!	getContentScene() : Scene
        return getWindow().getContentScene();
!!!376375.java!!!	setFinishOnTouchOutside(inout finish : boolean) : void
        mWindow.setCloseOnTouchOutside(finish);
!!!376503.java!!!	setDefaultKeyMode(in mode : int) : void
        mDefaultKeyMode = mode;

        // Some modes use a SpannableStringBuilder to track & dispatch input events
        // This list must remain in sync with the switch in onKeyDown()
        switch (mode) {
        case DEFAULT_KEYS_DISABLE:
        case DEFAULT_KEYS_SHORTCUT:
            mDefaultKeySsb = null;      // not used in these modes
            break;
        case DEFAULT_KEYS_DIALER:
        case DEFAULT_KEYS_SEARCH_LOCAL:
        case DEFAULT_KEYS_SEARCH_GLOBAL:
            mDefaultKeySsb = new SpannableStringBuilder();
            Selection.setSelection(mDefaultKeySsb,0);
            break;
        default:
            throw new IllegalArgumentException();
        }
!!!376631.java!!!	onKeyDown(in keyCode : int, inout event : KeyEvent) : boolean
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            if (getApplicationInfo().targetSdkVersion
                    >= Build.VERSION_CODES.ECLAIR) {
                event.startTracking();
            } else {
                onBackPressed();
            }
            return true;
        }

        if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
            return false;
        } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
            Window w = getWindow();
            if (w.hasFeature(Window.FEATURE_OPTIONS_PANEL) &&
                    w.performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event,
                            Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
                return true;
            }
            return false;
        } else {
            // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
            boolean clearSpannable = false;
            boolean handled;
            if ((event.getRepeatCount() != 0) || event.isSystem()) {
                clearSpannable = true;
                handled = false;
            } else {
                handled = TextKeyListener.getInstance().onKeyDown(
                        null, mDefaultKeySsb, keyCode, event);
                if (handled && mDefaultKeySsb.length() > 0) {
                    // something useable has been typed - dispatch it now.

                    final String str = mDefaultKeySsb.toString();
                    clearSpannable = true;

                    switch (mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL,  Uri.parse("tel:" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                    }
                }
            }
            if (clearSpannable) {
                mDefaultKeySsb.clear();
                mDefaultKeySsb.clearSpans();
                Selection.setSelection(mDefaultKeySsb,0);
            }
            return handled;
        }
!!!376759.java!!!	onKeyLongPress(in keyCode : int, inout event : KeyEvent) : boolean
        return false;
!!!376887.java!!!	onKeyUp(in keyCode : int, inout event : KeyEvent) : boolean
        if (getApplicationInfo().targetSdkVersion
                >= Build.VERSION_CODES.ECLAIR) {
            if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking()
                    && !event.isCanceled()) {
                onBackPressed();
                return true;
            }
        }
        return false;
!!!377015.java!!!	onKeyMultiple(in keyCode : int, in repeatCount : int, inout event : KeyEvent) : boolean
        return false;
!!!377143.java!!!	onBackPressed() : void
        if (mActionBar != null && mActionBar.collapseActionView()) {
            return;
        }

        if (!mFragments.getFragmentManager().popBackStackImmediate()) {
            finishAfterTransition();
        }
!!!377271.java!!!	onKeyShortcut(in keyCode : int, inout event : KeyEvent) : boolean
        // Let the Action Bar have a chance at handling the shortcut.
        ActionBar actionBar = getActionBar();
        return (actionBar != null && actionBar.onKeyShortcut(keyCode, event));
!!!377399.java!!!	onTouchEvent(inout event : MotionEvent) : boolean
        if (mWindow.shouldCloseOnTouch(this, event)) {
            finish();
            return true;
        }

        return false;
!!!377527.java!!!	onTrackballEvent(inout event : MotionEvent) : boolean
        return false;
!!!377655.java!!!	onGenericMotionEvent(inout event : MotionEvent) : boolean
        return false;
!!!377911.java!!!	onWindowAttributesChanged(inout params : WindowManager::LayoutParams) : void
        // Update window manager if: we have a view, that view is
        // attached to its parent (which will be a RootView), and
        // this activity is not embedded.
        if (mParent == null) {
            View decor = mDecor;
            if (decor != null && decor.getParent() != null) {
                getWindowManager().updateViewLayout(decor, params);
            }
        }
!!!378551.java!!!	hasWindowFocus() : boolean
        Window w = getWindow();
        if (w != null) {
            View d = w.getDecorView();
            if (d != null) {
                return d.hasWindowFocus();
            }
        }
        return false;
!!!378679.java!!!	onWindowDismissed(inout finishTask : boolean) : void
        finish(finishTask ? FINISH_TASK_WITH_ACTIVITY : DONT_FINISH_TASK_WITH_ACTIVITY);
!!!378807.java!!!	exitFreeformMode() : void
        ActivityManagerNative.getDefault().exitFreeformMode(mToken);
!!!378935.java!!!	getWindowStackId() : int
        return ActivityManagerNative.getDefault().getActivityStackId(mToken);
!!!379063.java!!!	enterPictureInPictureModeIfPossible() : void
        if (mActivityInfo.resizeMode == ActivityInfo.RESIZE_MODE_RESIZEABLE_AND_PIPABLE) {
            enterPictureInPictureMode();
        }
!!!379191.java!!!	dispatchKeyEvent(inout event : KeyEvent) : boolean
        onUserInteraction();

        // Let action bars open menus in response to the menu key prioritized over
        // the window handling it
        final int keyCode = event.getKeyCode();
        if (keyCode == KeyEvent.KEYCODE_MENU &&
                mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
            return true;
        } else if (event.isCtrlPressed() &&
                event.getUnicodeChar(event.getMetaState() & ~KeyEvent.META_CTRL_MASK) == '<') {
            // Capture the Control-< and send focus to the ActionBar
            final int action = event.getAction();
            if (action == KeyEvent.ACTION_DOWN) {
                final ActionBar actionBar = getActionBar();
                if (actionBar != null && actionBar.isShowing() && actionBar.requestFocus()) {
                    mEatKeyUpEvent = true;
                    return true;
                }
            } else if (action == KeyEvent.ACTION_UP && mEatKeyUpEvent) {
                mEatKeyUpEvent = false;
                return true;
            }
        }

        Window win = getWindow();
        if (win.superDispatchKeyEvent(event)) {
            return true;
        }
        View decor = mDecor;
        if (decor == null) decor = win.getDecorView();
        return event.dispatch(this, decor != null
                ? decor.getKeyDispatcherState() : null, this);
!!!379319.java!!!	dispatchKeyShortcutEvent(inout event : KeyEvent) : boolean
        onUserInteraction();
        if (getWindow().superDispatchKeyShortcutEvent(event)) {
            return true;
        }
        return onKeyShortcut(event.getKeyCode(), event);
!!!379447.java!!!	dispatchTouchEvent(inout ev : MotionEvent) : boolean
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
!!!379575.java!!!	dispatchTrackballEvent(inout ev : MotionEvent) : boolean
        onUserInteraction();
        if (getWindow().superDispatchTrackballEvent(ev)) {
            return true;
        }
        return onTrackballEvent(ev);
!!!379703.java!!!	dispatchGenericMotionEvent(inout ev : MotionEvent) : boolean
        onUserInteraction();
        if (getWindow().superDispatchGenericMotionEvent(ev)) {
            return true;
        }
        return onGenericMotionEvent(ev);
!!!379831.java!!!	dispatchPopulateAccessibilityEvent(inout event : AccessibilityEvent) : boolean
        event.setClassName(getClass().getName());
        event.setPackageName(getPackageName());

        LayoutParams params = getWindow().getAttributes();
        boolean isFullScreen = (params.width == LayoutParams.MATCH_PARENT) &&
            (params.height == LayoutParams.MATCH_PARENT);
        event.setFullScreen(isFullScreen);

        CharSequence title = getTitle();
        if (!TextUtils.isEmpty(title)) {
           event.getText().add(title);
        }

        return true;
!!!379959.java!!!	onCreatePanelView(in featureId : int) : View
        return null;
!!!380087.java!!!	onCreatePanelMenu(in featureId : int, inout menu : Menu) : boolean
        if (featureId == Window.FEATURE_OPTIONS_PANEL) {
            boolean show = onCreateOptionsMenu(menu);
            show |= mFragments.dispatchCreateOptionsMenu(menu, getMenuInflater());
            return show;
        }
        return false;
!!!380215.java!!!	onPreparePanel(in featureId : int, inout view : View, inout menu : Menu) : boolean
        if (featureId == Window.FEATURE_OPTIONS_PANEL && menu != null) {
            boolean goforit = onPrepareOptionsMenu(menu);
            goforit |= mFragments.dispatchPrepareOptionsMenu(menu);
            return goforit;
        }
        return true;
!!!380343.java!!!	onMenuOpened(in featureId : int, inout menu : Menu) : boolean
        if (featureId == Window.FEATURE_ACTION_BAR) {
            initWindowDecorActionBar();
            if (mActionBar != null) {
                mActionBar.dispatchMenuVisibilityChanged(true);
            } else {
                Log.e(TAG, "Tried to open action bar menu with no action bar");
            }
        }
        return true;
!!!380471.java!!!	onMenuItemSelected(in featureId : int, inout item : MenuItem) : boolean
        CharSequence titleCondensed = item.getTitleCondensed();

        switch (featureId) {
            case Window.FEATURE_OPTIONS_PANEL:
                // Put event logging here so it gets called even if subclass
                // doesn't call through to superclass's implmeentation of each
                // of these methods below
                if(titleCondensed != null) {
                    EventLog.writeEvent(50000, 0, titleCondensed.toString());
                }
                if (onOptionsItemSelected(item)) {
                    return true;
                }
                if (mFragments.dispatchOptionsItemSelected(item)) {
                    return true;
                }
                if (item.getItemId() == android.R.id.home && mActionBar != null &&
                        (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
                    if (mParent == null) {
                        return onNavigateUp();
                    } else {
                        return mParent.onNavigateUpFromChild(this);
                    }
                }
                return false;

            case Window.FEATURE_CONTEXT_MENU:
                if(titleCondensed != null) {
                    EventLog.writeEvent(50000, 1, titleCondensed.toString());
                }
                if (onContextItemSelected(item)) {
                    return true;
                }
                return mFragments.dispatchContextItemSelected(item);

            default:
                return false;
        }
!!!380599.java!!!	onPanelClosed(in featureId : int, inout menu : Menu) : void
        switch (featureId) {
            case Window.FEATURE_OPTIONS_PANEL:
                mFragments.dispatchOptionsMenuClosed(menu);
                onOptionsMenuClosed(menu);
                break;

            case Window.FEATURE_CONTEXT_MENU:
                onContextMenuClosed(menu);
                break;

            case Window.FEATURE_ACTION_BAR:
                initWindowDecorActionBar();
                mActionBar.dispatchMenuVisibilityChanged(false);
                break;
        }
!!!380727.java!!!	invalidateOptionsMenu() : void
        if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL) &&
                (mActionBar == null || !mActionBar.invalidateOptionsMenu())) {
            mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
        }
!!!380855.java!!!	onCreateOptionsMenu(inout menu : Menu) : boolean
        if (mParent != null) {
            return mParent.onCreateOptionsMenu(menu);
        }
        return true;
!!!380983.java!!!	onPrepareOptionsMenu(inout menu : Menu) : boolean
        if (mParent != null) {
            return mParent.onPrepareOptionsMenu(menu);
        }
        return true;
!!!381111.java!!!	onOptionsItemSelected(inout item : MenuItem) : boolean
        if (mParent != null) {
            return mParent.onOptionsItemSelected(item);
        }
        return false;
!!!381239.java!!!	onNavigateUp() : boolean
        // Automatically handle hierarchical Up navigation if the proper
        // metadata is available.
        Intent upIntent = getParentActivityIntent();
        if (upIntent != null) {
            if (mActivityInfo.taskAffinity == null) {
                // Activities with a null affinity are special; they really shouldn't
                // specify a parent activity intent in the first place. Just finish
                // the current activity and call it a day.
                finish();
            } else if (shouldUpRecreateTask(upIntent)) {
                TaskStackBuilder b = TaskStackBuilder.create(this);
                onCreateNavigateUpTaskStack(b);
                onPrepareNavigateUpTaskStack(b);
                b.startActivities();

                // We can't finishAffinity if we have a result.
                // Fall back and simply finish the current activity instead.
                if (mResultCode != RESULT_CANCELED || mResultData != null) {
                    // Tell the developer what's going on to avoid hair-pulling.
                    Log.i(TAG, "onNavigateUp only finishing topmost activity to return a result");
                    finish();
                } else {
                    finishAffinity();
                }
            } else {
                navigateUpTo(upIntent);
            }
            return true;
        }
        return false;
!!!381367.java!!!	onNavigateUpFromChild(inout child : Activity) : boolean
        return onNavigateUp();
!!!381495.java!!!	onCreateNavigateUpTaskStack(inout builder : TaskStackBuilder) : void
        builder.addParentStack(this);
!!!381751.java!!!	onOptionsMenuClosed(inout menu : Menu) : void
        if (mParent != null) {
            mParent.onOptionsMenuClosed(menu);
        }
!!!381879.java!!!	openOptionsMenu() : void
        if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL) &&
                (mActionBar == null || !mActionBar.openOptionsMenu())) {
            mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
        }
!!!382007.java!!!	closeOptionsMenu() : void
        if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL)) {
            mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
        }
!!!382263.java!!!	registerForContextMenu(inout view : View) : void
        view.setOnCreateContextMenuListener(this);
!!!382391.java!!!	unregisterForContextMenu(inout view : View) : void
        view.setOnCreateContextMenuListener(null);
!!!382519.java!!!	openContextMenu(inout view : View) : void
        view.showContextMenu();
!!!382647.java!!!	closeContextMenu() : void
        if (mWindow.hasFeature(Window.FEATURE_CONTEXT_MENU)) {
            mWindow.closePanel(Window.FEATURE_CONTEXT_MENU);
        }
!!!382775.java!!!	onContextItemSelected(inout item : MenuItem) : boolean
        if (mParent != null) {
            return mParent.onContextItemSelected(item);
        }
        return false;
!!!382903.java!!!	onContextMenuClosed(inout menu : Menu) : void
        if (mParent != null) {
            mParent.onContextMenuClosed(menu);
        }
!!!383031.java!!!	onCreateDialog(in id : int) : Dialog
        return null;
!!!383159.java!!!	onCreateDialog(in id : int, inout args : Bundle) : Dialog
        return onCreateDialog(id);
!!!383287.java!!!	onPrepareDialog(in id : int, inout dialog : Dialog) : void
        dialog.setOwnerActivity(this);
!!!383415.java!!!	onPrepareDialog(in id : int, inout dialog : Dialog, inout args : Bundle) : void
        onPrepareDialog(id, dialog);
!!!383543.java!!!	showDialog(in id : int) : void
        showDialog(id, null);
!!!383671.java!!!	showDialog(in id : int, inout args : Bundle) : boolean
        if (mManagedDialogs == null) {
            mManagedDialogs = new SparseArray<ManagedDialog>();
        }
        ManagedDialog md = mManagedDialogs.get(id);
        if (md == null) {
            md = new ManagedDialog();
            md.mDialog = createDialog(id, null, args);
            if (md.mDialog == null) {
                return false;
            }
            mManagedDialogs.put(id, md);
        }

        md.mArgs = args;
        onPrepareDialog(id, md.mDialog, args);
        md.mDialog.show();
        return true;
!!!383799.java!!!	dismissDialog(in id : int) : void
        if (mManagedDialogs == null) {
            throw missingDialog(id);
        }

        final ManagedDialog md = mManagedDialogs.get(id);
        if (md == null) {
            throw missingDialog(id);
        }
        md.mDialog.dismiss();
!!!383927.java!!!	missingDialog(in id : int) : IllegalArgumentException
        return new IllegalArgumentException("no dialog with id " + id + " was ever "
                + "shown via Activity#showDialog");
!!!384055.java!!!	removeDialog(in id : int) : void
        if (mManagedDialogs != null) {
            final ManagedDialog md = mManagedDialogs.get(id);
            if (md != null) {
                md.mDialog.dismiss();
                mManagedDialogs.remove(id);
            }
        }
!!!384183.java!!!	onSearchRequested(inout searchEvent : SearchEvent) : boolean
        mSearchEvent = searchEvent;
        boolean result = onSearchRequested();
        mSearchEvent = null;
        return result;
!!!384311.java!!!	onSearchRequested() : boolean
        if ((getResources().getConfiguration().uiMode&Configuration.UI_MODE_TYPE_MASK)
                != Configuration.UI_MODE_TYPE_TELEVISION) {
            startSearch(null, false, null, false);
            return true;
        } else {
            return false;
        }
!!!384439.java!!!	getSearchEvent() : SearchEvent
        return mSearchEvent;
!!!384567.java!!!	startSearch(inout initialQuery : String, inout selectInitialQuery : boolean, inout appSearchData : Bundle, inout globalSearch : boolean) : void
        ensureSearchManager();
        mSearchManager.startSearch(initialQuery, selectInitialQuery, getComponentName(),
                appSearchData, globalSearch);
!!!384695.java!!!	triggerSearch(inout query : String, inout appSearchData : Bundle) : void
        ensureSearchManager();
        mSearchManager.triggerSearch(query, getComponentName(), appSearchData);
!!!384823.java!!!	takeKeyEvents(inout get : boolean) : void
        getWindow().takeKeyEvents(get);
!!!384951.java!!!	requestWindowFeature(in featureId : int) : boolean
        return getWindow().requestFeature(featureId);
!!!385079.java!!!	setFeatureDrawableResource(in featureId : int, in resId : int) : void
        getWindow().setFeatureDrawableResource(featureId, resId);
!!!385207.java!!!	setFeatureDrawableUri(in featureId : int, inout uri : Uri) : void
        getWindow().setFeatureDrawableUri(featureId, uri);
!!!385335.java!!!	setFeatureDrawable(in featureId : int, inout drawable : Drawable) : void
        getWindow().setFeatureDrawable(featureId, drawable);
!!!385463.java!!!	setFeatureDrawableAlpha(in featureId : int, in alpha : int) : void
        getWindow().setFeatureDrawableAlpha(featureId, alpha);
!!!385591.java!!!	getLayoutInflater() : LayoutInflater
        return getWindow().getLayoutInflater();
!!!385719.java!!!	getMenuInflater() : MenuInflater
        // Make sure that action views can get an appropriate theme.
        if (mMenuInflater == null) {
            initWindowDecorActionBar();
            if (mActionBar != null) {
                mMenuInflater = new MenuInflater(mActionBar.getThemedContext(), this);
            } else {
                mMenuInflater = new MenuInflater(this);
            }
        }
        return mMenuInflater;
!!!385847.java!!!	setTheme(in resid : int) : void
        super.setTheme(resid);
        mWindow.setTheme(resid);
!!!385975.java!!!	onApplyThemeResource(inout theme : Resources::Theme, in resid : int, inout first : boolean) : void
        if (mParent == null) {
            super.onApplyThemeResource(theme, resid, first);
        } else {
            try {
                theme.setTo(mParent.getTheme());
            } catch (Exception e) {
                // Empty
            }
            theme.applyStyle(resid, false);
        }

        // Get the primary color and update the TaskDescription for this activity
        TypedArray a = theme.obtainStyledAttributes(
                com.android.internal.R.styleable.ActivityTaskDescription);
        if (mTaskDescription.getPrimaryColor() == 0) {
            int colorPrimary = a.getColor(
                    com.android.internal.R.styleable.ActivityTaskDescription_colorPrimary, 0);
            if (colorPrimary != 0 && Color.alpha(colorPrimary) == 0xFF) {
                mTaskDescription.setPrimaryColor(colorPrimary);
            }
        }
        // For dev-preview only.
        if (mTaskDescription.getBackgroundColor() == 0) {
            int colorBackground = a.getColor(
                    com.android.internal.R.styleable.ActivityTaskDescription_colorBackground, 0);
            if (colorBackground != 0 && Color.alpha(colorBackground) == 0xFF) {
                mTaskDescription.setBackgroundColor(colorBackground);
            }
        }
        a.recycle();
        setTaskDescription(mTaskDescription);
!!!386103.java!!!	requestPermissions(inout permissions : String, in requestCode : int) : void
        if (mHasCurrentPermissionsRequest) {
            Log.w(TAG, "Can reqeust only one set of permissions at a time");
            // Dispatch the callback with empty arrays which means a cancellation.
            onRequestPermissionsResult(requestCode, new String[0], new int[0]);
            return;
        }
        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
        mHasCurrentPermissionsRequest = true;
!!!386231.java!!!	onRequestPermissionsResult(in requestCode : int, inout permissions : String, inout grantResults : int) : void
        /* callback - no nothing */
!!!386359.java!!!	shouldShowRequestPermissionRationale(inout permission : String) : boolean
        return getPackageManager().shouldShowRequestPermissionRationale(permission);
!!!386487.java!!!	startActivityForResult(inout intent : Intent, in requestCode : int) : void
        startActivityForResult(intent, requestCode, null);
!!!386615.java!!!	startActivityForResult(inout intent : Intent, in requestCode : int, inout options : Bundle) : void
        if (mParent == null) {
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
            if (ar != null) {
                mMainThread.sendActivityResult(
                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                    ar.getResultData());
            }
            if (requestCode >= 0) {
                // If this start is requesting a result, we can avoid making
                // the activity visible until the result is received.  Setting
                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
                // activity hidden during this time, to avoid flickering.
                // This can only be done when a result is requested because
                // that guarantees we will get information back when the
                // activity is finished, no matter what happens to it.
                mStartedActivity = true;
            }

            cancelInputsAndStartExitTransition(options);
            // TODO Consider clearing/flushing other event sources and events for child windows.
        } else {
            if (options != null) {
                mParent.startActivityFromChild(this, intent, requestCode, options);
            } else {
                // Note we want to go through this method for compatibility with
                // existing applications that may have overridden it.
                mParent.startActivityFromChild(this, intent, requestCode);
            }
        }
!!!386743.java!!!	cancelInputsAndStartExitTransition(inout options : Bundle) : void
        final View decor = mWindow != null ? mWindow.peekDecorView() : null;
        if (decor != null) {
            decor.cancelPendingInputEvents();
        }
        if (options != null && !isTopOfTask()) {
            mActivityTransitionState.startExitOutTransition(this, options);
        }
!!!386871.java!!!	startActivityForResultAsUser(inout intent : Intent, in requestCode : int, inout user : UserHandle) : void
        startActivityForResultAsUser(intent, requestCode, null, user);
!!!386999.java!!!	startActivityForResultAsUser(inout intent : Intent, in requestCode : int, inout options : Bundle, inout user : UserHandle) : void
        if (mParent != null) {
            throw new RuntimeException("Can't be called from a child");
        }
        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode,
                options, user);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData());
        }
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }

        cancelInputsAndStartExitTransition(options);
!!!387127.java!!!	startActivityAsUser(inout intent : Intent, inout user : UserHandle) : void
        startActivityAsUser(intent, null, user);
!!!387255.java!!!	startActivityAsUser(inout intent : Intent, inout options : Bundle, inout user : UserHandle) : void
        if (mParent != null) {
            throw new RuntimeException("Can't be called from a child");
        }
        Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                        this, mMainThread.getApplicationThread(), mToken, this,
                        intent, -1, options, user);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, -1, ar.getResultCode(),
                ar.getResultData());
        }
        cancelInputsAndStartExitTransition(options);
!!!387383.java!!!	startActivityAsCaller(inout intent : Intent, inout options : Bundle, inout ignoreTargetSecurity : boolean, in userId : int) : void
        if (mParent != null) {
            throw new RuntimeException("Can't be called from a child");
        }
        Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivityAsCaller(
                        this, mMainThread.getApplicationThread(), mToken, this,
                        intent, -1, options, ignoreTargetSecurity, userId);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, -1, ar.getResultCode(),
                ar.getResultData());
        }
        cancelInputsAndStartExitTransition(options);
!!!387511.java!!!	startIntentSenderForResult(inout intent : IntentSender, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int) : void
        startIntentSenderForResult(intent, requestCode, fillInIntent, flagsMask,
                flagsValues, extraFlags, null);
!!!387639.java!!!	startIntentSenderForResult(inout intent : IntentSender, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int, inout options : Bundle) : void
        if (mParent == null) {
            startIntentSenderForResultInner(intent, mEmbeddedID, requestCode, fillInIntent,
                    flagsMask, flagsValues, options);
        } else if (options != null) {
            mParent.startIntentSenderFromChild(this, intent, requestCode,
                    fillInIntent, flagsMask, flagsValues, extraFlags, options);
        } else {
            // Note we want to go through this call for compatibility with
            // existing applications that may have overridden the method.
            mParent.startIntentSenderFromChild(this, intent, requestCode,
                    fillInIntent, flagsMask, flagsValues, extraFlags);
        }
!!!387767.java!!!	startIntentSenderForResultInner(inout intent : IntentSender, inout who : String, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, inout options : Bundle) : void
        try {
            String resolvedType = null;
            if (fillInIntent != null) {
                fillInIntent.migrateExtraStreamToClipData();
                fillInIntent.prepareToLeaveProcess(this);
                resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
            }
            int result = ActivityManagerNative.getDefault()
                .startActivityIntentSender(mMainThread.getApplicationThread(), intent,
                        fillInIntent, resolvedType, mToken, who,
                        requestCode, flagsMask, flagsValues, options);
            if (result == ActivityManager.START_CANCELED) {
                throw new IntentSender.SendIntentException();
            }
            Instrumentation.checkStartActivityResult(result, null);
        } catch (RemoteException e) {
        }
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
!!!387895.java!!!	startActivity(inout intent : Intent) : void
        this.startActivity(intent, null);
!!!388023.java!!!	startActivity(inout intent : Intent, inout options : Bundle) : void
        if (options != null) {
            startActivityForResult(intent, -1, options);
        } else {
            // Note we want to go through this call for compatibility with
            // applications that may have overridden the method.
            startActivityForResult(intent, -1);
        }
!!!388151.java!!!	startActivities(inout intents : Intent) : void
        startActivities(intents, null);
!!!388279.java!!!	startActivities(inout intents : Intent, inout options : Bundle) : void
        mInstrumentation.execStartActivities(this, mMainThread.getApplicationThread(),
                mToken, this, intents, options);
!!!388407.java!!!	startIntentSender(inout intent : IntentSender, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int) : void
        startIntentSender(intent, fillInIntent, flagsMask, flagsValues,
                extraFlags, null);
!!!388535.java!!!	startIntentSender(inout intent : IntentSender, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int, inout options : Bundle) : void
        if (options != null) {
            startIntentSenderForResult(intent, -1, fillInIntent, flagsMask,
                    flagsValues, extraFlags, options);
        } else {
            // Note we want to go through this call for compatibility with
            // applications that may have overridden the method.
            startIntentSenderForResult(intent, -1, fillInIntent, flagsMask,
                    flagsValues, extraFlags);
        }
!!!388663.java!!!	startActivityIfNeeded(inout intent : Intent, in requestCode : int) : boolean
        return startActivityIfNeeded(intent, requestCode, null);
!!!388791.java!!!	startActivityIfNeeded(inout intent : Intent, in requestCode : int, inout options : Bundle) : boolean
        if (mParent == null) {
            int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
            try {
                Uri referrer = onProvideReferrer();
                if (referrer != null) {
                    intent.putExtra(Intent.EXTRA_REFERRER, referrer);
                }
                intent.migrateExtraStreamToClipData();
                intent.prepareToLeaveProcess(this);
                result = ActivityManagerNative.getDefault()
                    .startActivity(mMainThread.getApplicationThread(), getBasePackageName(),
                            intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken,
                            mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED,
                            null, options);
            } catch (RemoteException e) {
                // Empty
            }

            Instrumentation.checkStartActivityResult(result, intent);

            if (requestCode >= 0) {
                // If this start is requesting a result, we can avoid making
                // the activity visible until the result is received.  Setting
                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
                // activity hidden during this time, to avoid flickering.
                // This can only be done when a result is requested because
                // that guarantees we will get information back when the
                // activity is finished, no matter what happens to it.
                mStartedActivity = true;
            }
            return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }

        throw new UnsupportedOperationException(
            "startActivityIfNeeded can only be called from a top-level activity");
!!!388919.java!!!	startNextMatchingActivity(inout intent : Intent) : boolean
        return startNextMatchingActivity(intent, null);
!!!389047.java!!!	startNextMatchingActivity(inout intent : Intent, inout options : Bundle) : boolean
        if (mParent == null) {
            try {
                intent.migrateExtraStreamToClipData();
                intent.prepareToLeaveProcess(this);
                return ActivityManagerNative.getDefault()
                    .startNextMatchingActivity(mToken, intent, options);
            } catch (RemoteException e) {
                // Empty
            }
            return false;
        }

        throw new UnsupportedOperationException(
            "startNextMatchingActivity can only be called from a top-level activity");
!!!389175.java!!!	startActivityFromChild(inout child : Activity, inout intent : Intent, in requestCode : int) : void
        startActivityFromChild(child, intent, requestCode, null);
!!!389303.java!!!	startActivityFromChild(inout child : Activity, inout intent : Intent, in requestCode : int, inout options : Bundle) : void
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, child,
                intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, child.mEmbeddedID, requestCode,
                ar.getResultCode(), ar.getResultData());
        }
        cancelInputsAndStartExitTransition(options);
!!!389431.java!!!	startActivityFromFragment(inout fragment : Fragment, inout intent : Intent, in requestCode : int) : void
        startActivityFromFragment(fragment, intent, requestCode, null);
!!!389559.java!!!	startActivityFromFragment(inout fragment : Fragment, inout intent : Intent, in requestCode : int, inout options : Bundle) : void
        startActivityForResult(fragment.mWho, intent, requestCode, options);
!!!389687.java!!!	startActivityForResult(inout who : String, inout intent : Intent, in requestCode : int, inout options : Bundle) : void
        Uri referrer = onProvideReferrer();
        if (referrer != null) {
            intent.putExtra(Intent.EXTRA_REFERRER, referrer);
        }
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, who,
                intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, who, requestCode,
                ar.getResultCode(), ar.getResultData());
        }
        cancelInputsAndStartExitTransition(options);
!!!389815.java!!!	canStartActivityForResult() : boolean
        return true;
!!!389943.java!!!	startIntentSenderFromChild(inout child : Activity, inout intent : IntentSender, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int) : void
        startIntentSenderFromChild(child, intent, requestCode, fillInIntent,
                flagsMask, flagsValues, extraFlags, null);
!!!390071.java!!!	startIntentSenderFromChild(inout child : Activity, inout intent : IntentSender, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int, inout options : Bundle) : void
        startIntentSenderForResultInner(intent, child.mEmbeddedID, requestCode, fillInIntent,
                flagsMask, flagsValues, options);
!!!390199.java!!!	startIntentSenderFromChildFragment(inout child : Fragment, inout intent : IntentSender, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int, inout options : Bundle) : void
        startIntentSenderForResultInner(intent, child.mWho, requestCode, fillInIntent,
                flagsMask, flagsValues, options);
!!!390327.java!!!	overridePendingTransition(in enterAnim : int, in exitAnim : int) : void
        try {
            ActivityManagerNative.getDefault().overridePendingTransition(
                    mToken, getPackageName(), enterAnim, exitAnim);
        } catch (RemoteException e) {
        }
!!!390455.java!!!	setResult(in resultCode : int) : void
        synchronized (this) {
            mResultCode = resultCode;
            mResultData = null;
        }
!!!390583.java!!!	setResult(in resultCode : int, inout data : Intent) : void
        synchronized (this) {
            mResultCode = resultCode;
            mResultData = data;
        }
!!!390711.java!!!	getReferrer() : Uri
        Intent intent = getIntent();
        try {
            Uri referrer = intent.getParcelableExtra(Intent.EXTRA_REFERRER);
            if (referrer != null) {
                return referrer;
            }
            String referrerName = intent.getStringExtra(Intent.EXTRA_REFERRER_NAME);
            if (referrerName != null) {
                return Uri.parse(referrerName);
            }
        } catch (BadParcelableException e) {
            Log.w(TAG, "Cannot read referrer from intent;"
                    + " intent extras contain unknown custom Parcelable objects");
        }
        if (mReferrer != null) {
            return new Uri.Builder().scheme("android-app").authority(mReferrer).build();
        }
        return null;
!!!390839.java!!!	onProvideReferrer() : Uri
        return null;
!!!390967.java!!!	getCallingPackage() : String
        try {
            return ActivityManagerNative.getDefault().getCallingPackage(mToken);
        } catch (RemoteException e) {
            return null;
        }
!!!391095.java!!!	getCallingActivity() : ComponentName
        try {
            return ActivityManagerNative.getDefault().getCallingActivity(mToken);
        } catch (RemoteException e) {
            return null;
        }
!!!391223.java!!!	setVisible(inout visible : boolean) : void
        if (mVisibleFromClient != visible) {
            mVisibleFromClient = visible;
            if (mVisibleFromServer) {
                if (visible) makeVisible();
                else mDecor.setVisibility(View.INVISIBLE);
            }
        }
!!!391351.java!!!	makeVisible() : void
        if (!mWindowAdded) {
            ViewManager wm = getWindowManager();
            wm.addView(mDecor, getWindow().getAttributes());
            mWindowAdded = true;
        }
        mDecor.setVisibility(View.VISIBLE);
!!!391479.java!!!	isFinishing() : boolean
        return mFinished;
!!!391607.java!!!	isDestroyed() : boolean
        return mDestroyed;
!!!391735.java!!!	isChangingConfigurations() : boolean
        return mChangingConfigurations;
!!!391863.java!!!	recreate() : void
        if (mParent != null) {
            throw new IllegalStateException("Can only be called on top-level activity");
        }
        if (Looper.myLooper() != mMainThread.getLooper()) {
            throw new IllegalStateException("Must be called from main thread");
        }
        mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false,
                false /* preserveWindow */);
!!!391991.java!!!	finish(in finishTask : int) : void
        if (mParent == null) {
            int resultCode;
            Intent resultData;
            synchronized (this) {
                resultCode = mResultCode;
                resultData = mResultData;
            }
            if (false) Log.v(TAG, "Finishing self: token=" + mToken);
            try {
                if (resultData != null) {
                    resultData.prepareToLeaveProcess(this);
                }
                if (ActivityManagerNative.getDefault()
                        .finishActivity(mToken, resultCode, resultData, finishTask)) {
                    mFinished = true;
                }
            } catch (RemoteException e) {
                // Empty
            }
        } else {
            mParent.finishFromChild(this);
        }
!!!392119.java!!!	finish() : void
        finish(DONT_FINISH_TASK_WITH_ACTIVITY);
!!!392247.java!!!	finishAffinity() : void
        if (mParent != null) {
            throw new IllegalStateException("Can not be called from an embedded activity");
        }
        if (mResultCode != RESULT_CANCELED || mResultData != null) {
            throw new IllegalStateException("Can not be called to deliver a result");
        }
        try {
            if (ActivityManagerNative.getDefault().finishActivityAffinity(mToken)) {
                mFinished = true;
            }
        } catch (RemoteException e) {
            // Empty
        }
!!!392375.java!!!	finishFromChild(inout child : Activity) : void
        finish();
!!!392503.java!!!	finishAfterTransition() : void
        if (!mActivityTransitionState.startExitBackTransition(this)) {
            finish();
        }
!!!392631.java!!!	finishActivity(in requestCode : int) : void
        if (mParent == null) {
            try {
                ActivityManagerNative.getDefault()
                    .finishSubActivity(mToken, mEmbeddedID, requestCode);
            } catch (RemoteException e) {
                // Empty
            }
        } else {
            mParent.finishActivityFromChild(this, requestCode);
        }
!!!392759.java!!!	finishActivityFromChild(inout child : Activity, in requestCode : int) : void
        try {
            ActivityManagerNative.getDefault()
                .finishSubActivity(mToken, child.mEmbeddedID, requestCode);
        } catch (RemoteException e) {
            // Empty
        }
!!!392887.java!!!	finishAndRemoveTask() : void
        finish(FINISH_TASK_WITH_ROOT_ACTIVITY);
!!!393015.java!!!	releaseInstance() : boolean
        try {
            return ActivityManagerNative.getDefault().releaseActivityInstance(mToken);
        } catch (RemoteException e) {
            // Empty
        }
        return false;
!!!393399.java!!!	createPendingResult(in requestCode : int, inout data : Intent, in flags : int) : PendingIntent
        String packageName = getPackageName();
        try {
            data.prepareToLeaveProcess(this);
            IIntentSender target =
                ActivityManagerNative.getDefault().getIntentSender(
                        ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName,
                        mParent == null ? mToken : mParent.mToken,
                        mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null,
                        UserHandle.myUserId());
            return target != null ? new PendingIntent(target) : null;
        } catch (RemoteException e) {
            // Empty
        }
        return null;
!!!393527.java!!!	setRequestedOrientation(in requestedOrientation : int) : void
        if (mParent == null) {
            try {
                ActivityManagerNative.getDefault().setRequestedOrientation(
                        mToken, requestedOrientation);
            } catch (RemoteException e) {
                // Empty
            }
        } else {
            mParent.setRequestedOrientation(requestedOrientation);
        }
!!!393655.java!!!	getRequestedOrientation() : int
        if (mParent == null) {
            try {
                return ActivityManagerNative.getDefault()
                        .getRequestedOrientation(mToken);
            } catch (RemoteException e) {
                // Empty
            }
        } else {
            return mParent.getRequestedOrientation();
        }
        return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
!!!393783.java!!!	getTaskId() : int
        try {
            return ActivityManagerNative.getDefault()
                .getTaskForActivity(mToken, false);
        } catch (RemoteException e) {
            return -1;
        }
!!!393911.java!!!	isTaskRoot() : boolean
        try {
            return ActivityManagerNative.getDefault().getTaskForActivity(mToken, true) >= 0;
        } catch (RemoteException e) {
            return false;
        }
!!!394039.java!!!	moveTaskToBack(inout nonRoot : boolean) : boolean
        try {
            return ActivityManagerNative.getDefault().moveActivityTaskToBack(
                    mToken, nonRoot);
        } catch (RemoteException e) {
            // Empty
        }
        return false;
!!!394167.java!!!	getLocalClassName() : String
        final String pkg = getPackageName();
        final String cls = mComponent.getClassName();
        int packageLen = pkg.length();
        if (!cls.startsWith(pkg) || cls.length() <= packageLen
                || cls.charAt(packageLen) != '.') {
            return cls;
        }
        return cls.substring(packageLen+1);
!!!394295.java!!!	getComponentName() : ComponentName
        return mComponent;
!!!394423.java!!!	getPreferences(in mode : int) : SharedPreferences
        return getSharedPreferences(getLocalClassName(), mode);
!!!394551.java!!!	ensureSearchManager() : void
        if (mSearchManager != null) {
            return;
        }

        mSearchManager = new SearchManager(this, null);
!!!394679.java!!!	getSystemService(inout name : String) : Object
        if (getBaseContext() == null) {
            throw new IllegalStateException(
                    "System services not available to Activities before onCreate()");
        }

        if (WINDOW_SERVICE.equals(name)) {
            return mWindowManager;
        } else if (SEARCH_SERVICE.equals(name)) {
            ensureSearchManager();
            return mSearchManager;
        }
        return super.getSystemService(name);
!!!394807.java!!!	setTitle(inout title : CharSequence) : void
        mTitle = title;
        onTitleChanged(title, mTitleColor);

        if (mParent != null) {
            mParent.onChildTitleChanged(this, title);
        }
!!!394935.java!!!	setTitle(in titleId : int) : void
        setTitle(getText(titleId));
!!!395063.java!!!	setTitleColor(in textColor : int) : void
        mTitleColor = textColor;
        onTitleChanged(mTitle, textColor);
!!!395191.java!!!	getTitle() : CharSequence
        return mTitle;
!!!395319.java!!!	getTitleColor() : int
        return mTitleColor;
!!!395447.java!!!	onTitleChanged(inout title : CharSequence, in color : int) : void
        if (mTitleReady) {
            final Window win = getWindow();
            if (win != null) {
                win.setTitle(title);
                if (color != 0) {
                    win.setTitleColor(color);
                }
            }
            if (mActionBar != null) {
                mActionBar.setWindowTitle(title);
            }
        }
!!!395703.java!!!	setTaskDescription(inout taskDescription : ActivityManager::TaskDescription) : void
        if (mTaskDescription != taskDescription) {
            mTaskDescription.copyFrom(taskDescription);
            // Scale the icon down to something reasonable if it is provided
            if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
                final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
                final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size,
                        true);
                mTaskDescription.setIcon(icon);
            }
        }
        try {
            ActivityManagerNative.getDefault().setTaskDescription(mToken, mTaskDescription);
        } catch (RemoteException e) {
        }
!!!395831.java!!!	setProgressBarVisibility(inout visible : boolean) : void
        getWindow().setFeatureInt(Window.FEATURE_PROGRESS, visible ? Window.PROGRESS_VISIBILITY_ON :
            Window.PROGRESS_VISIBILITY_OFF);
!!!395959.java!!!	setProgressBarIndeterminateVisibility(inout visible : boolean) : void
        getWindow().setFeatureInt(Window.FEATURE_INDETERMINATE_PROGRESS,
                visible ? Window.PROGRESS_VISIBILITY_ON : Window.PROGRESS_VISIBILITY_OFF);
!!!396087.java!!!	setProgressBarIndeterminate(inout indeterminate : boolean) : void
        getWindow().setFeatureInt(Window.FEATURE_PROGRESS,
                indeterminate ? Window.PROGRESS_INDETERMINATE_ON
                        : Window.PROGRESS_INDETERMINATE_OFF);
!!!396215.java!!!	setProgress(in progress : int) : void
        getWindow().setFeatureInt(Window.FEATURE_PROGRESS, progress + Window.PROGRESS_START);
!!!396343.java!!!	setSecondaryProgress(in secondaryProgress : int) : void
        getWindow().setFeatureInt(Window.FEATURE_PROGRESS,
                secondaryProgress + Window.PROGRESS_SECONDARY_START);
!!!396471.java!!!	setVolumeControlStream(in streamType : int) : void
        getWindow().setVolumeControlStream(streamType);
!!!396599.java!!!	getVolumeControlStream() : int
        return getWindow().getVolumeControlStream();
!!!396727.java!!!	setMediaController(inout controller : MediaController) : void
        getWindow().setMediaController(controller);
!!!396855.java!!!	getMediaController() : MediaController
        return getWindow().getMediaController();
!!!396983.java!!!	runOnUiThread(inout action : Runnable) : void
        if (Thread.currentThread() != mUiThread) {
            mHandler.post(action);
        } else {
            action.run();
        }
!!!397111.java!!!	onCreateView(inout name : String, inout context : Context, inout attrs : AttributeSet) : View
        return null;
!!!397239.java!!!	onCreateView(inout parent : View, inout name : String, inout context : Context, inout attrs : AttributeSet) : View
        if (!"fragment".equals(name)) {
            return onCreateView(name, context, attrs);
        }

        return mFragments.onCreateView(parent, name, context, attrs);
!!!397367.java!!!	dump(inout prefix : String, inout fd : FileDescriptor, inout writer : PrintWriter, inout args : String) : void
        dumpInner(prefix, fd, writer, args);
!!!397495.java!!!	dumpInner(inout prefix : String, inout fd : FileDescriptor, inout writer : PrintWriter, inout args : String) : void
        writer.print(prefix); writer.print("Local Activity ");
                writer.print(Integer.toHexString(System.identityHashCode(this)));
                writer.println(" State:");
        String innerPrefix = prefix + "  ";
        writer.print(innerPrefix); writer.print("mResumed=");
                writer.print(mResumed); writer.print(" mStopped=");
                writer.print(mStopped); writer.print(" mFinished=");
                writer.println(mFinished);
        writer.print(innerPrefix); writer.print("mChangingConfigurations=");
                writer.println(mChangingConfigurations);
        writer.print(innerPrefix); writer.print("mCurrentConfig=");
                writer.println(mCurrentConfig);

        mFragments.dumpLoaders(innerPrefix, fd, writer, args);
        mFragments.getFragmentManager().dump(innerPrefix, fd, writer, args);
        if (mVoiceInteractor != null) {
            mVoiceInteractor.dump(innerPrefix, fd, writer, args);
        }

        if (getWindow() != null &&
                getWindow().peekDecorView() != null &&
                getWindow().peekDecorView().getViewRootImpl() != null) {
            getWindow().peekDecorView().getViewRootImpl().dump(prefix, fd, writer, args);
        }

        mHandler.getLooper().dump(new PrintWriterPrinter(writer), prefix);
!!!397623.java!!!	isImmersive() : boolean
        try {
            return ActivityManagerNative.getDefault().isImmersive(mToken);
        } catch (RemoteException e) {
            return false;
        }
!!!397751.java!!!	isTopOfTask() : boolean
        if (mToken == null || mWindow == null) {
            return false;
        }
        try {
            return ActivityManagerNative.getDefault().isTopOfTask(getActivityToken());
        } catch (RemoteException e) {
            return false;
        }
!!!397879.java!!!	convertFromTranslucent() : void
        try {
            mTranslucentCallback = null;
            if (ActivityManagerNative.getDefault().convertFromTranslucent(mToken)) {
                WindowManagerGlobal.getInstance().changeCanvasOpacity(mToken, true);
            }
        } catch (RemoteException e) {
            // pass
        }
!!!398007.java!!!	convertToTranslucent(inout callback : Activity::TranslucentConversionListener, inout options : ActivityOptions) : boolean
        boolean drawComplete;
        try {
            mTranslucentCallback = callback;
            mChangeCanvasToTranslucent =
                    ActivityManagerNative.getDefault().convertToTranslucent(mToken, options);
            WindowManagerGlobal.getInstance().changeCanvasOpacity(mToken, false);
            drawComplete = true;
        } catch (RemoteException e) {
            // Make callback return as though it timed out.
            mChangeCanvasToTranslucent = false;
            drawComplete = false;
        }
        if (!mChangeCanvasToTranslucent && mTranslucentCallback != null) {
            // Window is already translucent.
            mTranslucentCallback.onTranslucentConversionComplete(drawComplete);
        }
        return mChangeCanvasToTranslucent;
!!!398135.java!!!	onTranslucentConversionComplete(inout drawComplete : boolean) : void
        if (mTranslucentCallback != null) {
            mTranslucentCallback.onTranslucentConversionComplete(drawComplete);
            mTranslucentCallback = null;
        }
        if (mChangeCanvasToTranslucent) {
            WindowManagerGlobal.getInstance().changeCanvasOpacity(mToken, false);
        }
!!!398263.java!!!	onNewActivityOptions(inout options : ActivityOptions) : void
        mActivityTransitionState.setEnterActivityOptions(this, options);
        if (!mStopped) {
            mActivityTransitionState.enterReady(this);
        }
!!!398391.java!!!	getActivityOptions() : ActivityOptions
        try {
            return ActivityManagerNative.getDefault().getActivityOptions(mToken);
        } catch (RemoteException e) {
        }
        return null;
!!!398519.java!!!	requestVisibleBehind(inout visible : boolean) : boolean
        if (!mResumed) {
            // Do not permit paused or stopped activities to do this.
            visible = false;
        }
        try {
            mVisibleBehind = ActivityManagerNative.getDefault()
                    .requestVisibleBehind(mToken, visible) && visible;
        } catch (RemoteException e) {
            mVisibleBehind = false;
        }
        return mVisibleBehind;
!!!398647.java!!!	onVisibleBehindCanceled() : void
        mCalled = true;
!!!398775.java!!!	isBackgroundVisibleBehind() : boolean
        try {
            return ActivityManagerNative.getDefault().isBackgroundVisibleBehind(mToken);
        } catch (RemoteException e) {
        }
        return false;
!!!399159.java!!!	dispatchEnterAnimationComplete() : void
        onEnterAnimationComplete();
        if (getWindow() != null && getWindow().getDecorView() != null) {
            getWindow().getDecorView().getViewTreeObserver().dispatchOnEnterAnimationComplete();
        }
!!!399287.java!!!	setImmersive(inout i : boolean) : void
        try {
            ActivityManagerNative.getDefault().setImmersive(mToken, i);
        } catch (RemoteException e) {
            // pass
        }
!!!399415.java!!!	setVrModeEnabled(inout enabled : boolean, inout requestedComponent : ComponentName) : void
        try {
            if (ActivityManagerNative.getDefault().setVrMode(mToken, enabled, requestedComponent)
                    != 0) {
                throw new PackageManager.NameNotFoundException(
                        requestedComponent.flattenToString());
            }
        } catch (RemoteException e) {
            // pass
        }
!!!399543.java!!!	startActionMode(inout callback : ActionMode::Callback) : ActionMode
        return mWindow.getDecorView().startActionMode(callback);
!!!399671.java!!!	startActionMode(inout callback : ActionMode::Callback, in type : int) : ActionMode
        return mWindow.getDecorView().startActionMode(callback, type);
!!!399799.java!!!	onWindowStartingActionMode(inout callback : ActionMode::Callback) : ActionMode
        // Only Primary ActionModes are represented in the ActionBar.
        if (mActionModeTypeStarting == ActionMode.TYPE_PRIMARY) {
            initWindowDecorActionBar();
            if (mActionBar != null) {
                return mActionBar.startActionMode(callback);
            }
        }
        return null;
!!!399927.java!!!	onWindowStartingActionMode(inout callback : ActionMode::Callback, in type : int) : ActionMode
        try {
            mActionModeTypeStarting = type;
            return onWindowStartingActionMode(callback);
        } finally {
            mActionModeTypeStarting = ActionMode.TYPE_PRIMARY;
        }
!!!400311.java!!!	shouldUpRecreateTask(inout targetIntent : Intent) : boolean
        try {
            PackageManager pm = getPackageManager();
            ComponentName cn = targetIntent.getComponent();
            if (cn == null) {
                cn = targetIntent.resolveActivity(pm);
            }
            ActivityInfo info = pm.getActivityInfo(cn, 0);
            if (info.taskAffinity == null) {
                return false;
            }
            return ActivityManagerNative.getDefault()
                    .shouldUpRecreateTask(mToken, info.taskAffinity);
        } catch (RemoteException e) {
            return false;
        } catch (NameNotFoundException e) {
            return false;
        }
!!!400439.java!!!	navigateUpTo(inout upIntent : Intent) : boolean
        if (mParent == null) {
            ComponentName destInfo = upIntent.getComponent();
            if (destInfo == null) {
                destInfo = upIntent.resolveActivity(getPackageManager());
                if (destInfo == null) {
                    return false;
                }
                upIntent = new Intent(upIntent);
                upIntent.setComponent(destInfo);
            }
            int resultCode;
            Intent resultData;
            synchronized (this) {
                resultCode = mResultCode;
                resultData = mResultData;
            }
            if (resultData != null) {
                resultData.prepareToLeaveProcess(this);
            }
            try {
                upIntent.prepareToLeaveProcess(this);
                return ActivityManagerNative.getDefault().navigateUpTo(mToken, upIntent,
                        resultCode, resultData);
            } catch (RemoteException e) {
                return false;
            }
        } else {
            return mParent.navigateUpToFromChild(this, upIntent);
        }
!!!400567.java!!!	navigateUpToFromChild(inout child : Activity, inout upIntent : Intent) : boolean
        return navigateUpTo(upIntent);
!!!400695.java!!!	getParentActivityIntent() : Intent
        final String parentName = mActivityInfo.parentActivityName;
        if (TextUtils.isEmpty(parentName)) {
            return null;
        }

        // If the parent itself has no parent, generate a main activity intent.
        final ComponentName target = new ComponentName(this, parentName);
        try {
            final ActivityInfo parentInfo = getPackageManager().getActivityInfo(target, 0);
            final String parentActivity = parentInfo.parentActivityName;
            final Intent parentIntent = parentActivity == null
                    ? Intent.makeMainActivity(target)
                    : new Intent().setComponent(target);
            return parentIntent;
        } catch (NameNotFoundException e) {
            Log.e(TAG, "getParentActivityIntent: bad parentActivityName '" + parentName +
                    "' in manifest");
            return null;
        }
!!!400823.java!!!	setEnterSharedElementCallback(inout callback : SharedElementCallback) : void
        if (callback == null) {
            callback = SharedElementCallback.NULL_CALLBACK;
        }
        mEnterTransitionListener = callback;
!!!400951.java!!!	setExitSharedElementCallback(inout callback : SharedElementCallback) : void
        if (callback == null) {
            callback = SharedElementCallback.NULL_CALLBACK;
        }
        mExitTransitionListener = callback;
!!!401079.java!!!	postponeEnterTransition() : void
        mActivityTransitionState.postponeEnterTransition();
!!!401207.java!!!	startPostponedEnterTransition() : void
        mActivityTransitionState.startPostponedEnterTransition();
!!!401335.java!!!	requestDragAndDropPermissions(inout event : DragEvent) : DragAndDropPermissions
        DragAndDropPermissions dragAndDropPermissions = DragAndDropPermissions.obtain(event);
        if (dragAndDropPermissions != null && dragAndDropPermissions.take(getActivityToken())) {
            return dragAndDropPermissions;
        }
        return null;
!!!401463.java!!!	setParent(inout parent : Activity) : void
        mParent = parent;
!!!401591.java!!!	attach(inout context : Context, inout aThread : ActivityThread, inout instr : Instrumentation, inout token : IBinder, in ident : int, inout application : Application, inout intent : Intent, inout info : ActivityInfo, inout title : CharSequence, inout parent : Activity, inout id : String, inout lastNonConfigurationInstances : Activity::NonConfigurationInstances, inout config : Configuration, inout referrer : String, inout voiceInteractor : IVoiceInteractor, inout window : Window) : void
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);

        mWindow = new PhoneWindow(this, window);
        mWindow.setWindowControllerCallback(this);
        mWindow.setCallback(this);
        mWindow.setOnWindowDismissedCallback(this);
        mWindow.getLayoutInflater().setPrivateFactory(this);
        if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
            mWindow.setSoftInputMode(info.softInputMode);
        }
        if (info.uiOptions != 0) {
            mWindow.setUiOptions(info.uiOptions);
        }
        mUiThread = Thread.currentThread();

        mMainThread = aThread;
        mInstrumentation = instr;
        mToken = token;
        mIdent = ident;
        mApplication = application;
        mIntent = intent;
        mReferrer = referrer;
        mComponent = intent.getComponent();
        mActivityInfo = info;
        mTitle = title;
        mParent = parent;
        mEmbeddedID = id;
        mLastNonConfigurationInstances = lastNonConfigurationInstances;
        if (voiceInteractor != null) {
            if (lastNonConfigurationInstances != null) {
                mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;
            } else {
                mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,
                        Looper.myLooper());
            }
        }

        mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        if (mParent != null) {
            mWindow.setContainer(mParent.getWindow());
        }
        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;
!!!401719.java!!!	getActivityToken() : IBinder
        return mParent != null ? mParent.getActivityToken() : mToken;
!!!401847.java!!!	performCreateCommon() : void
        mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(
                com.android.internal.R.styleable.Window_windowNoDisplay, false);
        mFragments.dispatchActivityCreated();
        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
!!!401975.java!!!	performCreate(inout icicle : Bundle) : void
        restoreHasCurrentPermissionRequest(icicle);
        onCreate(icicle);
        mActivityTransitionState.readState(icicle);
        performCreateCommon();
!!!402103.java!!!	performCreate(inout icicle : Bundle, inout persistentState : PersistableBundle) : void
        restoreHasCurrentPermissionRequest(icicle);
        onCreate(icicle, persistentState);
        mActivityTransitionState.readState(icicle);
        performCreateCommon();
!!!402231.java!!!	performStart() : void
        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
        mFragments.noteStateNotSaved();
        mCalled = false;
        mFragments.execPendingActions();
        mInstrumentation.callActivityOnStart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(
                "Activity " + mComponent.toShortString() +
                " did not call through to super.onStart()");
        }
        mFragments.dispatchStart();
        mFragments.reportLoaderStart();

        // This property is set for all builds except final release
        boolean isDlwarningEnabled = SystemProperties.getInt("ro.bionic.ld.warning", 0) == 1;
        boolean isAppDebuggable =
                (mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;

        if (isAppDebuggable || isDlwarningEnabled) {
            String dlwarning = getDlWarning();
            if (dlwarning != null) {
                String appName = getApplicationInfo().loadLabel(getPackageManager())
                        .toString();
                String warning = "Detected problems with app native libraries\n" +
                                 "(please consult log for detail):\n" + dlwarning;
                if (isAppDebuggable) {
                      new AlertDialog.Builder(this).
                          setTitle(appName).
                          setMessage(warning).
                          setPositiveButton(android.R.string.ok, null).
                          setCancelable(false).
                          show();
                } else {
                    Toast.makeText(this, appName + "\n" + warning, Toast.LENGTH_LONG).show();
                }
            }
        }

        mActivityTransitionState.enterReady(this);
!!!402359.java!!!	performRestart() : void
        mFragments.noteStateNotSaved();

        if (mToken != null && mParent == null) {
            // No need to check mStopped, the roots will check if they were actually stopped.
            WindowManagerGlobal.getInstance().setStoppedState(mToken, false /* stopped */);
        }

        if (mStopped) {
            mStopped = false;

            synchronized (mManagedCursors) {
                final int N = mManagedCursors.size();
                for (int i=0; i<N; i++) {
                    ManagedCursor mc = mManagedCursors.get(i);
                    if (mc.mReleased || mc.mUpdated) {
                        if (!mc.mCursor.requery()) {
                            if (getApplicationInfo().targetSdkVersion
                                    >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                                throw new IllegalStateException(
                                        "trying to requery an already closed cursor  "
                                        + mc.mCursor);
                            }
                        }
                        mc.mReleased = false;
                        mc.mUpdated = false;
                    }
                }
            }

            mCalled = false;
            mInstrumentation.callActivityOnRestart(this);
            if (!mCalled) {
                throw new SuperNotCalledException(
                    "Activity " + mComponent.toShortString() +
                    " did not call through to super.onRestart()");
            }
            performStart();
        }
!!!402487.java!!!	performResume() : void
        performRestart();

        mFragments.execPendingActions();

        mLastNonConfigurationInstances = null;

        mCalled = false;
        // mResumed is set by the instrumentation
        mInstrumentation.callActivityOnResume(this);
        if (!mCalled) {
            throw new SuperNotCalledException(
                "Activity " + mComponent.toShortString() +
                " did not call through to super.onResume()");
        }

        // invisible activities must be finished before onResume() completes
        if (!mVisibleFromClient && !mFinished) {
            Log.w(TAG, "An activity without a UI must call finish() before onResume() completes");
            if (getApplicationInfo().targetSdkVersion
                    > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
                throw new IllegalStateException(
                        "Activity " + mComponent.toShortString() +
                        " did not call finish() prior to onResume() completing");
            }
        }

        // Now really resume, and install the current status bar and menu.
        mCalled = false;

        mFragments.dispatchResume();
        mFragments.execPendingActions();

        onPostResume();
        if (!mCalled) {
            throw new SuperNotCalledException(
                "Activity " + mComponent.toShortString() +
                " did not call through to super.onPostResume()");
        }
!!!402615.java!!!	performPause() : void
        mDoReportFullyDrawn = false;
        mFragments.dispatchPause();
        mCalled = false;
        onPause();
        mResumed = false;
        if (!mCalled && getApplicationInfo().targetSdkVersion
                >= android.os.Build.VERSION_CODES.GINGERBREAD) {
            throw new SuperNotCalledException(
                    "Activity " + mComponent.toShortString() +
                    " did not call through to super.onPause()");
        }
        mResumed = false;
!!!402743.java!!!	performUserLeaving() : void
        onUserInteraction();
        onUserLeaveHint();
!!!402871.java!!!	performStop(inout preserveWindow : boolean) : void
        mDoReportFullyDrawn = false;
        mFragments.doLoaderStop(mChangingConfigurations /*retain*/);

        if (!mStopped) {
            if (mWindow != null) {
                mWindow.closeAllPanels();
            }

            // If we're preserving the window, don't setStoppedState to true, since we
            // need the window started immediately again. Stopping the window will
            // destroys hardware resources and causes flicker.
            if (!preserveWindow && mToken != null && mParent == null) {
                WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
            }

            mFragments.dispatchStop();

            mCalled = false;
            mInstrumentation.callActivityOnStop(this);
            if (!mCalled) {
                throw new SuperNotCalledException(
                    "Activity " + mComponent.toShortString() +
                    " did not call through to super.onStop()");
            }

            synchronized (mManagedCursors) {
                final int N = mManagedCursors.size();
                for (int i=0; i<N; i++) {
                    ManagedCursor mc = mManagedCursors.get(i);
                    if (!mc.mReleased) {
                        mc.mCursor.deactivate();
                        mc.mReleased = true;
                    }
                }
            }

            mStopped = true;
        }
        mResumed = false;
!!!402999.java!!!	performDestroy() : void
        mDestroyed = true;
        mWindow.destroy();
        mFragments.dispatchDestroy();
        onDestroy();
        mFragments.doLoaderDestroy();
        if (mVoiceInteractor != null) {
            mVoiceInteractor.detachActivity();
        }
!!!403127.java!!!	dispatchMultiWindowModeChanged(inout isInMultiWindowMode : boolean) : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG,
                "dispatchMultiWindowModeChanged " + this + ": " + isInMultiWindowMode);
        mFragments.dispatchMultiWindowModeChanged(isInMultiWindowMode);
        if (mWindow != null) {
            mWindow.onMultiWindowModeChanged();
        }
        onMultiWindowModeChanged(isInMultiWindowMode);
!!!403255.java!!!	dispatchPictureInPictureModeChanged(inout isInPictureInPictureMode : boolean) : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG,
                "dispatchPictureInPictureModeChanged " + this + ": " + isInPictureInPictureMode);
        mFragments.dispatchPictureInPictureModeChanged(isInPictureInPictureMode);
        onPictureInPictureModeChanged(isInPictureInPictureMode);
!!!403383.java!!!	isResumed() : boolean
        return mResumed;
!!!403511.java!!!	storeHasCurrentPermissionRequest(inout bundle : Bundle) : void
        if (bundle != null && mHasCurrentPermissionsRequest) {
            bundle.putBoolean(HAS_CURENT_PERMISSIONS_REQUEST_KEY, true);
        }
!!!403639.java!!!	restoreHasCurrentPermissionRequest(inout bundle : Bundle) : void
        if (bundle != null) {
            mHasCurrentPermissionsRequest = bundle.getBoolean(
                    HAS_CURENT_PERMISSIONS_REQUEST_KEY, false);
        }
!!!403767.java!!!	dispatchActivityResult(inout who : String, in requestCode : int, in resultCode : int, inout data : Intent) : void
        if (false) Log.v(
            TAG, "Dispatching result: who=" + who + ", reqCode=" + requestCode
            + ", resCode=" + resultCode + ", data=" + data);
        mFragments.noteStateNotSaved();
        if (who == null) {
            onActivityResult(requestCode, resultCode, data);
        } else if (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) {
            who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());
            if (TextUtils.isEmpty(who)) {
                dispatchRequestPermissionsResult(requestCode, data);
            } else {
                Fragment frag = mFragments.findFragmentByWho(who);
                if (frag != null) {
                    dispatchRequestPermissionsResultToFragment(requestCode, data, frag);
                }
            }
        } else if (who.startsWith("@android:view:")) {
            ArrayList<ViewRootImpl> views = WindowManagerGlobal.getInstance().getRootViews(
                    getActivityToken());
            for (ViewRootImpl viewRoot : views) {
                if (viewRoot.getView() != null
                        && viewRoot.getView().dispatchActivityResult(
                                who, requestCode, resultCode, data)) {
                    return;
                }
            }
        } else {
            Fragment frag = mFragments.findFragmentByWho(who);
            if (frag != null) {
                frag.onActivityResult(requestCode, resultCode, data);
            }
        }
!!!403895.java!!!	startLockTask() : void
        try {
            ActivityManagerNative.getDefault().startLockTaskMode(mToken);
        } catch (RemoteException e) {
        }
!!!404023.java!!!	stopLockTask() : void
        try {
            ActivityManagerNative.getDefault().stopLockTaskMode();
        } catch (RemoteException e) {
        }
!!!404151.java!!!	showLockTaskEscapeMessage() : void
        try {
            ActivityManagerNative.getDefault().showLockTaskEscapeMessage(mToken);
        } catch (RemoteException e) {
        }
!!!404279.java!!!	isOverlayWithDecorCaptionEnabled() : boolean
        return mWindow.isOverlayWithDecorCaptionEnabled();
!!!404407.java!!!	setOverlayWithDecorCaptionEnabled(inout enabled : boolean) : void
        mWindow.setOverlayWithDecorCaptionEnabled(enabled);
!!!404663.java!!!	dispatchRequestPermissionsResult(in requestCode : int, inout data : Intent) : void
        mHasCurrentPermissionsRequest = false;
        // If the package installer crashed we may have not data - best effort.
        String[] permissions = (data != null) ? data.getStringArrayExtra(
                PackageManager.EXTRA_REQUEST_PERMISSIONS_NAMES) : new String[0];
        final int[] grantResults = (data != null) ? data.getIntArrayExtra(
                PackageManager.EXTRA_REQUEST_PERMISSIONS_RESULTS) : new int[0];
        onRequestPermissionsResult(requestCode, permissions, grantResults);
!!!404791.java!!!	dispatchRequestPermissionsResultToFragment(in requestCode : int, inout data : Intent, inout fragment : Fragment) : void
        // If the package installer crashed we may have not data - best effort.
        String[] permissions = (data != null) ? data.getStringArrayExtra(
                PackageManager.EXTRA_REQUEST_PERMISSIONS_NAMES) : new String[0];
        final int[] grantResults = (data != null) ? data.getIntArrayExtra(
                PackageManager.EXTRA_REQUEST_PERMISSIONS_RESULTS) : new int[0];
        fragment.onRequestPermissionsResult(requestCode, permissions, grantResults);
