class Matrix_Delegate
!!!35274807.java!!!	getDelegate(in native_instance : long) : Matrix_Delegate
        return sManager.getDelegate(native_instance);
!!!35274935.java!!!	getAffineTransform(inout m : Matrix) : AffineTransform
        Matrix_Delegate delegate = sManager.getDelegate(m.native_instance);
        if (delegate == null) {
            return null;
        }

        return delegate.getAffineTransform();
!!!35275063.java!!!	hasPerspective(inout m : Matrix) : boolean
        Matrix_Delegate delegate = sManager.getDelegate(m.native_instance);
        if (delegate == null) {
            return false;
        }

        return delegate.hasPerspective();
!!!35275191.java!!!	set(inout matrix : Matrix_Delegate) : void
        System.arraycopy(matrix.mValues, 0, mValues, 0, MATRIX_SIZE);
!!!35275319.java!!!	set(inout values : float) : void
        System.arraycopy(values, 0, mValues, 0, MATRIX_SIZE);
!!!35275447.java!!!	reset() : void
        reset(mValues);
!!!35275575.java!!!	isIdentity() : boolean
        for (int i = 0, k = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++, k++) {
                if (mValues[k] != ((i==j) ? 1 : 0)) {
                    return false;
                }
            }
        }

        return true;
!!!35275703.java!!!	makeValues(inout matrix : AffineTransform) : float
        float[] values = new float[MATRIX_SIZE];
        values[0] = (float) matrix.getScaleX();
        values[1] = (float) matrix.getShearX();
        values[2] = (float) matrix.getTranslateX();
        values[3] = (float) matrix.getShearY();
        values[4] = (float) matrix.getScaleY();
        values[5] = (float) matrix.getTranslateY();
        values[6] = 0.f;
        values[7] = 0.f;
        values[8] = 1.f;

        return values;
!!!35275831.java!!!	make(inout matrix : AffineTransform) : Matrix_Delegate
        return new Matrix_Delegate(makeValues(matrix));
!!!35275959.java!!!	mapRect(inout dst : RectF, inout src : RectF) : boolean
        // array with 4 corners
        float[] corners = new float[] {
                src.left, src.top,
                src.right, src.top,
                src.right, src.bottom,
                src.left, src.bottom,
        };

        // apply the transform to them.
        mapPoints(corners);

        // now put the result in the rect. We take the min/max of Xs and min/max of Ys
        dst.left = Math.min(Math.min(corners[0], corners[2]), Math.min(corners[4], corners[6]));
        dst.right = Math.max(Math.max(corners[0], corners[2]), Math.max(corners[4], corners[6]));

        dst.top = Math.min(Math.min(corners[1], corners[3]), Math.min(corners[5], corners[7]));
        dst.bottom = Math.max(Math.max(corners[1], corners[3]), Math.max(corners[5], corners[7]));


        return (computeTypeMask() & kRectStaysRect_Mask) != 0;
!!!35276087.java!!!	getAffineTransform() : AffineTransform
        return getAffineTransform(mValues);
!!!35276215.java!!!	hasPerspective() : boolean
        return (mValues[6] != 0 || mValues[7] != 0 || mValues[8] != 1);
!!!35276343.java!!!	native_create(in native_src_or_zero : long) : long
        // create the delegate
        Matrix_Delegate newDelegate = new Matrix_Delegate();

        // copy from values if needed.
        if (native_src_or_zero > 0) {
            Matrix_Delegate oldDelegate = sManager.getDelegate(native_src_or_zero);
            if (oldDelegate != null) {
                System.arraycopy(
                        oldDelegate.mValues, 0,
                        newDelegate.mValues, 0,
                        MATRIX_SIZE);
            }
        }

        return sManager.addNewDelegate(newDelegate);
!!!35276471.java!!!	native_isIdentity(in native_object : long) : boolean
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return false;
        }

        return d.isIdentity();
!!!35276599.java!!!	native_isAffine(in native_object : long) : boolean
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return true;
        }

        return (d.computeTypeMask() & kPerspective_Mask) == 0;
!!!35276727.java!!!	native_rectStaysRect(in native_object : long) : boolean
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return true;
        }

        return (d.computeTypeMask() & kRectStaysRect_Mask) != 0;
!!!35276855.java!!!	native_reset(in native_object : long) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        reset(d.mValues);
!!!35276983.java!!!	native_set(in native_object : long, in other : long) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        Matrix_Delegate src = sManager.getDelegate(other);
        if (src == null) {
            return;
        }

        System.arraycopy(src.mValues, 0, d.mValues, 0, MATRIX_SIZE);
!!!35277111.java!!!	native_setTranslate(in native_object : long, in dx : float, in dy : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        setTranslate(d.mValues, dx, dy);
!!!35277239.java!!!	native_setScale(in native_object : long, in sx : float, in sy : float, in px : float, in py : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        d.mValues = getScale(sx, sy, px, py);
!!!35277367.java!!!	native_setScale(in native_object : long, in sx : float, in sy : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        d.mValues[0] = sx;
        d.mValues[1] = 0;
        d.mValues[2] = 0;
        d.mValues[3] = 0;
        d.mValues[4] = sy;
        d.mValues[5] = 0;
        d.mValues[6] = 0;
        d.mValues[7] = 0;
        d.mValues[8] = 1;
!!!35277495.java!!!	native_setRotate(in native_object : long, in degrees : float, in px : float, in py : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        d.mValues = getRotate(degrees, px, py);
!!!35277623.java!!!	native_setRotate(in native_object : long, in degrees : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        setRotate(d.mValues, degrees);
!!!35277751.java!!!	native_setSinCos(in native_object : long, in sinValue : float, in cosValue : float, in px : float, in py : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        // TODO: do it in one pass

        // translate so that the pivot is in 0,0
        setTranslate(d.mValues, -px, -py);

        // scale
        d.postTransform(getRotate(sinValue, cosValue));
        // translate back the pivot
        d.postTransform(getTranslate(px, py));
!!!35277879.java!!!	native_setSinCos(in native_object : long, in sinValue : float, in cosValue : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        setRotate(d.mValues, sinValue, cosValue);
!!!35278007.java!!!	native_setSkew(in native_object : long, in kx : float, in ky : float, in px : float, in py : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        d.mValues = getSkew(kx, ky, px, py);
!!!35278135.java!!!	native_setSkew(in native_object : long, in kx : float, in ky : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        d.mValues[0] = 1;
        d.mValues[1] = kx;
        d.mValues[2] = -0;
        d.mValues[3] = ky;
        d.mValues[4] = 1;
        d.mValues[5] = 0;
        d.mValues[6] = 0;
        d.mValues[7] = 0;
        d.mValues[8] = 1;
!!!35278263.java!!!	native_setConcat(in native_object : long, in a : long, in b : long) : void
        if (a == native_object) {
            native_preConcat(native_object, b);
            return;
        } else if (b == native_object) {
            native_postConcat(native_object, a);
            return;
        }

        Matrix_Delegate d = sManager.getDelegate(native_object);
        Matrix_Delegate a_mtx = sManager.getDelegate(a);
        Matrix_Delegate b_mtx = sManager.getDelegate(b);
        if (d != null && a_mtx != null && b_mtx != null) {
            multiply(d.mValues, a_mtx.mValues, b_mtx.mValues);
        }
!!!35278391.java!!!	native_preTranslate(in native_object : long, in dx : float, in dy : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.preTransform(getTranslate(dx, dy));
        }
!!!35278519.java!!!	native_preScale(in native_object : long, in sx : float, in sy : float, in px : float, in py : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.preTransform(getScale(sx, sy, px, py));
        }
!!!35278647.java!!!	native_preScale(in native_object : long, in sx : float, in sy : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.preTransform(getScale(sx, sy));
        }
!!!35278775.java!!!	native_preRotate(in native_object : long, in degrees : float, in px : float, in py : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.preTransform(getRotate(degrees, px, py));
        }
!!!35278903.java!!!	native_preRotate(in native_object : long, in degrees : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {

            double rad = Math.toRadians(degrees);
            float sin = (float) Math.sin(rad);
            float cos = (float) Math.cos(rad);

            d.preTransform(getRotate(sin, cos));
        }
!!!35279031.java!!!	native_preSkew(in native_object : long, in kx : float, in ky : float, in px : float, in py : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.preTransform(getSkew(kx, ky, px, py));
        }
!!!35279159.java!!!	native_preSkew(in native_object : long, in kx : float, in ky : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.preTransform(getSkew(kx, ky));
        }
!!!35279287.java!!!	native_preConcat(in native_object : long, in other_matrix : long) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        Matrix_Delegate other = sManager.getDelegate(other_matrix);
        if (d != null && other != null) {
            d.preTransform(other.mValues);
        }
!!!35279415.java!!!	native_postTranslate(in native_object : long, in dx : float, in dy : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.postTransform(getTranslate(dx, dy));
        }
!!!35279543.java!!!	native_postScale(in native_object : long, in sx : float, in sy : float, in px : float, in py : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.postTransform(getScale(sx, sy, px, py));
        }
!!!35279671.java!!!	native_postScale(in native_object : long, in sx : float, in sy : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.postTransform(getScale(sx, sy));
        }
!!!35279799.java!!!	native_postRotate(in native_object : long, in degrees : float, in px : float, in py : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.postTransform(getRotate(degrees, px, py));
        }
!!!35279927.java!!!	native_postRotate(in native_object : long, in degrees : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.postTransform(getRotate(degrees));
        }
!!!35280055.java!!!	native_postSkew(in native_object : long, in kx : float, in ky : float, in px : float, in py : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.postTransform(getSkew(kx, ky, px, py));
        }
!!!35280183.java!!!	native_postSkew(in native_object : long, in kx : float, in ky : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d != null) {
            d.postTransform(getSkew(kx, ky));
        }
!!!35280311.java!!!	native_postConcat(in native_object : long, in other_matrix : long) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        Matrix_Delegate other = sManager.getDelegate(other_matrix);
        if (d != null && other != null) {
            d.postTransform(other.mValues);
        }
!!!35280439.java!!!	native_setRectToRect(in native_object : long, inout src : RectF, inout dst : RectF, in stf : int) : boolean
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return false;
        }

        if (src.isEmpty()) {
            reset(d.mValues);
            return false;
        }

        if (dst.isEmpty()) {
            d.mValues[0] = d.mValues[1] = d.mValues[2] = d.mValues[3] = d.mValues[4] = d.mValues[5]
               = d.mValues[6] = d.mValues[7] = 0;
            d.mValues[8] = 1;
        } else {
            float    tx, sx = dst.width() / src.width();
            float    ty, sy = dst.height() / src.height();
            boolean  xLarger = false;

            if (stf != ScaleToFit.FILL.nativeInt) {
                if (sx > sy) {
                    xLarger = true;
                    sx = sy;
                } else {
                    sy = sx;
                }
            }

            tx = dst.left - src.left * sx;
            ty = dst.top - src.top * sy;
            if (stf == ScaleToFit.CENTER.nativeInt || stf == ScaleToFit.END.nativeInt) {
                float diff;

                if (xLarger) {
                    diff = dst.width() - src.width() * sy;
                } else {
                    diff = dst.height() - src.height() * sy;
                }

                if (stf == ScaleToFit.CENTER.nativeInt) {
                    diff = diff / 2;
                }

                if (xLarger) {
                    tx += diff;
                } else {
                    ty += diff;
                }
            }

            d.mValues[0] = sx;
            d.mValues[4] = sy;
            d.mValues[2] = tx;
            d.mValues[5] = ty;
            d.mValues[1]  = d.mValues[3] = d.mValues[6] = d.mValues[7] = 0;

        }
        // shared cleanup
        d.mValues[8] = 1;
        return true;
!!!35280567.java!!!	native_setPolyToPoly(in native_object : long, inout src : float, in srcIndex : int, inout dst : float, in dstIndex : int, in pointCount : int) : boolean
        // FIXME
        Bridge.getLog().fidelityWarning(LayoutLog.TAG_UNSUPPORTED,
                "Matrix.setPolyToPoly is not supported.",
                null, null /*data*/);
        return false;
!!!35280695.java!!!	native_invert(in native_object : long, in inverse : long) : boolean
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return false;
        }

        Matrix_Delegate inv_mtx = sManager.getDelegate(inverse);
        if (inv_mtx == null) {
            return false;
        }

        try {
            AffineTransform affineTransform = d.getAffineTransform();
            AffineTransform inverseTransform = affineTransform.createInverse();
            inv_mtx.mValues[0] = (float)inverseTransform.getScaleX();
            inv_mtx.mValues[1] = (float)inverseTransform.getShearX();
            inv_mtx.mValues[2] = (float)inverseTransform.getTranslateX();
            inv_mtx.mValues[3] = (float)inverseTransform.getScaleX();
            inv_mtx.mValues[4] = (float)inverseTransform.getShearY();
            inv_mtx.mValues[5] = (float)inverseTransform.getTranslateY();

            return true;
        } catch (NoninvertibleTransformException e) {
            return false;
        }
!!!35280823.java!!!	native_mapPoints(in native_object : long, inout dst : float, in dstIndex : int, inout src : float, in srcIndex : int, in ptCount : int, inout isPts : boolean) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        if (isPts) {
            d.mapPoints(dst, dstIndex, src, srcIndex, ptCount);
        } else {
            d.mapVectors(dst, dstIndex, src, srcIndex, ptCount);
        }
!!!35280951.java!!!	native_mapRect(in native_object : long, inout dst : RectF, inout src : RectF) : boolean
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return false;
        }

        return d.mapRect(dst, src);
!!!35281079.java!!!	native_mapRadius(in native_object : long, in radius : float) : float
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return 0.f;
        }

        float[] src = new float[] { radius, 0.f, 0.f, radius };
        d.mapVectors(src, 0, src, 0, 2);

        float l1 = (float) Math.hypot(src[0], src[1]);
        float l2 = (float) Math.hypot(src[2], src[3]);
        return (float) Math.sqrt(l1 * l2);
!!!35281207.java!!!	native_getValues(in native_object : long, inout values : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        System.arraycopy(d.mValues, 0, values, 0, MATRIX_SIZE);
!!!35281335.java!!!	native_setValues(in native_object : long, inout values : float) : void
        Matrix_Delegate d = sManager.getDelegate(native_object);
        if (d == null) {
            return;
        }

        System.arraycopy(values, 0, d.mValues, 0, MATRIX_SIZE);
!!!35281463.java!!!	native_equals(in native_a : long, in native_b : long) : boolean
        Matrix_Delegate a = sManager.getDelegate(native_a);
        if (a == null) {
            return false;
        }

        Matrix_Delegate b = sManager.getDelegate(native_b);
        if (b == null) {
            return false;
        }

        for (int i = 0 ; i < MATRIX_SIZE ; i++) {
            if (a.mValues[i] != b.mValues[i]) {
                return false;
            }
        }

        return true;
!!!35281591.java!!!	finalizer(in native_instance : long) : void
        sManager.removeJavaReferenceFor(native_instance);
!!!35281719.java!!!	getAffineTransform(inout matrix : float) : AffineTransform
        // the AffineTransform constructor takes the value in a different order
        // for a matrix [ 0 1 2 ]
        //              [ 3 4 5 ]
        // the order is 0, 3, 1, 4, 2, 5...
        return new AffineTransform(
                matrix[0], matrix[3], matrix[1],
                matrix[4], matrix[2], matrix[5]);
!!!35281847.java!!!	reset(inout mtx : float) : void
        for (int i = 0, k = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++, k++) {
                mtx[k] = ((i==j) ? 1 : 0);
            }
        }
!!!35281975.java!!!	computeTypeMask() : int
        int mask = 0;

        if (mValues[6] != 0. || mValues[7] != 0. || mValues[8] != 1.) {
            mask |= kPerspective_Mask;
        }

        if (mValues[2] != 0. || mValues[5] != 0.) {
            mask |= kTranslate_Mask;
        }

        float m00 = mValues[0];
        float m01 = mValues[1];
        float m10 = mValues[3];
        float m11 = mValues[4];

        if (m01 != 0. || m10 != 0.) {
            mask |= kAffine_Mask;
        }

        if (m00 != 1. || m11 != 1.) {
            mask |= kScale_Mask;
        }

        if ((mask & kPerspective_Mask) == 0) {
            // map non-zero to 1
            int im00 = m00 != 0 ? 1 : 0;
            int im01 = m01 != 0 ? 1 : 0;
            int im10 = m10 != 0 ? 1 : 0;
            int im11 = m11 != 0 ? 1 : 0;

            // record if the (p)rimary and (s)econdary diagonals are all 0 or
            // all non-zero (answer is 0 or 1)
            int dp0 = (im00 | im11) ^ 1;  // true if both are 0
            int dp1 = im00 & im11;        // true if both are 1
            int ds0 = (im01 | im10) ^ 1;  // true if both are 0
            int ds1 = im01 & im10;        // true if both are 1

            // return 1 if primary is 1 and secondary is 0 or
            // primary is 0 and secondary is 1
            mask |= ((dp0 & ds1) | (dp1 & ds0)) << kRectStaysRect_Shift;
        }

        return mask;
!!!35282103.java!!!	Matrix_Delegate()
        reset();
!!!35282231.java!!!	Matrix_Delegate(inout values : float)
        System.arraycopy(values, 0, mValues, 0, MATRIX_SIZE);
!!!35282359.java!!!	postTransform(inout matrix : float) : void
        float[] tmp = new float[9];
        multiply(tmp, mValues, matrix);
        mValues = tmp;
!!!35282487.java!!!	preTransform(inout matrix : float) : void
        float[] tmp = new float[9];
        multiply(tmp, matrix, mValues);
        mValues = tmp;
!!!35282615.java!!!	mapPoints(inout dst : float, in dstIndex : int, inout src : float, in srcIndex : int, in pointCount : int) : void
         final int count = pointCount * 2;

         float[] tmpDest = dst;
         boolean inPlace = dst == src;
         if (inPlace) {
             tmpDest = new float[dstIndex + count];
         }

         for (int i = 0 ; i < count ; i += 2) {
             // just in case we are doing in place, we better put this in temp vars
             float x = mValues[0] * src[i + srcIndex] +
                       mValues[1] * src[i + srcIndex + 1] +
                       mValues[2];
             float y = mValues[3] * src[i + srcIndex] +
                       mValues[4] * src[i + srcIndex + 1] +
                       mValues[5];

             tmpDest[i + dstIndex]     = x;
             tmpDest[i + dstIndex + 1] = y;
         }

         if (inPlace) {
             System.arraycopy(tmpDest, dstIndex, dst, dstIndex, count);
         }
!!!35282743.java!!!	mapPoints(inout pts : float) : void
         mapPoints(pts, 0, pts, 0, pts.length >> 1);
!!!35282871.java!!!	mapVectors(inout dst : float, in dstIndex : int, inout src : float, in srcIndex : int, in ptCount : int) : void
         if (hasPerspective()) {
             // transform the (0,0) point
             float[] origin = new float[] { 0.f, 0.f};
             mapPoints(origin);

             // translate the vector data as points
             mapPoints(dst, dstIndex, src, srcIndex, ptCount);

             // then substract the transformed origin.
             final int count = ptCount * 2;
             for (int i = 0 ; i < count ; i += 2) {
                 dst[dstIndex + i] = dst[dstIndex + i] - origin[0];
                 dst[dstIndex + i + 1] = dst[dstIndex + i + 1] - origin[1];
             }
         } else {
             // make a copy of the matrix
             Matrix_Delegate copy = new Matrix_Delegate(mValues);

             // remove the translation
             setTranslate(copy.mValues, 0, 0);

             // map the content as points.
             copy.mapPoints(dst, dstIndex, src, srcIndex, ptCount);
         }
!!!35282999.java!!!	multiply(inout dest : float, inout a : float, inout b : float) : void
        // first row
        dest[0] = b[0] * a[0] + b[1] * a[3] + b[2] * a[6];
        dest[1] = b[0] * a[1] + b[1] * a[4] + b[2] * a[7];
        dest[2] = b[0] * a[2] + b[1] * a[5] + b[2] * a[8];

        // 2nd row
        dest[3] = b[3] * a[0] + b[4] * a[3] + b[5] * a[6];
        dest[4] = b[3] * a[1] + b[4] * a[4] + b[5] * a[7];
        dest[5] = b[3] * a[2] + b[4] * a[5] + b[5] * a[8];

        // 3rd row
        dest[6] = b[6] * a[0] + b[7] * a[3] + b[8] * a[6];
        dest[7] = b[6] * a[1] + b[7] * a[4] + b[8] * a[7];
        dest[8] = b[6] * a[2] + b[7] * a[5] + b[8] * a[8];
!!!35283127.java!!!	getTranslate(in dx : float, in dy : float) : float
        return setTranslate(new float[9], dx, dy);
!!!35283255.java!!!	setTranslate(inout dest : float, in dx : float, in dy : float) : float
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = dx;
        dest[3] = 0;
        dest[4] = 1;
        dest[5] = dy;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 1;
        return dest;
!!!35283383.java!!!	getScale(in sx : float, in sy : float) : float
        return new float[] { sx, 0, 0, 0, sy, 0, 0, 0, 1 };
!!!35283511.java!!!	getScale(in sx : float, in sy : float, in px : float, in py : float) : float
        float[] tmp = new float[9];
        float[] tmp2 = new float[9];

        // TODO: do it in one pass

        // translate tmp so that the pivot is in 0,0
        setTranslate(tmp, -px, -py);

        // scale into tmp2
        multiply(tmp2, tmp, getScale(sx, sy));

        // translate back the pivot back into tmp
        multiply(tmp, tmp2, getTranslate(px, py));

        return tmp;
!!!35283639.java!!!	getRotate(in degrees : float) : float
        double rad = Math.toRadians(degrees);
        float sin = (float)Math.sin(rad);
        float cos = (float)Math.cos(rad);

        return getRotate(sin, cos);
!!!35283767.java!!!	getRotate(in sin : float, in cos : float) : float
        return setRotate(new float[9], sin, cos);
!!!35283895.java!!!	setRotate(inout dest : float, in degrees : float) : float
        double rad = Math.toRadians(degrees);
        float sin = (float)Math.sin(rad);
        float cos = (float)Math.cos(rad);

        return setRotate(dest, sin, cos);
!!!35284023.java!!!	setRotate(inout dest : float, in sin : float, in cos : float) : float
        dest[0] = cos;
        dest[1] = -sin;
        dest[2] = 0;
        dest[3] = sin;
        dest[4] = cos;
        dest[5] = 0;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 1;
        return dest;
!!!35284151.java!!!	getRotate(in degrees : float, in px : float, in py : float) : float
        float[] tmp = new float[9];
        float[] tmp2 = new float[9];

        // TODO: do it in one pass

        // translate so that the pivot is in 0,0
        setTranslate(tmp, -px, -py);

        // rotate into tmp2
        double rad = Math.toRadians(degrees);
        float cos = (float)Math.cos(rad);
        float sin = (float)Math.sin(rad);
        multiply(tmp2, tmp, getRotate(sin, cos));

        // translate back the pivot back into tmp
        multiply(tmp, tmp2, getTranslate(px, py));

        return tmp;
!!!35284279.java!!!	getSkew(in kx : float, in ky : float) : float
        return new float[] { 1, kx, 0, ky, 1, 0, 0, 0, 1 };
!!!35284407.java!!!	getSkew(in kx : float, in ky : float, in px : float, in py : float) : float
        float[] tmp = new float[9];
        float[] tmp2 = new float[9];

        // TODO: do it in one pass

        // translate so that the pivot is in 0,0
        setTranslate(tmp, -px, -py);

        // skew into tmp2
        multiply(tmp2, tmp, new float[] { 1, kx, 0, ky, 1, 0, 0, 0, 1 });
        // translate back the pivot back into tmp
        multiply(tmp, tmp2, getTranslate(px, py));

        return tmp;
