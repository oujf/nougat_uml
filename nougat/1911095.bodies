class SetterStore
!!!35779255.java!!!	SetterStore(inout modelAnalyzer : ModelAnalyzer, inout store : SetterStore::IntermediateV2)
        mClassAnalyzer = modelAnalyzer;
        mStore = store;
        for (HashMap<AccessorKey, InverseDescription> adapter : mStore.inverseAdapters.values()) {
            for (InverseDescription inverseDescription : adapter.values()) {
                mInverseEventAttributes.add(inverseDescription.event);
            }
        }
        for (HashMap<String, InverseDescription> method : mStore.inverseMethods.values()) {
            for (InverseDescription inverseDescription : method.values()) {
                mInverseEventAttributes.add(inverseDescription.event);
            }
        }
!!!35779383.java!!!	get(inout modelAnalyzer : ModelAnalyzer) : SetterStore
        if (sStore == null) {
            sStore = load(modelAnalyzer);
        }
        return sStore;
!!!35779511.java!!!	load(inout modelAnalyzer : ModelAnalyzer) : SetterStore
        IntermediateV2 store = new IntermediateV2();
        List<Intermediate> previousStores = GenerationalClassUtil
                .loadObjects(GenerationalClassUtil.ExtensionFilter.SETTER_STORE);
        for (Intermediate intermediate : previousStores) {
            merge(store, intermediate);
        }
        return new SetterStore(modelAnalyzer, store);
!!!35779639.java!!!	addRenamedMethod(inout attribute : String, inout declaringClass : String, inout method : String, inout declaredOn : TypeElement) : void
        attribute = stripNamespace(attribute);
        HashMap<String, MethodDescription> renamed = mStore.renamedMethods.get(attribute);
        if (renamed == null) {
            renamed = new HashMap<String, MethodDescription>();
            mStore.renamedMethods.put(attribute, renamed);
        }
        MethodDescription methodDescription = new MethodDescription(
                declaredOn.getQualifiedName().toString(), method);
        L.d("STORE addmethod desc %s", methodDescription);
        renamed.put(declaringClass, methodDescription);
!!!35779767.java!!!	addInverseMethod(inout attribute : String, inout event : String, inout declaringClass : String, inout method : String, inout declaredOn : TypeElement) : void
        attribute = stripNamespace(attribute);
        event = stripNamespace(event);
        HashMap<String, InverseDescription> inverseMethods = mStore.inverseMethods.get(attribute);
        if (inverseMethods == null) {
            inverseMethods = new HashMap<String, InverseDescription>();
            mStore.inverseMethods.put(attribute, inverseMethods);
        }
        InverseDescription methodDescription = new InverseDescription(
                declaredOn.getQualifiedName().toString(), method, event);
        L.d("STORE addInverseMethod desc %s", methodDescription);
        inverseMethods.put(declaringClass, methodDescription);
!!!35779895.java!!!	addBindingAdapter(inout processingEnv : ProcessingEnvironment, inout attribute : String, inout bindingMethod : ExecutableElement, inout takesComponent : boolean) : void
        attribute = stripNamespace(attribute);
        L.d("STORE addBindingAdapter %s %s", attribute, bindingMethod);
        HashMap<AccessorKey, MethodDescription> adapters = mStore.adapterMethods.get(attribute);

        if (adapters == null) {
            adapters = new HashMap<AccessorKey, MethodDescription>();
            mStore.adapterMethods.put(attribute, adapters);
        }
        List<? extends VariableElement> parameters = bindingMethod.getParameters();
        final int viewIndex = takesComponent ? 1 : 0;
        TypeMirror viewType = eraseType(processingEnv, parameters.get(viewIndex).asType());
        String view = getQualifiedName(viewType);
        TypeMirror parameterType = eraseType(processingEnv, parameters.get(viewIndex + 1).asType());
        String value = getQualifiedName(parameterType);

        AccessorKey key = new AccessorKey(view, value);
        if (adapters.containsKey(key)) {
            throw new IllegalArgumentException("Already exists!");
        }

        adapters.put(key, new MethodDescription(bindingMethod, 1, takesComponent));
!!!35780023.java!!!	addInverseAdapter(inout processingEnv : ProcessingEnvironment, inout attribute : String, inout event : String, inout bindingMethod : ExecutableElement, inout takesComponent : boolean) : void
        attribute = stripNamespace(attribute);
        event = stripNamespace(event);
        L.d("STORE addInverseAdapter %s %s", attribute, bindingMethod);
        HashMap<AccessorKey, InverseDescription> adapters = mStore.inverseAdapters.get(attribute);

        if (adapters == null) {
            adapters = new HashMap<AccessorKey, InverseDescription>();
            mStore.inverseAdapters.put(attribute, adapters);
        }
        List<? extends VariableElement> parameters = bindingMethod.getParameters();
        final int viewIndex = takesComponent ? 1 : 0;
        TypeMirror viewType = eraseType(processingEnv, parameters.get(viewIndex).asType());
        String view = getQualifiedName(viewType);
        TypeMirror returnType = eraseType(processingEnv, bindingMethod.getReturnType());
        String value = getQualifiedName(returnType);

        AccessorKey key = new AccessorKey(view, value);
        if (adapters.containsKey(key)) {
            throw new IllegalArgumentException("Already exists!");
        }

        adapters.put(key, new InverseDescription(bindingMethod, event, takesComponent));
!!!35780151.java!!!	eraseType(inout processingEnv : ProcessingEnvironment, inout typeMirror : TypeMirror) : TypeMirror
        if (hasTypeVar(typeMirror)) {
            return processingEnv.getTypeUtils().erasure(typeMirror);
        } else {
            return typeMirror;
        }
!!!35780279.java!!!	eraseType(inout modelClass : ModelClass) : ModelClass
        if (hasTypeVar(modelClass)) {
            return modelClass.erasure();
        } else {
            return modelClass;
        }
!!!35780407.java!!!	hasTypeVar(inout typeMirror : TypeMirror) : boolean
        TypeKind kind = typeMirror.getKind();
        if (kind == TypeKind.TYPEVAR) {
            return true;
        } else if (kind == TypeKind.ARRAY) {
            return hasTypeVar(((ArrayType) typeMirror).getComponentType());
        } else if (kind == TypeKind.DECLARED) {
            DeclaredType declaredType = (DeclaredType) typeMirror;
            List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
            if (typeArguments == null || typeArguments.isEmpty()) {
                return false;
            }
            for (TypeMirror arg : typeArguments) {
                if (hasTypeVar(arg)) {
                    return true;
                }
            }
            return false;
        } else {
            return false;
        }
!!!35780535.java!!!	hasTypeVar(inout type : ModelClass) : boolean
        if (type.isTypeVar()) {
            return true;
        } else if (type.isArray()) {
            return hasTypeVar(type.getComponentType());
        } else {
            List<ModelClass> typeArguments = type.getTypeArguments();
            if (typeArguments == null) {
                return false;
            }
            for (ModelClass arg : typeArguments) {
                if (hasTypeVar(arg)) {
                    return true;
                }
            }
            return false;
        }
!!!35780663.java!!!	addBindingAdapter(inout processingEnv : ProcessingEnvironment, inout attributes : String, inout bindingMethod : ExecutableElement, inout takesComponent : boolean, inout requireAll : boolean) : void
        L.d("STORE add multi-value BindingAdapter %d %s", attributes.length, bindingMethod);
        MultiValueAdapterKey key = new MultiValueAdapterKey(processingEnv, bindingMethod,
                attributes, takesComponent, requireAll);
        MethodDescription methodDescription = new MethodDescription(bindingMethod,
                attributes.length, takesComponent);
        mStore.multiValueAdapters.put(key, methodDescription);
!!!35780791.java!!!	stripAttributes(inout attributes : String) : String
        String[] strippedAttributes = new String[attributes.length];
        for (int i = 0; i < attributes.length; i++) {
            if (attributes[i] != null) {
                strippedAttributes[i] = stripNamespace(attributes[i]);
            }
        }
        return strippedAttributes;
!!!35780919.java!!!	addUntaggableTypes(inout typeNames : String, inout declaredOn : TypeElement) : void
        L.d("STORE addUntaggableTypes %s %s", Arrays.toString(typeNames), declaredOn);
        String declaredType = declaredOn.getQualifiedName().toString();
        for (String type : typeNames) {
            mStore.untaggableTypes.put(type, declaredType);
        }
!!!35781047.java!!!	getQualifiedName(inout type : TypeMirror) : String
        final TypeKind kind = type.getKind();
        if (kind == TypeKind.ARRAY) {
            return getQualifiedName(((ArrayType) type).getComponentType()) + "[]";
        } else if (kind == TypeKind.DECLARED && isIncompleteType(type)) {
            DeclaredType declaredType = (DeclaredType) type;
            return declaredType.asElement().toString();
        } else {
            return type.toString();
        }
!!!35781175.java!!!	isIncompleteType(inout type : TypeMirror) : boolean
        final TypeKind kind = type.getKind();
        if (kind == TypeKind.TYPEVAR || kind == TypeKind.WILDCARD) {
            return true;
        } else if (kind == TypeKind.DECLARED) {
            DeclaredType declaredType = (DeclaredType) type;
            List<? extends TypeMirror> typeArgs = declaredType.getTypeArguments();
            if (typeArgs == null) {
                return false;
            }
            for (TypeMirror arg : typeArgs) {
                if (isIncompleteType(arg)) {
                    return true;
                }
            }
        }
        return false;
!!!35781303.java!!!	addConversionMethod(inout conversionMethod : ExecutableElement) : void
        L.d("STORE addConversionMethod %s", conversionMethod);
        List<? extends VariableElement> parameters = conversionMethod.getParameters();
        String fromType = getQualifiedName(parameters.get(0).asType());
        String toType = getQualifiedName(conversionMethod.getReturnType());
        MethodDescription methodDescription = new MethodDescription(conversionMethod, 1, false);
        HashMap<String, MethodDescription> convertTo = mStore.conversionMethods.get(fromType);
        if (convertTo == null) {
            convertTo = new HashMap<String, MethodDescription>();
            mStore.conversionMethods.put(fromType, convertTo);
        }
        convertTo.put(toType, methodDescription);
!!!35781431.java!!!	clear(inout classes : Set<String>) : void
        ArrayList<AccessorKey> removedAccessorKeys = new ArrayList<AccessorKey>();
        for (HashMap<AccessorKey, MethodDescription> adapters : mStore.adapterMethods.values()) {
            for (AccessorKey key : adapters.keySet()) {
                MethodDescription description = adapters.get(key);
                if (classes.contains(description.type)) {
                    removedAccessorKeys.add(key);
                }
            }
            removeFromMap(adapters, removedAccessorKeys);
        }

        ArrayList<String> removedRenamed = new ArrayList<String>();
        for (HashMap<String, MethodDescription> renamed : mStore.renamedMethods.values()) {
            for (String key : renamed.keySet()) {
                if (classes.contains(renamed.get(key).type)) {
                    removedRenamed.add(key);
                }
            }
            removeFromMap(renamed, removedRenamed);
        }

        ArrayList<String> removedConversions = new ArrayList<String>();
        for (HashMap<String, MethodDescription> convertTos : mStore.conversionMethods.values()) {
            for (String toType : convertTos.keySet()) {
                MethodDescription methodDescription = convertTos.get(toType);
                if (classes.contains(methodDescription.type)) {
                    removedConversions.add(toType);
                }
            }
            removeFromMap(convertTos, removedConversions);
        }

        ArrayList<String> removedUntaggable = new ArrayList<String>();
        for (String typeName : mStore.untaggableTypes.keySet()) {
            if (classes.contains(mStore.untaggableTypes.get(typeName))) {
                removedUntaggable.add(typeName);
            }
        }
        removeFromMap(mStore.untaggableTypes, removedUntaggable);
!!!35781559.java!!!	removeFromMap(inout map : Map<K, V>, inout keys : List<K>) : void
        for (K key : keys) {
            map.remove(key);
        }
        keys.clear();
!!!35781687.java!!!	write(inout projectPackage : String, inout processingEnvironment : ProcessingEnvironment) : void
        GenerationalClassUtil.writeIntermediateFile(processingEnvironment,
                projectPackage, projectPackage +
                        GenerationalClassUtil.ExtensionFilter.SETTER_STORE.getExtension(), mStore);
!!!35781815.java!!!	stripNamespace(inout attribute : String) : String
        if (!attribute.startsWith("android:")) {
            int colon = attribute.indexOf(':');
            if (colon >= 0) {
                attribute = attribute.substring(colon + 1);
            }
        }
        return attribute;
!!!35781943.java!!!	isTwoWayEventAttribute(inout attribute : String) : boolean
        attribute = stripNamespace(attribute);
        return mInverseEventAttributes.contains(attribute);
!!!35782071.java!!!	getMultiAttributeSetterCalls(inout attributes : String, inout viewType : ModelClass, inout valueType : ModelClass) : SetterStore::MultiAttributeSetter
        attributes = stripAttributes(attributes);
        final ArrayList<MultiAttributeSetter> calls = new ArrayList<MultiAttributeSetter>();
        if (viewType != null && viewType.isGeneric()) {
            List<ModelClass> viewGenerics = viewType.getTypeArguments();
            for (int i = 0; i < valueType.length; i++) {
                valueType[i] = eraseType(valueType[i], viewGenerics);
            }
            viewType = viewType.erasure();
        }
        ArrayList<MultiAttributeSetter> matching = getMatchingMultiAttributeSetters(attributes,
                viewType, valueType);
        Collections.sort(matching, COMPARE_MULTI_ATTRIBUTE_SETTERS);
        while (!matching.isEmpty()) {
            MultiAttributeSetter bestMatch = matching.get(0);
            calls.add(bestMatch);
            removeConsumedAttributes(matching, bestMatch.attributes);
        }
        return calls;
!!!35782199.java!!!	simpleName(inout className : String) : String
        int dotIndex = className.lastIndexOf('.');
        if (dotIndex < 0) {
            return className;
        } else {
            return className.substring(dotIndex + 1);
        }
!!!35782327.java!!!	getComponentBindingAdapters() : String
        ensureInstanceAdapters();
        return mInstanceAdapters;
!!!35782455.java!!!	getBindingAdapterCall(inout className : String) : String
        ensureInstanceAdapters();
        final String simpleName = simpleName(className);
        List<String> adapters = mInstanceAdapters.get(simpleName);
        if (adapters.size() == 1) {
            return "get" + simpleName + "()";
        } else {
            int index = adapters.indexOf(className) + 1;
            return "get" + simpleName + index + "()";
        }
!!!35782583.java!!!	ensureInstanceAdapters() : void
        if (mInstanceAdapters == null) {
            HashSet<String> adapters = new HashSet<String>();
            for (HashMap<AccessorKey, MethodDescription> methods : mStore.adapterMethods.values()) {
                for (MethodDescription method : methods.values()) {
                    if (!method.isStatic) {
                        adapters.add(method.type);
                    }
                }
            }
            for (MethodDescription method : mStore.multiValueAdapters.values()) {
                if (!method.isStatic) {
                    adapters.add(method.type);
                }
            }
            for (Map<AccessorKey, InverseDescription> methods : mStore.inverseAdapters.values()) {
                for (InverseDescription method : methods.values()) {
                    if (!method.isStatic) {
                        adapters.add(method.type);
                    }
                }
            }
            mInstanceAdapters = new HashMap<String, List<String>>();
            for (String adapter : adapters) {
                final String simpleName = simpleName(adapter);
                List<String> list = mInstanceAdapters.get(simpleName);
                if (list == null) {
                    list = new ArrayList<String>();
                    mInstanceAdapters.put(simpleName, list);
                }
                list.add(adapter);
            }
            for (List<String> list : mInstanceAdapters.values()) {
                if (list.size() > 1) {
                    Collections.sort(list);
                }
            }
        }
!!!35782711.java!!!	removeConsumedAttributes(inout matching : ArrayList<MultiAttributeSetter>, inout attributes : String) : void
        for (int i = matching.size() - 1; i >= 0; i--) {
            final MultiAttributeSetter setter = matching.get(i);
            boolean found = false;
            for (String attribute : attributes) {
                if (isInArray(attribute, setter.attributes)) {
                    found = true;
                    break;
                }
            }
            if (found) {
                matching.remove(i);
            }
        }
!!!35782839.java!!!	isInArray(inout str : String, inout array : String) : boolean
        for (String value : array) {
            if (value.equals(str)) {
                return true;
            }
        }
        return false;
!!!35782967.java!!!	getMatchingMultiAttributeSetters(inout attributes : String, inout viewType : ModelClass, inout valueType : ModelClass) : SetterStore::MultiAttributeSetter
        final ArrayList<MultiAttributeSetter> setters = new ArrayList<MultiAttributeSetter>();
        for (MultiValueAdapterKey adapter : mStore.multiValueAdapters.keySet()) {
            if (adapter.requireAll && adapter.attributes.length > attributes.length) {
                continue;
            }
            ModelClass viewClass = mClassAnalyzer.findClass(adapter.viewType, null);
            if (viewClass.isGeneric()) {
                viewClass = viewClass.erasure();
            }
            if (!viewClass.isAssignableFrom(viewType)) {
                continue;
            }
            final MethodDescription method = mStore.multiValueAdapters.get(adapter);
            final MultiAttributeSetter setter = createMultiAttributeSetter(method, attributes,
                    valueType, adapter);
            if (setter != null) {
                setters.add(setter);
            }
        }
        return setters;
!!!35783095.java!!!	createMultiAttributeSetter(inout method : SetterStore::MethodDescription, inout allAttributes : String, inout attributeValues : ModelClass, inout adapter : SetterStore::MultiValueAdapterKey) : SetterStore::MultiAttributeSetter
        int matchingAttributes = 0;
        String[] casts = new String[adapter.attributes.length];
        MethodDescription[] conversions = new MethodDescription[adapter.attributes.length];
        boolean[] supplied = new boolean[adapter.attributes.length];

        for (int i = 0; i < allAttributes.length; i++) {
            Integer index = adapter.attributeIndices.get(allAttributes[i]);
            if (index != null) {
                supplied[index] = true;
                matchingAttributes++;
                final String parameterTypeStr = adapter.parameterTypes[index];
                final ModelClass parameterType = eraseType(
                        mClassAnalyzer.findClass(parameterTypeStr, null));
                final ModelClass attributeType = attributeValues[i];
                if (!parameterType.isAssignableFrom(attributeType)) {
                    if (ModelMethod.isBoxingConversion(parameterType, attributeType)) {
                        // automatic boxing is ok
                        continue;
                    } else if (ModelMethod.isImplicitConversion(attributeType, parameterType)) {
                        // implicit conversion is ok
                        continue;
                    }
                    // Look for a converter
                    conversions[index] = getConversionMethod(attributeType, parameterType, null);
                    if (conversions[index] == null) {
                        if (attributeType.isObject()) {
                            // Cast is allowed also
                            casts[index] = parameterTypeStr;
                        } else {
                            // Parameter type mismatch
                            return null;
                        }
                    }
                }
            }
        }

        if ((adapter.requireAll && matchingAttributes != adapter.attributes.length) ||
                matchingAttributes == 0) {
            return null;
        } else {
            return new MultiAttributeSetter(adapter, supplied, method, conversions, casts);
        }
!!!35783223.java!!!	getSetterCall(inout attribute : String, inout viewType : ModelClass, inout valueType : ModelClass, inout imports : Map<String, String>) : SetterStore::SetterCall
        attribute = stripNamespace(attribute);
        SetterCall setterCall = null;
        MethodDescription conversionMethod = null;
        if (viewType != null) {
            viewType = viewType.erasure();
            HashMap<AccessorKey, MethodDescription> adapters = mStore.adapterMethods.get(attribute);
            ModelMethod bestSetterMethod = getBestSetter(viewType, valueType, attribute, imports);
            ModelClass bestViewType = null;
            ModelClass bestValueType = null;
            if (bestSetterMethod != null) {
                bestViewType = bestSetterMethod.getDeclaringClass();
                bestValueType = bestSetterMethod.getParameterTypes()[0];
                setterCall = new ModelMethodSetter(bestSetterMethod);
            }

            if (adapters != null) {
                for (AccessorKey key : adapters.keySet()) {
                    try {
                        ModelClass adapterViewType = mClassAnalyzer
                                .findClass(key.viewType, imports).erasure();
                        if (adapterViewType != null && adapterViewType.isAssignableFrom(viewType)) {
                            try {
                                L.d("setter parameter type is %s", key.valueType);
                                final ModelClass adapterValueType = eraseType(mClassAnalyzer
                                        .findClass(key.valueType, imports));
                                L.d("setter %s takes type %s, compared to %s",
                                        adapters.get(key).method, adapterValueType.toJavaCode(),
                                        valueType.toJavaCode());
                                boolean isBetterView = bestViewType == null ||
                                        bestViewType.isAssignableFrom(adapterViewType);
                                if (isBetterParameter(valueType, adapterValueType, bestValueType,
                                        isBetterView, imports)) {
                                    bestViewType = adapterViewType;
                                    bestValueType = adapterValueType;
                                    MethodDescription adapter = adapters.get(key);
                                    setterCall = new AdapterSetter(adapter, adapterValueType);
                                }

                            } catch (Exception e) {
                                L.e(e, "Unknown class: %s", key.valueType);
                            }
                        }
                    } catch (Exception e) {
                        L.e(e, "Unknown class: %s", key.viewType);
                    }
                }
            }

            conversionMethod = getConversionMethod(valueType, bestValueType, imports);
            if (valueType.isObject() && setterCall != null && bestValueType.isNullable()) {
                setterCall.setCast(bestValueType);
            }
        }
        if (setterCall == null) {
            if (viewType != null && !viewType.isViewDataBinding()) {
                return null; // no setter found!!
            }
            setterCall = new DummySetter(getDefaultSetter(attribute));
        }
        setterCall.setConverter(conversionMethod);
        return setterCall;
!!!35783351.java!!!	getGetterCall(inout attribute : String, inout viewType : ModelClass, inout valueType : ModelClass, inout imports : Map<String, String>) : SetterStore::BindingGetterCall
        if (viewType == null) {
            return null;
        } else if (viewType.isViewDataBinding()) {
            return new ViewDataBindingGetterCall(attribute);
        }

        attribute = stripNamespace(attribute);
        viewType = viewType.erasure();

        InverseMethod bestMethod = getBestGetter(viewType, valueType, attribute, imports);
        HashMap<AccessorKey, InverseDescription> adapters = mStore.inverseAdapters.get(attribute);
        if (adapters != null) {
            for (AccessorKey key : adapters.keySet()) {
                try {
                    ModelClass adapterViewType = mClassAnalyzer
                            .findClass(key.viewType, imports).erasure();
                    if (adapterViewType != null && adapterViewType.isAssignableFrom(viewType)) {
                        try {
                            L.d("getter return type is %s", key.valueType);
                            final ModelClass adapterValueType = eraseType(mClassAnalyzer
                                    .findClass(key.valueType, imports));
                            L.d("getter %s returns type %s, compared to %s",
                                    adapters.get(key).method, adapterValueType.toJavaCode(),
                                    valueType);
                            boolean isBetterView = bestMethod.viewType == null ||
                                    bestMethod.viewType.isAssignableFrom(adapterViewType);
                            if (valueType == null ||
                                    isBetterParameter(adapterValueType, valueType,
                                            bestMethod.returnType, isBetterView, imports)) {
                                bestMethod.viewType = adapterViewType;
                                bestMethod.returnType = adapterValueType;
                                InverseDescription inverseDescription = adapters.get(key);
                                ModelClass listenerType = ModelAnalyzer.getInstance().findClass(
                                        InverseBindingListener.class);
                                BindingSetterCall eventCall = getSetterCall(
                                        inverseDescription.event, viewType, listenerType, imports);
                                if (eventCall == null) {
                                    List<MultiAttributeSetter> setters =
                                            getMultiAttributeSetterCalls(
                                                    new String[]{inverseDescription.event},
                                                    viewType, new ModelClass[] {listenerType});
                                    if (setters.size() != 1) {
                                        L.e("Could not find event '%s' on View type '%s'",
                                                inverseDescription.event,
                                                viewType.getCanonicalName());
                                    } else {
                                        bestMethod.call = new AdapterGetter(inverseDescription,
                                                setters.get(0));
                                    }
                                } else {
                                    bestMethod.call = new AdapterGetter(inverseDescription,
                                            eventCall);
                                }
                            }

                        } catch (Exception e) {
                            L.e(e, "Unknown class: %s", key.valueType);
                        }
                    }
                } catch (Exception e) {
                    L.e(e, "Unknown class: %s", key.viewType);
                }
            }
        }

        return bestMethod.call;
!!!35783479.java!!!	isUntaggable(inout viewType : String) : boolean
        return mStore.untaggableTypes.containsKey(viewType);
!!!35783607.java!!!	getBestSetter(inout viewType : ModelClass, inout argumentType : ModelClass, inout attribute : String, inout imports : Map<String, String>) : ModelMethod
        if (viewType.isGeneric()) {
            argumentType = eraseType(argumentType, viewType.getTypeArguments());
            viewType = viewType.erasure();
        }
        List<String> setterCandidates = new ArrayList<String>();
        HashMap<String, MethodDescription> renamed = mStore.renamedMethods.get(attribute);
        if (renamed != null) {
            for (String className : renamed.keySet()) {
                try {
                    ModelClass renamedViewType = mClassAnalyzer.findClass(className, imports);
                    if (renamedViewType.erasure().isAssignableFrom(viewType)) {
                        setterCandidates.add(renamed.get(className).method);
                        break;
                    }
                } catch (Exception e) {
                    //printMessage(Diagnostic.Kind.NOTE, "Unknown class: " + className);
                }
            }
        }
        setterCandidates.add(getDefaultSetter(attribute));
        setterCandidates.add(trimAttributeNamespace(attribute));

        ModelMethod bestMethod = null;
        ModelClass bestParameterType = null;
        List<ModelClass> args = new ArrayList<ModelClass>();
        args.add(argumentType);
        for (String name : setterCandidates) {
            ModelMethod[] methods = viewType.getMethods(name, 1);

            for (ModelMethod method : methods) {
                ModelClass[] parameterTypes = method.getParameterTypes();
                ModelClass param = parameterTypes[0];
                if (method.isVoid() &&
                        isBetterParameter(argumentType, param, bestParameterType, true, imports)) {
                    bestParameterType = param;
                    bestMethod = method;
                }
            }
        }
        return bestMethod;
!!!35783735.java!!!	getBestGetter(inout viewType : ModelClass, inout valueType : ModelClass, inout attribute : String, inout imports : Map<String, String>) : SetterStore::InverseMethod
        if (viewType.isGeneric()) {
            if (valueType != null) {
                valueType = eraseType(valueType, viewType.getTypeArguments());
            }
            viewType = viewType.erasure();
        }
        ModelClass bestReturnType = null;
        InverseDescription bestDescription = null;
        ModelClass bestViewType = null;
        ModelMethod bestMethod = null;

        HashMap<String, InverseDescription> inverseMethods = mStore.inverseMethods.get(attribute);
        if (inverseMethods != null) {
            for (String className : inverseMethods.keySet()) {
                try {
                    ModelClass methodViewType = mClassAnalyzer.findClass(className, imports);
                    if (methodViewType.erasure().isAssignableFrom(viewType)) {
                        boolean isBetterViewType = bestViewType == null ||
                                bestViewType.isAssignableFrom(methodViewType);
                        final InverseDescription inverseDescription = inverseMethods.get(className);
                        final String name =  inverseDescription.method.isEmpty() ?
                                trimAttributeNamespace(attribute) : inverseDescription.method;
                        ModelMethod method = methodViewType.findInstanceGetter(name);
                        ModelClass returnType = method.getReturnType(null); // no parameters
                        if (valueType == null || bestReturnType == null ||
                                isBetterParameter(returnType, valueType, bestReturnType,
                                        isBetterViewType, imports)) {
                            bestDescription = inverseDescription;
                            bestReturnType = returnType;
                            bestViewType = methodViewType;
                            bestMethod = method;
                        }
                    }
                } catch (Exception e) {
                    //printMessage(Diagnostic.Kind.NOTE, "Unknown class: " + className);
                }
            }
        }

        BindingGetterCall call = null;
        if (bestDescription != null) {
            final ModelClass listenerType = ModelAnalyzer.getInstance().findClass(
                    InverseBindingListener.class);
            SetterCall eventSetter = getSetterCall(bestDescription.event, viewType,
                    listenerType, imports);
            if (eventSetter == null) {
                List<MultiAttributeSetter> setters = getMultiAttributeSetterCalls(
                        new String[] {bestDescription.event}, viewType,
                        new ModelClass[] {listenerType});
                if (setters.size() != 1) {
                    L.e("Could not find event '%s' on View type '%s'", bestDescription.event,
                            viewType.getCanonicalName());
                    bestViewType = null;
                    bestReturnType = null;
                } else {
                    call = new ViewGetterCall(bestDescription, bestMethod, setters.get(0));
                }
            } else {
                call = new ViewGetterCall(bestDescription, bestMethod, eventSetter);
            }
        }
        return new InverseMethod(call, bestReturnType, bestViewType);
!!!35783863.java!!!	eraseType(inout type : ModelClass, inout typeParameters : List<ModelClass>) : ModelClass
        List<ModelClass> typeArguments = type.getTypeArguments();
        if (typeArguments == null || typeParameters == null) {
            return type;
        }
        for (ModelClass arg : typeArguments) {
            if (typeParameters.contains(arg)) {
                return type.erasure();
            }
        }
        return type;
!!!35783991.java!!!	trimAttributeNamespace(inout attribute : String) : String
        final int colonIndex = attribute.indexOf(':');
        return colonIndex == -1 ? attribute : attribute.substring(colonIndex + 1);
!!!35784119.java!!!	getDefaultSetter(inout attribute : String) : String
        return "set" + StringUtils.capitalize(trimAttributeNamespace(attribute));
!!!35784247.java!!!	isBetterParameter(inout argument : ModelClass, inout parameter : ModelClass, inout oldParameter : ModelClass, inout isBetterViewTypeMatch : boolean, inout imports : Map<String, String>) : boolean
        // Right view type. Check the value
        if (!isBetterViewTypeMatch && oldParameter.equals(argument)) {
            return false;
        } else if (argument.equals(parameter)) {
            // Exact match
            return true;
        } else if (!isBetterViewTypeMatch &&
                ModelMethod.isBoxingConversion(oldParameter, argument)) {
            return false;
        } else if (ModelMethod.isBoxingConversion(parameter, argument)) {
            // Boxing/unboxing is second best
            return true;
        } else {
            int oldConversionLevel = ModelMethod.getImplicitConversionLevel(oldParameter);
            if (ModelMethod.isImplicitConversion(argument, parameter)) {
                // Better implicit conversion
                int conversionLevel = ModelMethod.getImplicitConversionLevel(parameter);
                return oldConversionLevel < 0 || conversionLevel < oldConversionLevel;
            } else if (oldConversionLevel >= 0) {
                return false;
            } else if (parameter.isAssignableFrom(argument)) {
                // Right type, see if it is better than the current best match.
                if (oldParameter == null) {
                    return true;
                } else {
                    return oldParameter.isAssignableFrom(parameter);
                }
            } else {
                MethodDescription conversionMethod = getConversionMethod(argument, parameter,
                        imports);
                if (conversionMethod != null) {
                    return true;
                }
                if (getConversionMethod(argument, oldParameter, imports) != null) {
                    return false;
                }
                return argument.isObject() && !parameter.isPrimitive();
            }
        }
!!!35784375.java!!!	getConversionMethod(inout from : ModelClass, inout to : ModelClass, inout imports : Map<String, String>) : SetterStore::MethodDescription
        if (from != null && to != null) {
            if (to.isObject()) {
                return null;
            }
            for (String fromClassName : mStore.conversionMethods.keySet()) {
                try {
                    ModelClass convertFrom = mClassAnalyzer.findClass(fromClassName, imports);
                    if (canUseForConversion(from, convertFrom)) {
                        HashMap<String, MethodDescription> conversion =
                                mStore.conversionMethods.get(fromClassName);
                        for (String toClassName : conversion.keySet()) {
                            try {
                                ModelClass convertTo = mClassAnalyzer.findClass(toClassName,
                                        imports);
                                if (canUseForConversion(convertTo, to)) {
                                    return conversion.get(toClassName);
                                }
                            } catch (Exception e) {
                                L.d(e, "Unknown class: %s", toClassName);
                            }
                        }
                    }
                } catch (Exception e) {
                    L.d(e, "Unknown class: %s", fromClassName);
                }
            }
        }
        return null;
!!!35784503.java!!!	canUseForConversion(inout from : ModelClass, inout to : ModelClass) : boolean
        if (from.isIncomplete() || to.isIncomplete()) {
            from = from.erasure();
            to = to.erasure();
        }
        return from.equals(to) || ModelMethod.isBoxingConversion(from, to) ||
                to.isAssignableFrom(from);
!!!35784631.java!!!	merge(inout store : SetterStore::IntermediateV2, inout dumpStore : SetterStore::Intermediate) : void
        IntermediateV2 intermediateV2 = (IntermediateV2) dumpStore.upgrade();
        merge(store.adapterMethods, intermediateV2.adapterMethods);
        merge(store.renamedMethods, intermediateV2.renamedMethods);
        merge(store.conversionMethods, intermediateV2.conversionMethods);
        store.multiValueAdapters.putAll(intermediateV2.multiValueAdapters);
        store.untaggableTypes.putAll(intermediateV2.untaggableTypes);
        merge(store.inverseAdapters, intermediateV2.inverseAdapters);
        merge(store.inverseMethods, intermediateV2.inverseMethods);
!!!35784759.java!!!	merge(inout first : HashMap<K, HashMap<V, D>>, inout second : HashMap<K, HashMap<V, D>>) : void
        for (K key : second.keySet()) {
            HashMap<V, D> firstVals = first.get(key);
            HashMap<V, D> secondVals = second.get(key);
            if (firstVals == null) {
                first.put(key, secondVals);
            } else {
                for (V key2 : secondVals.keySet()) {
                    if (!firstVals.containsKey(key2)) {
                        firstVals.put(key2, secondVals.get(key2));
                    }
                }
            }
        }
!!!35784887.java!!!	createAdapterCall(inout adapter : SetterStore::MethodDescription, inout componentExpression : String, inout viewExpression : String, inout  : String...args) : String
        StringBuilder sb = new StringBuilder();

        if (adapter.isStatic) {
            sb.append(adapter.type);
        } else {
            final SetterStore setterStore = SetterStore.get(ModelAnalyzer.getInstance());
            final String binderCall =  setterStore.getBindingAdapterCall(adapter.type);
            sb.append(componentExpression).append('.').append(binderCall);
        }
        sb.append('.').append(adapter.method).append('(');
        if (adapter.componentClass != null) {
            if (!"DataBindingComponent".equals(adapter.componentClass)) {
                sb.append('(').append(adapter.componentClass).append(") ");
            }
            sb.append(componentExpression).append(", ");
        }
        sb.append(viewExpression);
        for (String arg: args) {
            sb.append(", ").append(arg);
        }
        sb.append(')');
        return sb.toString();
!!!35785399.java!!!	mergedHashCode(inout  : Object...objects) : int
        return Arrays.hashCode(objects);
