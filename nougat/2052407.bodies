class WifiNative
!!!36861751.java!!!	getLocalLog() : LocalLog
        return sLocalLog;
!!!36862007.java!!!	getWlanNativeInterface() : WifiNative
        return wlanNativeInterface;
!!!36862135.java!!!	getP2pNativeInterface() : WifiNative
        return p2pNativeInterface;
!!!36862263.java!!!	initContext(inout context : Context) : void
        if (mContext == null && context != null) {
            mContext = context;
        }
!!!36862391.java!!!	WifiNative(inout interfaceName : String, inout requiresPrefix : boolean)
        mInterfaceName = interfaceName;
        mTAG = "WifiNative-" + interfaceName;

        if (requiresPrefix) {
            mInterfacePrefix = "IFNAME=" + interfaceName + " ";
        } else {
            mInterfacePrefix = "";
        }
!!!36862519.java!!!	getInterfaceName() : String
        return mInterfaceName;
!!!36862647.java!!!	enableVerboseLogging(in verbose : int) : void
        if (verbose > 0) {
            DBG = true;
        } else {
            DBG = false;
        }
!!!36862775.java!!!	localLog(inout s : String) : void
        if (sLocalLog != null) sLocalLog.log(mInterfaceName + ": " + s);
!!!36863031.java!!!	loadDriver() : boolean
        synchronized (sLock) {
            return loadDriverNative();
        }
!!!36863287.java!!!	isDriverLoaded() : boolean
        synchronized (sLock) {
            return isDriverLoadedNative();
        }
!!!36863543.java!!!	unloadDriver() : boolean
        synchronized (sLock) {
            return unloadDriverNative();
        }
!!!36863799.java!!!	startSupplicant(inout p2pSupported : boolean) : boolean
        synchronized (sLock) {
            return startSupplicantNative(p2pSupported);
        }
!!!36864055.java!!!	killSupplicant(inout p2pSupported : boolean) : boolean
        synchronized (sLock) {
            return killSupplicantNative(p2pSupported);
        }
!!!36864311.java!!!	connectToSupplicant() : boolean
        synchronized (sLock) {
            localLog(mInterfacePrefix + "connectToSupplicant");
            return connectToSupplicantNative();
        }
!!!36864567.java!!!	closeSupplicantConnection() : void
        synchronized (sLock) {
            localLog(mInterfacePrefix + "closeSupplicantConnection");
            closeSupplicantConnectionNative();
        }
!!!36864823.java!!!	waitForEvent() : String
        // No synchronization necessary .. it is implemented in WifiMonitor
        return waitForEventNative();
!!!36865335.java!!!	doBooleanCommand(inout command : String) : boolean
        if (DBG) Log.d(mTAG, "doBoolean: " + command);
        synchronized (sLock) {
            String toLog = mInterfacePrefix + command;
            boolean result = doBooleanCommandNative(mInterfacePrefix + command);
            localLog(toLog + " -> " + result);
            if (DBG) Log.d(mTAG, command + ": returned " + result);
            return result;
        }
!!!36865463.java!!!	doBooleanCommandWithoutLogging(inout command : String) : boolean
        if (DBG) Log.d(mTAG, "doBooleanCommandWithoutLogging: " + command);
        synchronized (sLock) {
            boolean result = doBooleanCommandNative(mInterfacePrefix + command);
            if (DBG) Log.d(mTAG, command + ": returned " + result);
            return result;
        }
!!!36865591.java!!!	doIntCommand(inout command : String) : int
        if (DBG) Log.d(mTAG, "doInt: " + command);
        synchronized (sLock) {
            String toLog = mInterfacePrefix + command;
            int result = doIntCommandNative(mInterfacePrefix + command);
            localLog(toLog + " -> " + result);
            if (DBG) Log.d(mTAG, "   returned " + result);
            return result;
        }
!!!36865719.java!!!	doStringCommand(inout command : String) : String
        if (DBG) {
            //GET_NETWORK commands flood the logs
            if (!command.startsWith("GET_NETWORK")) {
                Log.d(mTAG, "doString: [" + command + "]");
            }
        }
        synchronized (sLock) {
            String toLog = mInterfacePrefix + command;
            String result = doStringCommandNative(mInterfacePrefix + command);
            if (result == null) {
                if (DBG) Log.d(mTAG, "doStringCommandNative no result");
            } else {
                if (!command.startsWith("STATUS-")) {
                    localLog(toLog + " -> " + result);
                }
                if (DBG) Log.d(mTAG, "   returned " + result.replace("\n", " "));
            }
            return result;
        }
!!!36865847.java!!!	doStringCommandWithoutLogging(inout command : String) : String
        if (DBG) {
            //GET_NETWORK commands flood the logs
            if (!command.startsWith("GET_NETWORK")) {
                Log.d(mTAG, "doString: [" + command + "]");
            }
        }
        synchronized (sLock) {
            return doStringCommandNative(mInterfacePrefix + command);
        }
!!!36865975.java!!!	doCustomSupplicantCommand(inout command : String) : String
        return doStringCommand(command);
!!!36866103.java!!!	ping() : boolean
        String pong = doStringCommand("PING");
        return (pong != null && pong.equals("PONG"));
!!!36866231.java!!!	setSupplicantLogLevel(inout level : String) : void
        doStringCommand("LOG_LEVEL " + level);
!!!36866359.java!!!	getFreqCapability() : String
        return doStringCommand("GET_CAPABILITY freq");
!!!36866487.java!!!	createCSVStringFromIntegerSet(inout values : Set<Integer>) : String
        StringBuilder list = new StringBuilder();
        boolean first = true;
        for (Integer value : values) {
            if (!first) {
                list.append(",");
            }
            list.append(value);
            first = false;
        }
        return list.toString();
!!!36866615.java!!!	scan(inout freqs : Set<Integer>, inout hiddenNetworkIds : Set<Integer>) : boolean
        String freqList = null;
        String hiddenNetworkIdList = null;
        if (freqs != null && freqs.size() != 0) {
            freqList = createCSVStringFromIntegerSet(freqs);
        }
        if (hiddenNetworkIds != null && hiddenNetworkIds.size() != 0) {
            hiddenNetworkIdList = createCSVStringFromIntegerSet(hiddenNetworkIds);
        }
        return scanWithParams(freqList, hiddenNetworkIdList);
!!!36866743.java!!!	scanWithParams(inout freqList : String, inout hiddenNetworkIdList : String) : boolean
        StringBuilder scanCommand = new StringBuilder();
        scanCommand.append("SCAN TYPE=ONLY");
        if (freqList != null) {
            scanCommand.append(" freq=" + freqList);
        }
        if (hiddenNetworkIdList != null) {
            scanCommand.append(" scan_id=" + hiddenNetworkIdList);
        }
        return doBooleanCommand(scanCommand.toString());
!!!36866871.java!!!	stopSupplicant() : boolean
        return doBooleanCommand("TERMINATE");
!!!36866999.java!!!	listNetworks() : String
        return doStringCommand("LIST_NETWORKS");
!!!36867127.java!!!	listNetworks(in last_id : int) : String
        return doStringCommand("LIST_NETWORKS LAST_ID=" + last_id);
!!!36867255.java!!!	addNetwork() : int
        return doIntCommand("ADD_NETWORK");
!!!36867383.java!!!	setNetworkExtra(in netId : int, inout name : String, inout values : Map<String, String>) : boolean
        final String encoded;
        try {
            encoded = URLEncoder.encode(new JSONObject(values).toString(), "UTF-8");
        } catch (NullPointerException e) {
            Log.e(TAG, "Unable to serialize networkExtra: " + e.toString());
            return false;
        } catch (UnsupportedEncodingException e) {
            Log.e(TAG, "Unable to serialize networkExtra: " + e.toString());
            return false;
        }
        return setNetworkVariable(netId, name, "\"" + encoded + "\"");
!!!36867511.java!!!	setNetworkVariable(in netId : int, inout name : String, inout value : String) : boolean
        if (TextUtils.isEmpty(name) || TextUtils.isEmpty(value)) return false;
        if (name.equals(WifiConfiguration.pskVarName)
                || name.equals(WifiEnterpriseConfig.PASSWORD_KEY)) {
            return doBooleanCommandWithoutLogging("SET_NETWORK " + netId + " " + name + " " + value);
        } else {
            return doBooleanCommand("SET_NETWORK " + netId + " " + name + " " + value);
        }
!!!36867639.java!!!	getNetworkExtra(in netId : int, inout name : String) : String
        final String wrapped = getNetworkVariable(netId, name);
        if (wrapped == null || !wrapped.startsWith("\"") || !wrapped.endsWith("\"")) {
            return null;
        }
        try {
            final String encoded = wrapped.substring(1, wrapped.length() - 1);
            // This method reads a JSON dictionary that was written by setNetworkExtra(). However,
            // on devices that upgraded from Marshmallow, it may encounter a legacy value instead -
            // an FQDN stored as a plain string. If such a value is encountered, the JSONObject
            // constructor will thrown a JSONException and the method will return null.
            final JSONObject json = new JSONObject(URLDecoder.decode(encoded, "UTF-8"));
            final Map<String, String> values = new HashMap<String, String>();
            final Iterator<?> it = json.keys();
            while (it.hasNext()) {
                final String key = (String) it.next();
                final Object value = json.get(key);
                if (value instanceof String) {
                    values.put(key, (String) value);
                }
            }
            return values;
        } catch (UnsupportedEncodingException e) {
            Log.e(TAG, "Unable to deserialize networkExtra: " + e.toString());
            return null;
        } catch (JSONException e) {
            // This is not necessarily an error. This exception will also occur if we encounter a
            // legacy FQDN stored as a plain string. We want to return null in this case as no JSON
            // dictionary of extras was found.
            return null;
        }
!!!36867767.java!!!	getNetworkVariable(in netId : int, inout name : String) : String
        if (TextUtils.isEmpty(name)) return null;

        // GET_NETWORK will likely flood the logs ...
        return doStringCommandWithoutLogging("GET_NETWORK " + netId + " " + name);
!!!36867895.java!!!	removeNetwork(in netId : int) : boolean
        return doBooleanCommand("REMOVE_NETWORK " + netId);
!!!36868023.java!!!	logDbg(inout debug : String) : void
        long now = SystemClock.elapsedRealtimeNanos();
        String ts = String.format("[%,d us] ", now/1000);
        Log.e("WifiNative: ", ts+debug+ " stack:"
                + Thread.currentThread().getStackTrace()[2].getMethodName() +" - "
                + Thread.currentThread().getStackTrace()[3].getMethodName() +" - "
                + Thread.currentThread().getStackTrace()[4].getMethodName() +" - "
                + Thread.currentThread().getStackTrace()[5].getMethodName()+" - "
                + Thread.currentThread().getStackTrace()[6].getMethodName());

!!!36868151.java!!!	enableNetwork(in netId : int) : boolean
        if (DBG) logDbg("enableNetwork nid=" + Integer.toString(netId));
        return doBooleanCommand("ENABLE_NETWORK " + netId);
!!!36868279.java!!!	enableNetworkWithoutConnect(in netId : int) : boolean
        if (DBG) logDbg("enableNetworkWithoutConnect nid=" + Integer.toString(netId));
        return doBooleanCommand("ENABLE_NETWORK " + netId + " " + "no-connect");
!!!36868407.java!!!	disableNetwork(in netId : int) : boolean
        if (DBG) logDbg("disableNetwork nid=" + Integer.toString(netId));
        return doBooleanCommand("DISABLE_NETWORK " + netId);
!!!36868535.java!!!	selectNetwork(in netId : int) : boolean
        if (DBG) logDbg("selectNetwork nid=" + Integer.toString(netId));
        return doBooleanCommand("SELECT_NETWORK " + netId);
!!!36868663.java!!!	reconnect() : boolean
        if (DBG) logDbg("RECONNECT ");
        return doBooleanCommand("RECONNECT");
!!!36868791.java!!!	reassociate() : boolean
        if (DBG) logDbg("REASSOCIATE ");
        return doBooleanCommand("REASSOCIATE");
!!!36868919.java!!!	disconnect() : boolean
        if (DBG) logDbg("DISCONNECT ");
        return doBooleanCommand("DISCONNECT");
!!!36869047.java!!!	status() : String
        return status(false);
!!!36869175.java!!!	status(inout noEvents : boolean) : String
        if (noEvents) {
            return doStringCommand("STATUS-NO_EVENTS");
        } else {
            return doStringCommand("STATUS");
        }
!!!36869303.java!!!	getMacAddress() : String
        //Macaddr = XX.XX.XX.XX.XX.XX
        String ret = doStringCommand("DRIVER MACADDR");
        if (!TextUtils.isEmpty(ret)) {
            String[] tokens = ret.split(" = ");
            if (tokens.length == 2) return tokens[1];
        }
        return null;
!!!36869431.java!!!	getRawScanResults(inout range : String) : String
        return doStringCommandWithoutLogging("BSS RANGE=" + range + " MASK=0x29d87");
!!!36869559.java!!!	getScanResults() : ScanDetail
        int next_sid = 0;
        ArrayList<ScanDetail> results = new ArrayList<>();
        while(next_sid >= 0) {
            String rawResult = getRawScanResults(next_sid+"-");
            next_sid = -1;

            if (TextUtils.isEmpty(rawResult))
                break;

            String[] lines = rawResult.split("\n");


            // note that all these splits and substrings keep references to the original
            // huge string buffer while the amount we really want is generally pretty small
            // so make copies instead (one example b/11087956 wasted 400k of heap here).
            final int bssidStrLen = BSS_BSSID_STR.length();
            final int flagLen = BSS_FLAGS_STR.length();

            String bssid = "";
            int level = 0;
            int freq = 0;
            long tsf = 0;
            String flags = "";
            WifiSsid wifiSsid = null;
            String infoElementsStr = null;
            List<String> anqpLines = null;

            for (String line : lines) {
                if (line.startsWith(BSS_ID_STR)) { // Will find the last id line
                    try {
                        next_sid = Integer.parseInt(line.substring(BSS_ID_STR.length())) + 1;
                    } catch (NumberFormatException e) {
                        // Nothing to do
                    }
                } else if (line.startsWith(BSS_BSSID_STR)) {
                    bssid = new String(line.getBytes(), bssidStrLen, line.length() - bssidStrLen);
                } else if (line.startsWith(BSS_FREQ_STR)) {
                    try {
                        freq = Integer.parseInt(line.substring(BSS_FREQ_STR.length()));
                    } catch (NumberFormatException e) {
                        freq = 0;
                    }
                } else if (line.startsWith(BSS_LEVEL_STR)) {
                    try {
                        level = Integer.parseInt(line.substring(BSS_LEVEL_STR.length()));
                        /* some implementations avoid negative values by adding 256
                         * so we need to adjust for that here.
                         */
                        if (level > 0) level -= 256;
                    } catch (NumberFormatException e) {
                        level = 0;
                    }
                } else if (line.startsWith(BSS_TSF_STR)) {
                    try {
                        tsf = Long.parseLong(line.substring(BSS_TSF_STR.length()));
                    } catch (NumberFormatException e) {
                        tsf = 0;
                    }
                } else if (line.startsWith(BSS_FLAGS_STR)) {
                    flags = new String(line.getBytes(), flagLen, line.length() - flagLen);
                } else if (line.startsWith(BSS_SSID_STR)) {
                    wifiSsid = WifiSsid.createFromAsciiEncoded(
                            line.substring(BSS_SSID_STR.length()));
                } else if (line.startsWith(BSS_IE_STR)) {
                    infoElementsStr = line;
                } else if (SupplicantBridge.isAnqpAttribute(line)) {
                    if (anqpLines == null) {
                        anqpLines = new ArrayList<>();
                    }
                    anqpLines.add(line);
                } else if (line.startsWith(BSS_DELIMITER_STR) || line.startsWith(BSS_END_STR)) {
                    if (bssid != null) {
                        try {
                            if (infoElementsStr == null) {
                                throw new IllegalArgumentException("Null information element data");
                            }
                            int seperator = infoElementsStr.indexOf('=');
                            if (seperator < 0) {
                                throw new IllegalArgumentException("No element separator");
                            }

                            ScanResult.InformationElement[] infoElements =
                                        InformationElementUtil.parseInformationElements(
                                        Utils.hexToBytes(infoElementsStr.substring(seperator + 1)));

                            NetworkDetail networkDetail = new NetworkDetail(bssid,
                                    infoElements, anqpLines, freq);
                            String xssid = (wifiSsid != null) ? wifiSsid.toString() : WifiSsid.NONE;
                            if (!xssid.equals(networkDetail.getTrimmedSSID())) {
                                Log.d(TAG, String.format(
                                        "Inconsistent SSID on BSSID '%s': '%s' vs '%s': %s",
                                        bssid, xssid, networkDetail.getSSID(), infoElementsStr));
                            }

                            if (networkDetail.hasInterworking()) {
                                if (DBG) Log.d(TAG, "HSNwk: '" + networkDetail);
                            }
                            ScanDetail scan = new ScanDetail(networkDetail, wifiSsid, bssid, flags,
                                    level, freq, tsf, infoElements, anqpLines);
                            results.add(scan);
                        } catch (IllegalArgumentException iae) {
                            Log.d(TAG, "Failed to parse information elements: " + iae);
                        }
                    }
                    bssid = null;
                    level = 0;
                    freq = 0;
                    tsf = 0;
                    flags = "";
                    wifiSsid = null;
                    infoElementsStr = null;
                    anqpLines = null;
                }
            }
        }
        return results;
!!!36869687.java!!!	scanResult(inout bssid : String) : String
        return doStringCommand("BSS " + bssid);
!!!36869815.java!!!	startDriver() : boolean
        return doBooleanCommand("DRIVER START");
!!!36869943.java!!!	stopDriver() : boolean
        return doBooleanCommand("DRIVER STOP");
!!!36870071.java!!!	startFilteringMulticastV4Packets() : boolean
        return doBooleanCommand("DRIVER RXFILTER-STOP")
            && doBooleanCommand("DRIVER RXFILTER-REMOVE 2")
            && doBooleanCommand("DRIVER RXFILTER-START");
!!!36870199.java!!!	stopFilteringMulticastV4Packets() : boolean
        return doBooleanCommand("DRIVER RXFILTER-STOP")
            && doBooleanCommand("DRIVER RXFILTER-ADD 2")
            && doBooleanCommand("DRIVER RXFILTER-START");
!!!36870327.java!!!	startFilteringMulticastV6Packets() : boolean
        return doBooleanCommand("DRIVER RXFILTER-STOP")
            && doBooleanCommand("DRIVER RXFILTER-REMOVE 3")
            && doBooleanCommand("DRIVER RXFILTER-START");
!!!36870455.java!!!	stopFilteringMulticastV6Packets() : boolean
        return doBooleanCommand("DRIVER RXFILTER-STOP")
            && doBooleanCommand("DRIVER RXFILTER-ADD 3")
            && doBooleanCommand("DRIVER RXFILTER-START");
!!!36870583.java!!!	setBand(in band : int) : boolean
        String bandstr;

        if (band == WifiManager.WIFI_FREQUENCY_BAND_5GHZ)
            bandstr = "5G";
        else if (band == WifiManager.WIFI_FREQUENCY_BAND_2GHZ)
            bandstr = "2G";
        else
            bandstr = "AUTO";
        return doBooleanCommand("SET SETBAND " + bandstr);
!!!36870711.java!!!	setBluetoothCoexistenceMode(in mode : int) : boolean
        return doBooleanCommand("DRIVER BTCOEXMODE " + mode);
!!!36870839.java!!!	setBluetoothCoexistenceScanMode(inout setCoexScanMode : boolean) : boolean
        if (setCoexScanMode) {
            return doBooleanCommand("DRIVER BTCOEXSCAN-START");
        } else {
            return doBooleanCommand("DRIVER BTCOEXSCAN-STOP");
        }
!!!36870967.java!!!	enableSaveConfig() : void
        doBooleanCommand("SET update_config 1");
!!!36871095.java!!!	saveConfig() : boolean
        return doBooleanCommand("SAVE_CONFIG");
!!!36871223.java!!!	addToBlacklist(inout bssid : String) : boolean
        if (TextUtils.isEmpty(bssid)) return false;
        return doBooleanCommand("BLACKLIST " + bssid);
!!!36871351.java!!!	clearBlacklist() : boolean
        return doBooleanCommand("BLACKLIST clear");
!!!36871479.java!!!	setSuspendOptimizations(inout enabled : boolean) : boolean
        if (enabled) {
            return doBooleanCommand("DRIVER SETSUSPENDMODE 1");
        } else {
            return doBooleanCommand("DRIVER SETSUSPENDMODE 0");
        }
!!!36871607.java!!!	setCountryCode(inout countryCode : String) : boolean
        if (countryCode != null)
            return doBooleanCommand("DRIVER COUNTRY " + countryCode.toUpperCase(Locale.ROOT));
        else
            return doBooleanCommand("DRIVER COUNTRY");
!!!36871735.java!!!	setPnoScan(inout enable : boolean) : boolean
        String cmd = enable ? "SET pno 1" : "SET pno 0";
        return doBooleanCommand(cmd);
!!!36871863.java!!!	enableAutoConnect(inout enable : boolean) : void
        if (enable) {
            doBooleanCommand("STA_AUTOCONNECT 1");
        } else {
            doBooleanCommand("STA_AUTOCONNECT 0");
        }
!!!36871991.java!!!	setScanInterval(in scanInterval : int) : void
        doBooleanCommand("SCAN_INTERVAL " + scanInterval);
!!!36872119.java!!!	setHs20(inout hs20 : boolean) : void
        if (hs20) {
            doBooleanCommand("SET HS20 1");
        } else {
            doBooleanCommand("SET HS20 0");
        }
!!!36872247.java!!!	startTdls(inout macAddr : String, inout enable : boolean) : void
        if (enable) {
            synchronized (sLock) {
                doBooleanCommand("TDLS_DISCOVER " + macAddr);
                doBooleanCommand("TDLS_SETUP " + macAddr);
            }
        } else {
            doBooleanCommand("TDLS_TEARDOWN " + macAddr);
        }
!!!36872375.java!!!	signalPoll() : String
        return doStringCommandWithoutLogging("SIGNAL_POLL");
!!!36872503.java!!!	pktcntPoll() : String
        return doStringCommand("PKTCNT_POLL");
!!!36872631.java!!!	bssFlush() : void
        doBooleanCommand("BSS_FLUSH 0");
!!!36872759.java!!!	startWpsPbc(inout bssid : String) : boolean
        if (TextUtils.isEmpty(bssid)) {
            return doBooleanCommand("WPS_PBC");
        } else {
            return doBooleanCommand("WPS_PBC " + bssid);
        }
!!!36872887.java!!!	startWpsPbc(inout iface : String, inout bssid : String) : boolean
        synchronized (sLock) {
            if (TextUtils.isEmpty(bssid)) {
                return doBooleanCommandNative("IFNAME=" + iface + " WPS_PBC");
            } else {
                return doBooleanCommandNative("IFNAME=" + iface + " WPS_PBC " + bssid);
            }
        }
!!!36873015.java!!!	startWpsPinKeypad(inout pin : String) : boolean
        if (TextUtils.isEmpty(pin)) return false;
        return doBooleanCommand("WPS_PIN any " + pin);
!!!36873143.java!!!	startWpsPinKeypad(inout iface : String, inout pin : String) : boolean
        if (TextUtils.isEmpty(pin)) return false;
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " WPS_PIN any " + pin);
        }
!!!36873271.java!!!	startWpsPinDisplay(inout bssid : String) : String
        if (TextUtils.isEmpty(bssid)) {
            return doStringCommand("WPS_PIN any");
        } else {
            return doStringCommand("WPS_PIN " + bssid);
        }
!!!36873399.java!!!	startWpsPinDisplay(inout iface : String, inout bssid : String) : String
        synchronized (sLock) {
            if (TextUtils.isEmpty(bssid)) {
                return doStringCommandNative("IFNAME=" + iface + " WPS_PIN any");
            } else {
                return doStringCommandNative("IFNAME=" + iface + " WPS_PIN " + bssid);
            }
        }
!!!36873527.java!!!	setExternalSim(inout external : boolean) : boolean
        String value = external ? "1" : "0";
        Log.d(TAG, "Setting external_sim to " + value);
        return doBooleanCommand("SET external_sim " + value);
!!!36873655.java!!!	simAuthResponse(in id : int, inout type : String, inout response : String) : boolean
        // with type = GSM-AUTH, UMTS-AUTH or UMTS-AUTS
        return doBooleanCommand("CTRL-RSP-SIM-" + id + ":" + type + response);
!!!36873783.java!!!	simAuthFailedResponse(in id : int) : boolean
        // should be used with type GSM-AUTH
        return doBooleanCommand("CTRL-RSP-SIM-" + id + ":GSM-FAIL");
!!!36873911.java!!!	umtsAuthFailedResponse(in id : int) : boolean
        // should be used with type UMTS-AUTH
        return doBooleanCommand("CTRL-RSP-SIM-" + id + ":UMTS-FAIL");
!!!36874039.java!!!	simIdentityResponse(in id : int, inout response : String) : boolean
        return doBooleanCommand("CTRL-RSP-IDENTITY-" + id + ":" + response);
!!!36874167.java!!!	startWpsRegistrar(inout bssid : String, inout pin : String) : boolean
        if (TextUtils.isEmpty(bssid) || TextUtils.isEmpty(pin)) return false;
        return doBooleanCommand("WPS_REG " + bssid + " " + pin);
!!!36874295.java!!!	cancelWps() : boolean
        return doBooleanCommand("WPS_CANCEL");
!!!36874423.java!!!	setPersistentReconnect(inout enabled : boolean) : boolean
        int value = (enabled == true) ? 1 : 0;
        return doBooleanCommand("SET persistent_reconnect " + value);
!!!36874551.java!!!	setDeviceName(inout name : String) : boolean
        return doBooleanCommand("SET device_name " + name);
!!!36874679.java!!!	setDeviceType(inout type : String) : boolean
        return doBooleanCommand("SET device_type " + type);
!!!36874807.java!!!	setConfigMethods(inout cfg : String) : boolean
        return doBooleanCommand("SET config_methods " + cfg);
!!!36874935.java!!!	setManufacturer(inout value : String) : boolean
        return doBooleanCommand("SET manufacturer " + value);
!!!36875063.java!!!	setModelName(inout value : String) : boolean
        return doBooleanCommand("SET model_name " + value);
!!!36875191.java!!!	setModelNumber(inout value : String) : boolean
        return doBooleanCommand("SET model_number " + value);
!!!36875319.java!!!	setSerialNumber(inout value : String) : boolean
        return doBooleanCommand("SET serial_number " + value);
!!!36875447.java!!!	setP2pSsidPostfix(inout postfix : String) : boolean
        return doBooleanCommand("SET p2p_ssid_postfix " + postfix);
!!!36875575.java!!!	setP2pGroupIdle(inout iface : String, in time : int) : boolean
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " SET p2p_group_idle " + time);
        }
!!!36875703.java!!!	setPowerSave(inout enabled : boolean) : void
        if (enabled) {
            doBooleanCommand("SET ps 1");
        } else {
            doBooleanCommand("SET ps 0");
        }
!!!36875831.java!!!	setP2pPowerSave(inout iface : String, inout enabled : boolean) : boolean
        synchronized (sLock) {
            if (enabled) {
                return doBooleanCommandNative("IFNAME=" + iface + " P2P_SET ps 1");
            } else {
                return doBooleanCommandNative("IFNAME=" + iface + " P2P_SET ps 0");
            }
        }
!!!36875959.java!!!	setWfdEnable(inout enable : boolean) : boolean
        return doBooleanCommand("SET wifi_display " + (enable ? "1" : "0"));
!!!36876087.java!!!	setWfdDeviceInfo(inout hex : String) : boolean
        return doBooleanCommand("WFD_SUBELEM_SET 0 " + hex);
!!!36876215.java!!!	setConcurrencyPriority(inout s : String) : boolean
        return doBooleanCommand("P2P_SET conc_pref " + s);
!!!36876343.java!!!	p2pFind() : boolean
        return doBooleanCommand("P2P_FIND");
!!!36876471.java!!!	p2pFind(in timeout : int) : boolean
        if (timeout <= 0) {
            return p2pFind();
        }
        return doBooleanCommand("P2P_FIND " + timeout);
!!!36876599.java!!!	p2pStopFind() : boolean
       return doBooleanCommand("P2P_STOP_FIND");
!!!36876727.java!!!	p2pListen() : boolean
        return doBooleanCommand("P2P_LISTEN");
!!!36876855.java!!!	p2pListen(in timeout : int) : boolean
        if (timeout <= 0) {
            return p2pListen();
        }
        return doBooleanCommand("P2P_LISTEN " + timeout);
!!!36876983.java!!!	p2pExtListen(inout enable : boolean, in period : int, in interval : int) : boolean
        if (enable && interval < period) {
            return false;
        }
        return doBooleanCommand("P2P_EXT_LISTEN"
                    + (enable ? (" " + period + " " + interval) : ""));
!!!36877111.java!!!	p2pSetChannel(in lc : int, in oc : int) : boolean
        if (DBG) Log.d(mTAG, "p2pSetChannel: lc="+lc+", oc="+oc);

        synchronized (sLock) {
            if (lc >=1 && lc <= 11) {
                if (!doBooleanCommand("P2P_SET listen_channel " + lc)) {
                    return false;
                }
            } else if (lc != 0) {
                return false;
            }

            if (oc >= 1 && oc <= 165 ) {
                int freq = (oc <= 14 ? 2407 : 5000) + oc * 5;
                return doBooleanCommand("P2P_SET disallow_freq 1000-"
                        + (freq - 5) + "," + (freq + 5) + "-6000");
            } else if (oc == 0) {
                /* oc==0 disables "P2P_SET disallow_freq" (enables all freqs) */
                return doBooleanCommand("P2P_SET disallow_freq \"\"");
            }
        }
        return false;
!!!36877239.java!!!	p2pFlush() : boolean
        return doBooleanCommand("P2P_FLUSH");
!!!36877367.java!!!	p2pConnect(inout config : WifiP2pConfig, inout joinExistingGroup : boolean) : String
        if (config == null) return null;
        List<String> args = new ArrayList<String>();
        WpsInfo wps = config.wps;
        args.add(config.deviceAddress);

        switch (wps.setup) {
            case WpsInfo.PBC:
                args.add("pbc");
                break;
            case WpsInfo.DISPLAY:
                if (TextUtils.isEmpty(wps.pin)) {
                    args.add("pin");
                } else {
                    args.add(wps.pin);
                }
                args.add("display");
                break;
            case WpsInfo.KEYPAD:
                args.add(wps.pin);
                args.add("keypad");
                break;
            case WpsInfo.LABEL:
                args.add(wps.pin);
                args.add("label");
            default:
                break;
        }

        if (config.netId == WifiP2pGroup.PERSISTENT_NET_ID) {
            args.add("persistent");
        }

        if (joinExistingGroup) {
            args.add("join");
        } else {
            //TODO: This can be adapted based on device plugged in state and
            //device battery state
            int groupOwnerIntent = config.groupOwnerIntent;
            if (groupOwnerIntent < 0 || groupOwnerIntent > 15) {
                groupOwnerIntent = DEFAULT_GROUP_OWNER_INTENT;
            }
            args.add("go_intent=" + groupOwnerIntent);
        }

        String command = "P2P_CONNECT ";
        for (String s : args) command += s + " ";

        return doStringCommand(command);
!!!36877495.java!!!	p2pCancelConnect() : boolean
        return doBooleanCommand("P2P_CANCEL");
!!!36877623.java!!!	p2pProvisionDiscovery(inout config : WifiP2pConfig) : boolean
        if (config == null) return false;

        switch (config.wps.setup) {
            case WpsInfo.PBC:
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " pbc");
            case WpsInfo.DISPLAY:
                //We are doing display, so provision discovery is keypad
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " keypad");
            case WpsInfo.KEYPAD:
                //We are doing keypad, so provision discovery is display
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " display");
            default:
                break;
        }
        return false;
!!!36877751.java!!!	p2pGroupAdd(inout persistent : boolean) : boolean
        if (persistent) {
            return doBooleanCommand("P2P_GROUP_ADD persistent");
        }
        return doBooleanCommand("P2P_GROUP_ADD");
!!!36877879.java!!!	p2pGroupAdd(in netId : int) : boolean
        return doBooleanCommand("P2P_GROUP_ADD persistent=" + netId);
!!!36878007.java!!!	p2pGroupRemove(inout iface : String) : boolean
        if (TextUtils.isEmpty(iface)) return false;
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " P2P_GROUP_REMOVE " + iface);
        }
!!!36878135.java!!!	p2pReject(inout deviceAddress : String) : boolean
        return doBooleanCommand("P2P_REJECT " + deviceAddress);
!!!36878263.java!!!	p2pInvite(inout group : WifiP2pGroup, inout deviceAddress : String) : boolean
        if (TextUtils.isEmpty(deviceAddress)) return false;

        if (group == null) {
            return doBooleanCommand("P2P_INVITE peer=" + deviceAddress);
        } else {
            return doBooleanCommand("P2P_INVITE group=" + group.getInterface()
                    + " peer=" + deviceAddress + " go_dev_addr=" + group.getOwner().deviceAddress);
        }
!!!36878391.java!!!	p2pReinvoke(in netId : int, inout deviceAddress : String) : boolean
        if (TextUtils.isEmpty(deviceAddress) || netId < 0) return false;

        return doBooleanCommand("P2P_INVITE persistent=" + netId + " peer=" + deviceAddress);
!!!36878519.java!!!	p2pGetSsid(inout deviceAddress : String) : String
        return p2pGetParam(deviceAddress, "oper_ssid");
!!!36878647.java!!!	p2pGetDeviceAddress() : String
        Log.d(TAG, "p2pGetDeviceAddress");

        String status = null;

        /* Explicitly calling the API without IFNAME= prefix to take care of the devices that
        don't have p2p0 interface. Supplicant seems to be returning the correct address anyway. */

        synchronized (sLock) {
            status = doStringCommandNative("STATUS");
        }

        String result = "";
        if (status != null) {
            String[] tokens = status.split("\n");
            for (String token : tokens) {
                if (token.startsWith("p2p_device_address=")) {
                    String[] nameValue = token.split("=");
                    if (nameValue.length != 2)
                        break;
                    result = nameValue[1];
                }
            }
        }

        Log.d(TAG, "p2pGetDeviceAddress returning " + result);
        return result;
!!!36878775.java!!!	getGroupCapability(inout deviceAddress : String) : int
        int gc = 0;
        if (TextUtils.isEmpty(deviceAddress)) return gc;
        String peerInfo = p2pPeer(deviceAddress);
        if (TextUtils.isEmpty(peerInfo)) return gc;

        String[] tokens = peerInfo.split("\n");
        for (String token : tokens) {
            if (token.startsWith("group_capab=")) {
                String[] nameValue = token.split("=");
                if (nameValue.length != 2) break;
                try {
                    return Integer.decode(nameValue[1]);
                } catch(NumberFormatException e) {
                    return gc;
                }
            }
        }
        return gc;
!!!36878903.java!!!	p2pPeer(inout deviceAddress : String) : String
        return doStringCommand("P2P_PEER " + deviceAddress);
!!!36879031.java!!!	p2pGetParam(inout deviceAddress : String, inout key : String) : String
        if (deviceAddress == null) return null;

        String peerInfo = p2pPeer(deviceAddress);
        if (peerInfo == null) return null;
        String[] tokens= peerInfo.split("\n");

        key += "=";
        for (String token : tokens) {
            if (token.startsWith(key)) {
                String[] nameValue = token.split("=");
                if (nameValue.length != 2) break;
                return nameValue[1];
            }
        }
        return null;
!!!36879159.java!!!	p2pServiceAdd(inout servInfo : WifiP2pServiceInfo) : boolean
        /*
         * P2P_SERVICE_ADD bonjour <query hexdump> <RDATA hexdump>
         * P2P_SERVICE_ADD upnp <version hex> <service>
         *
         * e.g)
         * [Bonjour]
         * # IP Printing over TCP (PTR) (RDATA=MyPrinter._ipp._tcp.local.)
         * P2P_SERVICE_ADD bonjour 045f697070c00c000c01 094d795072696e746572c027
         * # IP Printing over TCP (TXT) (RDATA=txtvers=1,pdl=application/postscript)
         * P2P_SERVICE_ADD bonjour 096d797072696e746572045f697070c00c001001
         *  09747874766572733d311a70646c3d6170706c69636174696f6e2f706f7374736372797074
         *
         * [UPnP]
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012::upnp:rootdevice
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012::urn:schemas-upnp
         * -org:device:InternetGatewayDevice:1
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9322-123456789012::urn:schemas-upnp
         * -org:service:ContentDirectory:2
         */
        synchronized (sLock) {
            for (String s : servInfo.getSupplicantQueryList()) {
                String command = "P2P_SERVICE_ADD";
                command += (" " + s);
                if (!doBooleanCommand(command)) {
                    return false;
                }
            }
        }
        return true;
!!!36879287.java!!!	p2pServiceDel(inout servInfo : WifiP2pServiceInfo) : boolean
        /*
         * P2P_SERVICE_DEL bonjour <query hexdump>
         * P2P_SERVICE_DEL upnp <version hex> <service>
         */
        synchronized (sLock) {
            for (String s : servInfo.getSupplicantQueryList()) {
                String command = "P2P_SERVICE_DEL ";

                String[] data = s.split(" ");
                if (data.length < 2) {
                    return false;
                }
                if ("upnp".equals(data[0])) {
                    command += s;
                } else if ("bonjour".equals(data[0])) {
                    command += data[0];
                    command += (" " + data[1]);
                } else {
                    return false;
                }
                if (!doBooleanCommand(command)) {
                    return false;
                }
            }
        }
        return true;
!!!36879415.java!!!	p2pServiceFlush() : boolean
        return doBooleanCommand("P2P_SERVICE_FLUSH");
!!!36879543.java!!!	p2pServDiscReq(inout addr : String, inout query : String) : String
        String command = "P2P_SERV_DISC_REQ";
        command += (" " + addr);
        command += (" " + query);

        return doStringCommand(command);
!!!36879671.java!!!	p2pServDiscCancelReq(inout id : String) : boolean
        return doBooleanCommand("P2P_SERV_DISC_CANCEL_REQ " + id);
!!!36879799.java!!!	setMiracastMode(in mode : int) : void
        // Note: optional feature on the driver. It is ok for this to fail.
        doBooleanCommand("DRIVER MIRACAST " + mode);
!!!36879927.java!!!	fetchAnqp(inout bssid : String, inout subtypes : String) : boolean
        return doBooleanCommand("ANQP_GET " + bssid + " " + subtypes);
!!!36880055.java!!!	getNfcWpsConfigurationToken(in netId : int) : String
        return doStringCommand("WPS_NFC_CONFIG_TOKEN WPS " + netId);
!!!36880183.java!!!	getNfcHandoverRequest() : String
        return doStringCommand("NFC_GET_HANDOVER_REQ NDEF P2P-CR");
!!!36880311.java!!!	getNfcHandoverSelect() : String
        return doStringCommand("NFC_GET_HANDOVER_SEL NDEF P2P-CR");
!!!36880439.java!!!	initiatorReportNfcHandover(inout selectMessage : String) : boolean
        return doBooleanCommand("NFC_REPORT_HANDOVER INIT P2P 00 " + selectMessage);
!!!36880567.java!!!	responderReportNfcHandover(inout requestMessage : String) : boolean
        return doBooleanCommand("NFC_REPORT_HANDOVER RESP P2P " + requestMessage + " 00");
!!!36880823.java!!!	readKernelLog() : String
        byte[] bytes = readKernelLogNative();
        if (bytes != null) {
            CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();
            try {
                CharBuffer decoded = decoder.decode(ByteBuffer.wrap(bytes));
                return decoded.toString();
            } catch (CharacterCodingException cce) {
                return new String(bytes, StandardCharsets.ISO_8859_1);
            }
        } else {
            return "*** failed to read kernel log ***";
        }
!!!36880951.java!!!	getNewCmdIdLocked() : int
        return sCmdId++;
!!!36881591.java!!!	startHal() : boolean
        String debugLog = "startHal stack: ";
        java.lang.StackTraceElement[] elements = Thread.currentThread().getStackTrace();
        for (int i = 2; i < elements.length && i <= 7; i++ ) {
            debugLog = debugLog + " - " + elements[i].getMethodName();
        }

        sLocalLog.log(debugLog);

        synchronized (sLock) {
            if (startHalNative()) {
                int wlan0Index = queryInterfaceIndex(mInterfaceName);
                if (wlan0Index == -1) {
                    if (DBG) sLocalLog.log("Could not find interface with name: " + mInterfaceName);
                    return false;
                }
                sWlan0Index = wlan0Index;
                sThread = new MonitorThread();
                sThread.start();
                return true;
            } else {
                if (DBG) sLocalLog.log("Could not start hal");
                Log.e(TAG, "Could not start hal");
                return false;
            }
        }
!!!36881719.java!!!	stopHal() : void
        synchronized (sLock) {
            if (isHalStarted()) {
                stopHalNative();
                try {
                    sThread.join(STOP_HAL_TIMEOUT_MS);
                    Log.d(TAG, "HAL event thread stopped successfully");
                } catch (InterruptedException e) {
                    Log.e(TAG, "Could not stop HAL cleanly");
                }
                sThread = null;
                sWifiHalHandle = 0;
                sWifiIfaceHandles = null;
                sWlan0Index = -1;
            }
        }
!!!36881847.java!!!	isHalStarted() : boolean
        return (sWifiHalHandle != 0);
!!!36882103.java!!!	queryInterfaceIndex(inout interfaceName : String) : int
        synchronized (sLock) {
            if (isHalStarted()) {
                int num = getInterfacesNative();
                for (int i = 0; i < num; i++) {
                    String name = getInterfaceNameNative(i);
                    if (name.equals(interfaceName)) {
                        return i;
                    }
                }
            }
        }
        return -1;
!!!36882359.java!!!	getInterfaceName(in index : int) : String
        synchronized (sLock) {
            return getInterfaceNameNative(index);
        }
!!!36882487.java!!!	getScanCapabilities(inout capabilities : WifiNative::ScanCapabilities) : boolean
        synchronized (sLock) {
            return isHalStarted() && getScanCapabilitiesNative(sWlan0Index, capabilities);
        }
!!!36884151.java!!!	onScanStatus(in id : int, in event : int) : void
        ScanEventHandler handler = sScanEventHandler;
        if (handler != null) {
            handler.onScanStatus(event);
        }
!!!36884279.java!!!	createWifiSsid(inout rawSsid : byte) : WifiSsid
        String ssidHexString = String.valueOf(HexEncoding.encode(rawSsid));

        if (ssidHexString == null) {
            return null;
        }

        WifiSsid wifiSsid = WifiSsid.createFromHex(ssidHexString);

        return wifiSsid;
!!!36884407.java!!!	ssidConvert(inout rawSsid : byte) : String
        String ssid;

        CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();
        try {
            CharBuffer decoded = decoder.decode(ByteBuffer.wrap(rawSsid));
            ssid = decoded.toString();
        } catch (CharacterCodingException cce) {
            ssid = null;
        }

        if (ssid == null) {
            ssid = new String(rawSsid, StandardCharsets.ISO_8859_1);
        }

        return ssid;
!!!36884535.java!!!	setSsid(inout rawSsid : byte, inout result : ScanResult) : boolean
        if (rawSsid == null || rawSsid.length == 0 || result == null) {
            return false;
        }

        result.SSID = ssidConvert(rawSsid);
        result.wifiSsid = createWifiSsid(rawSsid);
        return true;
!!!36884663.java!!!	populateScanResult(inout result : ScanResult, in beaconCap : int, inout dbg : String) : void
        if (dbg == null) dbg = "";

        InformationElementUtil.HtOperation htOperation = new InformationElementUtil.HtOperation();
        InformationElementUtil.VhtOperation vhtOperation =
                new InformationElementUtil.VhtOperation();
        InformationElementUtil.ExtendedCapabilities extendedCaps =
                new InformationElementUtil.ExtendedCapabilities();

        ScanResult.InformationElement elements[] =
                InformationElementUtil.parseInformationElements(result.bytes);
        for (ScanResult.InformationElement ie : elements) {
            if(ie.id == ScanResult.InformationElement.EID_HT_OPERATION) {
                htOperation.from(ie);
            } else if(ie.id == ScanResult.InformationElement.EID_VHT_OPERATION) {
                vhtOperation.from(ie);
            } else if (ie.id == ScanResult.InformationElement.EID_EXTENDED_CAPS) {
                extendedCaps.from(ie);
            }
        }

        if (extendedCaps.is80211McRTTResponder) {
            result.setFlag(ScanResult.FLAG_80211mc_RESPONDER);
        } else {
            result.clearFlag(ScanResult.FLAG_80211mc_RESPONDER);
        }

        //handle RTT related information
        if (vhtOperation.isValid()) {
            result.channelWidth = vhtOperation.getChannelWidth();
            result.centerFreq0 = vhtOperation.getCenterFreq0();
            result.centerFreq1 = vhtOperation.getCenterFreq1();
        } else {
            result.channelWidth = htOperation.getChannelWidth();
            result.centerFreq0 = htOperation.getCenterFreq0(result.frequency);
            result.centerFreq1  = 0;
        }

        // build capabilities string
        BitSet beaconCapBits = new BitSet(16);
        for (int i = 0; i < 16; i++) {
            if ((beaconCap & (1 << i)) != 0) {
                beaconCapBits.set(i);
            }
        }
        result.capabilities = InformationElementUtil.Capabilities.buildCapabilities(elements,
                                               beaconCapBits);

        if(DBG) {
            Log.d(TAG, dbg + "SSID: " + result.SSID + " ChannelWidth is: " + result.channelWidth
                    + " PrimaryFreq: " + result.frequency + " mCenterfreq0: " + result.centerFreq0
                    + " mCenterfreq1: " + result.centerFreq1 + (extendedCaps.is80211McRTTResponder
                    ? "Support RTT reponder: " : "Do not support RTT responder")
                    + " Capabilities: " + result.capabilities);
        }

        result.informationElements = elements;
!!!36884791.java!!!	onFullScanResult(in id : int, inout result : ScanResult, in bucketsScanned : int, in beaconCap : int) : void
        if (DBG) Log.i(TAG, "Got a full scan results event, ssid = " + result.SSID);

        ScanEventHandler handler = sScanEventHandler;
        if (handler != null) {
            populateScanResult(result, beaconCap, " onFullScanResult ");
            handler.onFullScanResult(result, bucketsScanned);
        }
!!!36884919.java!!!	startScan(inout settings : WifiNative::ScanSettings, inout eventHandler : WifiNative::ScanEventHandler) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sScanCmdId != 0) {
                    stopScan();
                } else if (sScanSettings != null || sScanEventHandler != null) {
                /* current scan is paused; no need to stop it */
                }

                sScanCmdId = getNewCmdIdLocked();

                sScanSettings = settings;
                sScanEventHandler = eventHandler;

                if (startScanNative(sWlan0Index, sScanCmdId, settings) == false) {
                    sScanEventHandler = null;
                    sScanSettings = null;
                    sScanCmdId = 0;
                    return false;
                }

                return true;
            } else {
                return false;
            }
        }
!!!36885047.java!!!	stopScan() : void
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sScanCmdId != 0) {
                    stopScanNative(sWlan0Index, sScanCmdId);
                }
                sScanSettings = null;
                sScanEventHandler = null;
                sScanCmdId = 0;
            }
        }
!!!36885175.java!!!	pauseScan() : void
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sScanCmdId != 0 && sScanSettings != null && sScanEventHandler != null) {
                    Log.d(TAG, "Pausing scan");
                    WifiScanner.ScanData scanData[] = getScanResultsNative(sWlan0Index, true);
                    stopScanNative(sWlan0Index, sScanCmdId);
                    sScanCmdId = 0;
                    sScanEventHandler.onScanPaused(scanData);
                }
            }
        }
!!!36885303.java!!!	restartScan() : void
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sScanCmdId == 0 && sScanSettings != null && sScanEventHandler != null) {
                    Log.d(TAG, "Restarting scan");
                    ScanEventHandler handler = sScanEventHandler;
                    ScanSettings settings = sScanSettings;
                    if (startScan(sScanSettings, sScanEventHandler)) {
                        sScanEventHandler.onScanRestarted();
                    } else {
                    /* we are still paused; don't change state */
                        sScanEventHandler = handler;
                        sScanSettings = settings;
                    }
                }
            }
        }
!!!36885431.java!!!	getScanResults(inout flush : boolean) : WifiScanner::ScanData
        synchronized (sLock) {
            WifiScanner.ScanData[] sd = null;
            if (isHalStarted()) {
                sd = getScanResultsNative(sWlan0Index, flush);
            }

            if (sd != null) {
                return sd;
            } else {
                return new WifiScanner.ScanData[0];
            }
        }
!!!36886071.java!!!	setHotlist(inout settings : WifiScanner::HotlistSettings, inout eventHandler : WifiNative::HotlistEventHandler) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sHotlistCmdId != 0) {
                    return false;
                } else {
                    sHotlistCmdId = getNewCmdIdLocked();
                }

                sHotlistEventHandler = eventHandler;
                if (setHotlistNative(sWlan0Index, sHotlistCmdId, settings) == false) {
                    sHotlistEventHandler = null;
                    return false;
                }

                return true;
            } else {
                return false;
            }
        }
!!!36886199.java!!!	resetHotlist() : void
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sHotlistCmdId != 0) {
                    resetHotlistNative(sWlan0Index, sHotlistCmdId);
                    sHotlistCmdId = 0;
                    sHotlistEventHandler = null;
                }
            }
        }
!!!36886327.java!!!	onHotlistApFound(in id : int, inout results : ScanResult) : void
        HotlistEventHandler handler = sHotlistEventHandler;
        if (handler != null) {
            handler.onHotlistApFound(results);
        } else {
            /* this can happen because of race conditions */
            Log.d(TAG, "Ignoring hotlist AP found event");
        }
!!!36886455.java!!!	onHotlistApLost(in id : int, inout results : ScanResult) : void
        HotlistEventHandler handler = sHotlistEventHandler;
        if (handler != null) {
            handler.onHotlistApLost(results);
        } else {
            /* this can happen because of race conditions */
            Log.d(TAG, "Ignoring hotlist AP lost event");
        }
!!!36886967.java!!!	trackSignificantWifiChange(inout settings : WifiScanner::WifiChangeSettings, inout handler : WifiNative::SignificantWifiChangeEventHandler) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sSignificantWifiChangeCmdId != 0) {
                    return false;
                } else {
                    sSignificantWifiChangeCmdId = getNewCmdIdLocked();
                }

                sSignificantWifiChangeHandler = handler;
                if (trackSignificantWifiChangeNative(sWlan0Index, sSignificantWifiChangeCmdId,
                        settings) == false) {
                    sSignificantWifiChangeHandler = null;
                    return false;
                }

                return true;
            } else {
                return false;
            }

        }
!!!36887095.java!!!	untrackSignificantWifiChange() : void
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sSignificantWifiChangeCmdId != 0) {
                    untrackSignificantWifiChangeNative(sWlan0Index, sSignificantWifiChangeCmdId);
                    sSignificantWifiChangeCmdId = 0;
                    sSignificantWifiChangeHandler = null;
                }
            }
        }
!!!36887223.java!!!	onSignificantWifiChange(in id : int, inout results : ScanResult) : void
        SignificantWifiChangeEventHandler handler = sSignificantWifiChangeHandler;
        if (handler != null) {
            handler.onChangesFound(results);
        } else {
            /* this can happen because of race conditions */
            Log.d(TAG, "Ignoring significant wifi change");
        }
!!!36887351.java!!!	getWifiLinkLayerStats(inout iface : String) : WifiLinkLayerStats
        // TODO: use correct iface name to Index translation
        if (iface == null) return null;
        synchronized (sLock) {
            if (isHalStarted()) {
                return getWifiLinkLayerStatsNative(sWlan0Index);
            } else {
                return null;
            }
        }
!!!36887479.java!!!	setWifiLinkLayerStats(inout iface : String, in enable : int) : void
        if (iface == null) return;
        synchronized (sLock) {
            if (isHalStarted()) {
                setWifiLinkLayerStatsNative(sWlan0Index, enable);
            }
        }
!!!36887735.java!!!	getSupportedFeatureSet() : int
        synchronized (sLock) {
            if (isHalStarted()) {
                return getSupportedFeatureSetNative(sWlan0Index);
            } else {
                Log.d(TAG, "Failing getSupportedFeatureset because HAL isn't started");
                return 0;
            }
        }
!!!36887991.java!!!	onRttResults(in id : int, inout results : RttManager::RttResult) : void
        RttEventHandler handler = sRttEventHandler;
        if (handler != null && id == sRttCmdId) {
            Log.d(TAG, "Received " + results.length + " rtt results");
            handler.onRttResults(results);
            sRttCmdId = 0;
        } else {
            Log.d(TAG, "RTT Received event for unknown cmd = " + id +
                    ", current id = " + sRttCmdId);
        }
!!!36888375.java!!!	requestRtt(inout params : RttManager::RttParams, inout handler : WifiNative::RttEventHandler) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sRttCmdId != 0) {
                    Log.v("TAG", "Last one is still under measurement!");
                    return false;
                } else {
                    sRttCmdId = getNewCmdIdLocked();
                }
                sRttEventHandler = handler;
                Log.v(TAG, "native issue RTT request");
                return requestRangeNative(sWlan0Index, sRttCmdId, params);
            } else {
                return false;
            }
        }
!!!36888503.java!!!	cancelRtt(inout params : RttManager::RttParams) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sRttCmdId == 0) {
                    return false;
                }

                sRttCmdId = 0;

                if (cancelRangeRequestNative(sWlan0Index, sRttCmdId, params)) {
                    sRttEventHandler = null;
                    Log.v(TAG, "RTT cancel Request Successfully");
                    return true;
                } else {
                    Log.e(TAG, "RTT cancel Request failed");
                    return false;
                }
            } else {
                return false;
            }
        }
!!!36888759.java!!!	enableRttResponder(in timeoutSeconds : int) : RttManager::ResponderConfig
        synchronized (sLock) {
            if (!isHalStarted()) return null;
            if (sRttResponderCmdId != 0) {
                if (DBG) Log.e(mTAG, "responder mode already enabled - this shouldn't happen");
                return null;
            }
            int id = getNewCmdIdLocked();
            ResponderConfig config = enableRttResponderNative(
                    sWlan0Index, id, timeoutSeconds, null);
            if (config != null) sRttResponderCmdId = id;
            if (DBG) Log.d(TAG, "enabling rtt " + (config != null));
            return config;
        }
!!!36889015.java!!!	disableRttResponder() : boolean
        synchronized (sLock) {
            if (!isHalStarted()) return false;
            if (sRttResponderCmdId == 0) {
                Log.e(mTAG, "responder role not enabled yet");
                return true;
            }
            sRttResponderCmdId = 0;
            return disableRttResponderNative(sWlan0Index, sRttResponderCmdId);
        }
!!!36889271.java!!!	setScanningMacOui(inout oui : byte) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                return setScanningMacOuiNative(sWlan0Index, oui);
            } else {
                return false;
            }
        }
!!!36889527.java!!!	getChannelsForBand(in band : int) : int
        synchronized (sLock) {
            if (isHalStarted()) {
                return getChannelsForBandNative(sWlan0Index, band);
            } else {
                return null;
            }
        }
!!!36889783.java!!!	isGetChannelsForBandSupported() : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                return isGetChannelsForBandSupportedNative();
            } else {
                return false;
            }
        }
!!!36890039.java!!!	setDfsFlag(inout dfsOn : boolean) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                return setDfsFlagNative(sWlan0Index, dfsOn);
            } else {
                return false;
            }
        }
!!!36890295.java!!!	setInterfaceUp(inout up : boolean) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                return setInterfaceUpNative(up);
            } else {
                return false;
            }
        }
!!!36890551.java!!!	getRttCapabilities() : RttManager::RttCapabilities
        synchronized (sLock) {
            if (isHalStarted()) {
                return getRttCapabilitiesNative(sWlan0Index);
            } else {
                return null;
            }
        }
!!!36890807.java!!!	getApfCapabilities() : ApfCapabilities
        synchronized (sLock) {
            if (isHalStarted()) {
                return getApfCapabilitiesNative(sWlan0Index);
            } else {
                return null;
            }
        }
!!!36891063.java!!!	installPacketFilter(inout filter : byte) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                return installPacketFilterNative(sWlan0Index, filter);
            } else {
                return false;
            }
        }
!!!36891319.java!!!	setCountryCodeHal(inout CountryCode : String) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                return setCountryCodeHalNative(sWlan0Index, CountryCode);
            } else {
                return false;
            }
        }
!!!36891703.java!!!	enableDisableTdls(inout enable : boolean, inout macAdd : String, inout tdlsCallBack : WifiNative::TdlsEventHandler) : boolean
        synchronized (sLock) {
            sTdlsEventHandler = tdlsCallBack;
            return enableDisableTdlsNative(sWlan0Index, enable, macAdd);
        }
!!!36891959.java!!!	getTdlsStatus(inout macAdd : String) : WifiNative::TdlsStatus
        synchronized (sLock) {
            if (isHalStarted()) {
                return getTdlsStatusNative(sWlan0Index, macAdd);
            } else {
                return null;
            }
        }
!!!36892215.java!!!	getTdlsCapabilities() : WifiNative::TdlsCapabilities
        synchronized (sLock) {
            if (isHalStarted()) {
                return getTdlsCapabilitiesNative(sWlan0Index);
            } else {
                return null;
            }
        }
!!!36892343.java!!!	onTdlsStatus(inout macAddr : String, in status : int, in reason : int) : boolean
        TdlsEventHandler handler = sTdlsEventHandler;
        if (handler == null) {
            return false;
        } else {
            handler.onTdlsStatus(macAddr, status, reason);
            return true;
        }
!!!36892727.java!!!	onRingBufferData(inout status : WifiNative::RingBufferStatus, inout buffer : byte) : void
        WifiLoggerEventHandler handler = sWifiLoggerEventHandler;
        if (handler != null)
            handler.onRingBufferData(status, buffer);
!!!36892855.java!!!	onWifiAlert(inout buffer : byte, in errorCode : int) : void
        WifiLoggerEventHandler handler = sWifiLoggerEventHandler;
        if (handler != null)
            handler.onWifiAlert(errorCode, buffer);
!!!36893111.java!!!	setLoggingEventHandler(inout handler : WifiNative::WifiLoggerEventHandler) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                int oldId =  sLogCmdId;
                sLogCmdId = getNewCmdIdLocked();
                if (!setLoggingEventHandlerNative(sWlan0Index, sLogCmdId)) {
                    sLogCmdId = oldId;
                    return false;
                }
                sWifiLoggerEventHandler = handler;
                return true;
            } else {
                return false;
            }
        }
!!!36893367.java!!!	startLoggingRingBuffer(in verboseLevel : int, in flags : int, in maxInterval : int, in minDataSize : int, inout ringName : String) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                return startLoggingRingBufferNative(sWlan0Index, verboseLevel, flags, maxInterval,
                        minDataSize, ringName);
            } else {
                return false;
            }
        }
!!!36893623.java!!!	getSupportedLoggerFeatureSet() : int
        synchronized (sLock) {
            if (isHalStarted()) {
                return getSupportedLoggerFeatureSetNative(sWlan0Index);
            } else {
                return 0;
            }
        }
!!!36893879.java!!!	resetLogHandler() : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                if (sLogCmdId == -1) {
                    Log.e(TAG,"Can not reset handler Before set any handler");
                    return false;
                }
                sWifiLoggerEventHandler = null;
                if (resetLogHandlerNative(sWlan0Index, sLogCmdId)) {
                    sLogCmdId = -1;
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
!!!36894135.java!!!	getDriverVersion() : String
        synchronized (sLock) {
            if (isHalStarted()) {
                return getDriverVersionNative(sWlan0Index);
            } else {
                return "";
            }
        }
!!!36894391.java!!!	getFirmwareVersion() : String
        synchronized (sLock) {
            if (isHalStarted()) {
                return getFirmwareVersionNative(sWlan0Index);
            } else {
                return "";
            }
        }
!!!36894775.java!!!	getRingBufferStatus() : WifiNative::RingBufferStatus
        synchronized (sLock) {
            if (isHalStarted()) {
                return getRingBufferStatusNative(sWlan0Index);
            } else {
                return null;
            }
        }
!!!36895031.java!!!	getRingBufferData(inout ringName : String) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                return getRingBufferDataNative(sWlan0Index, ringName);
            } else {
                return false;
            }
        }
!!!36895159.java!!!	onWifiFwMemoryAvailable(inout buffer : byte) : void
        mFwMemoryDump = buffer;
        if (DBG) {
            Log.d(TAG, "onWifiFwMemoryAvailable is called and buffer length is: " +
                    (buffer == null ? 0 :  buffer.length));
        }
!!!36895415.java!!!	getFwMemoryDump() : byte
        synchronized (sLock) {
            if (isHalStarted()) {
                if(getFwMemoryDumpNative(sWlan0Index)) {
                    byte[] fwMemoryDump = mFwMemoryDump;
                    mFwMemoryDump = null;
                    return fwMemoryDump;
                } else {
                    return null;
                }
            }
            return null;
        }
!!!36895671.java!!!	getDriverStateDump() : byte
        synchronized (sLock) {
            if (isHalStarted()) {
                return getDriverStateDumpNative(sWlan0Index);
            } else {
                return null;
            }
        }
!!!36897719.java!!!	startPktFateMonitoring() : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                return startPktFateMonitoringNative(sWlan0Index) == WIFI_SUCCESS;
            } else {
                return false;
            }
        }
!!!36897975.java!!!	getTxPktFates(inout reportBufs : WifiNative::TxFateReport) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                int res = getTxPktFatesNative(sWlan0Index, reportBufs);
                if (res != WIFI_SUCCESS) {
                    Log.e(TAG, "getTxPktFatesNative returned " + res);
                    return false;
                } else {
                    return true;
                }
            } else {
                return false;
            }
        }
!!!36898231.java!!!	getRxPktFates(inout reportBufs : WifiNative::RxFateReport) : boolean
        synchronized (sLock) {
            if (isHalStarted()) {
                int res = getRxPktFatesNative(sWlan0Index, reportBufs);
                if (res != WIFI_SUCCESS) {
                    Log.e(TAG, "getRxPktFatesNative returned " + res);
                    return false;
                } else {
                    return true;
                }
            } else {
                return false;
            }
        }
!!!36898487.java!!!	setPnoList(inout settings : WifiNative::PnoSettings, inout eventHandler : WifiNative::PnoEventHandler) : boolean
        Log.e(TAG, "setPnoList cmd " + sPnoCmdId);

        synchronized (sLock) {
            if (isHalStarted()) {
                sPnoCmdId = getNewCmdIdLocked();
                sPnoEventHandler = eventHandler;
                if (setPnoListNative(sWlan0Index, sPnoCmdId, settings)) {
                    return true;
                }
            }
            sPnoEventHandler = null;
            return false;
        }
!!!36898615.java!!!	setPnoList(inout list : WifiNative::PnoNetwork, inout eventHandler : WifiNative::PnoEventHandler) : boolean
        PnoSettings settings = new PnoSettings();
        settings.networkList = list;
        return setPnoList(settings, eventHandler);
!!!36898871.java!!!	resetPnoList() : boolean
        Log.e(TAG, "resetPnoList cmd " + sPnoCmdId);

        synchronized (sLock) {
            if (isHalStarted()) {
                sPnoCmdId = getNewCmdIdLocked();
                sPnoEventHandler = null;
                if (resetPnoListNative(sWlan0Index, sPnoCmdId)) {
                    return true;
                }
            }
            return false;
        }
!!!36898999.java!!!	onPnoNetworkFound(in id : int, inout results : ScanResult, inout beaconCaps : int) : void
        if (results == null) {
            Log.e(TAG, "onPnoNetworkFound null results");
            return;

        }
        Log.d(TAG, "WifiNative.onPnoNetworkFound result " + results.length);

        PnoEventHandler handler = sPnoEventHandler;
        if (sPnoCmdId != 0 && handler != null) {
            for (int i=0; i<results.length; i++) {
                Log.e(TAG, "onPnoNetworkFound SSID " + results[i].SSID
                        + " " + results[i].level + " " + results[i].frequency);

                populateScanResult(results[i], beaconCaps[i], "onPnoNetworkFound ");
                results[i].wifiSsid = WifiSsid.createFromAsciiEncoded(results[i].SSID);
            }

            handler.onPnoNetworkFound(results);
        } else {
            /* this can happen because of race conditions */
            Log.d(TAG, "Ignoring Pno Network found event");
        }
!!!36899255.java!!!	setBssidBlacklist(inout list : String) : boolean
        int size = 0;
        if (list != null) {
            size = list.length;
        }
        Log.e(TAG, "setBssidBlacklist cmd " + sPnoCmdId + " size " + size);

        synchronized (sLock) {
            if (isHalStarted()) {
                sPnoCmdId = getNewCmdIdLocked();
                return setBssidBlacklistNative(sWlan0Index, sPnoCmdId, list);
            } else {
                return false;
            }
        }
!!!36899511.java!!!	startSendingOffloadedPacket(in slot : int, inout keepAlivePacket : KeepalivePacketData, in period : int) : int
        Log.d(TAG, "startSendingOffloadedPacket slot=" + slot + " period=" + period);

        String[] macAddrStr = getMacAddress().split(":");
        byte[] srcMac = new byte[6];
        for(int i = 0; i < 6; i++) {
            Integer hexVal = Integer.parseInt(macAddrStr[i], 16);
            srcMac[i] = hexVal.byteValue();
        }
        synchronized (sLock) {
            if (isHalStarted()) {
                return startSendingOffloadedPacketNative(sWlan0Index, slot, srcMac,
                        keepAlivePacket.dstMac, keepAlivePacket.data, period);
            } else {
                return -1;
            }
        }
!!!36899767.java!!!	stopSendingOffloadedPacket(in slot : int) : int
        Log.d(TAG, "stopSendingOffloadedPacket " + slot);
        synchronized (sLock) {
            if (isHalStarted()) {
                return stopSendingOffloadedPacketNative(sWlan0Index, slot);
            } else {
                return -1;
            }
        }
!!!36900023.java!!!	onRssiThresholdBreached(in id : int, in curRssi : byte) : void
        WifiRssiEventHandler handler = sWifiRssiEventHandler;
        if (handler != null) {
            handler.onRssiThresholdBreached(curRssi);
        }
!!!36900279.java!!!	startRssiMonitoring(in maxRssi : byte, in minRssi : byte, inout rssiEventHandler : WifiNative::WifiRssiEventHandler) : int
        Log.d(TAG, "startRssiMonitoring: maxRssi=" + maxRssi + " minRssi=" + minRssi);
        synchronized (sLock) {
            sWifiRssiEventHandler = rssiEventHandler;
            if (isHalStarted()) {
                if (sRssiMonitorCmdId != 0) {
                    stopRssiMonitoring();
                }

                sRssiMonitorCmdId = getNewCmdIdLocked();
                Log.d(TAG, "sRssiMonitorCmdId = " + sRssiMonitorCmdId);
                int ret = startRssiMonitoringNative(sWlan0Index, sRssiMonitorCmdId,
                        maxRssi, minRssi);
                if (ret != 0) { // if not success
                    sRssiMonitorCmdId = 0;
                }
                return ret;
            } else {
                return -1;
            }
        }
!!!36900535.java!!!	stopRssiMonitoring() : int
        Log.d(TAG, "stopRssiMonitoring, cmdId " + sRssiMonitorCmdId);
        synchronized (sLock) {
            if (isHalStarted()) {
                int ret = 0;
                if (sRssiMonitorCmdId != 0) {
                    ret = stopRssiMonitoringNative(sWlan0Index, sRssiMonitorCmdId);
                }
                sRssiMonitorCmdId = 0;
                return ret;
            } else {
                return -1;
            }
        }
!!!36900791.java!!!	getWlanWakeReasonCount() : WifiWakeReasonAndCounts
        Log.d(TAG, "getWlanWakeReasonCount " + sWlan0Index);
        synchronized (sLock) {
            if (isHalStarted()) {
                return getWlanWakeReasonCountNative(sWlan0Index);
            } else {
                return null;
            }
        }
!!!36901047.java!!!	configureNeighborDiscoveryOffload(inout enabled : boolean) : boolean
        final String logMsg =  "configureNeighborDiscoveryOffload(" + enabled + ")";
        Log.d(mTAG, logMsg);
        synchronized (sLock) {
            if (isHalStarted()) {
                final int ret = configureNeighborDiscoveryOffload(sWlan0Index, enabled);
                if (ret != 0) {
                    Log.d(mTAG, logMsg + " returned: " + ret);
                }
                return (ret == 0);
            }
        }
        return false;
