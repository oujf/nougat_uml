class WifiConfigManager
!!!36802871.java!!!	WifiConfigManager(inout context : Context, inout wifiNative : WifiNative, inout facade : FrameworkFacade, inout clock : Clock, inout userManager : UserManager, inout keyStore : KeyStore)
        mContext = context;
        mFacade = facade;
        mClock = clock;
        mKeyStore = keyStore;
        mUserManager = userManager;

        if (mShowNetworks) {
            mLocalLog = wifiNative.getLocalLog();
        } else {
            mLocalLog = null;
        }

        mOnlyLinkSameCredentialConfigurations = mContext.getResources().getBoolean(
                R.bool.config_wifi_only_link_same_credential_configurations);
        mMaxNumActiveChannelsForPartialScans.set(mContext.getResources().getInteger(
                R.integer.config_wifi_framework_associated_partial_scan_max_num_active_channels));
        mEnableLinkDebouncing = mContext.getResources().getBoolean(
                R.bool.config_wifi_enable_disconnection_debounce);
        mBandAward5Ghz.set(mContext.getResources().getInteger(
                R.integer.config_wifi_framework_5GHz_preference_boost_factor));
        mThresholdMinimumRssi5.set(mContext.getResources().getInteger(
                R.integer.config_wifi_framework_wifi_score_bad_rssi_threshold_5GHz));
        mThresholdQualifiedRssi5.set(mContext.getResources().getInteger(
                R.integer.config_wifi_framework_wifi_score_low_rssi_threshold_5GHz));
        mThresholdSaturatedRssi5.set(mContext.getResources().getInteger(
                R.integer.config_wifi_framework_wifi_score_good_rssi_threshold_5GHz));
        mThresholdMinimumRssi24.set(mContext.getResources().getInteger(
                R.integer.config_wifi_framework_wifi_score_bad_rssi_threshold_24GHz));
        mThresholdQualifiedRssi24.set(mContext.getResources().getInteger(
                R.integer.config_wifi_framework_wifi_score_low_rssi_threshold_24GHz));
        mThresholdSaturatedRssi24.set(mContext.getResources().getInteger(
                R.integer.config_wifi_framework_wifi_score_good_rssi_threshold_24GHz));
        mEnableWifiCellularHandoverUserTriggeredAdjustment = mContext.getResources().getBoolean(
                R.bool.config_wifi_framework_cellular_handover_enable_user_triggered_adjustment);
        mBadLinkSpeed24 = mContext.getResources().getInteger(
                R.integer.config_wifi_framework_wifi_score_bad_link_speed_24);
        mBadLinkSpeed5 = mContext.getResources().getInteger(
                R.integer.config_wifi_framework_wifi_score_bad_link_speed_5);
        mGoodLinkSpeed24 = mContext.getResources().getInteger(
                R.integer.config_wifi_framework_wifi_score_good_link_speed_24);
        mGoodLinkSpeed5 = mContext.getResources().getInteger(
                R.integer.config_wifi_framework_wifi_score_good_link_speed_5);
        mEnableAutoJoinWhenAssociated.set(mContext.getResources().getBoolean(
                R.bool.config_wifi_framework_enable_associated_network_selection));
        mCurrentNetworkBoost.set(mContext.getResources().getInteger(
                R.integer.config_wifi_framework_current_network_boost));
        mNetworkSwitchingBlackListPeriodMs = mContext.getResources().getInteger(
                R.integer.config_wifi_network_switching_blacklist_time);

        boolean hs2on = mContext.getResources().getBoolean(R.bool.config_wifi_hotspot2_enabled);
        Log.d(Utils.hs2LogTag(getClass()), "Passpoint is " + (hs2on ? "enabled" : "disabled"));

        mConfiguredNetworks = new ConfigurationMap(userManager);
        mMOManager = new PasspointManagementObjectManager(new File(PPS_FILE), hs2on);
        mEnableOsuQueries = true;
        mAnqpCache = new AnqpCache(mClock);
        mSupplicantBridgeCallbacks = new SupplicantBridgeCallbacks();
        mSupplicantBridge = new SupplicantBridge(wifiNative, mSupplicantBridgeCallbacks);
        mScanDetailCaches = new ConcurrentHashMap<>(16, 0.75f, 2);
        mSIMAccessor = new SIMAccessor(mContext);
        mWriter = new DelayedDiskWrite();
        mIpconfigStore = new IpConfigStore(mWriter);
        mWifiNetworkHistory = new WifiNetworkHistory(context, mLocalLog, mWriter);
        mWifiConfigStore =
                new WifiConfigStore(wifiNative, mKeyStore, mLocalLog, mShowNetworks, true);
!!!36802999.java!!!	trimANQPCache(inout all : boolean) : void
        mAnqpCache.clear(all, DBG);
!!!36803127.java!!!	enableVerboseLogging(in verbose : int) : void
        mEnableVerboseLogging.set(verbose);
        if (verbose > 0) {
            sVDBG = true;
            mShowNetworks = true;
        } else {
            sVDBG = false;
        }
        if (verbose > 1) {
            sVVDBG = true;
        } else {
            sVVDBG = false;
        }
!!!36803255.java!!!	loadAndEnableAllNetworks() : void
        if (DBG) log("Loading config and enabling all networks ");
        loadConfiguredNetworks();
        enableAllNetworks();
!!!36803383.java!!!	getConfiguredNetworksSize() : int
        return mConfiguredNetworks.sizeForCurrentUser();
!!!36803511.java!!!	getSavedNetworks(inout pskMap : Map<String, String>) : WifiConfiguration
        List<WifiConfiguration> networks = new ArrayList<>();
        for (WifiConfiguration config : mConfiguredNetworks.valuesForCurrentUser()) {
            WifiConfiguration newConfig = new WifiConfiguration(config);
            // When updating this condition, update WifiStateMachine's CONNECT_NETWORK handler to
            // correctly handle updating existing configs that are filtered out here.
            if (config.ephemeral) {
                // Do not enumerate and return this configuration to anyone (e.g. WiFi Picker);
                // treat it as unknown instead. This configuration can still be retrieved
                // directly by its key or networkId.
                continue;
            }

            if (pskMap != null && config.allowedKeyManagement != null
                    && config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)
                    && pskMap.containsKey(config.configKey(true))) {
                newConfig.preSharedKey = pskMap.get(config.configKey(true));
            }
            networks.add(newConfig);
        }
        return networks;
!!!36803639.java!!!	getAllConfiguredNetworks() : WifiConfiguration
        List<WifiConfiguration> networks = new ArrayList<>();
        for (WifiConfiguration config : mConfiguredNetworks.valuesForCurrentUser()) {
            WifiConfiguration newConfig = new WifiConfiguration(config);
            networks.add(newConfig);
        }
        return networks;
!!!36803767.java!!!	getSavedNetworks() : WifiConfiguration
        return getSavedNetworks(null);
!!!36803895.java!!!	getPrivilegedSavedNetworks() : WifiConfiguration
        Map<String, String> pskMap = getCredentialsByConfigKeyMap();
        List<WifiConfiguration> configurations = getSavedNetworks(pskMap);
        for (WifiConfiguration configuration : configurations) {
            try {
                configuration
                        .setPasspointManagementObjectTree(mMOManager.getMOTree(configuration.FQDN));
            } catch (IOException ioe) {
                Log.w(TAG, "Failed to parse MO from " + configuration.FQDN + ": " + ioe);
            }
        }
        return configurations;
!!!36804023.java!!!	getHiddenConfiguredNetworkIds() : Set<Integer>
        return mConfiguredNetworks.getHiddenNetworkIdsForCurrentUser();
!!!36804151.java!!!	getMatchingConfig(inout scanResult : ScanResult) : WifiConfiguration
        if (scanResult == null) {
            return null;
        }
        for (Map.Entry entry : mScanDetailCaches.entrySet()) {
            Integer netId = (Integer) entry.getKey();
            ScanDetailCache cache = (ScanDetailCache) entry.getValue();
            WifiConfiguration config = getWifiConfiguration(netId);
            if (config == null) {
                continue;
            }
            if (cache.get(scanResult.BSSID) != null) {
                return config;
            }
        }

        return null;
!!!36804279.java!!!	getCredentialsByConfigKeyMap() : String
        return readNetworkVariablesFromSupplicantFile("psk");
!!!36804407.java!!!	getRecentSavedNetworks(in scanResultAgeMs : int, inout copy : boolean) : WifiConfiguration
        List<WifiConfiguration> networks = new ArrayList<WifiConfiguration>();

        for (WifiConfiguration config : mConfiguredNetworks.valuesForCurrentUser()) {
            if (config.ephemeral) {
                // Do not enumerate and return this configuration to anyone (e.g. WiFi Picker);
                // treat it as unknown instead. This configuration can still be retrieved
                // directly by its key or networkId.
                continue;
            }

            // Calculate the RSSI for scan results that are more recent than scanResultAgeMs.
            ScanDetailCache cache = getScanDetailCache(config);
            if (cache == null) {
                continue;
            }
            config.setVisibility(cache.getVisibility(scanResultAgeMs));
            if (config.visibility == null) {
                continue;
            }
            if (config.visibility.rssi5 == WifiConfiguration.INVALID_RSSI
                    && config.visibility.rssi24 == WifiConfiguration.INVALID_RSSI) {
                continue;
            }
            if (copy) {
                networks.add(new WifiConfiguration(config));
            } else {
                networks.add(config);
            }
        }
        return networks;
!!!36804535.java!!!	updateConfiguration(inout info : WifiInfo) : void
        WifiConfiguration config = getWifiConfiguration(info.getNetworkId());
        if (config != null && getScanDetailCache(config) != null) {
            ScanDetail scanDetail = getScanDetailCache(config).getScanDetail(info.getBSSID());
            if (scanDetail != null) {
                ScanResult result = scanDetail.getScanResult();
                long previousSeen = result.seen;
                int previousRssi = result.level;

                // Update the scan result
                scanDetail.setSeen();
                result.level = info.getRssi();

                // Average the RSSI value
                result.averageRssi(previousRssi, previousSeen,
                        WifiQualifiedNetworkSelector.SCAN_RESULT_MAXIMUNM_AGE);
                if (sVDBG) {
                    logd("updateConfiguration freq=" + result.frequency
                            + " BSSID=" + result.BSSID
                            + " RSSI=" + result.level
                            + " " + config.configKey());
                }
            }
        }
!!!36804663.java!!!	getWifiConfiguration(in netId : int) : WifiConfiguration
        return mConfiguredNetworks.getForCurrentUser(netId);
!!!36804791.java!!!	getWifiConfiguration(inout key : String) : WifiConfiguration
        return mConfiguredNetworks.getByConfigKeyForCurrentUser(key);
!!!36804919.java!!!	enableAllNetworks() : void
        boolean networkEnabledStateChanged = false;

        for (WifiConfiguration config : mConfiguredNetworks.valuesForCurrentUser()) {
            if (config != null && !config.ephemeral
                    && !config.getNetworkSelectionStatus().isNetworkEnabled()) {
                if (tryEnableQualifiedNetwork(config)) {
                    networkEnabledStateChanged = true;
                }
            }
        }

        if (networkEnabledStateChanged) {
            saveConfig();
            sendConfiguredNetworksChangedBroadcast();
        }
!!!36805047.java!!!	setNetworkPriorityNative(inout config : WifiConfiguration, in priority : int) : boolean
        return mWifiConfigStore.setNetworkPriority(config, priority);
!!!36805175.java!!!	setSSIDNative(inout config : WifiConfiguration, inout ssid : String) : boolean
        return mWifiConfigStore.setNetworkSSID(config, ssid);
!!!36805303.java!!!	updateLastConnectUid(inout config : WifiConfiguration, in uid : int) : boolean
        if (config != null) {
            if (config.lastConnectUid != uid) {
                config.lastConnectUid = uid;
                return true;
            }
        }
        return false;
!!!36805431.java!!!	selectNetwork(inout config : WifiConfiguration, inout updatePriorities : boolean, in uid : int) : boolean
        if (sVDBG) localLogNetwork("selectNetwork", config.networkId);
        if (config.networkId == INVALID_NETWORK_ID) return false;
        if (!WifiConfigurationUtil.isVisibleToAnyProfile(config,
                mUserManager.getProfiles(mCurrentUserId))) {
            loge("selectNetwork " + Integer.toString(config.networkId) + ": Network config is not "
                    + "visible to current user.");
            return false;
        }

        // Reset the priority of each network at start or if it goes too high.
        if (mLastPriority == -1 || mLastPriority > 1000000) {
            if (updatePriorities) {
                for (WifiConfiguration config2 : mConfiguredNetworks.valuesForCurrentUser()) {
                    if (config2.networkId != INVALID_NETWORK_ID) {
                        setNetworkPriorityNative(config2, 0);
                    }
                }
            }
            mLastPriority = 0;
        }

        // Set to the highest priority and save the configuration.
        if (updatePriorities) {
            setNetworkPriorityNative(config, ++mLastPriority);
        }

        if (config.isPasspoint()) {
            /* need to slap on the SSID of selected bssid to work */
            if (getScanDetailCache(config).size() != 0) {
                ScanDetail result = getScanDetailCache(config).getFirst();
                if (result == null) {
                    loge("Could not find scan result for " + config.BSSID);
                } else {
                    logd("Setting SSID for " + config.networkId + " to" + result.getSSID());
                    setSSIDNative(config, result.getSSID());
                }

            } else {
                loge("Could not find bssid for " + config);
            }
        }

        mWifiConfigStore.enableHS20(config.isPasspoint());

        if (updatePriorities) {
            saveConfig();
        }

        updateLastConnectUid(config, uid);

        writeKnownNetworkHistory();

        /* Enable the given network while disabling all other networks */
        selectNetworkWithoutBroadcast(config.networkId);

       /* Avoid saving the config & sending a broadcast to prevent settings
        * from displaying a disabled list of networks */
        return true;
!!!36805559.java!!!	saveNetwork(inout config : WifiConfiguration, in uid : int) : NetworkUpdateResult
        WifiConfiguration conf;

        // A new network cannot have null SSID
        if (config == null || (config.networkId == INVALID_NETWORK_ID && config.SSID == null)) {
            return new NetworkUpdateResult(INVALID_NETWORK_ID);
        }

        if (!WifiConfigurationUtil.isVisibleToAnyProfile(config,
                mUserManager.getProfiles(mCurrentUserId))) {
            return new NetworkUpdateResult(INVALID_NETWORK_ID);
        }

        if (sVDBG) localLogNetwork("WifiConfigManager: saveNetwork netId", config.networkId);
        if (sVDBG) {
            logd("WifiConfigManager saveNetwork,"
                    + " size=" + Integer.toString(mConfiguredNetworks.sizeForAllUsers())
                    + " (for all users)"
                    + " SSID=" + config.SSID
                    + " Uid=" + Integer.toString(config.creatorUid)
                    + "/" + Integer.toString(config.lastUpdateUid));
        }

        if (mDeletedEphemeralSSIDs.remove(config.SSID)) {
            if (sVDBG) {
                logd("WifiConfigManager: removed from ephemeral blacklist: " + config.SSID);
            }
            // NOTE: This will be flushed to disk as part of the addOrUpdateNetworkNative call
            // below, since we're creating/modifying a config.
        }

        boolean newNetwork = (config.networkId == INVALID_NETWORK_ID);
        NetworkUpdateResult result = addOrUpdateNetworkNative(config, uid);
        int netId = result.getNetworkId();

        if (sVDBG) localLogNetwork("WifiConfigManager: saveNetwork got it back netId=", netId);

        conf = mConfiguredNetworks.getForCurrentUser(netId);
        if (conf != null) {
            if (!conf.getNetworkSelectionStatus().isNetworkEnabled()) {
                if (sVDBG) localLog("WifiConfigManager: re-enabling: " + conf.SSID);

                // reenable autojoin, since new information has been provided
                updateNetworkSelectionStatus(netId,
                        WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_ENABLE);
            }
            if (sVDBG) {
                logd("WifiConfigManager: saveNetwork got config back netId="
                        + Integer.toString(netId)
                        + " uid=" + Integer.toString(config.creatorUid));
            }
        }

        saveConfig();
        sendConfiguredNetworksChangedBroadcast(
                conf,
                result.isNewNetwork()
                        ? WifiManager.CHANGE_REASON_ADDED
                        : WifiManager.CHANGE_REASON_CONFIG_CHANGE);
        return result;
!!!36805687.java!!!	noteRoamingFailure(inout config : WifiConfiguration, in reason : int) : void
        if (config == null) return;
        config.lastRoamingFailure = mClock.currentTimeMillis();
        config.roamingFailureBlackListTimeMilli =
                2 * (config.roamingFailureBlackListTimeMilli + 1000);
        if (config.roamingFailureBlackListTimeMilli > mNetworkSwitchingBlackListPeriodMs) {
            config.roamingFailureBlackListTimeMilli = mNetworkSwitchingBlackListPeriodMs;
        }
        config.lastRoamingFailureReason = reason;
!!!36805815.java!!!	saveWifiConfigBSSID(inout config : WifiConfiguration, inout bssid : String) : void
        mWifiConfigStore.setNetworkBSSID(config, bssid);
!!!36805943.java!!!	updateStatus(in netId : int, inout state : NetworkInfo::DetailedState) : void
        if (netId != INVALID_NETWORK_ID) {
            WifiConfiguration config = mConfiguredNetworks.getForAllUsers(netId);
            if (config == null) return;
            switch (state) {
                case CONNECTED:
                    config.status = Status.CURRENT;
                    //we successfully connected, hence remove the blacklist
                    updateNetworkSelectionStatus(netId,
                            WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_ENABLE);
                    break;
                case DISCONNECTED:
                    //If network is already disabled, keep the status
                    if (config.status == Status.CURRENT) {
                        config.status = Status.ENABLED;
                    }
                    break;
                default:
                    //do nothing, retain the existing state
                    break;
            }
        }
!!!36806071.java!!!	disableEphemeralNetwork(inout ssid : String) : WifiConfiguration
        if (ssid == null) {
            return null;
        }

        WifiConfiguration foundConfig = mConfiguredNetworks.getEphemeralForCurrentUser(ssid);

        mDeletedEphemeralSSIDs.add(ssid);
        logd("Forget ephemeral SSID " + ssid + " num=" + mDeletedEphemeralSSIDs.size());

        if (foundConfig != null) {
            logd("Found ephemeral config in disableEphemeralNetwork: " + foundConfig.networkId);
        }

        writeKnownNetworkHistory();
        return foundConfig;
!!!36806199.java!!!	forgetNetwork(in netId : int) : boolean
        if (mShowNetworks) localLogNetwork("forgetNetwork", netId);
        if (!removeNetwork(netId)) {
            loge("Failed to forget network " + netId);
            return false;
        }
        saveConfig();
        writeKnownNetworkHistory();
        return true;
!!!36806327.java!!!	addOrUpdateNetwork(inout config : WifiConfiguration, in uid : int) : int
        if (config == null || !WifiConfigurationUtil.isVisibleToAnyProfile(config,
                mUserManager.getProfiles(mCurrentUserId))) {
            return WifiConfiguration.INVALID_NETWORK_ID;
        }

        if (mShowNetworks) localLogNetwork("addOrUpdateNetwork id=", config.networkId);
        if (config.isPasspoint()) {
            /* create a temporary SSID with providerFriendlyName */
            Long csum = getChecksum(config.FQDN);
            config.SSID = csum.toString();
            config.enterpriseConfig.setDomainSuffixMatch(config.FQDN);
        }

        NetworkUpdateResult result = addOrUpdateNetworkNative(config, uid);
        if (result.getNetworkId() != WifiConfiguration.INVALID_NETWORK_ID) {
            WifiConfiguration conf = mConfiguredNetworks.getForCurrentUser(result.getNetworkId());
            if (conf != null) {
                sendConfiguredNetworksChangedBroadcast(
                        conf,
                        result.isNewNetwork
                                ? WifiManager.CHANGE_REASON_ADDED
                                : WifiManager.CHANGE_REASON_CONFIG_CHANGE);
            }
        }

        return result.getNetworkId();
!!!36806455.java!!!	addPasspointManagementObject(inout managementObject : String) : int
        try {
            mMOManager.addSP(managementObject);
            return 0;
        } catch (IOException | SAXException e) {
            return -1;
        }
!!!36806583.java!!!	modifyPasspointMo(inout fqdn : String, inout mos : List<PasspointManagementObjectDefinition>) : int
        try {
            return mMOManager.modifySP(fqdn, mos);
        } catch (IOException | SAXException e) {
            return -1;
        }
!!!36806711.java!!!	queryPasspointIcon(in bssid : long, inout fileName : String) : boolean
        return mSupplicantBridge.doIconQuery(bssid, fileName);
!!!36806839.java!!!	matchProviderWithCurrentNetwork(inout fqdn : String) : int
        ScanDetail scanDetail = null;
        synchronized (mActiveScanDetailLock) {
            scanDetail = mActiveScanDetail;
        }
        if (scanDetail == null) {
            return PasspointMatch.None.ordinal();
        }
        HomeSP homeSP = mMOManager.getHomeSP(fqdn);
        if (homeSP == null) {
            return PasspointMatch.None.ordinal();
        }

        ANQPData anqpData = mAnqpCache.getEntry(scanDetail.getNetworkDetail());

        Map<Constants.ANQPElementType, ANQPElement> anqpElements =
                anqpData != null ? anqpData.getANQPElements() : null;

        return homeSP.match(scanDetail.getNetworkDetail(), anqpElements, mSIMAccessor).ordinal();
!!!36807351.java!!!	retrieveDisconnectedPnoNetworkList() : WifiScanner::PnoSettings::PnoNetwork
        return retrievePnoNetworkList(sDisconnectedPnoListComparator);
!!!36807479.java!!!	retrieveConnectedPnoNetworkList() : WifiScanner::PnoSettings::PnoNetwork
        return retrievePnoNetworkList(sConnectedPnoListComparator);
!!!36807607.java!!!	createPnoNetworkFromWifiConfiguration(inout config : WifiConfiguration, in newPriority : int) : WifiScanner::PnoSettings::PnoNetwork
        WifiScanner.PnoSettings.PnoNetwork pnoNetwork =
                new WifiScanner.PnoSettings.PnoNetwork(config.SSID);
        pnoNetwork.networkId = config.networkId;
        pnoNetwork.priority = newPriority;
        if (config.hiddenSSID) {
            pnoNetwork.flags |= WifiScanner.PnoSettings.PnoNetwork.FLAG_DIRECTED_SCAN;
        }
        pnoNetwork.flags |= WifiScanner.PnoSettings.PnoNetwork.FLAG_A_BAND;
        pnoNetwork.flags |= WifiScanner.PnoSettings.PnoNetwork.FLAG_G_BAND;
        if (config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
            pnoNetwork.authBitField |= WifiScanner.PnoSettings.PnoNetwork.AUTH_CODE_PSK;
        } else if (config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP)
                || config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) {
            pnoNetwork.authBitField |= WifiScanner.PnoSettings.PnoNetwork.AUTH_CODE_EAPOL;
        } else {
            pnoNetwork.authBitField |= WifiScanner.PnoSettings.PnoNetwork.AUTH_CODE_OPEN;
        }
        return pnoNetwork;
!!!36807735.java!!!	retrievePnoNetworkList(inout pnoListComparator : WifiConfigManager::PnoListComparator) : WifiScanner::PnoSettings::PnoNetwork
        ArrayList<WifiScanner.PnoSettings.PnoNetwork> pnoList = new ArrayList<>();
        ArrayList<WifiConfiguration> wifiConfigurations =
                new ArrayList<>(mConfiguredNetworks.valuesForCurrentUser());
        Collections.sort(wifiConfigurations, pnoListComparator);
        // Let's use the network list size as the highest priority and then go down from there.
        // So, the most frequently connected network has the highest priority now.
        int priority = wifiConfigurations.size();
        for (WifiConfiguration config : wifiConfigurations) {
            pnoList.add(createPnoNetworkFromWifiConfiguration(config, priority));
            priority--;
        }
        return pnoList;
!!!36807863.java!!!	removeNetwork(in netId : int) : boolean
        if (mShowNetworks) localLogNetwork("removeNetwork", netId);
        WifiConfiguration config = mConfiguredNetworks.getForCurrentUser(netId);
        if (!removeConfigAndSendBroadcastIfNeeded(config)) {
            return false;
        }
        if (config.isPasspoint()) {
            writePasspointConfigs(config.FQDN, null);
        }
        return true;
!!!36807991.java!!!	getChecksum(inout source : String) : Long
        Checksum csum = new CRC32();
        csum.update(source.getBytes(), 0, source.getBytes().length);
        return csum.getValue();
!!!36808119.java!!!	removeConfigWithoutBroadcast(inout config : WifiConfiguration) : boolean
        if (config == null) {
            return false;
        }
        if (!mWifiConfigStore.removeNetwork(config)) {
            loge("Failed to remove network " + config.networkId);
            return false;
        }
        if (config.configKey().equals(mLastSelectedConfiguration)) {
            mLastSelectedConfiguration = null;
        }
        mConfiguredNetworks.remove(config.networkId);
        mScanDetailCaches.remove(config.networkId);
        return true;
!!!36808247.java!!!	removeConfigAndSendBroadcastIfNeeded(inout config : WifiConfiguration) : boolean
        if (!removeConfigWithoutBroadcast(config)) {
            return false;
        }
        String key = config.configKey();
        if (sVDBG) {
            logd("removeNetwork " + " key=" + key + " config.id=" + config.networkId);
        }
        writeIpAndProxyConfigurations();
        sendConfiguredNetworksChangedBroadcast(config, WifiManager.CHANGE_REASON_REMOVED);
        if (!config.ephemeral) {
            removeUserSelectionPreference(key);
        }
        writeKnownNetworkHistory();
        return true;
!!!36808375.java!!!	removeUserSelectionPreference(inout configKey : String) : void
        if (DBG) {
            Log.d(TAG, "removeUserSelectionPreference: key is " + configKey);
        }
        if (configKey == null) {
            return;
        }
        for (WifiConfiguration config : mConfiguredNetworks.valuesForCurrentUser()) {
            WifiConfiguration.NetworkSelectionStatus status = config.getNetworkSelectionStatus();
            String connectChoice = status.getConnectChoice();
            if (connectChoice != null && connectChoice.equals(configKey)) {
                Log.d(TAG, "remove connect choice:" + connectChoice + " from " + config.SSID
                        + " : " + config.networkId);
                status.setConnectChoice(null);
                status.setConnectChoiceTimestamp(WifiConfiguration.NetworkSelectionStatus
                            .INVALID_NETWORK_SELECTION_DISABLE_TIMESTAMP);
            }
        }
!!!36808503.java!!!	removeNetworksForApp(inout app : ApplicationInfo) : boolean
        if (app == null || app.packageName == null) {
            return false;
        }

        boolean success = true;

        WifiConfiguration [] copiedConfigs =
                mConfiguredNetworks.valuesForCurrentUser().toArray(new WifiConfiguration[0]);
        for (WifiConfiguration config : copiedConfigs) {
            if (app.uid != config.creatorUid || !app.packageName.equals(config.creatorName)) {
                continue;
            }
            if (mShowNetworks) {
                localLog("Removing network " + config.SSID
                         + ", application \"" + app.packageName + "\" uninstalled"
                         + " from user " + UserHandle.getUserId(app.uid));
            }
            success &= removeNetwork(config.networkId);
        }

        saveConfig();

        return success;
!!!36808631.java!!!	removeNetworksForUser(in userId : int) : boolean
        boolean success = true;

        WifiConfiguration[] copiedConfigs =
                mConfiguredNetworks.valuesForAllUsers().toArray(new WifiConfiguration[0]);
        for (WifiConfiguration config : copiedConfigs) {
            if (userId != UserHandle.getUserId(config.creatorUid)) {
                continue;
            }
            success &= removeNetwork(config.networkId);
            if (mShowNetworks) {
                localLog("Removing network " + config.SSID
                        + ", user " + userId + " removed");
            }
        }

        return success;
!!!36808759.java!!!	enableNetwork(inout config : WifiConfiguration, inout disableOthers : boolean, in uid : int) : boolean
        if (config == null) {
            return false;
        }

        updateNetworkSelectionStatus(
                config, WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_ENABLE);
        setLatestUserSelectedConfiguration(config);
        boolean ret = true;
        if (disableOthers) {
            ret = selectNetworkWithoutBroadcast(config.networkId);
            if (sVDBG) {
                localLogNetwork("enableNetwork(disableOthers=true, uid=" + uid + ") ",
                        config.networkId);
            }
            updateLastConnectUid(config, uid);
            writeKnownNetworkHistory();
            sendConfiguredNetworksChangedBroadcast();
        } else {
            if (sVDBG) localLogNetwork("enableNetwork(disableOthers=false) ", config.networkId);
            sendConfiguredNetworksChangedBroadcast(config, WifiManager.CHANGE_REASON_CONFIG_CHANGE);
        }
        return ret;
!!!36808887.java!!!	selectNetworkWithoutBroadcast(in netId : int) : boolean
        return mWifiConfigStore.selectNetwork(
                mConfiguredNetworks.getForCurrentUser(netId),
                mConfiguredNetworks.valuesForCurrentUser());
!!!36809015.java!!!	disableNetworkNative(inout config : WifiConfiguration) : boolean
        return mWifiConfigStore.disableNetwork(config);
!!!36809143.java!!!	disableAllNetworksNative() : void
        mWifiConfigStore.disableAllNetworks(mConfiguredNetworks.valuesForCurrentUser());
!!!36809271.java!!!	disableNetwork(in netId : int) : boolean
        return mWifiConfigStore.disableNetwork(mConfiguredNetworks.getForCurrentUser(netId));
!!!36809399.java!!!	updateNetworkSelectionStatus(in netId : int, in reason : int) : boolean
        WifiConfiguration config = getWifiConfiguration(netId);
        return updateNetworkSelectionStatus(config, reason);
!!!36809527.java!!!	updateNetworkSelectionStatus(inout config : WifiConfiguration, in reason : int) : boolean
        if (config == null) {
            return false;
        }

        WifiConfiguration.NetworkSelectionStatus networkStatus = config.getNetworkSelectionStatus();
        if (reason == WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_ENABLE) {
            updateNetworkStatus(config, WifiConfiguration.NetworkSelectionStatus
                    .NETWORK_SELECTION_ENABLE);
            localLog("Enable network:" + config.configKey());
            return true;
        }

        networkStatus.incrementDisableReasonCounter(reason);
        if (DBG) {
            localLog("Network:" + config.SSID + "disable counter of "
                    + WifiConfiguration.NetworkSelectionStatus.getNetworkDisableReasonString(reason)
                    + " is: " + networkStatus.getDisableReasonCounter(reason) + "and threshold is: "
                    + NETWORK_SELECTION_DISABLE_THRESHOLD[reason]);
        }

        if (networkStatus.getDisableReasonCounter(reason)
                >= NETWORK_SELECTION_DISABLE_THRESHOLD[reason]) {
            return updateNetworkStatus(config, reason);
        }
        return true;
!!!36809655.java!!!	tryEnableQualifiedNetwork(in networkId : int) : boolean
        WifiConfiguration config = getWifiConfiguration(networkId);
        if (config == null) {
            localLog("updateQualifiedNetworkstatus invalid network.");
            return false;
        }
        return tryEnableQualifiedNetwork(config);
!!!36809783.java!!!	tryEnableQualifiedNetwork(inout config : WifiConfiguration) : boolean
        WifiConfiguration.NetworkSelectionStatus networkStatus = config.getNetworkSelectionStatus();
        if (networkStatus.isNetworkTemporaryDisabled()) {
            //time difference in minutes
            long timeDifference =
                    (mClock.elapsedRealtime() - networkStatus.getDisableTime()) / 1000 / 60;
            if (timeDifference < 0 || timeDifference
                    >= NETWORK_SELECTION_DISABLE_TIMEOUT[
                    networkStatus.getNetworkSelectionDisableReason()]) {
                updateNetworkSelectionStatus(config.networkId,
                        networkStatus.NETWORK_SELECTION_ENABLE);
                return true;
            }
        }
        return false;
!!!36809911.java!!!	updateNetworkStatus(inout config : WifiConfiguration, in reason : int) : boolean
        localLog("updateNetworkStatus:" + (config == null ? null : config.SSID));
        if (config == null) {
            return false;
        }

        WifiConfiguration.NetworkSelectionStatus networkStatus = config.getNetworkSelectionStatus();
        if (reason < 0 || reason >= WifiConfiguration.NetworkSelectionStatus
                .NETWORK_SELECTION_DISABLED_MAX) {
            localLog("Invalid Network disable reason:" + reason);
            return false;
        }

        if (reason == WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_ENABLE) {
            if (networkStatus.isNetworkEnabled()) {
                if (DBG) {
                    localLog("Need not change Qualified network Selection status since"
                            + " already enabled");
                }
                return false;
            }
            networkStatus.setNetworkSelectionStatus(WifiConfiguration.NetworkSelectionStatus
                    .NETWORK_SELECTION_ENABLED);
            networkStatus.setNetworkSelectionDisableReason(reason);
            networkStatus.setDisableTime(
                    WifiConfiguration.NetworkSelectionStatus
                    .INVALID_NETWORK_SELECTION_DISABLE_TIMESTAMP);
            networkStatus.clearDisableReasonCounter();
            String disableTime = DateFormat.getDateTimeInstance().format(new Date());
            if (DBG) {
                localLog("Re-enable network: " + config.SSID + " at " + disableTime);
            }
            sendConfiguredNetworksChangedBroadcast(config, WifiManager.CHANGE_REASON_CONFIG_CHANGE);
        } else {
            //disable the network
            if (networkStatus.isNetworkPermanentlyDisabled()) {
                //alreay permanent disable
                if (DBG) {
                    localLog("Do nothing. Alreay permanent disabled! "
                            + WifiConfiguration.NetworkSelectionStatus
                            .getNetworkDisableReasonString(reason));
                }
                return false;
            } else if (networkStatus.isNetworkTemporaryDisabled()
                    && reason < WifiConfiguration.NetworkSelectionStatus
                    .DISABLED_TLS_VERSION_MISMATCH) {
                //alreay temporarily disable
                if (DBG) {
                    localLog("Do nothing. Already temporarily disabled! "
                            + WifiConfiguration.NetworkSelectionStatus
                            .getNetworkDisableReasonString(reason));
                }
                return false;
            }

            if (networkStatus.isNetworkEnabled()) {
                disableNetworkNative(config);
                sendConfiguredNetworksChangedBroadcast(config,
                        WifiManager.CHANGE_REASON_CONFIG_CHANGE);
                localLog("Disable network " + config.SSID + " reason:"
                        + WifiConfiguration.NetworkSelectionStatus
                        .getNetworkDisableReasonString(reason));
            }
            if (reason < WifiConfiguration.NetworkSelectionStatus.DISABLED_TLS_VERSION_MISMATCH) {
                networkStatus.setNetworkSelectionStatus(WifiConfiguration.NetworkSelectionStatus
                        .NETWORK_SELECTION_TEMPORARY_DISABLED);
                networkStatus.setDisableTime(mClock.elapsedRealtime());
            } else {
                networkStatus.setNetworkSelectionStatus(WifiConfiguration.NetworkSelectionStatus
                        .NETWORK_SELECTION_PERMANENTLY_DISABLED);
            }
            networkStatus.setNetworkSelectionDisableReason(reason);
            if (DBG) {
                String disableTime = DateFormat.getDateTimeInstance().format(new Date());
                localLog("Network:" + config.SSID + "Configure new status:"
                        + networkStatus.getNetworkStatusString() + " with reason:"
                        + networkStatus.getNetworkDisableReasonString() + " at: " + disableTime);
            }
        }
        return true;
!!!36810039.java!!!	saveConfig() : boolean
        return mWifiConfigStore.saveConfig();
!!!36810167.java!!!	startWpsWithPinFromAccessPoint(inout config : WpsInfo) : WpsResult
        return mWifiConfigStore.startWpsWithPinFromAccessPoint(
                config, mConfiguredNetworks.valuesForCurrentUser());
!!!36810295.java!!!	startWpsWithPinFromDevice(inout config : WpsInfo) : WpsResult
        return mWifiConfigStore.startWpsWithPinFromDevice(
            config, mConfiguredNetworks.valuesForCurrentUser());
!!!36810423.java!!!	startWpsPbc(inout config : WpsInfo) : WpsResult
        return mWifiConfigStore.startWpsPbc(
            config, mConfiguredNetworks.valuesForCurrentUser());
!!!36810551.java!!!	getStaticIpConfiguration(in netId : int) : StaticIpConfiguration
        WifiConfiguration config = mConfiguredNetworks.getForCurrentUser(netId);
        if (config != null) {
            return config.getStaticIpConfiguration();
        }
        return null;
!!!36810679.java!!!	setStaticIpConfiguration(in netId : int, inout staticIpConfiguration : StaticIpConfiguration) : void
        WifiConfiguration config = mConfiguredNetworks.getForCurrentUser(netId);
        if (config != null) {
            config.setStaticIpConfiguration(staticIpConfiguration);
        }
!!!36810807.java!!!	setDefaultGwMacAddress(in netId : int, inout macAddress : String) : void
        WifiConfiguration config = mConfiguredNetworks.getForCurrentUser(netId);
        if (config != null) {
            //update defaultGwMacAddress
            config.defaultGwMacAddress = macAddress;
        }
!!!36810935.java!!!	getProxyProperties(in netId : int) : ProxyInfo
        WifiConfiguration config = mConfiguredNetworks.getForCurrentUser(netId);
        if (config != null) {
            return config.getHttpProxy();
        }
        return null;
!!!36811063.java!!!	isUsingStaticIp(in netId : int) : boolean
        WifiConfiguration config = mConfiguredNetworks.getForCurrentUser(netId);
        if (config != null && config.getIpAssignment() == IpAssignment.STATIC) {
            return true;
        }
        return false;
!!!36811191.java!!!	isEphemeral(in netId : int) : boolean
        WifiConfiguration config = mConfiguredNetworks.getForCurrentUser(netId);
        return config != null && config.ephemeral;
!!!36811319.java!!!	getMeteredHint(in netId : int) : boolean
        WifiConfiguration config = mConfiguredNetworks.getForCurrentUser(netId);
        return config != null && config.meteredHint;
!!!36811447.java!!!	sendConfiguredNetworksChangedBroadcast(inout network : WifiConfiguration, in reason : int) : void
        Intent intent = new Intent(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        intent.putExtra(WifiManager.EXTRA_MULTIPLE_NETWORKS_CHANGED, false);
        intent.putExtra(WifiManager.EXTRA_WIFI_CONFIGURATION, network);
        intent.putExtra(WifiManager.EXTRA_CHANGE_REASON, reason);
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
!!!36811575.java!!!	sendConfiguredNetworksChangedBroadcast() : void
        Intent intent = new Intent(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        intent.putExtra(WifiManager.EXTRA_MULTIPLE_NETWORKS_CHANGED, true);
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
!!!36811703.java!!!	loadConfiguredNetworks() : void

        final Map<String, WifiConfiguration> configs = new HashMap<>();
        final SparseArray<Map<String, String>> networkExtras = new SparseArray<>();
        mLastPriority = mWifiConfigStore.loadNetworks(configs, networkExtras);

        readNetworkHistory(configs);
        readPasspointConfig(configs, networkExtras);

        // We are only now updating mConfiguredNetworks for two reasons:
        // 1) The information required to compute configKeys is spread across wpa_supplicant.conf
        //    and networkHistory.txt. Thus, we had to load both files first.
        // 2) mConfiguredNetworks caches a Passpoint network's FQDN the moment the network is added.
        //    Thus, we had to load the FQDNs first.
        mConfiguredNetworks.clear();
        for (Map.Entry<String, WifiConfiguration> entry : configs.entrySet()) {
            final String configKey = entry.getKey();
            final WifiConfiguration config = entry.getValue();
            if (!configKey.equals(config.configKey())) {
                if (mShowNetworks) {
                    log("Ignoring network " + config.networkId + " because the configKey loaded "
                            + "from wpa_supplicant.conf is not valid.");
                }
                mWifiConfigStore.removeNetwork(config);
                continue;
            }
            mConfiguredNetworks.put(config);
        }

        readIpAndProxyConfigurations();

        sendConfiguredNetworksChangedBroadcast();

        if (mShowNetworks) {
            localLog("loadConfiguredNetworks loaded " + mConfiguredNetworks.sizeForAllUsers()
                    + " networks (for all users)");
        }

        if (mConfiguredNetworks.sizeForAllUsers() == 0) {
            // no networks? Lets log if the file contents
            logKernelTime();
            logContents(WifiConfigStore.SUPPLICANT_CONFIG_FILE);
            logContents(WifiConfigStore.SUPPLICANT_CONFIG_FILE_BACKUP);
            logContents(WifiNetworkHistory.NETWORK_HISTORY_CONFIG_FILE);
        }
!!!36811831.java!!!	logContents(inout file : String) : void
        localLogAndLogcat("--- Begin " + file + " ---");
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(file));
            for (String line = reader.readLine(); line != null; line = reader.readLine()) {
                localLogAndLogcat(line);
            }
        } catch (FileNotFoundException e) {
            localLog("Could not open " + file + ", " + e);
            Log.w(TAG, "Could not open " + file + ", " + e);
        } catch (IOException e) {
            localLog("Could not read " + file + ", " + e);
            Log.w(TAG, "Could not read " + file + ", " + e);
        } finally {
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException e) {
                // Just ignore the fact that we couldn't close
            }
        }
        localLogAndLogcat("--- End " + file + " Contents ---");
!!!36811959.java!!!	readNetworkVariablesFromSupplicantFile(inout key : String) : String
        return mWifiConfigStore.readNetworkVariablesFromSupplicantFile(key);
!!!36812087.java!!!	readNetworkVariableFromSupplicantFile(inout configKey : String, inout key : String) : String
        long start = SystemClock.elapsedRealtimeNanos();
        Map<String, String> data = mWifiConfigStore.readNetworkVariablesFromSupplicantFile(key);
        long end = SystemClock.elapsedRealtimeNanos();

        if (sVDBG) {
            localLog("readNetworkVariableFromSupplicantFile configKey=[" + configKey + "] key="
                    + key + " duration=" + (long) (end - start));
        }
        return data.get(configKey);
!!!36812215.java!!!	needsUnlockedKeyStore() : boolean

        // Any network using certificates to authenticate access requires
        // unlocked key store; unless the certificates can be stored with
        // hardware encryption

        for (WifiConfiguration config : mConfiguredNetworks.valuesForCurrentUser()) {

            if (config.allowedKeyManagement.get(KeyMgmt.WPA_EAP)
                    && config.allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {

                if (needsSoftwareBackedKeyStore(config.enterpriseConfig)) {
                    return true;
                }
            }
        }

        return false;
!!!36812343.java!!!	readPasspointConfig(inout configs : Map<String, WifiConfiguration>, inout networkExtras : SparseArray) : void
        List<HomeSP> homeSPs;
        try {
            homeSPs = mMOManager.loadAllSPs();
        } catch (IOException e) {
            loge("Could not read " + PPS_FILE + " : " + e);
            return;
        }

        int matchedConfigs = 0;
        for (HomeSP homeSp : homeSPs) {
            String fqdn = homeSp.getFQDN();
            Log.d(TAG, "Looking for " + fqdn);
            for (WifiConfiguration config : configs.values()) {
                Log.d(TAG, "Testing " + config.SSID);

                if (config.enterpriseConfig == null) {
                    continue;
                }
                final String configFqdn =
                        networkExtras.get(config.networkId).get(WifiConfigStore.ID_STRING_KEY_FQDN);
                if (configFqdn != null && configFqdn.equals(fqdn)) {
                    Log.d(TAG, "Matched " + configFqdn + " with " + config.networkId);
                    ++matchedConfigs;
                    config.FQDN = fqdn;
                    config.providerFriendlyName = homeSp.getFriendlyName();

                    HashSet<Long> roamingConsortiumIds = homeSp.getRoamingConsortiums();
                    config.roamingConsortiumIds = new long[roamingConsortiumIds.size()];
                    int i = 0;
                    for (long id : roamingConsortiumIds) {
                        config.roamingConsortiumIds[i] = id;
                        i++;
                    }
                    IMSIParameter imsiParameter = homeSp.getCredential().getImsi();
                    config.enterpriseConfig.setPlmn(
                            imsiParameter != null ? imsiParameter.toString() : null);
                    config.enterpriseConfig.setRealm(homeSp.getCredential().getRealm());
                }
            }
        }

        Log.d(TAG, "loaded " + matchedConfigs + " passpoint configs");
!!!36812471.java!!!	writePasspointConfigs(in fqdn : String, in homeSP : HomeSP) : void
        mWriter.write(PPS_FILE, new DelayedDiskWrite.Writer() {
            @Override
            public void onWriteCalled(DataOutputStream out) throws IOException {
                try {
                    if (homeSP != null) {
                        mMOManager.addSP(homeSP);
                    } else {
                        mMOManager.removeSP(fqdn);
                    }
                } catch (IOException e) {
                    loge("Could not write " + PPS_FILE + " : " + e);
                }
            }
        }, false);
!!!36812599.java!!!	readNetworkHistory(inout configs : Map<String, WifiConfiguration>) : void
        mWifiNetworkHistory.readNetworkHistory(configs,
                mScanDetailCaches,
                mDeletedEphemeralSSIDs);
!!!36812727.java!!!	writeKnownNetworkHistory() : void
        final List<WifiConfiguration> networks = new ArrayList<WifiConfiguration>();
        for (WifiConfiguration config : mConfiguredNetworks.valuesForAllUsers()) {
            networks.add(new WifiConfiguration(config));
        }
        mWifiNetworkHistory.writeKnownNetworkHistory(networks,
                mScanDetailCaches,
                mDeletedEphemeralSSIDs);
!!!36812855.java!!!	setAndEnableLastSelectedConfiguration(in netId : int) : void
        if (sVDBG) {
            logd("setLastSelectedConfiguration " + Integer.toString(netId));
        }
        if (netId == WifiConfiguration.INVALID_NETWORK_ID) {
            mLastSelectedConfiguration = null;
            mLastSelectedTimeStamp = -1;
        } else {
            WifiConfiguration selected = getWifiConfiguration(netId);
            if (selected == null) {
                mLastSelectedConfiguration = null;
                mLastSelectedTimeStamp = -1;
            } else {
                mLastSelectedConfiguration = selected.configKey();
                mLastSelectedTimeStamp = mClock.elapsedRealtime();
                updateNetworkSelectionStatus(netId,
                        WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_ENABLE);
                if (sVDBG) {
                    logd("setLastSelectedConfiguration now: " + mLastSelectedConfiguration);
                }
            }
        }
!!!36812983.java!!!	setLatestUserSelectedConfiguration(inout network : WifiConfiguration) : void
        if (network != null) {
            mLastSelectedConfiguration = network.configKey();
            mLastSelectedTimeStamp = mClock.elapsedRealtime();
        }
!!!36813111.java!!!	getLastSelectedConfiguration() : String
        return mLastSelectedConfiguration;
!!!36813239.java!!!	getLastSelectedTimeStamp() : long
        return mLastSelectedTimeStamp;
!!!36813367.java!!!	isLastSelectedConfiguration(inout config : WifiConfiguration) : boolean
        return (mLastSelectedConfiguration != null
                && config != null
                && mLastSelectedConfiguration.equals(config.configKey()));
!!!36813495.java!!!	writeIpAndProxyConfigurations() : void
        final SparseArray<IpConfiguration> networks = new SparseArray<IpConfiguration>();
        for (WifiConfiguration config : mConfiguredNetworks.valuesForAllUsers()) {
            if (!config.ephemeral) {
                networks.put(configKey(config), config.getIpConfiguration());
            }
        }

        mIpconfigStore.writeIpAndProxyConfigurations(IP_CONFIG_FILE, networks);
!!!36813623.java!!!	readIpAndProxyConfigurations() : void
        SparseArray<IpConfiguration> networks =
                mIpconfigStore.readIpAndProxyConfigurations(IP_CONFIG_FILE);

        if (networks == null || networks.size() == 0) {
            // IpConfigStore.readIpAndProxyConfigurations has already logged an error.
            return;
        }

        for (int i = 0; i < networks.size(); i++) {
            int id = networks.keyAt(i);
            WifiConfiguration config = mConfiguredNetworks.getByConfigKeyIDForAllUsers(id);
            // This is the only place the map is looked up through a (dangerous) hash-value!

            if (config == null || config.ephemeral) {
                logd("configuration found for missing network, nid=" + id
                        + ", ignored, networks.size=" + Integer.toString(networks.size()));
            } else {
                config.setIpConfiguration(networks.valueAt(i));
            }
        }
!!!36813751.java!!!	addOrUpdateNetworkNative(inout config : WifiConfiguration, in uid : int) : NetworkUpdateResult
        /*
         * If the supplied networkId is INVALID_NETWORK_ID, we create a new empty
         * network configuration. Otherwise, the networkId should
         * refer to an existing configuration.
         */

        if (sVDBG) localLog("addOrUpdateNetworkNative " + config.getPrintableSsid());
        if (config.isPasspoint() && !mMOManager.isEnabled()) {
            Log.e(TAG, "Passpoint is not enabled");
            return new NetworkUpdateResult(INVALID_NETWORK_ID);
        }

        boolean newNetwork = false;
        boolean existingMO = false;
        WifiConfiguration currentConfig;
        // networkId of INVALID_NETWORK_ID means we want to create a new network
        if (config.networkId == INVALID_NETWORK_ID) {
            // Try to fetch the existing config using configKey
            currentConfig = mConfiguredNetworks.getByConfigKeyForCurrentUser(config.configKey());
            if (currentConfig != null) {
                config.networkId = currentConfig.networkId;
            } else {
                if (mMOManager.getHomeSP(config.FQDN) != null) {
                    logd("addOrUpdateNetworkNative passpoint " + config.FQDN
                            + " was found, but no network Id");
                    existingMO = true;
                }
                newNetwork = true;
            }
        } else {
            // Fetch the existing config using networkID
            currentConfig = mConfiguredNetworks.getForCurrentUser(config.networkId);
        }

        // originalConfig is used to check for credential and config changes that would cause
        // HasEverConnected to be set to false.
        WifiConfiguration originalConfig = new WifiConfiguration(currentConfig);

        if (!mWifiConfigStore.addOrUpdateNetwork(config, currentConfig)) {
            return new NetworkUpdateResult(INVALID_NETWORK_ID);
        }
        int netId = config.networkId;
        String savedConfigKey = config.configKey();

        /* An update of the network variables requires reading them
         * back from the supplicant to update mConfiguredNetworks.
         * This is because some of the variables (SSID, wep keys &
         * passphrases) reflect different values when read back than
         * when written. For example, wep key is stored as * irrespective
         * of the value sent to the supplicant.
         */
        if (currentConfig == null) {
            currentConfig = new WifiConfiguration();
            currentConfig.setIpAssignment(IpAssignment.DHCP);
            currentConfig.setProxySettings(ProxySettings.NONE);
            currentConfig.networkId = netId;
            if (config != null) {
                // Carry over the creation parameters
                currentConfig.selfAdded = config.selfAdded;
                currentConfig.didSelfAdd = config.didSelfAdd;
                currentConfig.ephemeral = config.ephemeral;
                currentConfig.meteredHint = config.meteredHint;
                currentConfig.useExternalScores = config.useExternalScores;
                currentConfig.lastConnectUid = config.lastConnectUid;
                currentConfig.lastUpdateUid = config.lastUpdateUid;
                currentConfig.creatorUid = config.creatorUid;
                currentConfig.creatorName = config.creatorName;
                currentConfig.lastUpdateName = config.lastUpdateName;
                currentConfig.peerWifiConfiguration = config.peerWifiConfiguration;
                currentConfig.FQDN = config.FQDN;
                currentConfig.providerFriendlyName = config.providerFriendlyName;
                currentConfig.roamingConsortiumIds = config.roamingConsortiumIds;
                currentConfig.validatedInternetAccess = config.validatedInternetAccess;
                currentConfig.numNoInternetAccessReports = config.numNoInternetAccessReports;
                currentConfig.updateTime = config.updateTime;
                currentConfig.creationTime = config.creationTime;
                currentConfig.shared = config.shared;
            }
            if (DBG) {
                log("created new config netId=" + Integer.toString(netId)
                        + " uid=" + Integer.toString(currentConfig.creatorUid)
                        + " name=" + currentConfig.creatorName);
            }
        }

        /* save HomeSP object for passpoint networks */
        HomeSP homeSP = null;

        if (!existingMO && config.isPasspoint()) {
            try {
                if (config.updateIdentifier == null) {   // Only create an MO for r1 networks
                    Credential credential =
                            new Credential(config.enterpriseConfig, mKeyStore, !newNetwork);
                    HashSet<Long> roamingConsortiumIds = new HashSet<Long>();
                    for (Long roamingConsortiumId : config.roamingConsortiumIds) {
                        roamingConsortiumIds.add(roamingConsortiumId);
                    }

                    homeSP = new HomeSP(Collections.<String, Long>emptyMap(), config.FQDN,
                            roamingConsortiumIds, Collections.<String>emptySet(),
                            Collections.<Long>emptySet(), Collections.<Long>emptyList(),
                            config.providerFriendlyName, null, credential);

                    log("created a homeSP object for " + config.networkId + ":" + config.SSID);
                }

                /* fix enterprise config properties for passpoint */
                currentConfig.enterpriseConfig.setRealm(config.enterpriseConfig.getRealm());
                currentConfig.enterpriseConfig.setPlmn(config.enterpriseConfig.getPlmn());
            } catch (IOException ioe) {
                Log.e(TAG, "Failed to create Passpoint config: " + ioe);
                return new NetworkUpdateResult(INVALID_NETWORK_ID);
            }
        }

        if (uid != WifiConfiguration.UNKNOWN_UID) {
            if (newNetwork) {
                currentConfig.creatorUid = uid;
            } else {
                currentConfig.lastUpdateUid = uid;
            }
        }

        // For debug, record the time the configuration was modified
        StringBuilder sb = new StringBuilder();
        sb.append("time=");
        Calendar c = Calendar.getInstance();
        c.setTimeInMillis(mClock.currentTimeMillis());
        sb.append(String.format("%tm-%td %tH:%tM:%tS.%tL", c, c, c, c, c, c));

        if (newNetwork) {
            currentConfig.creationTime = sb.toString();
        } else {
            currentConfig.updateTime = sb.toString();
        }

        if (currentConfig.status == WifiConfiguration.Status.ENABLED) {
            // Make sure autojoin remain in sync with user modifying the configuration
            updateNetworkSelectionStatus(currentConfig.networkId,
                    WifiConfiguration.NetworkSelectionStatus.NETWORK_SELECTION_ENABLE);
        }

        if (currentConfig.configKey().equals(getLastSelectedConfiguration())
                && currentConfig.ephemeral) {
            // Make the config non-ephemeral since the user just explicitly clicked it.
            currentConfig.ephemeral = false;
            if (DBG) {
                log("remove ephemeral status netId=" + Integer.toString(netId)
                        + " " + currentConfig.configKey());
            }
        }

        if (sVDBG) log("will read network variables netId=" + Integer.toString(netId));

        readNetworkVariables(currentConfig);
        // When we read back the config from wpa_supplicant, some of the default values are set
        // which could change the configKey.
        if (!savedConfigKey.equals(currentConfig.configKey())) {
            if (!mWifiConfigStore.saveNetworkMetadata(currentConfig)) {
                loge("Failed to set network metadata. Removing config " + config.networkId);
                mWifiConfigStore.removeNetwork(config);
                return new NetworkUpdateResult(INVALID_NETWORK_ID);
            }
        }

        boolean passwordChanged = false;
        // check passed in config to see if it has more than a password set.
        if (!newNetwork && config.preSharedKey != null && !config.preSharedKey.equals("*")) {
            passwordChanged = true;
        }

        if (newNetwork || passwordChanged || wasCredentialChange(originalConfig, currentConfig)) {
            currentConfig.getNetworkSelectionStatus().setHasEverConnected(false);
        }

        // Persist configuration paramaters that are not saved by supplicant.
        if (config.lastUpdateName != null) {
            currentConfig.lastUpdateName = config.lastUpdateName;
        }
        if (config.lastUpdateUid != WifiConfiguration.UNKNOWN_UID) {
            currentConfig.lastUpdateUid = config.lastUpdateUid;
        }

        mConfiguredNetworks.put(currentConfig);

        NetworkUpdateResult result =
                writeIpAndProxyConfigurationsOnChange(currentConfig, config, newNetwork);
        result.setIsNewNetwork(newNetwork);
        result.setNetworkId(netId);

        if (homeSP != null) {
            writePasspointConfigs(null, homeSP);
        }

        saveConfig();
        writeKnownNetworkHistory();

        return result;
!!!36813879.java!!!	wasBitSetUpdated(inout originalBitSet : BitSet, inout currentBitSet : BitSet) : boolean
        if (originalBitSet != null && currentBitSet != null) {
            // both configs have values set, check if they are different
            if (!originalBitSet.equals(currentBitSet)) {
                // the BitSets are different
                return true;
            }
        } else if (originalBitSet != null || currentBitSet != null) {
            return true;
        }
        return false;
!!!36814007.java!!!	wasCredentialChange(inout originalConfig : WifiConfiguration, inout currentConfig : WifiConfiguration) : boolean
        // Check if any core WifiConfiguration parameters changed that would impact new connections
        if (originalConfig == null) {
            return true;
        }

        if (wasBitSetUpdated(originalConfig.allowedKeyManagement,
                currentConfig.allowedKeyManagement)) {
            return true;
        }

        if (wasBitSetUpdated(originalConfig.allowedProtocols, currentConfig.allowedProtocols)) {
            return true;
        }

        if (wasBitSetUpdated(originalConfig.allowedAuthAlgorithms,
                currentConfig.allowedAuthAlgorithms)) {
            return true;
        }

        if (wasBitSetUpdated(originalConfig.allowedPairwiseCiphers,
                currentConfig.allowedPairwiseCiphers)) {
            return true;
        }

        if (wasBitSetUpdated(originalConfig.allowedGroupCiphers,
                currentConfig.allowedGroupCiphers)) {
            return true;
        }

        if (originalConfig.wepKeys != null && currentConfig.wepKeys != null) {
            if (originalConfig.wepKeys.length == currentConfig.wepKeys.length) {
                for (int i = 0; i < originalConfig.wepKeys.length; i++) {
                    if (!Objects.equals(originalConfig.wepKeys[i], currentConfig.wepKeys[i])) {
                        return true;
                    }
                }
            } else {
                return true;
            }
        }

        if (originalConfig.hiddenSSID != currentConfig.hiddenSSID) {
            return true;
        }

        if (originalConfig.requirePMF != currentConfig.requirePMF) {
            return true;
        }

        if (wasEnterpriseConfigChange(originalConfig.enterpriseConfig,
                currentConfig.enterpriseConfig)) {
            return true;
        }
        return false;
!!!36814135.java!!!	wasEnterpriseConfigChange(inout originalEnterpriseConfig : WifiEnterpriseConfig, inout currentEnterpriseConfig : WifiEnterpriseConfig) : boolean
        if (originalEnterpriseConfig != null && currentEnterpriseConfig != null) {
            if (originalEnterpriseConfig.getEapMethod() != currentEnterpriseConfig.getEapMethod()) {
                return true;
            }

            if (originalEnterpriseConfig.getPhase2Method()
                    != currentEnterpriseConfig.getPhase2Method()) {
                return true;
            }

            X509Certificate[] originalCaCerts = originalEnterpriseConfig.getCaCertificates();
            X509Certificate[] currentCaCerts = currentEnterpriseConfig.getCaCertificates();

            if (originalCaCerts != null && currentCaCerts != null) {
                if (originalCaCerts.length == currentCaCerts.length) {
                    for (int i = 0; i < originalCaCerts.length; i++) {
                        if (!originalCaCerts[i].equals(currentCaCerts[i])) {
                            return true;
                        }
                    }
                } else {
                    // number of aliases is different, so the configs are different
                    return true;
                }
            } else {
                // one of the enterprise configs may have aliases
                if (originalCaCerts != null || currentCaCerts != null) {
                    return true;
                }
            }
        } else {
            // One of the configs may have an enterpriseConfig
            if (originalEnterpriseConfig != null || currentEnterpriseConfig != null) {
                return true;
            }
        }
        return false;
!!!36814263.java!!!	getWifiConfigForHomeSP(inout homeSP : HomeSP) : WifiConfiguration
        WifiConfiguration config = mConfiguredNetworks.getByFQDNForCurrentUser(homeSP.getFQDN());
        if (config == null) {
            Log.e(TAG, "Could not find network for homeSP " + homeSP.getFQDN());
        }
        return config;
!!!36814391.java!!!	getHomeSPForConfig(inout config : WifiConfiguration) : HomeSP
        WifiConfiguration storedConfig = mConfiguredNetworks.getForCurrentUser(config.networkId);
        return storedConfig != null && storedConfig.isPasspoint()
                ? mMOManager.getHomeSP(storedConfig.FQDN)
                : null;
!!!36814519.java!!!	getScanDetailCache(inout config : WifiConfiguration) : ScanDetailCache
        if (config == null) return null;
        ScanDetailCache cache = mScanDetailCaches.get(config.networkId);
        if (cache == null && config.networkId != WifiConfiguration.INVALID_NETWORK_ID) {
            cache = new ScanDetailCache(config);
            mScanDetailCaches.put(config.networkId, cache);
        }
        return cache;
!!!36814647.java!!!	linkConfiguration(inout config : WifiConfiguration) : void
        if (!WifiConfigurationUtil.isVisibleToAnyProfile(config,
                mUserManager.getProfiles(mCurrentUserId))) {
            logd("linkConfiguration: Attempting to link config " + config.configKey()
                    + " that is not visible to the current user.");
            return;
        }

        if (getScanDetailCache(config) != null && getScanDetailCache(config).size() > 6) {
            // Ignore configurations with large number of BSSIDs
            return;
        }
        if (!config.allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
            // Only link WPA_PSK config
            return;
        }
        for (WifiConfiguration link : mConfiguredNetworks.valuesForCurrentUser()) {
            boolean doLink = false;

            if (link.configKey().equals(config.configKey())) {
                continue;
            }

            if (link.ephemeral) {
                continue;
            }

            // Autojoin will be allowed to dynamically jump from a linked configuration
            // to another, hence only link configurations that have equivalent level of security
            if (!link.allowedKeyManagement.equals(config.allowedKeyManagement)) {
                continue;
            }

            ScanDetailCache linkedScanDetailCache = getScanDetailCache(link);
            if (linkedScanDetailCache != null && linkedScanDetailCache.size() > 6) {
                // Ignore configurations with large number of BSSIDs
                continue;
            }

            if (config.defaultGwMacAddress != null && link.defaultGwMacAddress != null) {
                // If both default GW are known, link only if they are equal
                if (config.defaultGwMacAddress.equals(link.defaultGwMacAddress)) {
                    if (sVDBG) {
                        logd("linkConfiguration link due to same gw " + link.SSID
                                + " and " + config.SSID + " GW " + config.defaultGwMacAddress);
                    }
                    doLink = true;
                }
            } else {
                // We do not know BOTH default gateways hence we will try to link
                // hoping that WifiConfigurations are indeed behind the same gateway.
                // once both WifiConfiguration have been tried and thus once both efault gateways
                // are known we will revisit the choice of linking them
                if ((getScanDetailCache(config) != null)
                        && (getScanDetailCache(config).size() <= 6)) {

                    for (String abssid : getScanDetailCache(config).keySet()) {
                        for (String bbssid : linkedScanDetailCache.keySet()) {
                            if (sVVDBG) {
                                logd("linkConfiguration try to link due to DBDC BSSID match "
                                        + link.SSID + " and " + config.SSID + " bssida " + abssid
                                        + " bssidb " + bbssid);
                            }
                            if (abssid.regionMatches(true, 0, bbssid, 0, 16)) {
                                // If first 16 ascii characters of BSSID matches,
                                // we assume this is a DBDC
                                doLink = true;
                            }
                        }
                    }
                }
            }

            if (doLink && mOnlyLinkSameCredentialConfigurations) {
                String apsk =
                        readNetworkVariableFromSupplicantFile(link.configKey(), "psk");
                String bpsk =
                        readNetworkVariableFromSupplicantFile(config.configKey(), "psk");
                if (apsk == null || bpsk == null
                        || TextUtils.isEmpty(apsk) || TextUtils.isEmpty(apsk)
                        || apsk.equals("*") || apsk.equals(DELETED_CONFIG_PSK)
                        || !apsk.equals(bpsk)) {
                    doLink = false;
                }
            }

            if (doLink) {
                if (sVDBG) {
                    logd("linkConfiguration: will link " + link.configKey()
                            + " and " + config.configKey());
                }
                if (link.linkedConfigurations == null) {
                    link.linkedConfigurations = new HashMap<String, Integer>();
                }
                if (config.linkedConfigurations == null) {
                    config.linkedConfigurations = new HashMap<String, Integer>();
                }
                if (link.linkedConfigurations.get(config.configKey()) == null) {
                    link.linkedConfigurations.put(config.configKey(), Integer.valueOf(1));
                }
                if (config.linkedConfigurations.get(link.configKey()) == null) {
                    config.linkedConfigurations.put(link.configKey(), Integer.valueOf(1));
                }
            } else {
                if (link.linkedConfigurations != null
                        && (link.linkedConfigurations.get(config.configKey()) != null)) {
                    if (sVDBG) {
                        logd("linkConfiguration: un-link " + config.configKey()
                                + " from " + link.configKey());
                    }
                    link.linkedConfigurations.remove(config.configKey());
                }
                if (config.linkedConfigurations != null
                        && (config.linkedConfigurations.get(link.configKey()) != null)) {
                    if (sVDBG) {
                        logd("linkConfiguration: un-link " + link.configKey()
                                + " from " + config.configKey());
                    }
                    config.linkedConfigurations.remove(link.configKey());
                }
            }
        }
!!!36814775.java!!!	makeChannelList(inout config : WifiConfiguration, in age : int) : HashSet<Integer>
        if (config == null) {
            return null;
        }
        long now_ms = mClock.currentTimeMillis();

        HashSet<Integer> channels = new HashSet<Integer>();

        //get channels for this configuration, if there are at least 2 BSSIDs
        if (getScanDetailCache(config) == null && config.linkedConfigurations == null) {
            return null;
        }

        if (sVDBG) {
            StringBuilder dbg = new StringBuilder();
            dbg.append("makeChannelList age=" + Integer.toString(age)
                    + " for " + config.configKey()
                    + " max=" + mMaxNumActiveChannelsForPartialScans);
            if (getScanDetailCache(config) != null) {
                dbg.append(" bssids=" + getScanDetailCache(config).size());
            }
            if (config.linkedConfigurations != null) {
                dbg.append(" linked=" + config.linkedConfigurations.size());
            }
            logd(dbg.toString());
        }

        int numChannels = 0;
        if (getScanDetailCache(config) != null && getScanDetailCache(config).size() > 0) {
            for (ScanDetail scanDetail : getScanDetailCache(config).values()) {
                ScanResult result = scanDetail.getScanResult();
                //TODO : cout active and passive channels separately
                if (numChannels > mMaxNumActiveChannelsForPartialScans.get()) {
                    break;
                }
                if (sVDBG) {
                    boolean test = (now_ms - result.seen) < age;
                    logd("has " + result.BSSID + " freq=" + Integer.toString(result.frequency)
                            + " age=" + Long.toString(now_ms - result.seen) + " ?=" + test);
                }
                if (((now_ms - result.seen) < age)) {
                    channels.add(result.frequency);
                    numChannels++;
                }
            }
        }

        //get channels for linked configurations
        if (config.linkedConfigurations != null) {
            for (String key : config.linkedConfigurations.keySet()) {
                WifiConfiguration linked = getWifiConfiguration(key);
                if (linked == null) {
                    continue;
                }
                if (getScanDetailCache(linked) == null) {
                    continue;
                }
                for (ScanDetail scanDetail : getScanDetailCache(linked).values()) {
                    ScanResult result = scanDetail.getScanResult();
                    if (sVDBG) {
                        logd("has link: " + result.BSSID
                                + " freq=" + Integer.toString(result.frequency)
                                + " age=" + Long.toString(now_ms - result.seen));
                    }
                    if (numChannels > mMaxNumActiveChannelsForPartialScans.get()) {
                        break;
                    }
                    if (((now_ms - result.seen) < age)) {
                        channels.add(result.frequency);
                        numChannels++;
                    }
                }
            }
        }
        return channels;
!!!36814903.java!!!	matchPasspointNetworks(inout scanDetail : ScanDetail) : HomeSP
        if (!mMOManager.isConfigured()) {
            if (mEnableOsuQueries) {
                NetworkDetail networkDetail = scanDetail.getNetworkDetail();
                List<Constants.ANQPElementType> querySet =
                        ANQPFactory.buildQueryList(networkDetail, false, true);

                if (networkDetail.queriable(querySet)) {
                    querySet = mAnqpCache.initiate(networkDetail, querySet);
                    if (querySet != null) {
                        mSupplicantBridge.startANQP(scanDetail, querySet);
                    }
                    updateAnqpCache(scanDetail, networkDetail.getANQPElements());
                }
            }
            return null;
        }
        NetworkDetail networkDetail = scanDetail.getNetworkDetail();
        if (!networkDetail.hasInterworking()) {
            return null;
        }
        updateAnqpCache(scanDetail, networkDetail.getANQPElements());

        Map<HomeSP, PasspointMatch> matches = matchNetwork(scanDetail, true);
        Log.d(Utils.hs2LogTag(getClass()), scanDetail.getSSID()
                + " pass 1 matches: " + toMatchString(matches));
        return matches;
!!!36815031.java!!!	matchNetwork(inout scanDetail : ScanDetail, inout query : boolean) : HomeSP
        NetworkDetail networkDetail = scanDetail.getNetworkDetail();

        ANQPData anqpData = mAnqpCache.getEntry(networkDetail);

        Map<Constants.ANQPElementType, ANQPElement> anqpElements =
                anqpData != null ? anqpData.getANQPElements() : null;

        boolean queried = !query;
        Collection<HomeSP> homeSPs = mMOManager.getLoadedSPs().values();
        Map<HomeSP, PasspointMatch> matches = new HashMap<>(homeSPs.size());
        Log.d(Utils.hs2LogTag(getClass()), "match nwk " + scanDetail.toKeyString()
                + ", anqp " + (anqpData != null ? "present" : "missing")
                + ", query " + query + ", home sps: " + homeSPs.size());

        for (HomeSP homeSP : homeSPs) {
            PasspointMatch match = homeSP.match(networkDetail, anqpElements, mSIMAccessor);

            Log.d(Utils.hs2LogTag(getClass()), " -- "
                    + homeSP.getFQDN() + ": match " + match + ", queried " + queried);

            if ((match == PasspointMatch.Incomplete || mEnableOsuQueries) && !queried) {
                boolean matchSet = match == PasspointMatch.Incomplete;
                boolean osu = mEnableOsuQueries;
                List<Constants.ANQPElementType> querySet =
                        ANQPFactory.buildQueryList(networkDetail, matchSet, osu);
                if (networkDetail.queriable(querySet)) {
                    querySet = mAnqpCache.initiate(networkDetail, querySet);
                    if (querySet != null) {
                        mSupplicantBridge.startANQP(scanDetail, querySet);
                    }
                }
                queried = true;
            }
            matches.put(homeSP, match);
        }
        return matches;
!!!36815159.java!!!	getANQPData(inout network : NetworkDetail) : Constants::ANQPElementType
        ANQPData data = mAnqpCache.getEntry(network);
        return data != null ? data.getANQPElements() : null;
!!!36815287.java!!!	getSIMAccessor() : SIMAccessor
        return mSIMAccessor;
!!!36815415.java!!!	notifyANQPDone(inout bssid : Long, inout success : boolean) : void
        mSupplicantBridge.notifyANQPDone(bssid, success);
!!!36815543.java!!!	notifyIconReceived(inout iconEvent : IconEvent) : void
        Intent intent = new Intent(WifiManager.PASSPOINT_ICON_RECEIVED_ACTION);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        intent.putExtra(WifiManager.EXTRA_PASSPOINT_ICON_BSSID, iconEvent.getBSSID());
        intent.putExtra(WifiManager.EXTRA_PASSPOINT_ICON_FILE, iconEvent.getFileName());
        try {
            intent.putExtra(WifiManager.EXTRA_PASSPOINT_ICON_DATA,
                    mSupplicantBridge.retrieveIcon(iconEvent));
        } catch (IOException ioe) {
            /* Simply omit the icon data as a failure indication */
        }
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);

!!!36815671.java!!!	updateAnqpCache(inout scanDetail : ScanDetail, inout anqpElements : Map<Constants.ANQPElementType, ANQPElement>) : void
        NetworkDetail networkDetail = scanDetail.getNetworkDetail();

        if (anqpElements == null) {
            // Try to pull cached data if query failed.
            ANQPData data = mAnqpCache.getEntry(networkDetail);
            if (data != null) {
                scanDetail.propagateANQPInfo(data.getANQPElements());
            }
            return;
        }

        mAnqpCache.update(networkDetail, anqpElements);
!!!36815799.java!!!	toMatchString(inout matches : Map<HomeSP, PasspointMatch>) : String
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<HomeSP, PasspointMatch> entry : matches.entrySet()) {
            sb.append(' ').append(entry.getKey().getFQDN()).append("->").append(entry.getValue());
        }
        return sb.toString();
!!!36815927.java!!!	cacheScanResultForPasspointConfigs(inout scanDetail : ScanDetail, inout matches : Map<HomeSP, PasspointMatch>, inout associatedWifiConfigurations : List<WifiConfiguration>) : void

        for (Map.Entry<HomeSP, PasspointMatch> entry : matches.entrySet()) {
            PasspointMatch match = entry.getValue();
            if (match == PasspointMatch.HomeProvider || match == PasspointMatch.RoamingProvider) {
                WifiConfiguration config = getWifiConfigForHomeSP(entry.getKey());
                if (config != null) {
                    cacheScanResultForConfig(config, scanDetail, entry.getValue());
                    if (associatedWifiConfigurations != null) {
                        associatedWifiConfigurations.add(config);
                    }
                } else {
                    Log.w(Utils.hs2LogTag(getClass()), "Failed to find config for '"
                            + entry.getKey().getFQDN() + "'");
                    /* perhaps the configuration was deleted?? */
                }
            }
        }
!!!36816055.java!!!	cacheScanResultForConfig(inout config : WifiConfiguration, inout scanDetail : ScanDetail, inout passpointMatch : PasspointMatch) : void

        ScanResult scanResult = scanDetail.getScanResult();

        ScanDetailCache scanDetailCache = getScanDetailCache(config);
        if (scanDetailCache == null) {
            Log.w(TAG, "Could not allocate scan cache for " + config.SSID);
            return;
        }

        // Adding a new BSSID
        ScanResult result = scanDetailCache.get(scanResult.BSSID);
        if (result != null) {
            // transfer the black list status
            scanResult.blackListTimestamp = result.blackListTimestamp;
            scanResult.numIpConfigFailures = result.numIpConfigFailures;
            scanResult.numConnection = result.numConnection;
            scanResult.isAutoJoinCandidate = result.isAutoJoinCandidate;
        }

        if (config.ephemeral) {
            // For an ephemeral Wi-Fi config, the ScanResult should be considered
            // untrusted.
            scanResult.untrusted = true;
        }

        if (scanDetailCache.size() > (MAX_NUM_SCAN_CACHE_ENTRIES + 64)) {
            long now_dbg = 0;
            if (sVVDBG) {
                logd(" Will trim config " + config.configKey()
                        + " size " + scanDetailCache.size());

                for (ScanDetail sd : scanDetailCache.values()) {
                    logd("     " + sd.getBSSIDString() + " " + sd.getSeen());
                }
                now_dbg = SystemClock.elapsedRealtimeNanos();
            }
            // Trim the scan result cache to MAX_NUM_SCAN_CACHE_ENTRIES entries max
            // Since this operation is expensive, make sure it is not performed
            // until the cache has grown significantly above the trim treshold
            scanDetailCache.trim(MAX_NUM_SCAN_CACHE_ENTRIES);
            if (sVVDBG) {
                long diff = SystemClock.elapsedRealtimeNanos() - now_dbg;
                logd(" Finished trimming config, time(ns) " + diff);
                for (ScanDetail sd : scanDetailCache.values()) {
                    logd("     " + sd.getBSSIDString() + " " + sd.getSeen());
                }
            }
        }

        // Add the scan result to this WifiConfiguration
        if (passpointMatch != null) {
            scanDetailCache.put(scanDetail, passpointMatch, getHomeSPForConfig(config));
        } else {
            scanDetailCache.put(scanDetail);
        }

        // Since we added a scan result to this configuration, re-attempt linking
        linkConfiguration(config);
!!!36816183.java!!!	isEncryptionWep(inout encryption : String) : boolean
        return encryption.contains("WEP");
!!!36816311.java!!!	isEncryptionPsk(inout encryption : String) : boolean
        return encryption.contains("PSK");
!!!36816439.java!!!	isEncryptionEap(inout encryption : String) : boolean
        return encryption.contains("EAP");
!!!36816567.java!!!	isOpenNetwork(inout encryption : String) : boolean
        if (!isEncryptionWep(encryption) && !isEncryptionPsk(encryption)
                && !isEncryptionEap(encryption)) {
            return true;
        }
        return false;
!!!36816695.java!!!	isOpenNetwork(inout scan : ScanResult) : boolean
        String scanResultEncrypt = scan.capabilities;
        return isOpenNetwork(scanResultEncrypt);
!!!36816823.java!!!	isOpenNetwork(inout config : WifiConfiguration) : boolean
        String configEncrypt = config.configKey();
        return isOpenNetwork(configEncrypt);
!!!36816951.java!!!	getSavedNetworkFromScanDetail(inout scanDetail : ScanDetail) : WifiConfiguration
        ScanResult scanResult = scanDetail.getScanResult();
        if (scanResult == null) {
            return null;
        }
        List<WifiConfiguration> savedWifiConfigurations = new ArrayList<>();
        String ssid = "\"" + scanResult.SSID + "\"";
        for (WifiConfiguration config : mConfiguredNetworks.valuesForCurrentUser()) {
            if (config.SSID == null || !config.SSID.equals(ssid)) {
                continue;
            }
            if (DBG) {
                localLog("getSavedNetworkFromScanDetail(): try " + config.configKey()
                        + " SSID=" + config.SSID + " " + scanResult.SSID + " "
                        + scanResult.capabilities);
            }
            String scanResultEncrypt = scanResult.capabilities;
            String configEncrypt = config.configKey();
            if (isEncryptionWep(scanResultEncrypt) && isEncryptionWep(configEncrypt)
                    || (isEncryptionPsk(scanResultEncrypt) && isEncryptionPsk(configEncrypt))
                    || (isEncryptionEap(scanResultEncrypt) && isEncryptionEap(configEncrypt))
                    || (isOpenNetwork(scanResultEncrypt) && isOpenNetwork(configEncrypt))) {
                savedWifiConfigurations.add(config);
            }
        }
        return savedWifiConfigurations;
!!!36817079.java!!!	updateSavedNetworkWithNewScanDetail(inout scanDetail : ScanDetail, inout isConnectingOrConnected : boolean) : WifiConfiguration
        ScanResult scanResult = scanDetail.getScanResult();
        if (scanResult == null) {
            return null;
        }
        NetworkDetail networkDetail = scanDetail.getNetworkDetail();
        List<WifiConfiguration> associatedWifiConfigurations = new ArrayList<>();
        if (networkDetail.hasInterworking() && !isConnectingOrConnected) {
            Map<HomeSP, PasspointMatch> matches = matchPasspointNetworks(scanDetail);
            if (matches != null) {
                cacheScanResultForPasspointConfigs(scanDetail, matches,
                        associatedWifiConfigurations);
                //Do not return here. A BSSID can belong to both passpoint network and non-passpoint
                //Network
            }
        }
        List<WifiConfiguration> savedConfigurations = getSavedNetworkFromScanDetail(scanDetail);
        if (savedConfigurations != null) {
            for (WifiConfiguration config : savedConfigurations) {
                cacheScanResultForConfig(config, scanDetail, null);
                associatedWifiConfigurations.add(config);
            }
        }
        if (associatedWifiConfigurations.size() == 0) {
            return null;
        } else {
            return associatedWifiConfigurations;
        }
!!!36817207.java!!!	handleUserSwitch(in userId : int) : void
        mCurrentUserId = userId;
        Set<WifiConfiguration> ephemeralConfigs = new HashSet<>();
        for (WifiConfiguration config : mConfiguredNetworks.valuesForCurrentUser()) {
            if (config.ephemeral) {
                ephemeralConfigs.add(config);
            }
        }
        if (!ephemeralConfigs.isEmpty()) {
            for (WifiConfiguration config : ephemeralConfigs) {
                removeConfigWithoutBroadcast(config);
            }
            saveConfig();
            writeKnownNetworkHistory();
        }

        final List<WifiConfiguration> hiddenConfigurations =
                mConfiguredNetworks.handleUserSwitch(mCurrentUserId);
        for (WifiConfiguration network : hiddenConfigurations) {
            disableNetworkNative(network);
        }
        enableAllNetworks();

        // TODO(b/26785746): This broadcast is unnecessary if either of the following is true:
        // * The user switch did not change the list of visible networks
        // * The user switch revealed additional networks that were temporarily disabled and got
        //   re-enabled now (because enableAllNetworks() sent the same broadcast already).
        sendConfiguredNetworksChangedBroadcast();
!!!36817335.java!!!	getCurrentUserId() : int
        return mCurrentUserId;
!!!36817463.java!!!	isCurrentUserProfile(in userId : int) : boolean
        if (userId == mCurrentUserId) {
            return true;
        }
        final UserInfo parent = mUserManager.getProfileParent(userId);
        return parent != null && parent.id == mCurrentUserId;
!!!36817591.java!!!	writeIpAndProxyConfigurationsOnChange(inout currentConfig : WifiConfiguration, inout newConfig : WifiConfiguration, inout isNewNetwork : boolean) : NetworkUpdateResult
        boolean ipChanged = false;
        boolean proxyChanged = false;

        switch (newConfig.getIpAssignment()) {
            case STATIC:
                if (currentConfig.getIpAssignment() != newConfig.getIpAssignment()) {
                    ipChanged = true;
                } else {
                    ipChanged = !Objects.equals(
                            currentConfig.getStaticIpConfiguration(),
                            newConfig.getStaticIpConfiguration());
                }
                break;
            case DHCP:
                if (currentConfig.getIpAssignment() != newConfig.getIpAssignment()) {
                    ipChanged = true;
                }
                break;
            case UNASSIGNED:
                /* Ignore */
                break;
            default:
                loge("Ignore invalid ip assignment during write");
                break;
        }

        switch (newConfig.getProxySettings()) {
            case STATIC:
            case PAC:
                ProxyInfo newHttpProxy = newConfig.getHttpProxy();
                ProxyInfo currentHttpProxy = currentConfig.getHttpProxy();

                if (newHttpProxy != null) {
                    proxyChanged = !newHttpProxy.equals(currentHttpProxy);
                } else {
                    proxyChanged = (currentHttpProxy != null);
                }
                break;
            case NONE:
                if (currentConfig.getProxySettings() != newConfig.getProxySettings()) {
                    proxyChanged = true;
                }
                break;
            case UNASSIGNED:
                /* Ignore */
                break;
            default:
                loge("Ignore invalid proxy configuration during write");
                break;
        }

        if (ipChanged) {
            currentConfig.setIpAssignment(newConfig.getIpAssignment());
            currentConfig.setStaticIpConfiguration(newConfig.getStaticIpConfiguration());
            log("IP config changed SSID = " + currentConfig.SSID);
            if (currentConfig.getStaticIpConfiguration() != null) {
                log(" static configuration: "
                        + currentConfig.getStaticIpConfiguration().toString());
            }
        }

        if (proxyChanged) {
            currentConfig.setProxySettings(newConfig.getProxySettings());
            currentConfig.setHttpProxy(newConfig.getHttpProxy());
            log("proxy changed SSID = " + currentConfig.SSID);
            if (currentConfig.getHttpProxy() != null) {
                log(" proxyProperties: " + currentConfig.getHttpProxy().toString());
            }
        }

        if (ipChanged || proxyChanged || isNewNetwork) {
            if (sVDBG) {
                logd("writeIpAndProxyConfigurationsOnChange: " + currentConfig.SSID + " -> "
                        + newConfig.SSID + " path: " + IP_CONFIG_FILE);
            }
            writeIpAndProxyConfigurations();
        }
        return new NetworkUpdateResult(ipChanged, proxyChanged);
!!!36817719.java!!!	readNetworkVariables(inout config : WifiConfiguration) : void
        mWifiConfigStore.readNetworkVariables(config);
!!!36817847.java!!!	wifiConfigurationFromScanResult(inout result : ScanResult) : WifiConfiguration

        WifiConfiguration config = new WifiConfiguration();

        config.SSID = "\"" + result.SSID + "\"";

        if (sVDBG) {
            logd("WifiConfiguration from scan results "
                    + config.SSID + " cap " + result.capabilities);
        }

        if (result.capabilities.contains("PSK") || result.capabilities.contains("EAP")
                || result.capabilities.contains("WEP")) {
            if (result.capabilities.contains("PSK")) {
                config.allowedKeyManagement.set(KeyMgmt.WPA_PSK);
            }

            if (result.capabilities.contains("EAP")) {
                config.allowedKeyManagement.set(KeyMgmt.WPA_EAP);
                config.allowedKeyManagement.set(KeyMgmt.IEEE8021X);
            }

            if (result.capabilities.contains("WEP")) {
                config.allowedKeyManagement.set(KeyMgmt.NONE);
                config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);
                config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.SHARED);
            }
        } else {
            config.allowedKeyManagement.set(KeyMgmt.NONE);
        }

        return config;
!!!36817975.java!!!	wifiConfigurationFromScanResult(inout scanDetail : ScanDetail) : WifiConfiguration
        ScanResult result = scanDetail.getScanResult();
        return wifiConfigurationFromScanResult(result);
!!!36818103.java!!!	configKey(inout config : WifiConfiguration) : int
        String key = config.configKey();
        return key.hashCode();
!!!36818231.java!!!	dump(inout fd : FileDescriptor, inout pw : PrintWriter, inout args : String) : void
        pw.println("Dump of WifiConfigManager");
        pw.println("mLastPriority " + mLastPriority);
        pw.println("Configured networks");
        for (WifiConfiguration conf : getAllConfiguredNetworks()) {
            pw.println(conf);
        }
        pw.println();
        if (mLostConfigsDbg != null && mLostConfigsDbg.size() > 0) {
            pw.println("LostConfigs: ");
            for (String s : mLostConfigsDbg) {
                pw.println(s);
            }
        }
        if (mLocalLog != null) {
            pw.println("WifiConfigManager - Log Begin ----");
            mLocalLog.dump(fd, pw, args);
            pw.println("WifiConfigManager - Log End ----");
        }
        if (mMOManager.isConfigured()) {
            pw.println("Begin dump of ANQP Cache");
            mAnqpCache.dump(pw);
            pw.println("End dump of ANQP Cache");
        }
!!!36818359.java!!!	getConfigFile() : String
        return IP_CONFIG_FILE;
!!!36818487.java!!!	logd(inout s : String) : void
        Log.d(TAG, s);
!!!36818615.java!!!	loge(inout s : String) : void
        loge(s, false);
!!!36818743.java!!!	loge(inout s : String, inout stack : boolean) : void
        if (stack) {
            Log.e(TAG, s + " stack:" + Thread.currentThread().getStackTrace()[2].getMethodName()
                    + " - " + Thread.currentThread().getStackTrace()[3].getMethodName()
                    + " - " + Thread.currentThread().getStackTrace()[4].getMethodName()
                    + " - " + Thread.currentThread().getStackTrace()[5].getMethodName());
        } else {
            Log.e(TAG, s);
        }
!!!36818871.java!!!	logKernelTime() : void
        long kernelTimeMs = System.nanoTime() / (1000 * 1000);
        StringBuilder builder = new StringBuilder();
        builder.append("kernel time = ")
                .append(kernelTimeMs / 1000)
                .append(".")
                .append(kernelTimeMs % 1000)
                .append("\n");
        localLog(builder.toString());
!!!36818999.java!!!	log(inout s : String) : void
        Log.d(TAG, s);
!!!36819127.java!!!	localLog(inout s : String) : void
        if (mLocalLog != null) {
            mLocalLog.log(s);
        }
!!!36819255.java!!!	localLogAndLogcat(inout s : String) : void
        localLog(s);
        Log.d(TAG, s);
!!!36819383.java!!!	localLogNetwork(inout s : String, in netId : int) : void
        if (mLocalLog == null) {
            return;
        }

        WifiConfiguration config;
        synchronized (mConfiguredNetworks) {             // !!! Useless synchronization
            config = mConfiguredNetworks.getForAllUsers(netId);
        }

        if (config != null) {
            mLocalLog.log(s + " " + config.getPrintableSsid() + " " + netId
                    + " status=" + config.status
                    + " key=" + config.configKey());
        } else {
            mLocalLog.log(s + " " + netId);
        }
!!!36819511.java!!!	needsSoftwareBackedKeyStore(inout config : WifiEnterpriseConfig) : boolean
        String client = config.getClientCertificateAlias();
        if (!TextUtils.isEmpty(client)) {
            // a valid client certificate is configured

            // BUGBUG: keyStore.get() never returns certBytes; because it is not
            // taking WIFI_UID as a parameter. It always looks for certificate
            // with SYSTEM_UID, and never finds any Wifi certificates. Assuming that
            // all certificates need software keystore until we get the get() API
            // fixed.

            return true;
        }

        /*
        try {

            if (DBG) Slog.d(TAG, "Loading client certificate " + Credentials
                    .USER_CERTIFICATE + client);

            CertificateFactory factory = CertificateFactory.getInstance("X.509");
            if (factory == null) {
                Slog.e(TAG, "Error getting certificate factory");
                return;
            }

            byte[] certBytes = keyStore.get(Credentials.USER_CERTIFICATE + client);
            if (certBytes != null) {
                Certificate cert = (X509Certificate) factory.generateCertificate(
                        new ByteArrayInputStream(certBytes));

                if (cert != null) {
                    mNeedsSoftwareKeystore = hasHardwareBackedKey(cert);

                    if (DBG) Slog.d(TAG, "Loaded client certificate " + Credentials
                            .USER_CERTIFICATE + client);
                    if (DBG) Slog.d(TAG, "It " + (mNeedsSoftwareKeystore ? "needs" :
                            "does not need" ) + " software key store");
                } else {
                    Slog.d(TAG, "could not generate certificate");
                }
            } else {
                Slog.e(TAG, "Could not load client certificate " + Credentials
                        .USER_CERTIFICATE + client);
                mNeedsSoftwareKeystore = true;
            }

        } catch(CertificateException e) {
            Slog.e(TAG, "Could not read certificates");
            mCaCert = null;
            mClientCertificate = null;
        }
        */

        return false;
!!!36819639.java!!!	isSimConfig(inout config : WifiConfiguration) : boolean
        return mWifiConfigStore.isSimConfig(config);
!!!36819767.java!!!	resetSimNetworks() : void
        mWifiConfigStore.resetSimNetworks(mConfiguredNetworks.valuesForCurrentUser());
!!!36819895.java!!!	isNetworkConfigured(inout config : WifiConfiguration) : boolean
        // Check if either we have a network Id or a WifiConfiguration
        // matching the one we are trying to add.

        if (config.networkId != INVALID_NETWORK_ID) {
            return (mConfiguredNetworks.getForCurrentUser(config.networkId) != null);
        }

        return (mConfiguredNetworks.getByConfigKeyForCurrentUser(config.configKey()) != null);
!!!36820023.java!!!	canModifyNetwork(in uid : int, in networkId : int, inout onlyAnnotate : boolean) : boolean
        WifiConfiguration config = mConfiguredNetworks.getForCurrentUser(networkId);

        if (config == null) {
            loge("canModifyNetwork: cannot find config networkId " + networkId);
            return false;
        }

        final DevicePolicyManagerInternal dpmi = LocalServices.getService(
                DevicePolicyManagerInternal.class);

        final boolean isUidDeviceOwner = dpmi != null && dpmi.isActiveAdminWithPolicy(uid,
                DeviceAdminInfo.USES_POLICY_DEVICE_OWNER);

        if (isUidDeviceOwner) {
            return true;
        }

        final boolean isCreator = (config.creatorUid == uid);

        if (onlyAnnotate) {
            return isCreator || checkConfigOverridePermission(uid);
        }

        // Check if device has DPM capability. If it has and dpmi is still null, then we
        // treat this case with suspicion and bail out.
        if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN)
                && dpmi == null) {
            return false;
        }

        // WiFi config lockdown related logic. At this point we know uid NOT to be a Device Owner.

        final boolean isConfigEligibleForLockdown = dpmi != null && dpmi.isActiveAdminWithPolicy(
                config.creatorUid, DeviceAdminInfo.USES_POLICY_DEVICE_OWNER);
        if (!isConfigEligibleForLockdown) {
            return isCreator || checkConfigOverridePermission(uid);
        }

        final ContentResolver resolver = mContext.getContentResolver();
        final boolean isLockdownFeatureEnabled = Settings.Global.getInt(resolver,
                Settings.Global.WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN, 0) != 0;
        return !isLockdownFeatureEnabled && checkConfigOverridePermission(uid);
!!!36820151.java!!!	canModifyNetwork(in uid : int, inout config : WifiConfiguration, inout onlyAnnotate : boolean) : boolean
        if (config == null) {
            loge("canModifyNetowrk recieved null configuration");
            return false;
        }

        // Resolve the correct network id.
        int netid;
        if (config.networkId != INVALID_NETWORK_ID) {
            netid = config.networkId;
        } else {
            WifiConfiguration test =
                    mConfiguredNetworks.getByConfigKeyForCurrentUser(config.configKey());
            if (test == null) {
                return false;
            } else {
                netid = test.networkId;
            }
        }

        return canModifyNetwork(uid, netid, onlyAnnotate);
!!!36820279.java!!!	checkConfigOverridePermission(in uid : int) : boolean
        try {
            return (mFacade.checkUidPermission(
                    android.Manifest.permission.OVERRIDE_WIFI_CONFIG, uid)
                    == PackageManager.PERMISSION_GRANTED);
        } catch (RemoteException e) {
            return false;
        }
!!!36820407.java!!!	handleBadNetworkDisconnectReport(in netId : int, inout info : WifiInfo) : void
        /* TODO verify the bad network is current */
        WifiConfiguration config = mConfiguredNetworks.getForCurrentUser(netId);
        if (config != null) {
            if ((info.is24GHz() && info.getRssi()
                    <= WifiQualifiedNetworkSelector.QUALIFIED_RSSI_24G_BAND)
                    || (info.is5GHz() && info.getRssi()
                    <= WifiQualifiedNetworkSelector.QUALIFIED_RSSI_5G_BAND)) {
                // We do not block due to bad RSSI since network selection should not select bad
                // RSSI candidate
            } else {
                // We got disabled but RSSI is good, so disable hard
                updateNetworkSelectionStatus(config,
                        WifiConfiguration.NetworkSelectionStatus.DISABLED_BAD_LINK);
            }
        }
        // Record last time Connectivity Service switched us away from WiFi and onto Cell
        mLastUnwantedNetworkDisconnectTimestamp = mClock.currentTimeMillis();
!!!36820535.java!!!	getMaxDhcpRetries() : int
        return mFacade.getIntegerSetting(mContext,
                Settings.Global.WIFI_MAX_DHCP_RETRY_COUNT,
                DEFAULT_MAX_DHCP_RETRIES);
!!!36820663.java!!!	clearBssidBlacklist() : void
        mWifiConfigStore.clearBssidBlacklist();
!!!36820791.java!!!	blackListBssid(inout bssid : String) : void
        mWifiConfigStore.blackListBssid(bssid);
!!!36820919.java!!!	isBssidBlacklisted(inout bssid : String) : boolean
        return mWifiConfigStore.isBssidBlacklisted(bssid);
!!!36821047.java!!!	getEnableAutoJoinWhenAssociated() : boolean
        return mEnableAutoJoinWhenAssociated.get();
!!!36821175.java!!!	setEnableAutoJoinWhenAssociated(inout enabled : boolean) : void
        mEnableAutoJoinWhenAssociated.set(enabled);
!!!36821303.java!!!	setActiveScanDetail(inout activeScanDetail : ScanDetail) : void
        synchronized (mActiveScanDetailLock) {
            mActiveScanDetail = activeScanDetail;
        }
!!!36821431.java!!!	wasEphemeralNetworkDeleted(inout ssid : String) : boolean
        return mDeletedEphemeralSSIDs.contains(ssid);
