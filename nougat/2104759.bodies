class WifiLastResortWatchdogTest
!!!37177271.java!!!	setUp() : void
        mWifiMetrics = mock(WifiMetrics.class);
        mLastResortWatchdog = new WifiLastResortWatchdog(mWifiMetrics);
!!!37177399.java!!!	createFilteredQnsCandidates(inout ssids : String, inout bssids : String, inout frequencies : int, inout caps : String, inout levels : int, inout isEphemeral : boolean) : Pair
        List<Pair<ScanDetail, WifiConfiguration>> candidates = new ArrayList<>();
        long timeStamp = System.currentTimeMillis();
        for (int index = 0; index < ssids.length; index++) {
            String ssid = ssids[index].replaceAll("^\"+", "").replaceAll("\"+$", "");
            ScanDetail scanDetail = new ScanDetail(WifiSsid.createFromAsciiEncoded(ssid),
                    bssids[index], caps[index], levels[index], frequencies[index], timeStamp,
                    0);
            WifiConfiguration config = null;
            if (!isEphemeral[index]) {
                config = mock(WifiConfiguration.class);
                WifiConfiguration.NetworkSelectionStatus networkSelectionStatus =
                        mock(WifiConfiguration.NetworkSelectionStatus.class);
                when(config.getNetworkSelectionStatus()).thenReturn(networkSelectionStatus);
                when(networkSelectionStatus.getHasEverConnected()).thenReturn(true);
            }
            candidates.add(Pair.create(scanDetail, config));
        }
        return candidates;
!!!37177527.java!!!	createFilteredQnsCandidates(inout ssids : String, inout bssids : String, inout frequencies : int, inout caps : String, inout levels : int, inout isEphemeral : boolean, inout hasEverConnected : boolean) : Pair
        List<Pair<ScanDetail, WifiConfiguration>> candidates =
                new ArrayList<Pair<ScanDetail, WifiConfiguration>>();
        long timeStamp = System.currentTimeMillis();
        for (int index = 0; index < ssids.length; index++) {
            String ssid = ssids[index].replaceAll("^\"+", "").replaceAll("\"+$", "");
            ScanDetail scanDetail = new ScanDetail(WifiSsid.createFromAsciiEncoded(ssid),
                    bssids[index], caps[index], levels[index], frequencies[index], timeStamp,
                    0);
            WifiConfiguration config = null;
            if (!isEphemeral[index]) {
                config = mock(WifiConfiguration.class);
                WifiConfiguration.NetworkSelectionStatus networkSelectionStatus =
                        mock(WifiConfiguration.NetworkSelectionStatus.class);
                when(config.getNetworkSelectionStatus()).thenReturn(networkSelectionStatus);
                when(networkSelectionStatus.getHasEverConnected())
                        .thenReturn(hasEverConnected[index]);
            }
            candidates.add(Pair.create(scanDetail, config));
        }
        return candidates;
!!!37177655.java!!!	assertFailureCountEquals(inout bssid : String, in associationRejections : int, in authenticationFailures : int, in dhcpFailures : int) : void
        assertEquals(associationRejections, mLastResortWatchdog.getFailureCount(bssid,
                WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION));
        assertEquals(authenticationFailures, mLastResortWatchdog.getFailureCount(bssid,
                WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION));
        assertEquals(dhcpFailures, mLastResortWatchdog.getFailureCount(bssid,
                WifiLastResortWatchdog.FAILURE_CODE_DHCP));
!!!37177783.java!!!	testAvailableNetworkBuffering_ageCullingWorks() : void
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral);
        mLastResortWatchdog.updateAvailableNetworks(candidates);
        assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().size(), 4);

        // Repeatedly buffer candidates 1 & 2, MAX_BSSID_AGE - 1 times
        candidates = createFilteredQnsCandidates(Arrays.copyOfRange(mSsids, 0, 2),
                Arrays.copyOfRange(mBssids, 0, 2),
                Arrays.copyOfRange(mFrequencies, 0, 2),
                Arrays.copyOfRange(mCaps, 0, 2),
                Arrays.copyOfRange(mLevels, 0, 2),
                Arrays.copyOfRange(mIsEphemeral, 0, 2));
        for (int i = 0; i < WifiLastResortWatchdog.MAX_BSSID_AGE - 1; i++) {
            mLastResortWatchdog.updateAvailableNetworks(candidates);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().get(mBssids[0]).age, 0);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().get(mBssids[1]).age, 0);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().get(mBssids[2]).age,
                    i + 1);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().get(mBssids[3]).age,
                    i + 1);
        }
        assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().size(), 4);

        // One more buffering should age and cull candidates 2 & 3
        mLastResortWatchdog.updateAvailableNetworks(candidates);
        assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().size(), 2);
!!!37177911.java!!!	testAvailableNetworkBuffering_emptyBufferWithEmptyScanResults() : void
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral);
        mLastResortWatchdog.updateAvailableNetworks(candidates);
        assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().size(), 4);

        // Repeatedly buffer with no candidates
        candidates = createFilteredQnsCandidates(Arrays.copyOfRange(mSsids, 0, 0),
                Arrays.copyOfRange(mBssids, 0, 0),
                Arrays.copyOfRange(mFrequencies, 0, 0),
                Arrays.copyOfRange(mCaps, 0, 0),
                Arrays.copyOfRange(mLevels, 0, 0),
                Arrays.copyOfRange(mIsEphemeral, 0, 0));
        for (int i = 0; i < WifiLastResortWatchdog.MAX_BSSID_AGE; i++) {
            mLastResortWatchdog.updateAvailableNetworks(candidates);
        }
        assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().size(), 0);
        for (int i = 0; i < WifiLastResortWatchdog.MAX_BSSID_AGE; i++) {
            mLastResortWatchdog.updateAvailableNetworks(candidates);
        }
        assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().size(), 0);
!!!37178039.java!!!	testAvailableNetworkBuffering_addNewNetworksOverTime() : void
        List<Pair<ScanDetail, WifiConfiguration>> candidates;
        // Buffer (i) scan results with each successive scan result
        for (int i = 1; i <= mSsids.length; i++) {
            candidates = createFilteredQnsCandidates(Arrays.copyOfRange(mSsids, 0, i),
                    Arrays.copyOfRange(mBssids, 0, i),
                    Arrays.copyOfRange(mFrequencies, 0, i),
                    Arrays.copyOfRange(mCaps, 0, i),
                    Arrays.copyOfRange(mLevels, 0, i),
                    Arrays.copyOfRange(mIsEphemeral, 0, i));
            mLastResortWatchdog.updateAvailableNetworks(candidates);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().size(), i);
            for (int j = 0; j < i; j++) {
                assertEquals(
                        mLastResortWatchdog.getRecentAvailableNetworks().get(mBssids[j]).age, 0);
            }
        }
!!!37178167.java!!!	testAvailableNetworkBuffering_multipleNetworksSomeEphemeral() : void
        boolean[] isEphemeral = {true, false, true, false};

        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, isEphemeral);
        mLastResortWatchdog.updateAvailableNetworks(candidates);
        assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().size(), 4);

        // Repeatedly buffer candidates 1 & 2, MAX_BSSID_AGE - 1 times
        candidates = createFilteredQnsCandidates(Arrays.copyOfRange(mSsids, 0, 2),
                Arrays.copyOfRange(mBssids, 0, 2),
                Arrays.copyOfRange(mFrequencies, 0, 2),
                Arrays.copyOfRange(mCaps, 0, 2),
                Arrays.copyOfRange(mLevels, 0, 2),
                Arrays.copyOfRange(isEphemeral, 0, 2));
        for (int i = 0; i < WifiLastResortWatchdog.MAX_BSSID_AGE - 1; i++) {
            mLastResortWatchdog.updateAvailableNetworks(candidates);
            mLastResortWatchdog.toString();
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().get(mBssids[0]).age, 0);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().get(mBssids[1]).age, 0);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().get(mBssids[2]).age,
                    i + 1);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().get(mBssids[3]).age,
                    i + 1);
        }
        assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().size(), 4);

        // One more buffering should age and cull candidates 2 & 3
        mLastResortWatchdog.updateAvailableNetworks(candidates);
        assertEquals(mLastResortWatchdog.getRecentAvailableNetworks().size(), 2);
        mLastResortWatchdog.toString();
!!!37178295.java!!!	testFailureCounting_countFailuresForSingleBssid() : void
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).associationRejection);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).authenticationFailure);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).dhcpFailure);
        }
        assertFailureCountEquals(mBssids[0], associationRejections, 0, 0);
        assertFailureCountEquals(mBssids[1], 0, authenticationFailures, 0);
        assertFailureCountEquals(mBssids[2], 0, 0, dhcpFailures);
        assertFailureCountEquals(mBssids[3], 0, 0, 0);
!!!37178423.java!!!	testFailureCounting_countFailuresForSingleBssidWithEphemeral() : void
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;
        boolean[] mIsEphemeral = {false, true, false, true};
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).associationRejection, i + 1);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).authenticationFailure, i + 1);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).dhcpFailure, i + 1);
        }
        assertFailureCountEquals(mBssids[0], associationRejections, 0, 0);
        assertFailureCountEquals(mBssids[1], 0, authenticationFailures, 0);
        assertFailureCountEquals(mBssids[2], 0, 0, dhcpFailures);
        assertFailureCountEquals(mBssids[3], 0, 0, 0);
!!!37178551.java!!!	testFailureCounting_countFailuresForSingleBssidWrongSsid() : void
        String badSsid = "ItHertzWhenIP";
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(badSsid, mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(badSsid, mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(badSsid, mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
        }

        // Ensure all networks still have zero failure count
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }
!!!37178679.java!!!	testFailureCounting_countFailuresForNonexistentBssid() : void
        String badBssid = "de:ad:be:ee:e3:ef";
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], badBssid,
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], badBssid,
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], badBssid,
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
        }

        // Ensure all networks still have zero failure count
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }
!!!37178807.java!!!	testFailureCounting_countFailuresForAnyBssid() : void
        String[] ssids = {"\"test1\"", "\"test2\"", "\"test1\"", "\"test4\""};
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(ssids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < ssids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[0], WifiLastResortWatchdog.BSSID_ANY,
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[0], WifiLastResortWatchdog.BSSID_ANY,
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[0], WifiLastResortWatchdog.BSSID_ANY,
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
        }
        assertFailureCountEquals(mBssids[0], associationRejections, authenticationFailures,
                dhcpFailures);
        assertFailureCountEquals(mBssids[1], 0, 0, 0);
        assertFailureCountEquals(mBssids[2], associationRejections, authenticationFailures,
                dhcpFailures);
        assertFailureCountEquals(mBssids[3], 0, 0, 0);
!!!37178935.java!!!	testFailureCounting_countFailuresForAnyBssidNonexistentSsid() : void
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;
        String badSsid = "DropItLikeIt'sHotSpot";
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    badSsid, WifiLastResortWatchdog.BSSID_ANY,
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    badSsid, WifiLastResortWatchdog.BSSID_ANY,
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    badSsid, WifiLastResortWatchdog.BSSID_ANY,
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
        }
        // Check that all network failure counts are still zero
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }
!!!37179063.java!!!	testFailureCounting_failureOverThresholdCheck() : void
        int associationRejections = WifiLastResortWatchdog.FAILURE_THRESHOLD;
        int authenticationFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD;
        int dhcpFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
        }
        assertEquals(true, mLastResortWatchdog.isOverFailureThreshold(mBssids[0]));
        assertEquals(true, mLastResortWatchdog.isOverFailureThreshold(mBssids[1]));
        assertEquals(true, mLastResortWatchdog.isOverFailureThreshold(mBssids[2]));
        assertEquals(false, mLastResortWatchdog.isOverFailureThreshold(mBssids[3]));
!!!37179191.java!!!	testFailureCounting_failureUnderThresholdCheck() : void
        int associationRejections = WifiLastResortWatchdog.FAILURE_THRESHOLD - 1;
        int authenticationFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD - 1;
        int dhcpFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD - 1;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
        }
        assertEquals(false, mLastResortWatchdog.isOverFailureThreshold(mBssids[0]));
        assertEquals(false, mLastResortWatchdog.isOverFailureThreshold(mBssids[1]));
        assertEquals(false, mLastResortWatchdog.isOverFailureThreshold(mBssids[2]));
        assertEquals(false, mLastResortWatchdog.isOverFailureThreshold(mBssids[3]));
!!!37179319.java!!!	testAvailableNetworkBuffering_doesNotAffectFailureCounts() : void
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).associationRejection);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).authenticationFailure);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).dhcpFailure);
        }
        // Check Each Network has appropriate failure count
        assertFailureCountEquals(mBssids[0], associationRejections, 0, 0);
        assertFailureCountEquals(mBssids[1], 0, authenticationFailures, 0);
        assertFailureCountEquals(mBssids[2], 0, 0, dhcpFailures);
        assertFailureCountEquals(mBssids[3], 0, 0, 0);

        // Re-buffer all networks
        for (int i = 0; i < WifiLastResortWatchdog.MAX_BSSID_AGE; i++) {
            mLastResortWatchdog.updateAvailableNetworks(candidates);
        }

        // Check Each Network still has appropriate failure count
        assertFailureCountEquals(mBssids[0], associationRejections, 0, 0);
        assertFailureCountEquals(mBssids[1], 0, authenticationFailures, 0);
        assertFailureCountEquals(mBssids[2], 0, 0, dhcpFailures);
        assertFailureCountEquals(mBssids[3], 0, 0, 0);
!!!37179447.java!!!	testAvailableNetworkBuffering_rebufferWipesCounts() : void
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).associationRejection);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).authenticationFailure);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).dhcpFailure);
        }
        // Check Each Network has appropriate failure count
        assertFailureCountEquals(mBssids[0], associationRejections, 0, 0);
        assertFailureCountEquals(mBssids[1], 0, authenticationFailures, 0);
        assertFailureCountEquals(mBssids[2], 0, 0, dhcpFailures);
        assertFailureCountEquals(mBssids[3], 0, 0, 0);

        // Re-buffer all networks except 'test1' until it dies of old age
        candidates = createFilteredQnsCandidates(Arrays.copyOfRange(mSsids, 1, 4),
                Arrays.copyOfRange(mBssids, 1, 4),
                Arrays.copyOfRange(mFrequencies, 1, 4),
                Arrays.copyOfRange(mCaps, 1, 4),
                Arrays.copyOfRange(mLevels, 1, 4),
                Arrays.copyOfRange(mIsEphemeral, 1, 4));
        for (int i = 0; i < WifiLastResortWatchdog.MAX_BSSID_AGE; i++) {
            mLastResortWatchdog.updateAvailableNetworks(candidates);
        }
        assertEquals(3, mLastResortWatchdog.getRecentAvailableNetworks().size());
        // Re-buffer All networks, with 'test1' again
        candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Check Each Network has appropriate failure count (network 1 should be zero'd)
        assertFailureCountEquals(mBssids[0], 0, 0, 0);
        assertFailureCountEquals(mBssids[1], 0, authenticationFailures, 0);
        assertFailureCountEquals(mBssids[2], 0, 0, dhcpFailures);
        assertFailureCountEquals(mBssids[3], 0, 0, 0);
!!!37179575.java!!!	testFailureCounting_nullInputsNoBreaky() : void
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(null, mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], null,
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(null, null,
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
        }

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }
!!!37179703.java!!!	testFailureCounting_countFailuresAcrossSsids() : void
        String[] ssids = {"\"test1\"", "\"test2\"", "\"test3\"", "\"test4\"",
                "\"test1\"", "\"test2\"", "\"test3\"", "\"test4\""};
        String[] bssids = {"6c:f3:7f:ae:8c:f3", "6c:f3:7f:ae:8c:f4", "de:ad:ba:b1:e5:55",
                "c0:ff:ee:ee:e3:ee", "6c:f3:7f:ae:3c:f3", "6c:f3:7f:ae:3c:f4", "d3:ad:ba:b1:35:55",
                "c0:ff:ee:ee:33:ee"};
        int[] frequencies = {2437, 5180, 5180, 2437, 2437, 5180, 5180, 2437};
        String[] caps = {"[WPA2-EAP-CCMP][ESS]", "[WPA2-EAP-CCMP][ESS]",
                "[WPA2-EAP-CCMP][ESS]", "[WPA2-EAP-CCMP][ESS]", "[WPA2-EAP-CCMP][ESS]",
                "[WPA2-EAP-CCMP][ESS]", "[WPA2-EAP-CCMP][ESS]", "[WPA2-EAP-CCMP][ESS]"};
        int[] levels = {-60, -86, -50, -62, -60, -86, -50, -62};
        boolean[] isEphemeral = {false, false, false, false, false, false, false, false};
        boolean[] hasEverConnected = {false, false, false, false, false, false, false,
                false};
        int firstNetFails = 13;
        int secondNetFails = 8;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(ssids,
                bssids, frequencies, caps, levels, isEphemeral, hasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < ssids.length; i++) {
            assertFailureCountEquals(bssids[i], 0, 0, 0);
        }

        //Increment failure count for the first test network ssid & bssid
        for (int i = 0; i < firstNetFails; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[0], bssids[0], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[0], bssids[0], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[0], bssids[0], WifiLastResortWatchdog.FAILURE_CODE_DHCP);
        }
        //Increment failure count for the first test network ssid & BSSID_ANY
        for (int i = 0; i < secondNetFails; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[1], WifiLastResortWatchdog.BSSID_ANY,
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[1], WifiLastResortWatchdog.BSSID_ANY,
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[1], WifiLastResortWatchdog.BSSID_ANY,
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
        }
        assertFailureCountEquals(bssids[0], firstNetFails, firstNetFails, firstNetFails);
        assertFailureCountEquals(bssids[1], secondNetFails, secondNetFails, secondNetFails);
        assertFailureCountEquals(bssids[2], 0, 0, 0);
        assertFailureCountEquals(bssids[3], 0, 0, 0);
        assertFailureCountEquals(bssids[4], firstNetFails, firstNetFails, firstNetFails);
        assertFailureCountEquals(bssids[5], secondNetFails, secondNetFails, secondNetFails);
        assertFailureCountEquals(bssids[6], 0, 0, 0);
        assertFailureCountEquals(bssids[7], 0, 0, 0);
!!!37179831.java!!!	testFailureCounting_wifiIsConnectedDoesNotAffectCounting() : void
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;

        // Set Watchdogs internal wifi state tracking to 'connected'
        mLastResortWatchdog.connectedStateTransition(true);

        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).associationRejection);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).authenticationFailure);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(i + 1, mLastResortWatchdog.getRecentAvailableNetworks()
                    .get(mBssids[net]).dhcpFailure);
        }
        assertFailureCountEquals(mBssids[0], associationRejections, 0, 0);
        assertFailureCountEquals(mBssids[1], 0, authenticationFailures, 0);
        assertFailureCountEquals(mBssids[2], 0, 0, dhcpFailures);
        assertFailureCountEquals(mBssids[3], 0, 0, 0);
!!!37179959.java!!!	testFailureCounting_enteringWifiConnectedStateClearsCounts() : void
        int associationRejections = 5;
        int authenticationFailures = 9;
        int dhcpFailures = 11;

        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        //Increment failure count for each network and failure type
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(mSsids[net], mBssids[net],
                    WifiLastResortWatchdog.FAILURE_CODE_DHCP);
        }

        // Check that we have Failures
        assertFailureCountEquals(mBssids[0], associationRejections, 0, 0);
        assertFailureCountEquals(mBssids[1], 0, authenticationFailures, 0);
        assertFailureCountEquals(mBssids[2], 0, 0, dhcpFailures);

        // Transition to 'ConnectedState'
        mLastResortWatchdog.connectedStateTransition(true);

        // Check that we have no failures
        for (int i = 0; i < mSsids.length; i++) {
            assertFailureCountEquals(mBssids[i], 0, 0, 0);
        }
!!!37180087.java!!!	testTriggerCondition_someNetworksOverFailureThreshold_allHaveEverConnected() : void
        int associationRejections = WifiLastResortWatchdog.FAILURE_THRESHOLD;
        int authenticationFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 2;
        int dhcpFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 3;
        boolean[] hasEverConnected = {true, true, true, true};

        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, hasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Increment failure count for 3 networks and failure types, asserting each time that it
        // does not trigger, with only 3 over threshold
        boolean watchdogTriggered = false;
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(false, watchdogTriggered);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(false, watchdogTriggered);
        }

        // Check that we have Failures
        assertFailureCountEquals(mBssids[0], associationRejections, 0, 0);
        assertFailureCountEquals(mBssids[1], 0, authenticationFailures, 0);
        assertFailureCountEquals(mBssids[2], 0, 0, dhcpFailures);

        // Add one more failure to one of the already over threshold networks, assert that it
        // does not trigger
        watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[0], mBssids[0], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        assertEquals(false, watchdogTriggered);
!!!37180215.java!!!	testTriggerCondition_allNetworksOverFailureThreshold_allHaveEverConnected() : void
        int associationRejections = WifiLastResortWatchdog.FAILURE_THRESHOLD;
        int authenticationFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 2;
        int dhcpFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 3;
        boolean[] hasEverConnected = {true, true, true, true};

        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, hasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Bring 3 of the 4 networks over failure Threshold without triggering watchdog
        boolean watchdogTriggered = false;
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(false, watchdogTriggered);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(false, watchdogTriggered);
        }

        // Bring the remaining unfailed network upto 1 less than the failure threshold
        net = 3;
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD - 1; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
        // Increment failure count once more, check that watchdog triggered this time
        watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        mLastResortWatchdog.updateAvailableNetworks(candidates);
        assertEquals(true, watchdogTriggered);

        // Increment failure count 5 more times, watchdog should not trigger
        for (int i = 0; i < 5; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                        mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
!!!37180343.java!!!	testTriggerCondition_allNetworksOverFailureThreshold_oneHaveEverConnected() : void
        int associationRejections = WifiLastResortWatchdog.FAILURE_THRESHOLD;
        int authenticationFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 2;
        int dhcpFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 3;
        boolean[] hasEverConnected = {false, true, false, false};

        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, hasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Bring 3 of the 4 networks over failure Threshold without triggering watchdog
        boolean watchdogTriggered = false;
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(false, watchdogTriggered);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(false, watchdogTriggered);
        }

        // Bring the remaining unfailed network upto 1 less than the failure threshold
        net = 3;
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD - 1; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
        // Increment failure count once more, check that watchdog triggered this time
        watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        mLastResortWatchdog.updateAvailableNetworks(candidates);
        assertEquals(true, watchdogTriggered);

        // Increment failure count 5 more times, watchdog should not trigger
        for (int i = 0; i < 5; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                        mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
!!!37180471.java!!!	testTriggerCondition_allNetworksOverFailureThreshold_zeroHaveEverConnected() : void
        int associationRejections = WifiLastResortWatchdog.FAILURE_THRESHOLD + 1;
        int authenticationFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 2;
        int dhcpFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 3;

        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Count failures on all 4 networks until all of them are over the failure threshold
        boolean watchdogTriggered = false;
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(false, watchdogTriggered);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(false, watchdogTriggered);
        }
        net = 3;
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD + 1; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
!!!37180599.java!!!	testTriggerCondition_allNetworksOverFailureThreshold_isConnected() : void
        int associationRejections = WifiLastResortWatchdog.FAILURE_THRESHOLD + 1;
        int authenticationFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 2;
        int dhcpFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 3;

        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, mHasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Set Watchdogs internal wifi state tracking to 'connected'
        mLastResortWatchdog.connectedStateTransition(true);

        // Count failures on all 4 networks until all of them are over the failure threshold
        boolean watchdogTriggered = false;
        int net = 0;
        for (int i = 0; i < associationRejections; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
        net = 1;
        for (int i = 0; i < authenticationFailures; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(false, watchdogTriggered);
        }
        net = 2;
        for (int i = 0; i < dhcpFailures; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(false, watchdogTriggered);
        }
        net = 3;
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD + 1; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[net], mBssids[net], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
!!!37180727.java!!!	incrementFailuresUntilTrigger(inout ssids : String, inout bssids : String) : void
        // Bring 3 of the 4 networks over failure Threshold without triggering watchdog
        boolean watchdogTriggered = false;
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD; i++) {
            for (int j = 0; j < ssids.length - 1; j++) {
                watchdogTriggered = mLastResortWatchdog
                        .noteConnectionFailureAndTriggerIfNeeded(ssids[j], bssids[j],
                        WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
                assertEquals(false, watchdogTriggered);
            }
        }
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD - 1; i++) {
            watchdogTriggered = mLastResortWatchdog
                    .noteConnectionFailureAndTriggerIfNeeded(ssids[ssids.length - 1],
                    bssids[ssids.length - 1], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }

        // Increment failure count once more, check that watchdog triggered this time
        watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[ssids.length - 1], bssids[ssids.length - 1],
                    WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        assertEquals(true, watchdogTriggered);
!!!37180855.java!!!	testTriggerEnabling_disabledAfterTriggering() : void
        int associationRejections = WifiLastResortWatchdog.FAILURE_THRESHOLD;
        int authenticationFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 2;
        int dhcpFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 3;
        boolean[] hasEverConnected = {false, true, false, false};

        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, hasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        incrementFailuresUntilTrigger(mSsids, mBssids);

        // Increment failure count 5 more times, watchdog should not trigger
        for (int i = 0; i < 5; i++) {
            boolean watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                        mSsids[3], mBssids[3], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
!!!37180983.java!!!	testTriggerEnabling_enabledAfterConnecting() : void
        int associationRejections = WifiLastResortWatchdog.FAILURE_THRESHOLD;
        int authenticationFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 2;
        int dhcpFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 3;
        boolean[] hasEverConnected = {false, true, false, false};
        boolean watchdogTriggered;
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(mSsids,
                mBssids, mFrequencies, mCaps, mLevels, mIsEphemeral, hasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        incrementFailuresUntilTrigger(mSsids, mBssids);

        // Increment failure count 5 more times, ensure trigger is deactivated
        for (int i = 0; i < 5; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                        mSsids[3], mBssids[3], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            mLastResortWatchdog.updateAvailableNetworks(candidates);
            assertEquals(false, watchdogTriggered);
        }

        // transition Watchdog wifi state tracking to 'connected' then back to 'disconnected'
        mLastResortWatchdog.connectedStateTransition(true);
        mLastResortWatchdog.connectedStateTransition(false);

        // Fail 3/4 networks until they're over threshold
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD + 1; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[0], mBssids[0], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[1], mBssids[1], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            assertEquals(false, watchdogTriggered);
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[2], mBssids[2], WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            assertEquals(false, watchdogTriggered);
        }

        // Bring the remaining unfailed network upto 1 less than the failure threshold
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD - 1; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[3], mBssids[3], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            assertEquals(false, watchdogTriggered);
        }
        // Increment failure count once more, check that watchdog triggered this time
        watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[3], mBssids[3], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        assertEquals(true, watchdogTriggered);
!!!37181111.java!!!	testTriggerEnabling_enabledAfterNewNetwork() : void
        int associationRejections = WifiLastResortWatchdog.FAILURE_THRESHOLD;
        int authenticationFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 2;
        int dhcpFailures = WifiLastResortWatchdog.FAILURE_THRESHOLD + 3;
        boolean[] hasEverConnected = {false, true, false, false};
        boolean watchdogTriggered;

        // Buffer potential candidates 1,2,3
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(
                Arrays.copyOfRange(mSsids, 0, 3),
                Arrays.copyOfRange(mBssids, 0, 3),
                Arrays.copyOfRange(mFrequencies, 0, 3),
                Arrays.copyOfRange(mCaps, 0, 3),
                Arrays.copyOfRange(mLevels, 0, 3),
                Arrays.copyOfRange(mIsEphemeral, 0, 3),
                Arrays.copyOfRange(hasEverConnected, 0, 3));
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        incrementFailuresUntilTrigger(Arrays.copyOfRange(mSsids, 0, 3),
                Arrays.copyOfRange(mBssids, 0, 3));

        // Increment failure count 5 more times, ensure trigger is deactivated
        for (int i = 0; i < 5; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                        mSsids[2], mBssids[2], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            mLastResortWatchdog.updateAvailableNetworks(candidates);
            assertEquals(false, watchdogTriggered);
        }

        candidates = createFilteredQnsCandidates(mSsids, mBssids, mFrequencies, mCaps, mLevels,
                mIsEphemeral, hasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        incrementFailuresUntilTrigger(mSsids, mBssids);

!!!37181239.java!!!	testMetricsCollection() : void
        String[] ssids = {"\"test1\"", "\"test2\"", "\"test3\"", "\"test4\"", "\"test5\""};
        String[] bssids = {"6c:f3:7f:ae:8c:f3", "6c:f3:7f:ae:8c:f4", "de:ad:ba:b1:e5:55",
                "c0:ff:ee:ee:e3:ee", "6c:f3:7f:ae:3c:f3"};
        int[] frequencies = {2437, 5180, 5180, 2437, 2437};
        String[] caps = {"[WPA2-EAP-CCMP][ESS]", "[WPA2-EAP-CCMP][ESS]",
                "[WPA2-EAP-CCMP][ESS]", "[WPA2-EAP-CCMP][ESS]", "[WPA2-EAP-CCMP][ESS]"};
        int[] levels = {-60, -86, -50, -62, -60};
        boolean[] isEphemeral = {false, false, false, false, false};
        boolean[] hasEverConnected = {true, false, false, false, false};
        // Buffer potential candidates 1,2,3 & 4
        List<Pair<ScanDetail, WifiConfiguration>> candidates = createFilteredQnsCandidates(ssids,
                bssids, frequencies, caps, levels, isEphemeral, hasEverConnected);
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        // Ensure new networks have zero'ed failure counts
        for (int i = 0; i < ssids.length; i++) {
            assertFailureCountEquals(bssids[i], 0, 0, 0);
        }

        //Increment failure count for the first test network ssid & bssid
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD; i++) {
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[1], bssids[1], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[2], bssids[2], WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[3], bssids[3], WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[4], bssids[4], WifiLastResortWatchdog.FAILURE_CODE_DHCP);
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[4], bssids[4], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    ssids[0], bssids[0], WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
        }

        // Verify relevant WifiMetrics calls were made once with appropriate arguments
        verify(mWifiMetrics, times(1)).incrementNumLastResortWatchdogTriggers();
        verify(mWifiMetrics, times(1)).addCountToNumLastResortWatchdogAvailableNetworksTotal(5);
        verify(mWifiMetrics, times(1))
                .addCountToNumLastResortWatchdogBadAuthenticationNetworksTotal(2);
        verify(mWifiMetrics, times(1))
                .incrementNumLastResortWatchdogTriggersWithBadAuthentication();
        verify(mWifiMetrics, times(1))
                .addCountToNumLastResortWatchdogBadAssociationNetworksTotal(1);
        verify(mWifiMetrics, times(1)).incrementNumLastResortWatchdogTriggersWithBadAssociation();
        verify(mWifiMetrics, times(1)).addCountToNumLastResortWatchdogBadDhcpNetworksTotal(3);
        verify(mWifiMetrics, times(1)).incrementNumLastResortWatchdogTriggersWithBadDhcp();
!!!37181367.java!!!	testUpdateNetworkWithNullConfig() : void
        List<Pair<ScanDetail, WifiConfiguration>> candidates =
                new ArrayList<Pair<ScanDetail, WifiConfiguration>>();
        String ssid = mSsids[0].replaceAll("^\"+", "").replaceAll("\"+$", "");
        ScanDetail scanDetail = new ScanDetail(WifiSsid.createFromAsciiEncoded(ssid),
                mBssids[0], mCaps[0], mLevels[0], mFrequencies[0], System.currentTimeMillis(), 0);
        WifiConfiguration config = mock(WifiConfiguration.class);
        WifiConfiguration.NetworkSelectionStatus networkSelectionStatus =
                mock(WifiConfiguration.NetworkSelectionStatus.class);
        when(config.getNetworkSelectionStatus()).thenReturn(networkSelectionStatus);
        when(networkSelectionStatus.getHasEverConnected())
                .thenReturn(true);
        candidates.add(Pair.create(scanDetail, config));
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        candidates.clear();

        candidates.add(Pair.create(scanDetail, null));
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        boolean watchdogTriggered = false;
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[0], mBssids[0], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        assertEquals(true, watchdogTriggered);
!!!37181495.java!!!	testUpdateNetworkWithHasEverConnectedTrue() : void
        List<Pair<ScanDetail, WifiConfiguration>> candidates =
                new ArrayList<Pair<ScanDetail, WifiConfiguration>>();
        String ssid = mSsids[0].replaceAll("^\"+", "").replaceAll("\"+$", "");
        ScanDetail scanDetail = new ScanDetail(WifiSsid.createFromAsciiEncoded(ssid),
                mBssids[0], mCaps[0], mLevels[0], mFrequencies[0], System.currentTimeMillis(), 0);
        WifiConfiguration configHasEverConnectedFalse = mock(WifiConfiguration.class);
        WifiConfiguration.NetworkSelectionStatus networkSelectionStatusFalse =
                mock(WifiConfiguration.NetworkSelectionStatus.class);
        when(configHasEverConnectedFalse.getNetworkSelectionStatus())
                .thenReturn(networkSelectionStatusFalse);
        when(networkSelectionStatusFalse.getHasEverConnected())
                .thenReturn(false);
        candidates.add(Pair.create(scanDetail, configHasEverConnectedFalse));
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        boolean watchdogTriggered = false;
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[0], mBssids[0], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        assertEquals(false, watchdogTriggered);

        candidates.clear();

        WifiConfiguration configHasEverConnectedTrue = mock(WifiConfiguration.class);
        WifiConfiguration.NetworkSelectionStatus networkSelectionStatusTrue =
                mock(WifiConfiguration.NetworkSelectionStatus.class);
        when(configHasEverConnectedTrue.getNetworkSelectionStatus())
                .thenReturn(networkSelectionStatusTrue);
        when(networkSelectionStatusTrue.getHasEverConnected())
                .thenReturn(true);
        candidates.add(Pair.create(scanDetail, configHasEverConnectedTrue));
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                mSsids[0], mBssids[0], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        assertEquals(true, watchdogTriggered);
!!!37181623.java!!!	testUpdateNetworkWithHasEverConnectedFalse() : void
        List<Pair<ScanDetail, WifiConfiguration>> candidates =
                new ArrayList<Pair<ScanDetail, WifiConfiguration>>();
        String ssid = mSsids[0].replaceAll("^\"+", "").replaceAll("\"+$", "");
        ScanDetail scanDetail = new ScanDetail(WifiSsid.createFromAsciiEncoded(ssid),
                mBssids[0], mCaps[0], mLevels[0], mFrequencies[0], System.currentTimeMillis(), 0);

        WifiConfiguration configHasEverConnectedTrue = mock(WifiConfiguration.class);
        WifiConfiguration.NetworkSelectionStatus networkSelectionStatusTrue =
                mock(WifiConfiguration.NetworkSelectionStatus.class);
        when(configHasEverConnectedTrue.getNetworkSelectionStatus())
                .thenReturn(networkSelectionStatusTrue);
        when(networkSelectionStatusTrue.getHasEverConnected())
                .thenReturn(true);
        candidates.add(Pair.create(scanDetail, configHasEverConnectedTrue));
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        boolean watchdogTriggered = false;
        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[0], mBssids[0], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        assertEquals(true, watchdogTriggered);

        candidates.clear();

        WifiConfiguration configHasEverConnectedFalse = mock(WifiConfiguration.class);
        WifiConfiguration.NetworkSelectionStatus networkSelectionStatusFalse =
                mock(WifiConfiguration.NetworkSelectionStatus.class);
        when(configHasEverConnectedFalse.getNetworkSelectionStatus())
                .thenReturn(networkSelectionStatusFalse);
        when(networkSelectionStatusFalse.getHasEverConnected())
                .thenReturn(false);
        candidates.add(Pair.create(scanDetail, configHasEverConnectedFalse));
        mLastResortWatchdog.updateAvailableNetworks(candidates);

        for (int i = 0; i < WifiLastResortWatchdog.FAILURE_THRESHOLD; i++) {
            watchdogTriggered = mLastResortWatchdog.noteConnectionFailureAndTriggerIfNeeded(
                    mSsids[0], mBssids[0], WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
        }
        assertEquals(false, watchdogTriggered);
!!!37181751.java!!!	testHasEverConnectedValueInAvailableNetworkFailureCountToString() : void
        // Check with HasEverConnected true
        WifiConfiguration configHasEverConnectedTrue = mock(WifiConfiguration.class);
        WifiConfiguration.NetworkSelectionStatus networkSelectionStatusTrue =
                mock(WifiConfiguration.NetworkSelectionStatus.class);
        when(configHasEverConnectedTrue.getNetworkSelectionStatus())
                .thenReturn(networkSelectionStatusTrue);
        when(networkSelectionStatusTrue.getHasEverConnected()).thenReturn(true);
        WifiLastResortWatchdog.AvailableNetworkFailureCount withConfigHECTrue =
                new WifiLastResortWatchdog.AvailableNetworkFailureCount(configHasEverConnectedTrue);
        String output = withConfigHECTrue.toString();
        assertTrue(output.contains("HasEverConnected: true"));

        // check with HasEverConnected false
        WifiConfiguration configHasEverConnectedFalse = mock(WifiConfiguration.class);
        WifiConfiguration.NetworkSelectionStatus networkSelectionStatusFalse =
                mock(WifiConfiguration.NetworkSelectionStatus.class);
        when(configHasEverConnectedFalse.getNetworkSelectionStatus())
                .thenReturn(networkSelectionStatusFalse);
        when(networkSelectionStatusFalse.getHasEverConnected()).thenReturn(false);
        WifiLastResortWatchdog.AvailableNetworkFailureCount withConfigHECFalse =
                new WifiLastResortWatchdog.AvailableNetworkFailureCount(
                        configHasEverConnectedFalse);
        output = withConfigHECFalse.toString();
        assertTrue(output.contains("HasEverConnected: false"));

        // Check with a null config
        WifiLastResortWatchdog.AvailableNetworkFailureCount withNullConfig =
                new WifiLastResortWatchdog.AvailableNetworkFailureCount(null);
        output = withNullConfig.toString();
        assertTrue(output.contains("HasEverConnected: null_config"));
