class CallManager
!!!37535799.java!!!	CallManager()
        mPhones = new ArrayList<Phone>();
        mRingingCalls = new ArrayList<Call>();
        mBackgroundCalls = new ArrayList<Call>();
        mForegroundCalls = new ArrayList<Call>();
        mDefaultPhone = null;
!!!37535927.java!!!	getInstance() : CallManager
        return INSTANCE;
!!!37536055.java!!!	getAllPhones() : Phone
        return Collections.unmodifiableList(mPhones);
!!!37536183.java!!!	getPhone(in subId : int) : Phone
        Phone p = null;
        for (Phone phone : mPhones) {
            if (phone.getSubId() == subId &&
                    phone.getPhoneType() != PhoneConstants.PHONE_TYPE_IMS) {
                p = phone;
                break;
            }
        }
        return p;
!!!37536311.java!!!	getState() : PhoneConstants::State
        PhoneConstants.State s = PhoneConstants.State.IDLE;

        for (Phone phone : mPhones) {
            if (phone.getState() == PhoneConstants.State.RINGING) {
                s = PhoneConstants.State.RINGING;
            } else if (phone.getState() == PhoneConstants.State.OFFHOOK) {
                if (s == PhoneConstants.State.IDLE) s = PhoneConstants.State.OFFHOOK;
            }
        }
        return s;
!!!37536439.java!!!	getState(in subId : int) : PhoneConstants::State
        PhoneConstants.State s = PhoneConstants.State.IDLE;

        for (Phone phone : mPhones) {
            if (phone.getSubId() == subId) {
                if (phone.getState() == PhoneConstants.State.RINGING) {
                    s = PhoneConstants.State.RINGING;
                } else if (phone.getState() == PhoneConstants.State.OFFHOOK) {
                    if (s == PhoneConstants.State.IDLE) s = PhoneConstants.State.OFFHOOK;
                }
            }
        }
        return s;
!!!37536567.java!!!	getServiceState() : int
        int resultState = ServiceState.STATE_OUT_OF_SERVICE;

        for (Phone phone : mPhones) {
            int serviceState = phone.getServiceState().getState();
            if (serviceState == ServiceState.STATE_IN_SERVICE) {
                // IN_SERVICE has the highest priority
                resultState = serviceState;
                break;
            } else if (serviceState == ServiceState.STATE_OUT_OF_SERVICE) {
                // OUT_OF_SERVICE replaces EMERGENCY_ONLY and POWER_OFF
                // Note: EMERGENCY_ONLY is not in use at this moment
                if ( resultState == ServiceState.STATE_EMERGENCY_ONLY ||
                        resultState == ServiceState.STATE_POWER_OFF) {
                    resultState = serviceState;
                }
            } else if (serviceState == ServiceState.STATE_EMERGENCY_ONLY) {
                if (resultState == ServiceState.STATE_POWER_OFF) {
                    resultState = serviceState;
                }
            }
        }
        return resultState;
!!!37536695.java!!!	getServiceState(in subId : int) : int
        int resultState = ServiceState.STATE_OUT_OF_SERVICE;

        for (Phone phone : mPhones) {
            if (phone.getSubId() == subId) {
                int serviceState = phone.getServiceState().getState();
                if (serviceState == ServiceState.STATE_IN_SERVICE) {
                    // IN_SERVICE has the highest priority
                    resultState = serviceState;
                    break;
                } else if (serviceState == ServiceState.STATE_OUT_OF_SERVICE) {
                    // OUT_OF_SERVICE replaces EMERGENCY_ONLY and POWER_OFF
                    // Note: EMERGENCY_ONLY is not in use at this moment
                    if ( resultState == ServiceState.STATE_EMERGENCY_ONLY ||
                            resultState == ServiceState.STATE_POWER_OFF) {
                        resultState = serviceState;
                    }
                } else if (serviceState == ServiceState.STATE_EMERGENCY_ONLY) {
                    if (resultState == ServiceState.STATE_POWER_OFF) {
                        resultState = serviceState;
                    }
                }
            }
        }
        return resultState;
!!!37536823.java!!!	getPhoneInCall() : Phone
        Phone phone = null;
        if (!getFirstActiveRingingCall().isIdle()) {
            phone = getFirstActiveRingingCall().getPhone();
        } else if (!getActiveFgCall().isIdle()) {
            phone = getActiveFgCall().getPhone();
        } else {
            // If BG call is idle, we return default phone
            phone = getFirstActiveBgCall().getPhone();
        }
        return phone;
!!!37536951.java!!!	getPhoneInCall(in subId : int) : Phone
        Phone phone = null;
        if (!getFirstActiveRingingCall(subId).isIdle()) {
            phone = getFirstActiveRingingCall(subId).getPhone();
        } else if (!getActiveFgCall(subId).isIdle()) {
            phone = getActiveFgCall(subId).getPhone();
        } else {
            // If BG call is idle, we return default phone
            phone = getFirstActiveBgCall(subId).getPhone();
        }
        return phone;
!!!37537079.java!!!	registerPhone(inout phone : Phone) : boolean
        if (phone != null && !mPhones.contains(phone)) {

            if (DBG) {
                Rlog.d(LOG_TAG, "registerPhone(" +
                        phone.getPhoneName() + " " + phone + ")");
            }

            if (mPhones.isEmpty()) {
                mDefaultPhone = phone;
            }
            mPhones.add(phone);
            mRingingCalls.add(phone.getRingingCall());
            mBackgroundCalls.add(phone.getBackgroundCall());
            mForegroundCalls.add(phone.getForegroundCall());
            registerForPhoneStates(phone);
            return true;
        }
        return false;
!!!37537207.java!!!	unregisterPhone(inout phone : Phone) : void
        if (phone != null && mPhones.contains(phone)) {

            if (DBG) {
                Rlog.d(LOG_TAG, "unregisterPhone(" +
                        phone.getPhoneName() + " " + phone + ")");
            }

            Phone imsPhone = phone.getImsPhone();
            if (imsPhone != null) {
                unregisterPhone(imsPhone);
            }

            mPhones.remove(phone);
            mRingingCalls.remove(phone.getRingingCall());
            mBackgroundCalls.remove(phone.getBackgroundCall());
            mForegroundCalls.remove(phone.getForegroundCall());
            unregisterForPhoneStates(phone);
            if (phone == mDefaultPhone) {
                if (mPhones.isEmpty()) {
                    mDefaultPhone = null;
                } else {
                    mDefaultPhone = mPhones.get(0);
                }
            }
        }
!!!37537335.java!!!	getDefaultPhone() : Phone
        return mDefaultPhone;
!!!37537463.java!!!	getFgPhone() : Phone
        return getActiveFgCall().getPhone();
!!!37537591.java!!!	getFgPhone(in subId : int) : Phone
        return getActiveFgCall(subId).getPhone();
!!!37537719.java!!!	getBgPhone() : Phone
        return getFirstActiveBgCall().getPhone();
!!!37537847.java!!!	getBgPhone(in subId : int) : Phone
        return getFirstActiveBgCall(subId).getPhone();
!!!37537975.java!!!	getRingingPhone() : Phone
        return getFirstActiveRingingCall().getPhone();
!!!37538103.java!!!	getRingingPhone(in subId : int) : Phone
        return getFirstActiveRingingCall(subId).getPhone();
!!!37538231.java!!!	getContext() : Context
        Phone defaultPhone = getDefaultPhone();
        return ((defaultPhone == null) ? null : defaultPhone.getContext());
!!!37538359.java!!!	getRegistrantIdentifier() : Object
        return mRegistrantidentifier;
!!!37538487.java!!!	registerForPhoneStates(inout phone : Phone) : void
        // We need to keep a mapping of handler to Phone for proper unregistration.
        // TODO: Clean up this solution as it is just a work around for each Phone instance
        // using the same Handler to register with the RIL. When time permits, we should consider
        // moving the handler (or the reference ot the handler) into the Phone object.
        // See b/17414427.
        CallManagerHandler handler = mHandlerMap.get(phone);
        if (handler != null) {
            Rlog.d(LOG_TAG, "This phone has already been registered.");
            return;
        }

        // New registration, create a new handler instance and register the phone.
        handler = new CallManagerHandler();
        mHandlerMap.put(phone, handler);

        // for common events supported by all phones
        // The mRegistrantIdentifier passed here, is to identify in the Phone
        // that the registrants are coming from the CallManager.
        phone.registerForPreciseCallStateChanged(handler, EVENT_PRECISE_CALL_STATE_CHANGED,
                mRegistrantidentifier);
        phone.registerForDisconnect(handler, EVENT_DISCONNECT,
                mRegistrantidentifier);
        phone.registerForNewRingingConnection(handler, EVENT_NEW_RINGING_CONNECTION,
                mRegistrantidentifier);
        phone.registerForUnknownConnection(handler, EVENT_UNKNOWN_CONNECTION,
                mRegistrantidentifier);
        phone.registerForIncomingRing(handler, EVENT_INCOMING_RING,
                mRegistrantidentifier);
        phone.registerForRingbackTone(handler, EVENT_RINGBACK_TONE,
                mRegistrantidentifier);
        phone.registerForInCallVoicePrivacyOn(handler, EVENT_IN_CALL_VOICE_PRIVACY_ON,
                mRegistrantidentifier);
        phone.registerForInCallVoicePrivacyOff(handler, EVENT_IN_CALL_VOICE_PRIVACY_OFF,
                mRegistrantidentifier);
        phone.registerForDisplayInfo(handler, EVENT_DISPLAY_INFO,
                mRegistrantidentifier);
        phone.registerForSignalInfo(handler, EVENT_SIGNAL_INFO,
                mRegistrantidentifier);
        phone.registerForResendIncallMute(handler, EVENT_RESEND_INCALL_MUTE,
                mRegistrantidentifier);
        phone.registerForMmiInitiate(handler, EVENT_MMI_INITIATE,
                mRegistrantidentifier);
        phone.registerForMmiComplete(handler, EVENT_MMI_COMPLETE,
                mRegistrantidentifier);
        phone.registerForSuppServiceFailed(handler, EVENT_SUPP_SERVICE_FAILED,
                mRegistrantidentifier);
        phone.registerForServiceStateChanged(handler, EVENT_SERVICE_STATE_CHANGED,
                mRegistrantidentifier);

        // FIXME Taken from klp-sprout-dev but setAudioMode was removed in L.
        //phone.registerForRadioOffOrNotAvailable(handler, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);

        // for events supported only by GSM, CDMA and IMS phone
        phone.setOnPostDialCharacter(handler, EVENT_POST_DIAL_CHARACTER, null);

        // for events supported only by CDMA phone
        phone.registerForCdmaOtaStatusChange(handler, EVENT_CDMA_OTA_STATUS_CHANGE, null);
        phone.registerForSubscriptionInfoReady(handler, EVENT_SUBSCRIPTION_INFO_READY, null);
        phone.registerForCallWaiting(handler, EVENT_CALL_WAITING, null);
        phone.registerForEcmTimerReset(handler, EVENT_ECM_TIMER_RESET, null);

        // for events supported only by IMS phone
        phone.registerForOnHoldTone(handler, EVENT_ONHOLD_TONE, null);
        phone.registerForSuppServiceFailed(handler, EVENT_SUPP_SERVICE_FAILED, null);
        phone.registerForTtyModeReceived(handler, EVENT_TTY_MODE_RECEIVED, null);
!!!37538615.java!!!	unregisterForPhoneStates(inout phone : Phone) : void
        // Make sure that we clean up our map of handlers to Phones.
        CallManagerHandler handler = mHandlerMap.get(phone);
        if (handler == null) {
            Rlog.e(LOG_TAG, "Could not find Phone handler for unregistration");
            return;
        }
        mHandlerMap.remove(phone);

        //  for common events supported by all phones
        phone.unregisterForPreciseCallStateChanged(handler);
        phone.unregisterForDisconnect(handler);
        phone.unregisterForNewRingingConnection(handler);
        phone.unregisterForUnknownConnection(handler);
        phone.unregisterForIncomingRing(handler);
        phone.unregisterForRingbackTone(handler);
        phone.unregisterForInCallVoicePrivacyOn(handler);
        phone.unregisterForInCallVoicePrivacyOff(handler);
        phone.unregisterForDisplayInfo(handler);
        phone.unregisterForSignalInfo(handler);
        phone.unregisterForResendIncallMute(handler);
        phone.unregisterForMmiInitiate(handler);
        phone.unregisterForMmiComplete(handler);
        phone.unregisterForSuppServiceFailed(handler);
        phone.unregisterForServiceStateChanged(handler);
        phone.unregisterForTtyModeReceived(handler);
        // FIXME Taken from klp-sprout-dev but setAudioMode was removed in L.
        //phone.unregisterForRadioOffOrNotAvailable(handler);

        // for events supported only by GSM, CDMA and IMS phone
        phone.setOnPostDialCharacter(null, EVENT_POST_DIAL_CHARACTER, null);

        // for events supported only by CDMA phone
        phone.unregisterForCdmaOtaStatusChange(handler);
        phone.unregisterForSubscriptionInfoReady(handler);
        phone.unregisterForCallWaiting(handler);
        phone.unregisterForEcmTimerReset(handler);

        // for events supported only by IMS phone
        phone.unregisterForOnHoldTone(handler);
        phone.unregisterForSuppServiceFailed(handler);
!!!37538743.java!!!	acceptCall(inout ringingCall : Call) : void
        Phone ringingPhone = ringingCall.getPhone();

        if (VDBG) {
            Rlog.d(LOG_TAG, "acceptCall(" +ringingCall + " from " + ringingCall.getPhone() + ")");
            Rlog.d(LOG_TAG, toString());
        }

        if ( hasActiveFgCall() ) {
            Phone activePhone = getActiveFgCall().getPhone();
            boolean hasBgCall = ! (activePhone.getBackgroundCall().isIdle());
            boolean sameChannel = (activePhone == ringingPhone);

            if (VDBG) {
                Rlog.d(LOG_TAG, "hasBgCall: "+ hasBgCall + "sameChannel:" + sameChannel);
            }

            if (sameChannel && hasBgCall) {
                getActiveFgCall().hangup();
            } else if (!sameChannel && !hasBgCall) {
                activePhone.switchHoldingAndActive();
            } else if (!sameChannel && hasBgCall) {
                getActiveFgCall().hangup();
            }
        }

        // We only support the AUDIO_ONLY video state in this scenario.
        ringingPhone.acceptCall(VideoProfile.STATE_AUDIO_ONLY);

        if (VDBG) {
            Rlog.d(LOG_TAG, "End acceptCall(" +ringingCall + ")");
            Rlog.d(LOG_TAG, toString());
        }
!!!37538871.java!!!	rejectCall(inout ringingCall : Call) : void
        if (VDBG) {
            Rlog.d(LOG_TAG, "rejectCall(" +ringingCall + ")");
            Rlog.d(LOG_TAG, toString());
        }

        Phone ringingPhone = ringingCall.getPhone();

        ringingPhone.rejectCall();

        if (VDBG) {
            Rlog.d(LOG_TAG, "End rejectCall(" +ringingCall + ")");
            Rlog.d(LOG_TAG, toString());
        }
!!!37538999.java!!!	switchHoldingAndActive(inout heldCall : Call) : void
        Phone activePhone = null;
        Phone heldPhone = null;

        if (VDBG) {
            Rlog.d(LOG_TAG, "switchHoldingAndActive(" +heldCall + ")");
            Rlog.d(LOG_TAG, toString());
        }

        if (hasActiveFgCall()) {
            activePhone = getActiveFgCall().getPhone();
        }

        if (heldCall != null) {
            heldPhone = heldCall.getPhone();
        }

        if (activePhone != null) {
            activePhone.switchHoldingAndActive();
        }

        if (heldPhone != null && heldPhone != activePhone) {
            heldPhone.switchHoldingAndActive();
        }

        if (VDBG) {
            Rlog.d(LOG_TAG, "End switchHoldingAndActive(" +heldCall + ")");
            Rlog.d(LOG_TAG, toString());
        }
!!!37539127.java!!!	hangupForegroundResumeBackground(inout heldCall : Call) : void
        Phone foregroundPhone = null;
        Phone backgroundPhone = null;

        if (VDBG) {
            Rlog.d(LOG_TAG, "hangupForegroundResumeBackground(" +heldCall + ")");
            Rlog.d(LOG_TAG, toString());
        }

        if (hasActiveFgCall()) {
            foregroundPhone = getFgPhone();
            if (heldCall != null) {
                backgroundPhone = heldCall.getPhone();
                if (foregroundPhone == backgroundPhone) {
                    getActiveFgCall().hangup();
                } else {
                // the call to be hangup and resumed belongs to different phones
                    getActiveFgCall().hangup();
                    switchHoldingAndActive(heldCall);
                }
            }
        }

        if (VDBG) {
            Rlog.d(LOG_TAG, "End hangupForegroundResumeBackground(" +heldCall + ")");
            Rlog.d(LOG_TAG, toString());
        }
!!!37539255.java!!!	canConference(inout heldCall : Call) : boolean
        Phone activePhone = null;
        Phone heldPhone = null;

        if (hasActiveFgCall()) {
            activePhone = getActiveFgCall().getPhone();
        }

        if (heldCall != null) {
            heldPhone = heldCall.getPhone();
        }

        return heldPhone.getClass().equals(activePhone.getClass());
!!!37539383.java!!!	canConference(inout heldCall : Call, in subId : int) : boolean
        Phone activePhone = null;
        Phone heldPhone = null;

        if (hasActiveFgCall(subId)) {
            activePhone = getActiveFgCall(subId).getPhone();
        }

        if (heldCall != null) {
            heldPhone = heldCall.getPhone();
        }

        return heldPhone.getClass().equals(activePhone.getClass());
!!!37539511.java!!!	conference(inout heldCall : Call) : void
        int subId  = heldCall.getPhone().getSubId();

        if (VDBG) {
            Rlog.d(LOG_TAG, "conference(" +heldCall + ")");
            Rlog.d(LOG_TAG, toString());
        }

        Phone fgPhone = getFgPhone(subId);
        if (fgPhone != null) {
            if (fgPhone instanceof SipPhone) {
                ((SipPhone) fgPhone).conference(heldCall);
            } else if (canConference(heldCall)) {
                fgPhone.conference();
            } else {
                throw(new CallStateException("Can't conference foreground and selected background call"));
            }
        } else {
            Rlog.d(LOG_TAG, "conference: fgPhone=null");
        }

        if (VDBG) {
            Rlog.d(LOG_TAG, "End conference(" +heldCall + ")");
            Rlog.d(LOG_TAG, toString());
        }

!!!37539639.java!!!	dial(inout phone : Phone, inout dialString : String, in videoState : int) : Connection
        int subId = phone.getSubId();
        Connection result;

        if (VDBG) {
            Rlog.d(LOG_TAG, " dial(" + phone + ", "+ dialString + ")" +
                    " subId = " + subId);
            Rlog.d(LOG_TAG, toString());
        }

        if (!canDial(phone)) {
            /*
             * canDial function only checks whether the phone can make a new call.
             * InCall MMI commmands are basically supplementary services
             * within a call eg: call hold, call deflection, explicit call transfer etc.
             */
            String newDialString = PhoneNumberUtils.stripSeparators(dialString);
            if (phone.handleInCallMmiCommands(newDialString)) {
                return null;
            } else {
                throw new CallStateException("cannot dial in current state");
            }
        }

        if ( hasActiveFgCall(subId) ) {
            Phone activePhone = getActiveFgCall(subId).getPhone();
            boolean hasBgCall = !(activePhone.getBackgroundCall().isIdle());

            if (DBG) {
                Rlog.d(LOG_TAG, "hasBgCall: "+ hasBgCall + " sameChannel:" + (activePhone == phone));
            }

            // Manipulation between IMS phone and its owner
            // will be treated in GSM/CDMA phone.
            Phone imsPhone = phone.getImsPhone();
            if (activePhone != phone
                    && (imsPhone == null || imsPhone != activePhone)) {
                if (hasBgCall) {
                    Rlog.d(LOG_TAG, "Hangup");
                    getActiveFgCall(subId).hangup();
                } else {
                    Rlog.d(LOG_TAG, "Switch");
                    activePhone.switchHoldingAndActive();
                }
            }
        }

        // FIXME Taken from klp-sprout-dev but setAudioMode was removed in L.
        //mIsEccDialing = PhoneNumberUtils.isEmergencyNumber(dialString);

        result = phone.dial(dialString, videoState);

        if (VDBG) {
            Rlog.d(LOG_TAG, "End dial(" + phone + ", "+ dialString + ")");
            Rlog.d(LOG_TAG, toString());
        }

        return result;
!!!37539767.java!!!	dial(inout phone : Phone, inout dialString : String, inout uusInfo : UUSInfo, in videoState : int) : Connection
        return phone.dial(dialString, uusInfo, videoState, null);
!!!37539895.java!!!	clearDisconnected() : void
        for(Phone phone : mPhones) {
            phone.clearDisconnected();
        }
!!!37540023.java!!!	clearDisconnected(in subId : int) : void
        for(Phone phone : mPhones) {
            if (phone.getSubId() == subId) {
                phone.clearDisconnected();
            }
        }
!!!37540151.java!!!	canDial(inout phone : Phone) : boolean
        int serviceState = phone.getServiceState().getState();
        int subId = phone.getSubId();
        boolean hasRingingCall = hasActiveRingingCall();
        Call.State fgCallState = getActiveFgCallState(subId);

        boolean result = (serviceState != ServiceState.STATE_POWER_OFF
                && !hasRingingCall
                && ((fgCallState == Call.State.ACTIVE)
                    || (fgCallState == Call.State.IDLE)
                    || (fgCallState == Call.State.DISCONNECTED)
                    /*As per 3GPP TS 51.010-1 section 31.13.1.4
                    call should be alowed when the foreground
                    call is in ALERTING state*/
                    || (fgCallState == Call.State.ALERTING)));

        if (result == false) {
            Rlog.d(LOG_TAG, "canDial serviceState=" + serviceState
                            + " hasRingingCall=" + hasRingingCall
                            + " fgCallState=" + fgCallState);
        }
        return result;
!!!37540279.java!!!	canTransfer(inout heldCall : Call) : boolean
        Phone activePhone = null;
        Phone heldPhone = null;

        if (hasActiveFgCall()) {
            activePhone = getActiveFgCall().getPhone();
        }

        if (heldCall != null) {
            heldPhone = heldCall.getPhone();
        }

        return (heldPhone == activePhone && activePhone.canTransfer());
!!!37540407.java!!!	canTransfer(inout heldCall : Call, in subId : int) : boolean
        Phone activePhone = null;
        Phone heldPhone = null;

        if (hasActiveFgCall(subId)) {
            activePhone = getActiveFgCall(subId).getPhone();
        }

        if (heldCall != null) {
            heldPhone = heldCall.getPhone();
        }

        return (heldPhone == activePhone && activePhone.canTransfer());
!!!37540535.java!!!	explicitCallTransfer(inout heldCall : Call) : void
        if (VDBG) {
            Rlog.d(LOG_TAG, " explicitCallTransfer(" + heldCall + ")");
            Rlog.d(LOG_TAG, toString());
        }

        if (canTransfer(heldCall)) {
            heldCall.getPhone().explicitCallTransfer();
        }

        if (VDBG) {
            Rlog.d(LOG_TAG, "End explicitCallTransfer(" + heldCall + ")");
            Rlog.d(LOG_TAG, toString());
        }

!!!37540663.java!!!	getPendingMmiCodes(inout phone : Phone) : List<? extends MmiCode>
        Rlog.e(LOG_TAG, "getPendingMmiCodes not implemented");
        return null;
!!!37540791.java!!!	sendUssdResponse(inout phone : Phone, inout ussdMessge : String) : boolean
        Rlog.e(LOG_TAG, "sendUssdResponse not implemented");
        return false;
!!!37540919.java!!!	setMute(inout muted : boolean) : void
        if (VDBG) {
            Rlog.d(LOG_TAG, " setMute(" + muted + ")");
            Rlog.d(LOG_TAG, toString());
        }

        if (hasActiveFgCall()) {
            getActiveFgCall().getPhone().setMute(muted);
        }

        if (VDBG) {
            Rlog.d(LOG_TAG, "End setMute(" + muted + ")");
            Rlog.d(LOG_TAG, toString());
        }
!!!37541047.java!!!	getMute() : boolean
        if (hasActiveFgCall()) {
            return getActiveFgCall().getPhone().getMute();
        } else if (hasActiveBgCall()) {
            return getFirstActiveBgCall().getPhone().getMute();
        }
        return false;
!!!37541175.java!!!	setEchoSuppressionEnabled() : void
        if (VDBG) {
            Rlog.d(LOG_TAG, " setEchoSuppression()");
            Rlog.d(LOG_TAG, toString());
        }

        if (hasActiveFgCall()) {
            getActiveFgCall().getPhone().setEchoSuppressionEnabled();
        }

        if (VDBG) {
            Rlog.d(LOG_TAG, "End setEchoSuppression()");
            Rlog.d(LOG_TAG, toString());
        }
!!!37541303.java!!!	sendDtmf(in c : char) : boolean
        boolean result = false;

        if (VDBG) {
            Rlog.d(LOG_TAG, " sendDtmf(" + c + ")");
            Rlog.d(LOG_TAG, toString());
        }

        if (hasActiveFgCall()) {
            getActiveFgCall().getPhone().sendDtmf(c);
            result = true;
        }

        if (VDBG) {
            Rlog.d(LOG_TAG, "End sendDtmf(" + c + ")");
            Rlog.d(LOG_TAG, toString());
        }
        return result;
!!!37541431.java!!!	startDtmf(in c : char) : boolean
        boolean result = false;

        if (VDBG) {
            Rlog.d(LOG_TAG, " startDtmf(" + c + ")");
            Rlog.d(LOG_TAG, toString());
        }

        if (hasActiveFgCall()) {
            getActiveFgCall().getPhone().startDtmf(c);
            result = true;
        }

        if (VDBG) {
            Rlog.d(LOG_TAG, "End startDtmf(" + c + ")");
            Rlog.d(LOG_TAG, toString());
        }

        return result;
!!!37541559.java!!!	stopDtmf() : void
        if (VDBG) {
            Rlog.d(LOG_TAG, " stopDtmf()" );
            Rlog.d(LOG_TAG, toString());
        }

        if (hasActiveFgCall()) getFgPhone().stopDtmf();

        if (VDBG) {
            Rlog.d(LOG_TAG, "End stopDtmf()");
            Rlog.d(LOG_TAG, toString());
        }
!!!37541687.java!!!	sendBurstDtmf(inout dtmfString : String, in on : int, in off : int, inout onComplete : Message) : boolean
        if (hasActiveFgCall()) {
            getActiveFgCall().getPhone().sendBurstDtmf(dtmfString, on, off, onComplete);
            return true;
        }
        return false;
!!!37541815.java!!!	registerForDisconnect(inout h : Handler, in what : int, inout obj : Object) : void
        mDisconnectRegistrants.addUnique(h, what, obj);
!!!37541943.java!!!	unregisterForDisconnect(inout h : Handler) : void
        mDisconnectRegistrants.remove(h);
!!!37542071.java!!!	registerForPreciseCallStateChanged(inout h : Handler, in what : int, inout obj : Object) : void
        mPreciseCallStateRegistrants.addUnique(h, what, obj);
!!!37542199.java!!!	unregisterForPreciseCallStateChanged(inout h : Handler) : void
        mPreciseCallStateRegistrants.remove(h);
!!!37542327.java!!!	registerForUnknownConnection(inout h : Handler, in what : int, inout obj : Object) : void
        mUnknownConnectionRegistrants.addUnique(h, what, obj);
!!!37542455.java!!!	unregisterForUnknownConnection(inout h : Handler) : void
        mUnknownConnectionRegistrants.remove(h);
!!!37542583.java!!!	registerForNewRingingConnection(inout h : Handler, in what : int, inout obj : Object) : void
        mNewRingingConnectionRegistrants.addUnique(h, what, obj);
!!!37542711.java!!!	unregisterForNewRingingConnection(inout h : Handler) : void
        mNewRingingConnectionRegistrants.remove(h);
!!!37542839.java!!!	registerForIncomingRing(inout h : Handler, in what : int, inout obj : Object) : void
        mIncomingRingRegistrants.addUnique(h, what, obj);
!!!37542967.java!!!	unregisterForIncomingRing(inout h : Handler) : void
        mIncomingRingRegistrants.remove(h);
!!!37543095.java!!!	registerForRingbackTone(inout h : Handler, in what : int, inout obj : Object) : void
        mRingbackToneRegistrants.addUnique(h, what, obj);
!!!37543223.java!!!	unregisterForRingbackTone(inout h : Handler) : void
        mRingbackToneRegistrants.remove(h);
!!!37543351.java!!!	registerForOnHoldTone(inout h : Handler, in what : int, inout obj : Object) : void
        mOnHoldToneRegistrants.addUnique(h, what, obj);
!!!37543479.java!!!	unregisterForOnHoldTone(inout h : Handler) : void
        mOnHoldToneRegistrants.remove(h);
!!!37543607.java!!!	registerForResendIncallMute(inout h : Handler, in what : int, inout obj : Object) : void
        mResendIncallMuteRegistrants.addUnique(h, what, obj);
!!!37543735.java!!!	unregisterForResendIncallMute(inout h : Handler) : void
        mResendIncallMuteRegistrants.remove(h);
!!!37543863.java!!!	registerForMmiInitiate(inout h : Handler, in what : int, inout obj : Object) : void
        mMmiInitiateRegistrants.addUnique(h, what, obj);
!!!37543991.java!!!	unregisterForMmiInitiate(inout h : Handler) : void
        mMmiInitiateRegistrants.remove(h);
!!!37544119.java!!!	registerForMmiComplete(inout h : Handler, in what : int, inout obj : Object) : void
        mMmiCompleteRegistrants.addUnique(h, what, obj);
!!!37544247.java!!!	unregisterForMmiComplete(inout h : Handler) : void
        mMmiCompleteRegistrants.remove(h);
!!!37544375.java!!!	registerForEcmTimerReset(inout h : Handler, in what : int, inout obj : Object) : void
        mEcmTimerResetRegistrants.addUnique(h, what, obj);
!!!37544503.java!!!	unregisterForEcmTimerReset(inout h : Handler) : void
        mEcmTimerResetRegistrants.remove(h);
!!!37544631.java!!!	registerForServiceStateChanged(inout h : Handler, in what : int, inout obj : Object) : void
        mServiceStateChangedRegistrants.addUnique(h, what, obj);
!!!37544759.java!!!	unregisterForServiceStateChanged(inout h : Handler) : void
        mServiceStateChangedRegistrants.remove(h);
!!!37544887.java!!!	registerForSuppServiceFailed(inout h : Handler, in what : int, inout obj : Object) : void
        mSuppServiceFailedRegistrants.addUnique(h, what, obj);
!!!37545015.java!!!	unregisterForSuppServiceFailed(inout h : Handler) : void
        mSuppServiceFailedRegistrants.remove(h);
!!!37545143.java!!!	registerForInCallVoicePrivacyOn(inout h : Handler, in what : int, inout obj : Object) : void
        mInCallVoicePrivacyOnRegistrants.addUnique(h, what, obj);
!!!37545271.java!!!	unregisterForInCallVoicePrivacyOn(inout h : Handler) : void
        mInCallVoicePrivacyOnRegistrants.remove(h);
!!!37545399.java!!!	registerForInCallVoicePrivacyOff(inout h : Handler, in what : int, inout obj : Object) : void
        mInCallVoicePrivacyOffRegistrants.addUnique(h, what, obj);
!!!37545527.java!!!	unregisterForInCallVoicePrivacyOff(inout h : Handler) : void
        mInCallVoicePrivacyOffRegistrants.remove(h);
!!!37545655.java!!!	registerForCallWaiting(inout h : Handler, in what : int, inout obj : Object) : void
        mCallWaitingRegistrants.addUnique(h, what, obj);
!!!37545783.java!!!	unregisterForCallWaiting(inout h : Handler) : void
        mCallWaitingRegistrants.remove(h);
!!!37545911.java!!!	registerForSignalInfo(inout h : Handler, in what : int, inout obj : Object) : void
        mSignalInfoRegistrants.addUnique(h, what, obj);
!!!37546039.java!!!	unregisterForSignalInfo(inout h : Handler) : void
        mSignalInfoRegistrants.remove(h);
!!!37546167.java!!!	registerForDisplayInfo(inout h : Handler, in what : int, inout obj : Object) : void
        mDisplayInfoRegistrants.addUnique(h, what, obj);
!!!37546295.java!!!	unregisterForDisplayInfo(inout h : Handler) : void
        mDisplayInfoRegistrants.remove(h);
!!!37546423.java!!!	registerForCdmaOtaStatusChange(inout h : Handler, in what : int, inout obj : Object) : void
        mCdmaOtaStatusChangeRegistrants.addUnique(h, what, obj);
!!!37546551.java!!!	unregisterForCdmaOtaStatusChange(inout h : Handler) : void
        mCdmaOtaStatusChangeRegistrants.remove(h);
!!!37546679.java!!!	registerForSubscriptionInfoReady(inout h : Handler, in what : int, inout obj : Object) : void
        mSubscriptionInfoReadyRegistrants.addUnique(h, what, obj);
!!!37546807.java!!!	unregisterForSubscriptionInfoReady(inout h : Handler) : void
        mSubscriptionInfoReadyRegistrants.remove(h);
!!!37546935.java!!!	registerForPostDialCharacter(inout h : Handler, in what : int, inout obj : Object) : void
        mPostDialCharacterRegistrants.addUnique(h, what, obj);
!!!37547063.java!!!	unregisterForPostDialCharacter(inout h : Handler) : void
        mPostDialCharacterRegistrants.remove(h);
!!!37547191.java!!!	registerForTtyModeReceived(inout h : Handler, in what : int, inout obj : Object) : void
        mTtyModeReceivedRegistrants.addUnique(h, what, obj);
!!!37547319.java!!!	unregisterForTtyModeReceived(inout h : Handler) : void
        mTtyModeReceivedRegistrants.remove(h);
!!!37547447.java!!!	getRingingCalls() : Call
        return Collections.unmodifiableList(mRingingCalls);
!!!37547575.java!!!	getForegroundCalls() : Call
        return Collections.unmodifiableList(mForegroundCalls);
!!!37547703.java!!!	getBackgroundCalls() : Call
        return Collections.unmodifiableList(mBackgroundCalls);
!!!37547831.java!!!	hasActiveFgCall() : boolean
        return (getFirstActiveCall(mForegroundCalls) != null);
!!!37547959.java!!!	hasActiveFgCall(in subId : int) : boolean
        return (getFirstActiveCall(mForegroundCalls, subId) != null);
!!!37548087.java!!!	hasActiveBgCall() : boolean
        // TODO since hasActiveBgCall may get called often
        // better to cache it to improve performance
        return (getFirstActiveCall(mBackgroundCalls) != null);
!!!37548215.java!!!	hasActiveBgCall(in subId : int) : boolean
        // TODO since hasActiveBgCall may get called often
        // better to cache it to improve performance
        return (getFirstActiveCall(mBackgroundCalls, subId) != null);
!!!37548343.java!!!	hasActiveRingingCall() : boolean
        return (getFirstActiveCall(mRingingCalls) != null);
!!!37548471.java!!!	hasActiveRingingCall(in subId : int) : boolean
        return (getFirstActiveCall(mRingingCalls, subId) != null);
!!!37548599.java!!!	getActiveFgCall() : Call
        Call call = getFirstNonIdleCall(mForegroundCalls);
        if (call == null) {
            call = (mDefaultPhone == null)
                    ? null
                    : mDefaultPhone.getForegroundCall();
        }
        return call;
!!!37548727.java!!!	getActiveFgCall(in subId : int) : Call
        Call call = getFirstNonIdleCall(mForegroundCalls, subId);
        if (call == null) {
            Phone phone = getPhone(subId);
            call = (phone == null)
                    ? null
                    : phone.getForegroundCall();
        }
        return call;
!!!37548855.java!!!	getFirstNonIdleCall(inout calls : List<Call>) : Call
        Call result = null;
        for (Call call : calls) {
            if (!call.isIdle()) {
                return call;
            } else if (call.getState() != Call.State.IDLE) {
                if (result == null) result = call;
            }
        }
        return result;
!!!37548983.java!!!	getFirstNonIdleCall(inout calls : List<Call>, in subId : int) : Call
        Call result = null;
        for (Call call : calls) {
            if ((call.getPhone().getSubId() == subId) ||
                    (call.getPhone() instanceof SipPhone)) {
                if (!call.isIdle()) {
                    return call;
                } else if (call.getState() != Call.State.IDLE) {
                    if (result == null) result = call;
                }
            }
        }
        return result;
!!!37549111.java!!!	getFirstActiveBgCall() : Call
        Call call = getFirstNonIdleCall(mBackgroundCalls);
        if (call == null) {
            call = (mDefaultPhone == null)
                    ? null
                    : mDefaultPhone.getBackgroundCall();
        }
        return call;
!!!37549239.java!!!	getFirstActiveBgCall(in subId : int) : Call
        Phone phone = getPhone(subId);
        if (hasMoreThanOneHoldingCall(subId)) {
            return phone.getBackgroundCall();
        } else {
            Call call = getFirstNonIdleCall(mBackgroundCalls, subId);
            if (call == null) {
                call = (phone == null)
                        ? null
                        : phone.getBackgroundCall();
            }
            return call;
        }
!!!37549367.java!!!	getFirstActiveRingingCall() : Call
        Call call = getFirstNonIdleCall(mRingingCalls);
        if (call == null) {
            call = (mDefaultPhone == null)
                    ? null
                    : mDefaultPhone.getRingingCall();
        }
        return call;
!!!37549495.java!!!	getFirstActiveRingingCall(in subId : int) : Call
        Phone phone = getPhone(subId);
        Call call = getFirstNonIdleCall(mRingingCalls, subId);
        if (call == null) {
            call = (phone == null)
                    ? null
                    : phone.getRingingCall();
        }
        return call;
!!!37549623.java!!!	getActiveFgCallState() : Call::State
        Call fgCall = getActiveFgCall();

        if (fgCall != null) {
            return fgCall.getState();
        }

        return Call.State.IDLE;
!!!37549751.java!!!	getActiveFgCallState(in subId : int) : Call::State
        Call fgCall = getActiveFgCall(subId);

        if (fgCall != null) {
            return fgCall.getState();
        }

        return Call.State.IDLE;
!!!37549879.java!!!	getFgCallConnections() : Connection
        Call fgCall = getActiveFgCall();
        if ( fgCall != null) {
            return fgCall.getConnections();
        }
        return mEmptyConnections;
!!!37550007.java!!!	getFgCallConnections(in subId : int) : Connection
        Call fgCall = getActiveFgCall(subId);
        if ( fgCall != null) {
            return fgCall.getConnections();
        }
        return mEmptyConnections;
!!!37550135.java!!!	getBgCallConnections() : Connection
        Call bgCall = getFirstActiveBgCall();
        if ( bgCall != null) {
            return bgCall.getConnections();
        }
        return mEmptyConnections;
!!!37550263.java!!!	getBgCallConnections(in subId : int) : Connection
        Call bgCall = getFirstActiveBgCall(subId);
        if ( bgCall != null) {
            return bgCall.getConnections();
        }
        return mEmptyConnections;
!!!37550391.java!!!	getFgCallLatestConnection() : Connection
        Call fgCall = getActiveFgCall();
        if ( fgCall != null) {
            return fgCall.getLatestConnection();
        }
        return null;
!!!37550519.java!!!	getFgCallLatestConnection(in subId : int) : Connection
        Call fgCall = getActiveFgCall(subId);
        if ( fgCall != null) {
            return fgCall.getLatestConnection();
        }
        return null;
!!!37550647.java!!!	hasDisconnectedFgCall() : boolean
        return (getFirstCallOfState(mForegroundCalls, Call.State.DISCONNECTED) != null);
!!!37550775.java!!!	hasDisconnectedFgCall(in subId : int) : boolean
        return (getFirstCallOfState(mForegroundCalls, Call.State.DISCONNECTED,
                subId) != null);
!!!37550903.java!!!	hasDisconnectedBgCall() : boolean
        return (getFirstCallOfState(mBackgroundCalls, Call.State.DISCONNECTED) != null);
!!!37551031.java!!!	hasDisconnectedBgCall(in subId : int) : boolean
        return (getFirstCallOfState(mBackgroundCalls, Call.State.DISCONNECTED,
                subId) != null);
!!!37551159.java!!!	getFirstActiveCall(inout calls : ArrayList<Call>) : Call
        for (Call call : calls) {
            if (!call.isIdle()) {
                return call;
            }
        }
        return null;
!!!37551287.java!!!	getFirstActiveCall(inout calls : ArrayList<Call>, in subId : int) : Call
        for (Call call : calls) {
            if ((!call.isIdle()) && ((call.getPhone().getSubId() == subId) ||
                    (call.getPhone() instanceof SipPhone))) {
                return call;
            }
        }
        return null;
!!!37551415.java!!!	getFirstCallOfState(inout calls : ArrayList<Call>, inout state : Call::State) : Call
        for (Call call : calls) {
            if (call.getState() == state) {
                return call;
            }
        }
        return null;
!!!37551543.java!!!	getFirstCallOfState(inout calls : ArrayList<Call>, inout state : Call::State, in subId : int) : Call
        for (Call call : calls) {
            if ((call.getState() == state) ||
                ((call.getPhone().getSubId() == subId) ||
                (call.getPhone() instanceof SipPhone))) {
                return call;
            }
        }
        return null;
!!!37551671.java!!!	hasMoreThanOneRingingCall() : boolean
        int count = 0;
        for (Call call : mRingingCalls) {
            if (call.getState().isRinging()) {
                if (++count > 1) return true;
            }
        }
        return false;
!!!37551799.java!!!	hasMoreThanOneRingingCall(in subId : int) : boolean
        int count = 0;
        for (Call call : mRingingCalls) {
            if ((call.getState().isRinging()) &&
                ((call.getPhone().getSubId() == subId) ||
                (call.getPhone() instanceof SipPhone))) {
                if (++count > 1) return true;
            }
        }
        return false;
!!!37551927.java!!!	hasMoreThanOneHoldingCall(in subId : int) : boolean
        int count = 0;
        for (Call call : mBackgroundCalls) {
            if ((call.getState() == Call.State.HOLDING) &&
                ((call.getPhone().getSubId() == subId) ||
                (call.getPhone() instanceof SipPhone))) {
                if (++count > 1) return true;
            }
        }
        return false;
!!!37552183.java!!!	toString() : String
        Call call;
        StringBuilder b = new StringBuilder();
        for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
            b.append("CallManager {");
            b.append("\nstate = " + getState(i));
            call = getActiveFgCall(i);
            if (call != null) {
                b.append("\n- Foreground: " + getActiveFgCallState(i));
                b.append(" from " + call.getPhone());
                b.append("\n  Conn: ").append(getFgCallConnections(i));
            }
            call = getFirstActiveBgCall(i);
            if (call != null) {
                b.append("\n- Background: " + call.getState());
                b.append(" from " + call.getPhone());
                b.append("\n  Conn: ").append(getBgCallConnections(i));
            }
            call = getFirstActiveRingingCall(i);
            if (call != null) {
                b.append("\n- Ringing: " +call.getState());
                b.append(" from " + call.getPhone());
            }
        }

        for (Phone phone : getAllPhones()) {
            if (phone != null) {
                b.append("\nPhone: " + phone + ", name = " + phone.getPhoneName()
                        + ", state = " + phone.getState());
                call = phone.getForegroundCall();
                if (call != null) {
                    b.append("\n- Foreground: ").append(call);
                }
                call = phone.getBackgroundCall();
                if (call != null) {
                    b.append(" Background: ").append(call);
                }
                call = phone.getRingingCall();
                if (call != null) {
                    b.append(" Ringing: ").append(call);
                }
            }
        }
        b.append("\n}");
        return b.toString();
