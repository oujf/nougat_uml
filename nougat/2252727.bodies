class UT_reduce
!!!38731447.java!!!	UT_reduce(inout rstc : RSTestCore, inout res : Resources, inout ctx : Context)
        super(rstc, "reduce", ctx);
!!!38732983.java!!!	createInputArrayByte(in len : int, in seed : int) : byte
        byte[] array = new byte[len];
        (new Random(seed)).nextBytes(array);
        return array;
!!!38733111.java!!!	createInputArrayFloat(in len : int, in seed : int) : float
        Random rand = new Random(seed);
        float[] array = new float[len];
        for (int i = 0; i < len; ++i)
            array[i] = rand.nextFloat();
        return array;
!!!38733239.java!!!	createInputArrayInt(in len : int, in seed : int) : int
        Random rand = new Random(seed);
        int[] array = new int[len];
        for (int i = 0; i < len; ++i)
            array[i] = rand.nextInt();
        return array;
!!!38733367.java!!!	createInputArrayInt(in len : int, in seed : int, in eltRange : int) : int
        Random rand = new Random(seed);
        int[] array = new int[len];
        for (int i = 0; i < len; ++i)
            array[i] = rand.nextInt(eltRange);
        return array;
!!!38733495.java!!!	intArrayToLong(in input : int) : long
        final long[] output = new long[input.length];

        for (int i = 0; i < input.length; ++i)
            output[i] = input[i];

        return output;
!!!38733623.java!!!	result(inout testName : String, in t : UT_reduce::timing, inout javaRslt : T, inout rsRslt : T) : boolean
        final boolean success = javaRslt.equals(rsRslt);
        String status = (success ? "PASSED" : "FAILED");
        if (success && (t != null))
            status += " " + t.string();
        Log.i(TAG, testName + ": java " + javaRslt + ", rs " + rsRslt + ": " + status);
        return success;
!!!38733751.java!!!	result(inout testName : String, in t : UT_reduce::timing, in javaRslt : float, in rsRslt : float) : boolean
        if (javaRslt.length != rsRslt.length) {
            Log.i(TAG, testName + ": java length " + javaRslt.length +
                       ", rs length " + rsRslt.length + ": FAILED");
            return false;
        }
        for (int i = 0; i < javaRslt.length; ++i) {
            if (javaRslt[i] != rsRslt[i]) {
                Log.i(TAG, testName + "[" + i + "]: java " + javaRslt[i] +
                           ", rs " + rsRslt[i] + ": FAILED");
                return false;
            }
        }
        String status = "PASSED";
        if (t != null)
            status += " " + t.string();
        Log.i(TAG, testName + ": " + status);
        return true;
!!!38733879.java!!!	result(inout testName : String, in t : UT_reduce::timing, in javaRslt : long, in rsRslt : long) : boolean
        if (javaRslt.length != rsRslt.length) {
            Log.i(TAG, testName + ": java length " + javaRslt.length +
                       ", rs length " + rsRslt.length + ": FAILED");
            return false;
        }
        for (int i = 0; i < javaRslt.length; ++i) {
            if (javaRslt[i] != rsRslt[i]) {
                Log.i(TAG, testName + "[" + i + "]: java " + javaRslt[i] +
                           ", rs " + rsRslt[i] + ": FAILED");
                return false;
            }
        }
        String status = "PASSED";
        if (t != null)
            status += " " + t.string();
        Log.i(TAG, testName + ": " + status);
        return true;
!!!38734007.java!!!	result(inout testName : String, in t : UT_reduce::timing, in javaRslt : int, in rsRslt : int) : boolean
        return result(testName, t, intArrayToLong(javaRslt), intArrayToLong(rsRslt));
!!!38734135.java!!!	result(inout testName : String, in t : UT_reduce::timing, inout javaRslt : Int2, inout rsRslt : Int2) : boolean
        final boolean success = (javaRslt.x == rsRslt.x) && (javaRslt.y == rsRslt.y);
        String status = (success ? "PASSED" : "FAILED");
        if (success && (t != null))
            status += " " + t.string();
        Log.i(TAG,
                testName +
                ": java (" + javaRslt.x + ", " + javaRslt.y + ")" +
                ", rs (" + rsRslt.x + ", " + rsRslt.y + ")" +
                ": " + status);
        return success;
!!!38734263.java!!!	result(inout testName : String, in t : UT_reduce::timing, inout javaRslt : Float2, inout rsRslt : Float2) : boolean
        final boolean success = (javaRslt.x == rsRslt.x) && (javaRslt.y == rsRslt.y);
        String status = (success ? "PASSED" : "FAILED");
        if (success && (t != null))
            status += " " + t.string();
        Log.i(TAG,
                testName +
                ": java (" + javaRslt.x + ", " + javaRslt.y + ")" +
                ", rs (" + rsRslt.x + ", " + rsRslt.y + ")" +
                ": " + status);
        return success;
!!!38734391.java!!!	addint(inout input : int) : int
        int rslt = 0;
        for (int idx = 0; idx < input.length; ++idx)
            rslt += input[idx];
        return rslt;
!!!38734519.java!!!	addint1D_array(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final int[] input = createInputArrayInt(size[0], seed, Integer.MAX_VALUE / size[0]);

        final int javaRslt = addint(input);
        final int rsRslt = s.reduce_addint(input).get();

        return result("addint1D_array", new timing(size[0]), javaRslt, rsRslt);
!!!38734647.java!!!	addint1D(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final int[] inputArray = createInputArrayInt(size[0], seed, Integer.MAX_VALUE / size[0]);

        final long javaTimeStart = java.lang.System.currentTimeMillis();
        final int javaRslt = addint(inputArray);
        final long javaTimeEnd = java.lang.System.currentTimeMillis();

        final long rsTimeStart = java.lang.System.currentTimeMillis();

        Allocation inputAllocation = Allocation.createSized(RS, Element.I32(RS), inputArray.length);

        final long copyTimeStart = java.lang.System.currentTimeMillis();

        inputAllocation.copyFrom(inputArray);

        final long kernelTimeStart = java.lang.System.currentTimeMillis();
        final int rsRslt = s.reduce_addint(inputAllocation).get();
        final long rsTimeEnd = java.lang.System.currentTimeMillis();

        final boolean success =
                result("addint1D",
                        new timing(javaTimeStart, javaTimeEnd, rsTimeStart,
                                   copyTimeStart, kernelTimeStart, rsTimeEnd, inputAllocation),
                        javaRslt, rsRslt);
        inputAllocation.destroy();
        return success;
!!!38734775.java!!!	addint2D(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final int dimX = size[0];
        final int dimY = size[1];

        final int[] inputArray = createInputArrayInt(dimX * dimY, seed, Integer.MAX_VALUE / (dimX * dimY));

        final long javaTimeStart = java.lang.System.currentTimeMillis();
        final int javaRslt = addint(inputArray);
        final long javaTimeEnd = java.lang.System.currentTimeMillis();

        final long rsTimeStart = java.lang.System.currentTimeMillis();

        Type.Builder typeBuilder = new Type.Builder(RS, Element.I32(RS));
        typeBuilder.setX(dimX).setY(dimY);
        Allocation inputAllocation = Allocation.createTyped(RS, typeBuilder.create());

        final long copyTimeStart = java.lang.System.currentTimeMillis();

        inputAllocation.copy2DRangeFrom(0, 0, dimX, dimY, inputArray);

        final long kernelTimeStart = java.lang.System.currentTimeMillis();
        final int rsRslt = s.reduce_addint(inputAllocation).get();
        final long rsTimeEnd = java.lang.System.currentTimeMillis();

        final boolean success =
                result("addint2D",
                        new timing(javaTimeStart, javaTimeEnd, rsTimeStart,
                                   copyTimeStart, kernelTimeStart, rsTimeEnd, inputAllocation),
                        javaRslt, rsRslt);
        inputAllocation.destroy();
        return success;
!!!38734903.java!!!	addint3D(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final int dimX = size[0];
        final int dimY = size[1];
        final int dimZ = size[2];

        final int[] inputArray = createInputArrayInt(dimX * dimY * dimZ, seed, Integer.MAX_VALUE / (dimX * dimY * dimZ));

        final long javaTimeStart = java.lang.System.currentTimeMillis();
        final int javaRslt = addint(inputArray);
        final long javaTimeEnd = java.lang.System.currentTimeMillis();

        final long rsTimeStart = java.lang.System.currentTimeMillis();

        Type.Builder typeBuilder = new Type.Builder(RS, Element.I32(RS));
        typeBuilder.setX(dimX).setY(dimY).setZ(dimZ);
        Allocation inputAllocation = Allocation.createTyped(RS, typeBuilder.create());

        final long copyTimeStart = java.lang.System.currentTimeMillis();

        inputAllocation.copy3DRangeFrom(0, 0, 0, dimX, dimY, dimZ, inputArray);

        final long kernelTimeStart = java.lang.System.currentTimeMillis();
        final int rsRslt = s.reduce_addint(inputAllocation).get();
        final long rsTimeEnd = java.lang.System.currentTimeMillis();

        final boolean success =
                result("addint3D",
                        new timing(javaTimeStart, javaTimeEnd, rsTimeStart,
                                   copyTimeStart, kernelTimeStart, rsTimeEnd, inputAllocation),
                        javaRslt, rsRslt);
        inputAllocation.destroy();
        return success;
!!!38735031.java!!!	patternInterleavedReduce(inout RS : RenderScript, inout s : ScriptC_reduce) : boolean
        // Run two reduce operations without forcing completion between them.
        // We want to ensure that the driver can handle this, and that
        // temporary Allocations created to run the reduce operations survive
        // until get().

        boolean pass = true;

        final int inputSize = (1 << 18);

        final int[] input1 = createInputArrayInt(123, Integer.MAX_VALUE / inputSize);
        final int[] input2 = createInputArrayInt(456, Integer.MAX_VALUE / inputSize);

        final int javaRslt1 = addint(input1);
        final int javaRslt2 = addint(input2);

        final ScriptC_reduce.result_int rsRsltFuture1 = s.reduce_addint(input1);
        final ScriptC_reduce.result_int rsRsltFuture2 = s.reduce_addint(input2);

        pass &= result("patternInterleavedReduce (1)", new timing(inputSize),
                javaRslt1, rsRsltFuture1.get());
        pass &= result("patternInterleavedReduce (2)", new timing(inputSize),
                javaRslt2, rsRsltFuture2.get());

        return pass;
!!!38735159.java!!!	sillySumIntoDecArray(in input : int) : int
        final int resultScalar = addint(input);
        final int[] result = new int[4];
        for (int i = 0; i < 4; ++i)
            result[i] = resultScalar/(i+1);
        return result;
!!!38735287.java!!!	sillySumIntoIncArray(in input : int) : int
        final int resultScalar = addint(input);
        final int[] result = new int[4];
        for (int i = 0; i < 4; ++i)
            result[i] = resultScalar/(4-i);
        return result;
!!!38735415.java!!!	patternDuplicateAnonymousResult(inout RS : RenderScript, inout s : ScriptC_reduce) : boolean
        // Ensure that we can have two kernels with the same anonymous result type.

        boolean pass = true;

        final int inputSize = 1000;
        final int[] input = createInputArrayInt(149, Integer.MAX_VALUE / inputSize);

        final int[] javaRsltDec = sillySumIntoDecArray(input);
        final int[] rsRsltDec = s.reduce_sillySumIntoDecArray(input).get();
        pass &= result("patternDuplicateAnonymousResult (Dec)", new timing(inputSize),
                javaRsltDec, rsRsltDec);

        final int[] javaRsltInc = sillySumIntoIncArray(input);
        final int[] rsRsltInc = s.reduce_sillySumIntoIncArray(input).get();
        pass &= result("patternDuplicateAnonymousResult (Inc)", new timing(inputSize),
                javaRsltInc, rsRsltInc);

        return pass;
!!!38735543.java!!!	findMinAndMax(inout input : float) : Int2
        float minVal = Float.POSITIVE_INFINITY;
        int minIdx = -1;
        float maxVal = Float.NEGATIVE_INFINITY;
        int maxIdx = -1;

        for (int idx = 0; idx < input.length; ++idx) {
            if (input[idx] < minVal) {
                minVal = input[idx];
                minIdx = idx;
            }
            if (input[idx] > maxVal) {
                maxVal = input[idx];
                maxIdx = idx;
            }
        }

        return new Int2(minIdx, maxIdx);
!!!38735671.java!!!	findMinAndMax_array(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final float[] input = createInputArrayFloat(size[0], seed);

        final Int2 javaRslt = findMinAndMax(input);
        final Int2 rsRslt = s.reduce_findMinAndMax(input).get();

        // Note that the Java and RenderScript algorithms are not
        // guaranteed to find the same cells -- but they should
        // find cells of the same value.
        final Float2 javaVal = new Float2(input[javaRslt.x], input[javaRslt.y]);
        final Float2 rsVal = new Float2(input[rsRslt.x], input[rsRslt.y]);

        return result("findMinAndMax_array", new timing(size[0]), javaVal, rsVal);
!!!38735799.java!!!	findMinAndMax(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final float[] inputArray = createInputArrayFloat(size[0], seed);

        final long javaTimeStart = java.lang.System.currentTimeMillis();
        final Int2 javaRslt = findMinAndMax(inputArray);
        final long javaTimeEnd = java.lang.System.currentTimeMillis();

        final long rsTimeStart = java.lang.System.currentTimeMillis();

        Allocation inputAllocation = Allocation.createSized(RS, Element.F32(RS), inputArray.length);

        final long copyTimeStart = java.lang.System.currentTimeMillis();

        inputAllocation.copyFrom(inputArray);

        final long kernelTimeStart = java.lang.System.currentTimeMillis();
        final Int2 rsRslt = s.reduce_findMinAndMax(inputAllocation).get();
        final long rsTimeEnd = java.lang.System.currentTimeMillis();

        // Note that the Java and RenderScript algorithms are not
        // guaranteed to find the same cells -- but they should
        // find cells of the same value.
        final Float2 javaVal = new Float2(inputArray[javaRslt.x], inputArray[javaRslt.y]);
        final Float2 rsVal = new Float2(inputArray[rsRslt.x], inputArray[rsRslt.y]);

        final boolean success =
                result("findMinAndMax",
                        new timing(javaTimeStart, javaTimeEnd, rsTimeStart,
                                   copyTimeStart, kernelTimeStart, rsTimeEnd, inputAllocation),
                        javaVal, rsVal);
        inputAllocation.destroy();
        return success;
!!!38735927.java!!!	findMinMat(in inputArray : float, in matSize : int) : float
        final int matSizeSquared = matSize*matSize;

        float[] result = new float[matSizeSquared];
        for (int i = 0; i < matSizeSquared; ++i)
            result[i] = Float.POSITIVE_INFINITY;

        for (int i = 0; i < inputArray.length; ++i)
            result[i % matSizeSquared] = Math.min(result[i % matSizeSquared], inputArray[i]);

        return result;
!!!38736183.java!!!	findMinMat(inout RS : RenderScript, in seed : int, inout inputSize : int, in matSize : int, inout matElement : Element, inout reduction : UT_reduce::ReduceFindMinMat) : boolean
        final int length = inputSize[0];
        final int matSizeSquared = matSize*matSize;

        final float[] inputArray = createInputArrayFloat(matSizeSquared * length, seed);

        final long javaTimeStart = java.lang.System.currentTimeMillis();
        final float[] javaRslt = findMinMat(inputArray, matSize);
        final long javaTimeEnd = java.lang.System.currentTimeMillis();

        final long rsTimeStart = java.lang.System.currentTimeMillis();

        Allocation inputAllocation = Allocation.createSized(RS, matElement, length);

        final long copyTimeStart = java.lang.System.currentTimeMillis();

        inputAllocation.copyFromUnchecked(inputArray);

        final long kernelTimeStart = java.lang.System.currentTimeMillis();
        final float[] rsRslt = reduction.run(inputAllocation);
        final long rsTimeEnd = java.lang.System.currentTimeMillis();

        final boolean success =
                result("findMinMat" + matSize,
                        new timing(javaTimeStart, javaTimeEnd, rsTimeStart,
                                   copyTimeStart, kernelTimeStart, rsTimeEnd, inputAllocation),
                        javaRslt, rsRslt);
        inputAllocation.destroy();
        return success;
!!!38736311.java!!!	findMinMat2(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        return findMinMat(RS, seed, size, 2, Element.MATRIX_2X2(RS),
                (Allocation input) -> s.reduce_findMinMat2(input).get());
!!!38736439.java!!!	findMinMat4(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        return findMinMat(RS, seed, size, 4, Element.MATRIX_4X4(RS),
                (Allocation input) -> s.reduce_findMinMat4(input).get());
!!!38736567.java!!!	fz(in input : int) : int
        for (int i = 0; i < input.length; ++i)
            if (input[i] == 0)
                return i;
        return -1;
!!!38736695.java!!!	fz_array(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final int inputLen = size[0];
        int[] input = createInputArrayInt(inputLen, seed+0);
        // just in case we got unlucky
        input[(new Random(seed+1)).nextInt(inputLen)] = 0;

        final int rsRslt = s.reduce_fz(input).get();

        final boolean success = (input[rsRslt] == 0);
        Log.i(TAG,
                "fz_array: input[" + rsRslt + "] == " + input[rsRslt] + ": " +
                (success ? "PASSED " + timing.string(size[0]) : "FAILED"));
        return success;
!!!38736823.java!!!	fz(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final int inputLen = size[0];
        int[] inputArray = createInputArrayInt(inputLen, seed+0);
        // just in case we got unlucky
        inputArray[(new Random(seed+1)).nextInt(inputLen)] = 0;

        final long javaTimeStart = java.lang.System.currentTimeMillis();
        final int javaRslt = fz(inputArray);
        final long javaTimeEnd = java.lang.System.currentTimeMillis();

        final long rsTimeStart = java.lang.System.currentTimeMillis();

        Allocation inputAllocation = Allocation.createSized(RS, Element.I32(RS), inputArray.length);

        final long copyTimeStart = java.lang.System.currentTimeMillis();

        inputAllocation.copyFrom(inputArray);

        final long kernelTimeStart = java.lang.System.currentTimeMillis();
        final int rsRslt = s.reduce_fz(inputAllocation).get();
        final long rsTimeEnd = java.lang.System.currentTimeMillis();

        final boolean success = (inputArray[rsRslt] == 0);
        String status = (success ? "PASSED" : "FAILED");
        if (success)
            status += " " + timing.string(javaTimeStart, javaTimeEnd, rsTimeStart,
                                          copyTimeStart, kernelTimeStart, rsTimeEnd, inputAllocation);
        Log.i(TAG,
                "fz: java input[" + javaRslt + "] == " + inputArray[javaRslt] +
                ", rs input[" + rsRslt + "] == " + inputArray[javaRslt] + ": " + status);
        inputAllocation.destroy();
        return success;
!!!38736951.java!!!	fz2(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final int dimX = size[0], dimY = size[1];
        final int inputLen = dimX * dimY;

        int[] inputArray = createInputArrayInt(inputLen, seed+0);
        // just in case we got unlucky
        inputArray[(new Random(seed+1)).nextInt(inputLen)] = 0;

        final long javaTimeStart = java.lang.System.currentTimeMillis();
        final int javaRsltLinear = fz(inputArray);
        final long javaTimeEnd = java.lang.System.currentTimeMillis();

        final Int2 javaRslt = new Int2(javaRsltLinear % dimX, javaRsltLinear / dimX);
        final int javaCellVal = inputArray[javaRslt.x + dimX * javaRslt.y];

        final long rsTimeStart = java.lang.System.currentTimeMillis();

        Type.Builder typeBuilder = new Type.Builder(RS, Element.I32(RS));
        typeBuilder.setX(dimX).setY(dimY);
        Allocation inputAllocation = Allocation.createTyped(RS, typeBuilder.create());

        final long copyTimeStart = java.lang.System.currentTimeMillis();

        inputAllocation.copy2DRangeFrom(0, 0, dimX, dimY, inputArray);

        final long kernelTimeStart = java.lang.System.currentTimeMillis();
        final Int2 rsRslt = s.reduce_fz2(inputAllocation).get();
        final long rsTimeEnd = java.lang.System.currentTimeMillis();

        final int rsCellVal = inputArray[rsRslt.x + dimX * rsRslt.y];
        final boolean success = (rsCellVal == 0);
        String status = (success ? "PASSED" : "FAILED");
        if (success)
            status += " " + timing.string(javaTimeStart, javaTimeEnd, rsTimeStart,
                                          copyTimeStart, kernelTimeStart, rsTimeEnd, inputAllocation);
        Log.i(TAG,
                "fz2: java input[" + javaRslt.x + ", " + javaRslt.y + "] == " + javaCellVal +
                ", rs input[" + rsRslt.x + ", " + rsRslt.y + "] == " + rsCellVal + ": " + status);
        inputAllocation.destroy();
        return success;
!!!38737079.java!!!	fz3(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final int dimX = size[0], dimY = size[1], dimZ = size[2];
        final int inputLen = dimX * dimY * dimZ;

        int[] inputArray = createInputArrayInt(inputLen, seed+0);
        // just in case we got unlucky
        inputArray[(new Random(seed+1)).nextInt(inputLen)] = 0;

        final long javaTimeStart = java.lang.System.currentTimeMillis();
        final int javaRsltLinear = fz(inputArray);
        final long javaTimeEnd = java.lang.System.currentTimeMillis();

        final Int3 javaRslt = new Int3(
            javaRsltLinear % dimX,
            (javaRsltLinear / dimX) % dimY,
            javaRsltLinear / (dimX * dimY));
        final int javaCellVal = inputArray[javaRslt.x + dimX * javaRslt.y + dimX * dimY * javaRslt.z];

        final long rsTimeStart = java.lang.System.currentTimeMillis();

        Type.Builder typeBuilder = new Type.Builder(RS, Element.I32(RS));
        typeBuilder.setX(dimX).setY(dimY).setZ(dimZ);
        Allocation inputAllocation = Allocation.createTyped(RS, typeBuilder.create());

        final long copyTimeStart = java.lang.System.currentTimeMillis();

        inputAllocation.copy3DRangeFrom(0, 0, 0, dimX, dimY, dimZ, inputArray);

        final long kernelTimeStart = java.lang.System.currentTimeMillis();
        final Int3 rsRslt = s.reduce_fz3(inputAllocation).get();
        final long rsTimeEnd = java.lang.System.currentTimeMillis();

        final int rsCellVal = inputArray[rsRslt.x + dimX * rsRslt.y + dimX * dimY * rsRslt.z];
        final boolean success = (rsCellVal == 0);
        String status = (success ? "PASSED" : "FAILED");
        if (success)
            status += " " + timing.string(javaTimeStart, javaTimeEnd, rsTimeStart,
                                          copyTimeStart, kernelTimeStart, rsTimeEnd, inputAllocation);
        Log.i(TAG,
                "fz3: java input[" + javaRslt.x + ", " + javaRslt.y + ", " + javaRslt.z + "] == " + javaCellVal +
                ", rs input[" + rsRslt.x + ", " + rsRslt.y + ", " + rsRslt.z + "] == " + rsCellVal + ": " + status);
        inputAllocation.destroy();
        return success;
!!!38737207.java!!!	histogram(inout RS : RenderScript, in inputArray : byte) : long
        Allocation inputAllocation = Allocation.createSized(RS, Element.U8(RS), inputArray.length);
        inputAllocation.copyFrom(inputArray);

        Allocation outputAllocation = Allocation.createSized(RS, Element.U32(RS), histogramBucketCount);

        ScriptIntrinsicHistogram scriptHsg = ScriptIntrinsicHistogram.create(RS, Element.U8(RS));
        scriptHsg.setOutput(outputAllocation);
        scriptHsg.forEach(inputAllocation);

        int[] outputArrayMistyped = new int[histogramBucketCount];
        outputAllocation.copyTo(outputArrayMistyped);

        long[] outputArray = new long[histogramBucketCount];
        for (int i = 0; i < histogramBucketCount; ++i)
            outputArray[i] = outputArrayMistyped[i] & (long)0xffffffff;

        inputAllocation.destroy();
        outputAllocation.destroy();

        return outputArray;
!!!38737335.java!!!	histogram_array(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final byte[] inputArray = createInputArrayByte(size[0], seed);

        final long[] javaRslt = histogram(RS, inputArray);
        assertEquals("javaRslt length", histogramBucketCount, javaRslt.length);
        final long[] rsRslt = s.reduce_histogram(inputArray).get();
        assertEquals("rsRslt length", histogramBucketCount, rsRslt.length);

        return result("histogram_array", new timing(size[0]), javaRslt, rsRslt);
!!!38737463.java!!!	histogram(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final byte[] inputArray = createInputArrayByte(size[0], seed);

        final long javaTimeStart = java.lang.System.currentTimeMillis();
        final long[] javaRslt = histogram(RS, inputArray);
        final long javaTimeEnd = java.lang.System.currentTimeMillis();
        assertEquals("javaRslt length", histogramBucketCount, javaRslt.length);

        final long rsTimeStart = java.lang.System.currentTimeMillis();

        Allocation inputAllocation = Allocation.createSized(RS, Element.U8(RS), inputArray.length);

        final long copyTimeStart = java.lang.System.currentTimeMillis();

        inputAllocation.copyFrom(inputArray);

        final long kernelTimeStart = java.lang.System.currentTimeMillis();
        final long[] rsRslt = s.reduce_histogram(inputAllocation).get();
        final long rsTimeEnd = java.lang.System.currentTimeMillis();
        assertEquals("rsRslt length", histogramBucketCount, rsRslt.length);

        // NOTE: The "java time" is actually for the RenderScript histogram intrinsic
        final boolean success =
                result("histogram",
                        new timing(javaTimeStart, javaTimeEnd, rsTimeStart,
                                   copyTimeStart, kernelTimeStart, rsTimeEnd, inputAllocation),
                        javaRslt, rsRslt);
        inputAllocation.destroy();
        return success;
!!!38737591.java!!!	patternRedundantGet(inout RS : RenderScript, inout s : ScriptC_reduce) : boolean
        // Ensure that get() can be called multiple times on the same
        // result, and returns the same object each time.

        boolean pass = true;

        final int inputLength = 1 << 18;
        final byte[] inputArray = createInputArrayByte(inputLength, 789);

        final long[] javaRslt = histogram(RS, inputArray);
        assertEquals("javaRslt length", histogramBucketCount, javaRslt.length);

        final ScriptC_reduce.resultArray256_uint rsRsltFuture = s.reduce_histogram(inputArray);
        final long[] rsRslt1 = rsRsltFuture.get();
        assertEquals("rsRslt1 length", histogramBucketCount, rsRslt1.length);
        pass &= result("patternRedundantGet (1)", new timing(inputLength), javaRslt, rsRslt1);

        final long[] rsRslt2 = rsRsltFuture.get();
        pass &= result("patternRedundantGet (2)", new timing(inputLength), javaRslt, rsRslt2);

        final boolean success = (rsRslt1 == rsRslt2);
        Log.i(TAG, "patternRedundantGet (object equality): " + (success ? "PASSED" : "FAILED"));
        pass &= success;

        return pass;
!!!38737719.java!!!	mode(inout RS : RenderScript, in inputArray : byte) : Int2
        long[] hsg = histogram(RS, inputArray);

        int modeIdx = 0;
        for (int i = 1; i < hsg.length; ++i)
            if (hsg[i] > hsg[modeIdx]) modeIdx =i;
        return new Int2(modeIdx, (int)hsg[modeIdx]);
!!!38737847.java!!!	mode_array(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final byte[] inputArray = createInputArrayByte(size[0], seed);

        final Int2 javaRslt = mode(RS, inputArray);
        final Int2 rsRslt = s.reduce_mode(inputArray).get();

        return result("mode", new timing(size[0]), javaRslt, rsRslt);
!!!38737975.java!!!	sumgcd(in in1 : int, in in2 : int) : long
        assertEquals("sumgcd input lengths", in1.length, in2.length);

        long sum = 0;
        for (int i = 0; i < in1.length; ++i) {
            int a = in1[i], b = in2[i];

            while (b != 0) {
                final int aNew = b;
                final int bNew = a % b;

                a = aNew;
                b = bNew;
            }

            sum += a;
        }
        return sum;
!!!38738103.java!!!	sumgcd(inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        final int len = size[0];

        final int[] inputArrayA = createInputArrayInt(len, seed+0);
        final int[] inputArrayB = createInputArrayInt(len, seed+1);

        final long javaTimeStart = java.lang.System.currentTimeMillis();
        final long javaRslt = sumgcd(inputArrayA, inputArrayB);
        final long javaTimeEnd = java.lang.System.currentTimeMillis();

        final long rsTimeStart = java.lang.System.currentTimeMillis();

        Allocation inputAllocationA = Allocation.createSized(RS, Element.I32(RS), len);
        Allocation inputAllocationB = Allocation.createSized(RS, Element.I32(RS), len);

        final long copyTimeStart = java.lang.System.currentTimeMillis();

        inputAllocationA.copyFrom(inputArrayA);
        inputAllocationB.copyFrom(inputArrayB);

        final long kernelTimeStart = java.lang.System.currentTimeMillis();
        final long rsRslt = s.reduce_sumgcd(inputAllocationA, inputAllocationB).get();
        final long rsTimeEnd = java.lang.System.currentTimeMillis();

        final boolean success =
                result("sumgcd",
                        new timing(javaTimeStart, javaTimeEnd, rsTimeStart, copyTimeStart, kernelTimeStart, rsTimeEnd,
                                   inputAllocationA, inputAllocationB),
                        javaRslt, rsRslt);
        inputAllocationA.destroy();
        inputAllocationB.destroy();
        return success;
!!!38738231.java!!!	computeSizePoints(in maxVal : int, in sparseness : int) : int
        assertTrue((maxVal >= 0) && (sparseness > 0));

        final boolean maxValIsExtra = ((maxVal % sparseness) != 0);
        int[] result = new int[1 + maxVal/sparseness + (maxValIsExtra ? 1 : 0)];

        for (int i = 0; i * sparseness <= maxVal; ++i)
            result[i] = i * sparseness;
        if (maxValIsExtra)
            result[result.length - 1] = maxVal;

        return result;
!!!38738871.java!!!	run(inout td : UT_reduce::TestDescription, inout RS : RenderScript, inout s : ScriptC_reduce, in seed : int, inout size : int) : boolean
        String arrayContent = "";
        for (int i = 0; i < size.length; ++i) {
            if (i != 0)
                arrayContent += ", ";
            arrayContent += size[i];
        }
        Log.i(TAG, "Running " + td.testName + "(seed = " + seed + ", size[] = {" + arrayContent + "})");
        return td.test.run(RS, s, seed, size);
!!!38738999.java!!!	runCorrectnessQuick(inout RS : RenderScript, inout s : ScriptC_reduce) : boolean
        boolean pass = true;

        for (TestDescription td : correctnessTests) {
            pass &= run(td, RS, s, maxSeedsPerTest * td.seed, td.defSize);
        }

        return pass;
!!!38739127.java!!!	runCorrectness(inout RS : RenderScript, inout s : ScriptC_reduce) : boolean
        boolean pass = true;

        for (TestDescription td : correctnessTests) {
            switch (td.defSize.length) {
                case 1:
                    pass &= runCorrectness1D(td, RS, s);
                    break;
                case 2:
                    pass &= runCorrectness2D(td, RS, s);
                    break;
                case 3:
                    pass &= runCorrectness3D(td, RS, s);
                    break;
                default:
                    assertTrue("unexpected defSize.length " + td.defSize.length, false);
                    pass &= false;
                    break;
            }
        }

        return pass;
!!!38739255.java!!!	runCorrectness1D(inout td : UT_reduce::TestDescription, inout RS : RenderScript, inout s : ScriptC_reduce) : boolean
        assertEquals(1, td.sparseness);
        final int log2MaxSize = td.log2MaxSize;
        assertTrue(log2MaxSize >= 0);

        boolean pass = true;

        // We will execute the test with the following sizes:
        // (a) Each power of 2 from zero (2**0) up to log2MaxSize (2**log2MaxSize)
        // (b) Each size from (a) +/-1
        // (c) 2 random sizes between each pair of adjacent points in (a)
        int[] testSizes = new int[
            /* a */ (1 + log2MaxSize) +
            /* b */ 2*(1 + log2MaxSize) +
            /* c */ 2*log2MaxSize];
        // See seedsPerTestDescriptionCorrectness1D

        final int seedForPickingTestSizes = td.seed * seedsPerTestDescriptionCorrectness;

        int nextTestIdx = 0;

        // Fill in (a) and (b)
        for (int i = 0; i <= log2MaxSize; ++i) {
            final int pwrOf2 = 1 << i;
            testSizes[nextTestIdx++] = pwrOf2;      /* a */
            testSizes[nextTestIdx++] = pwrOf2 - 1;  /* b */
            testSizes[nextTestIdx++] = pwrOf2 + 1;  /* b */
        }

        // Fill in (c)
        Random r = new Random(seedForPickingTestSizes);
        for (int i = 0; i < log2MaxSize; ++i) {
            final int lo = (1 << i) + 1;
            final int hi = 1 << (i + 1);

            if (lo < hi) {
                for (int j = 0; j < 2; ++j) {
                    testSizes[nextTestIdx++] = r.nextInt(hi - lo) + lo;
                }
            }
        }

        Arrays.sort(testSizes);

        int[] lastTestSizeArg = new int[]{-1};
        for (int i = 0; i < testSizes.length; ++i) {
            if ((testSizes[i] > 0) && (testSizes[i] != lastTestSizeArg[0])) {
                lastTestSizeArg[0] = testSizes[i];
                final int seedForTestExecution = seedForPickingTestSizes + 1 + i*maxSeedsPerTest;
                pass &= run(td, RS, s, seedForTestExecution, lastTestSizeArg);
            }
        }

        return pass;
!!!38739383.java!!!	runCorrectness2D(inout td : UT_reduce::TestDescription, inout RS : RenderScript, inout s : ScriptC_reduce) : boolean
        final int log2MaxSize = td.log2MaxSize, maxSize = 1 << log2MaxSize, sparseness = td.sparseness;
        assertTrue((log2MaxSize >= 0) && (sparseness >= 1));

        boolean pass = true;

        final int[] sizePoints = computeSizePoints(log2MaxSize, sparseness);

        // We will execute the test with the following sizes:
        // (a) Each dimension at a power of 2 from sizePoints[]
        ///    such that the sum of the exponents does not exceed
        //     log2MaxSize
        // (b) Each size from (a) with one or both dimensions +/-1,
        //     except where this would exceed 2**log2MaxSize
        // (c) Approximately 2*(sizePoints.length**2) random sizes
        ArrayList<int[]> testSizesList = new ArrayList<int[]>();
        // See seedsPerTestDescriptionCorrectness2D

        final int seedForPickingTestSizes = td.seed * seedsPerTestDescriptionCorrectness;

        // Fill in (a) and (b)
        for (int i : sizePoints) {
            final int iPwrOf2 = 1 << i;
            for (int iDelta = -1; iDelta <= 1; ++iDelta) {
                final int iSize = iPwrOf2 + iDelta;
                for (int j : sizePoints) {
                    final int jPwrOf2 = 1 << j;
                    for (int jDelta = -1; jDelta <= 1; ++jDelta) {
                        final int jSize = jPwrOf2 + jDelta;
                        if ((long)iSize * (long)jSize <= maxSize)
                            testSizesList.add(new int[]{iSize, jSize});
                    }
                }
            }
        }

        // Fill in (c)
        Random r = new Random(seedForPickingTestSizes);
        for (int i : sizePoints) {
            for (int j : sizePoints) {
                final int size0 = 1 + r.nextInt(1 << i);
                final int size1 = 1 + r.nextInt(maxSize / size0);

                testSizesList.add(new int[]{size0, size1});
                testSizesList.add(new int[]{size1, size0});
            }
        }

        int[][] testSizes = testSizesList.toArray(new int[0][]);
        Arrays.sort(testSizes,
                (a, b) -> {
                    final int comp0 = ((Integer)a[0]).compareTo(b[0]);
                    return (comp0 != 0 ? comp0 : ((Integer)a[1]).compareTo(b[1]));
                });

        int[] lastTestSizeArg = null;
        for (int i = 0; i < testSizes.length; ++i) {
            if ((testSizes[i][0] <= 0) || (testSizes[i][1] <= 0))
                continue;
            if ((lastTestSizeArg != null) &&
                (testSizes[i][0] == lastTestSizeArg[0]) &&
                (testSizes[i][1] == lastTestSizeArg[1]))
                continue;
            lastTestSizeArg = testSizes[i];
            final int seedForTestExecution = seedForPickingTestSizes + 1 + i*maxSeedsPerTest;
            pass &= run(td, RS, s, seedForTestExecution, lastTestSizeArg);
        }

        return pass;
!!!38739511.java!!!	runCorrectness3D(inout td : UT_reduce::TestDescription, inout RS : RenderScript, inout s : ScriptC_reduce) : boolean
        final int log2MaxSize = td.log2MaxSize, maxSize = 1 << log2MaxSize, sparseness = td.sparseness;
        assertTrue((log2MaxSize >= 0) && (sparseness >= 1));

        boolean pass = true;

        final int[] sizePoints = computeSizePoints(log2MaxSize, sparseness);

        // We will execute the test with the following sizes:
        // (a) Each dimension at a power of 2 from sizePoints[]
        ///    such that the sum of the exponents does not exceed
        //     log2MaxSize
        // (b) Each size from (a) with one or both dimensions +/-1,
        //     except where this would exceed 2**log2MaxSize
        // (c) Approximately 6*(sizePoints.length**2) random sizes
        ArrayList<int[]> testSizesList = new ArrayList<int[]>();
        // See seedsPerTestDescriptionCorrectness3D

        final int seedForPickingTestSizes = td.seed * seedsPerTestDescriptionCorrectness;

        // Fill in (a) and (b)
        for (int i : sizePoints) {
            final int iPwrOf2 = 1 << i;
            for (int iDelta = -1; iDelta <= 1; ++iDelta) {
                final int iSize = iPwrOf2 + iDelta;
                for (int j : sizePoints) {
                    final int jPwrOf2 = 1 << j;
                    for (int jDelta = -1; jDelta <= 1; ++jDelta) {
                        final int jSize = jPwrOf2 + jDelta;
                        for (int k : sizePoints) {
                            final int kPwrOf2 = 1 << k;
                            for (int kDelta = -1; kDelta <= 1; ++kDelta) {
                                final int kSize = kPwrOf2 + kDelta;
                                if ((long)iSize * (long)jSize * (long)kSize <= maxSize)
                                    testSizesList.add(new int[]{iSize, jSize, kSize});
                            }
                        }
                    }
                }
            }
        }

        // Fill in (c)
        Random r = new Random(seedForPickingTestSizes);
        for (int i : sizePoints) {
            for (int j : sizePoints) {
                final int size0 = 1 + r.nextInt(1 << i);
                final int size1 = 1 + r.nextInt(Math.min(1 << j, maxSize / size0));
                final int size2 = 1 + r.nextInt(maxSize / (size0*size1));

                testSizesList.add(new int[]{size0, size1, size2});
                testSizesList.add(new int[]{size0, size2, size1});
                testSizesList.add(new int[]{size1, size0, size2});
                testSizesList.add(new int[]{size1, size2, size0});
                testSizesList.add(new int[]{size2, size0, size1});
                testSizesList.add(new int[]{size2, size1, size0});
            }
        }

        int[][] testSizes = testSizesList.toArray(new int[0][]);
        Arrays.sort(testSizes,
                (a, b) -> {
                    int comp = ((Integer)a[0]).compareTo(b[0]);
                    if (comp == 0)
                        comp = ((Integer)a[1]).compareTo(b[1]);
                    if (comp == 0)
                        comp = ((Integer)a[2]).compareTo(b[2]);
                    return comp;
                });

        int[] lastTestSizeArg = null;
        for (int i = 0; i < testSizes.length; ++i) {
            if ((testSizes[i][0] <= 0) || (testSizes[i][1] <= 0) || (testSizes[i][2] <= 0))
                continue;
            if ((lastTestSizeArg != null) &&
                (testSizes[i][0] == lastTestSizeArg[0]) &&
                (testSizes[i][1] == lastTestSizeArg[1]) &&
                (testSizes[i][2] == lastTestSizeArg[2]))
                continue;

            // Apply Z-dimension limiting.
            //
            // The Z dimension is always handled specially by GPU
            // drivers, and a high value for this dimension can have
            // serious performance implications.  For example, Cuda
            // and OpenCL encourage Z to be the smallest dimension.
            if (testSizes[i][2] > 1024)
                continue;

            lastTestSizeArg = testSizes[i];
            final int seedForTestExecution = seedForPickingTestSizes + 1 + i*maxSeedsPerTest;
            pass &= run(td, RS, s, seedForTestExecution, lastTestSizeArg);
        }

        return pass;
!!!38739639.java!!!	runPerformanceQuick(inout RS : RenderScript, inout s : ScriptC_reduce) : boolean
        boolean pass = true;

        for (TestDescription td : performanceTests) {
            pass &= run(td, RS, s, maxSeedsPerTest * td.seed, td.defSize);
        }

        return pass;
!!!38739767.java!!!	runCorrectnessPatterns(inout RS : RenderScript, inout s : ScriptC_reduce) : boolean
        // Test some very specific usage patterns.
        boolean pass = true;

        pass &= patternDuplicateAnonymousResult(RS, s);
        pass &= patternInterleavedReduce(RS, s);
        pass &= patternRedundantGet(RS, s);

        return pass;
!!!38739895.java!!!	run() : void
        RenderScript pRS = RenderScript.create(mCtx);
        ScriptC_reduce s = new ScriptC_reduce(pRS);
        s.set_negInf(Float.NEGATIVE_INFINITY);
        s.set_posInf(Float.POSITIVE_INFINITY);

        boolean pass = true;

        pass &= runCorrectnessPatterns(pRS, s);
        pass &= runCorrectnessQuick(pRS, s);
        pass &= runCorrectness(pRS, s);
        // pass &= runPerformanceQuick(pRS, s);

        pRS.finish();
        pRS.destroy();

        Log.i(TAG, pass ? "PASSED" : "FAILED");
        if (pass)
            passTest();
        else
            failTest();
