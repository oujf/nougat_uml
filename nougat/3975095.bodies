class ShortcutService
!!!42763831.java!!!	ShortcutService(inout context : Context)
        this(context, BackgroundThread.get().getLooper());
!!!42763959.java!!!	ShortcutService(inout context : Context, inout looper : Looper)
        mContext = Preconditions.checkNotNull(context);
        LocalServices.addService(ShortcutServiceInternal.class, new LocalService());
        mHandler = new Handler(looper);
        mIPackageManager = AppGlobals.getPackageManager();
        mPackageManagerInternal = LocalServices.getService(PackageManagerInternal.class);
        mUserManager = context.getSystemService(UserManager.class);

        if (!FEATURE_ENABLED) {
            return;
        }
        mPackageMonitor.register(context, looper, UserHandle.ALL, /* externalStorage= */ false);

        injectRegisterUidObserver(mUidObserver, ActivityManager.UID_OBSERVER_PROCSTATE
                | ActivityManager.UID_OBSERVER_GONE);
!!!42764087.java!!!	logDurationStat(in statId : int, in start : long) : void
        synchronized (mStatLock) {
            mCountStats[statId]++;
            mDurationStats[statId] += (System.currentTimeMillis() - start);
        }
!!!42764215.java!!!	getLocaleChangeSequenceNumber() : long
        return mLocaleChangeSequenceNumber.get();
!!!42764343.java!!!	handleOnUidStateChanged(in uid : int, in procState : int) : void
        if (DEBUG_PROCSTATE) {
            Slog.d(TAG, "onUidStateChanged: uid=" + uid + " state=" + procState);
        }
        synchronized (mLock) {
            mUidState.put(uid, procState);

            // We need to keep track of last time an app comes to foreground.
            // See ShortcutPackage.getApiCallCount() for how it's used.
            // It doesn't have to be persisted, but it needs to be the elapsed time.
            if (isProcessStateForeground(procState)) {
                mUidLastForegroundElapsedTime.put(uid, injectElapsedRealtime());
            }
        }
!!!42764471.java!!!	isProcessStateForeground(in processState : int) : boolean
        return processState <= PROCESS_STATE_FOREGROUND_THRESHOLD;
!!!42764599.java!!!	isUidForegroundLocked(in uid : int) : boolean
        if (uid == Process.SYSTEM_UID) {
            // IUidObserver doesn't report the state of SYSTEM, but it always has bound services,
            // so it's foreground anyway.
            return true;
        }
        return isProcessStateForeground(mUidState.get(uid, ActivityManager.MAX_PROCESS_STATE));
!!!42764727.java!!!	getUidLastForegroundElapsedTimeLocked(in uid : int) : long
        return mUidLastForegroundElapsedTime.get(uid);
!!!42765495.java!!!	onBootPhase(in phase : int) : void
        // We want to call initialize() to initialize the configurations, so we don't disable this.
        if (DEBUG) {
            Slog.d(TAG, "onBootPhase: " + phase);
        }
        switch (phase) {
            case SystemService.PHASE_LOCK_SETTINGS_READY:
                initialize();
                break;
        }
!!!42765623.java!!!	handleUnlockUser(in userId : int) : void
        if (!FEATURE_ENABLED) {
            return;
        }
        synchronized (mLock) {
            // Preload
            getUserShortcutsLocked(userId);

            checkPackageChanges(userId);
        }
!!!42765751.java!!!	handleCleanupUser(in userId : int) : void
        if (!FEATURE_ENABLED) {
            return;
        }
        synchronized (mLock) {
            unloadUserLocked(userId);
        }
!!!42765879.java!!!	unloadUserLocked(in userId : int) : void
        if (DEBUG) {
            Slog.d(TAG, "unloadUserLocked: user=" + userId);
        }
        // Save all dirty information.
        saveDirtyInfo();

        // Unload
        mUsers.delete(userId);
!!!42766007.java!!!	getBaseStateFile() : AtomicFile
        final File path = new File(injectSystemDataPath(), FILENAME_BASE_STATE);
        path.mkdirs();
        return new AtomicFile(path);
!!!42766135.java!!!	initialize() : void
        synchronized (mLock) {
            loadConfigurationLocked();
            loadBaseStateLocked();
        }
!!!42766263.java!!!	loadConfigurationLocked() : void
        updateConfigurationLocked(injectShortcutManagerConstants());
!!!42766391.java!!!	updateConfigurationLocked(inout config : String) : boolean
        boolean result = true;

        final KeyValueListParser parser = new KeyValueListParser(',');
        try {
            parser.setString(config);
        } catch (IllegalArgumentException e) {
            // Failed to parse the settings string, log this and move on
            // with defaults.
            Slog.e(TAG, "Bad shortcut manager settings", e);
            result = false;
        }

        mSaveDelayMillis = Math.max(0, (int) parser.getLong(ConfigConstants.KEY_SAVE_DELAY_MILLIS,
                DEFAULT_SAVE_DELAY_MS));

        mResetInterval = Math.max(1, parser.getLong(
                ConfigConstants.KEY_RESET_INTERVAL_SEC, DEFAULT_RESET_INTERVAL_SEC)
                * 1000L);

        mMaxUpdatesPerInterval = Math.max(0, (int) parser.getLong(
                ConfigConstants.KEY_MAX_UPDATES_PER_INTERVAL, DEFAULT_MAX_UPDATES_PER_INTERVAL));

        mMaxDynamicShortcuts = Math.max(0, (int) parser.getLong(
                ConfigConstants.KEY_MAX_SHORTCUTS, DEFAULT_MAX_SHORTCUTS_PER_APP));

        final int iconDimensionDp = Math.max(1, injectIsLowRamDevice()
                ? (int) parser.getLong(
                    ConfigConstants.KEY_MAX_ICON_DIMENSION_DP_LOWRAM,
                    DEFAULT_MAX_ICON_DIMENSION_LOWRAM_DP)
                : (int) parser.getLong(
                    ConfigConstants.KEY_MAX_ICON_DIMENSION_DP,
                    DEFAULT_MAX_ICON_DIMENSION_DP));

        mMaxIconDimension = injectDipToPixel(iconDimensionDp);

        mIconPersistFormat = CompressFormat.valueOf(
                parser.getString(ConfigConstants.KEY_ICON_FORMAT, DEFAULT_ICON_PERSIST_FORMAT));

        mIconPersistQuality = (int) parser.getLong(
                ConfigConstants.KEY_ICON_QUALITY,
                DEFAULT_ICON_PERSIST_QUALITY);

        return result;
!!!42766519.java!!!	injectShortcutManagerConstants() : String
        return android.provider.Settings.Global.getString(
                mContext.getContentResolver(),
                android.provider.Settings.Global.SHORTCUT_MANAGER_CONSTANTS);
!!!42766647.java!!!	injectDipToPixel(in dip : int) : int
        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dip,
                mContext.getResources().getDisplayMetrics());
!!!42766775.java!!!	parseStringAttribute(inout parser : XmlPullParser, inout attribute : String) : String
        return parser.getAttributeValue(null, attribute);
!!!42766903.java!!!	parseBooleanAttribute(inout parser : XmlPullParser, inout attribute : String) : boolean
        return parseLongAttribute(parser, attribute) == 1;
!!!42767031.java!!!	parseIntAttribute(inout parser : XmlPullParser, inout attribute : String) : int
        return (int) parseLongAttribute(parser, attribute);
!!!42767159.java!!!	parseIntAttribute(inout parser : XmlPullParser, inout attribute : String, in def : int) : int
        return (int) parseLongAttribute(parser, attribute, def);
!!!42767287.java!!!	parseLongAttribute(inout parser : XmlPullParser, inout attribute : String) : long
        return parseLongAttribute(parser, attribute, 0);
!!!42767415.java!!!	parseLongAttribute(inout parser : XmlPullParser, inout attribute : String, in def : long) : long
        final String value = parseStringAttribute(parser, attribute);
        if (TextUtils.isEmpty(value)) {
            return def;
        }
        try {
            return Long.parseLong(value);
        } catch (NumberFormatException e) {
            Slog.e(TAG, "Error parsing long " + value);
            return def;
        }
!!!42767543.java!!!	parseComponentNameAttribute(inout parser : XmlPullParser, inout attribute : String) : ComponentName
        final String value = parseStringAttribute(parser, attribute);
        if (TextUtils.isEmpty(value)) {
            return null;
        }
        return ComponentName.unflattenFromString(value);
!!!42767671.java!!!	parseIntentAttribute(inout parser : XmlPullParser, inout attribute : String) : Intent
        final String value = parseStringAttribute(parser, attribute);
        if (TextUtils.isEmpty(value)) {
            return null;
        }
        try {
            return Intent.parseUri(value, /* flags =*/ 0);
        } catch (URISyntaxException e) {
            Slog.e(TAG, "Error parsing intent", e);
            return null;
        }
!!!42767799.java!!!	writeTagValue(inout out : XmlSerializer, inout tag : String, inout value : String) : void
        if (TextUtils.isEmpty(value)) return;

        out.startTag(null, tag);
        out.attribute(null, ATTR_VALUE, value);
        out.endTag(null, tag);
!!!42767927.java!!!	writeTagValue(inout out : XmlSerializer, inout tag : String, in value : long) : void
        writeTagValue(out, tag, Long.toString(value));
!!!42768055.java!!!	writeTagValue(inout out : XmlSerializer, inout tag : String, inout name : ComponentName) : void
        if (name == null) return;
        writeTagValue(out, tag, name.flattenToString());
!!!42768183.java!!!	writeTagExtra(inout out : XmlSerializer, inout tag : String, inout bundle : PersistableBundle) : void
        if (bundle == null) return;

        out.startTag(null, tag);
        bundle.saveToXml(out);
        out.endTag(null, tag);
!!!42768311.java!!!	writeAttr(inout out : XmlSerializer, inout name : String, inout value : String) : void
        if (TextUtils.isEmpty(value)) return;

        out.attribute(null, name, value);
!!!42768439.java!!!	writeAttr(inout out : XmlSerializer, inout name : String, in value : long) : void
        writeAttr(out, name, String.valueOf(value));
!!!42768567.java!!!	writeAttr(inout out : XmlSerializer, inout name : String, inout value : boolean) : void
        if (value) {
            writeAttr(out, name, "1");
        }
!!!42768695.java!!!	writeAttr(inout out : XmlSerializer, inout name : String, inout comp : ComponentName) : void
        if (comp == null) return;
        writeAttr(out, name, comp.flattenToString());
!!!42768823.java!!!	writeAttr(inout out : XmlSerializer, inout name : String, inout intent : Intent) : void
        if (intent == null) return;

        writeAttr(out, name, intent.toUri(/* flags =*/ 0));
!!!42768951.java!!!	saveBaseStateLocked() : void
        final AtomicFile file = getBaseStateFile();
        if (DEBUG) {
            Slog.d(TAG, "Saving to " + file.getBaseFile());
        }

        FileOutputStream outs = null;
        try {
            outs = file.startWrite();

            // Write to XML
            XmlSerializer out = new FastXmlSerializer();
            out.setOutput(outs, StandardCharsets.UTF_8.name());
            out.startDocument(null, true);
            out.startTag(null, TAG_ROOT);

            // Body.
            writeTagValue(out, TAG_LAST_RESET_TIME, mRawLastResetTime);
            writeTagValue(out, TAG_LOCALE_CHANGE_SEQUENCE_NUMBER,
                    mLocaleChangeSequenceNumber.get());

            // Epilogue.
            out.endTag(null, TAG_ROOT);
            out.endDocument();

            // Close.
            file.finishWrite(outs);
        } catch (IOException e) {
            Slog.e(TAG, "Failed to write to file " + file.getBaseFile(), e);
            file.failWrite(outs);
        }
!!!42769079.java!!!	loadBaseStateLocked() : void
        mRawLastResetTime = 0;

        final AtomicFile file = getBaseStateFile();
        if (DEBUG) {
            Slog.d(TAG, "Loading from " + file.getBaseFile());
        }
        try (FileInputStream in = file.openRead()) {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(in, StandardCharsets.UTF_8.name());

            int type;
            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {
                if (type != XmlPullParser.START_TAG) {
                    continue;
                }
                final int depth = parser.getDepth();
                // Check the root tag
                final String tag = parser.getName();
                if (depth == 1) {
                    if (!TAG_ROOT.equals(tag)) {
                        Slog.e(TAG, "Invalid root tag: " + tag);
                        return;
                    }
                    continue;
                }
                // Assume depth == 2
                switch (tag) {
                    case TAG_LAST_RESET_TIME:
                        mRawLastResetTime = parseLongAttribute(parser, ATTR_VALUE);
                        break;
                    case TAG_LOCALE_CHANGE_SEQUENCE_NUMBER:
                        mLocaleChangeSequenceNumber.set(parseLongAttribute(parser, ATTR_VALUE));
                        break;
                    default:
                        Slog.e(TAG, "Invalid tag: " + tag);
                        break;
                }
            }
        } catch (FileNotFoundException e) {
            // Use the default
        } catch (IOException|XmlPullParserException e) {
            Slog.e(TAG, "Failed to read file " + file.getBaseFile(), e);

            mRawLastResetTime = 0;
        }
        // Adjust the last reset time.
        getLastResetTimeLocked();
!!!42769207.java!!!	saveUserLocked(in userId : int) : void
        final File path = new File(injectUserDataPath(userId), FILENAME_USER_PACKAGES);
        if (DEBUG) {
            Slog.d(TAG, "Saving to " + path);
        }
        path.mkdirs();
        final AtomicFile file = new AtomicFile(path);
        FileOutputStream os = null;
        try {
            os = file.startWrite();

            saveUserInternalLocked(userId, os, /* forBackup= */ false);

            file.finishWrite(os);
        } catch (XmlPullParserException|IOException e) {
            Slog.e(TAG, "Failed to write to file " + file.getBaseFile(), e);
            file.failWrite(os);
        }
!!!42769335.java!!!	saveUserInternalLocked(in userId : int, inout os : OutputStream, inout forBackup : boolean) : void

        final BufferedOutputStream bos = new BufferedOutputStream(os);

        // Write to XML
        XmlSerializer out = new FastXmlSerializer();
        out.setOutput(bos, StandardCharsets.UTF_8.name());
        out.startDocument(null, true);

        getUserShortcutsLocked(userId).saveToXml(this, out, forBackup);

        out.endDocument();

        bos.flush();
        os.flush();
!!!42769463.java!!!	throwForInvalidTag(in depth : int, inout tag : String) : IOException
        throw new IOException(String.format("Invalid tag '%s' found at depth %d", tag, depth));
!!!42769591.java!!!	warnForInvalidTag(in depth : int, inout tag : String) : void
        Slog.w(TAG, String.format("Invalid tag '%s' found at depth %d", tag, depth));
!!!42769719.java!!!	loadUserLocked(in userId : int) : ShortcutUser
        final File path = new File(injectUserDataPath(userId), FILENAME_USER_PACKAGES);
        if (DEBUG) {
            Slog.d(TAG, "Loading from " + path);
        }
        final AtomicFile file = new AtomicFile(path);

        final FileInputStream in;
        try {
            in = file.openRead();
        } catch (FileNotFoundException e) {
            if (DEBUG) {
                Slog.d(TAG, "Not found " + path);
            }
            return null;
        }
        try {
            return loadUserInternal(userId, in, /* forBackup= */ false);
        } catch (IOException|XmlPullParserException e) {
            Slog.e(TAG, "Failed to read file " + file.getBaseFile(), e);
            return null;
        } finally {
            IoUtils.closeQuietly(in);
        }
!!!42769847.java!!!	loadUserInternal(in userId : int, inout is : InputStream, inout fromBackup : boolean) : ShortcutUser

        final BufferedInputStream bis = new BufferedInputStream(is);

        ShortcutUser ret = null;
        XmlPullParser parser = Xml.newPullParser();
        parser.setInput(bis, StandardCharsets.UTF_8.name());

        int type;
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {
            if (type != XmlPullParser.START_TAG) {
                continue;
            }
            final int depth = parser.getDepth();

            final String tag = parser.getName();
            if (DEBUG_LOAD) {
                Slog.d(TAG, String.format("depth=%d type=%d name=%s",
                        depth, type, tag));
            }
            if ((depth == 1) && ShortcutUser.TAG_ROOT.equals(tag)) {
                ret = ShortcutUser.loadFromXml(this, parser, userId, fromBackup);
                continue;
            }
            throwForInvalidTag(depth, tag);
        }
        return ret;
!!!42769975.java!!!	scheduleSaveBaseState() : void
        scheduleSaveInner(UserHandle.USER_NULL); // Special case -- use USER_NULL for base state.
!!!42770103.java!!!	scheduleSaveUser(in userId : int) : void
        scheduleSaveInner(userId);
!!!42770231.java!!!	scheduleSaveInner(in userId : int) : void
        if (DEBUG) {
            Slog.d(TAG, "Scheduling to save for " + userId);
        }
        synchronized (mLock) {
            if (!mDirtyUserIds.contains(userId)) {
                mDirtyUserIds.add(userId);
            }
        }
        // If already scheduled, remove that and re-schedule in N seconds.
        mHandler.removeCallbacks(mSaveDirtyInfoRunner);
        mHandler.postDelayed(mSaveDirtyInfoRunner, mSaveDelayMillis);
!!!42770359.java!!!	saveDirtyInfo() : void
        if (DEBUG) {
            Slog.d(TAG, "saveDirtyInfo");
        }
        synchronized (mLock) {
            for (int i = mDirtyUserIds.size() - 1; i >= 0; i--) {
                final int userId = mDirtyUserIds.get(i);
                if (userId == UserHandle.USER_NULL) { // USER_NULL for base state.
                    saveBaseStateLocked();
                } else {
                    saveUserLocked(userId);
                }
            }
            mDirtyUserIds.clear();
        }
!!!42770487.java!!!	getLastResetTimeLocked() : long
        updateTimesLocked();
        return mRawLastResetTime;
!!!42770615.java!!!	getNextResetTimeLocked() : long
        updateTimesLocked();
        return mRawLastResetTime + mResetInterval;
!!!42770743.java!!!	isClockValid(in time : long) : boolean
        return time >= 1420070400; // Thu, 01 Jan 2015 00:00:00 GMT
!!!42770871.java!!!	updateTimesLocked() : void

        final long now = injectCurrentTimeMillis();

        final long prevLastResetTime = mRawLastResetTime;

        if (mRawLastResetTime == 0) { // first launch.
            // TODO Randomize??
            mRawLastResetTime = now;
        } else if (now < mRawLastResetTime) {
            // Clock rewound.
            if (isClockValid(now)) {
                Slog.w(TAG, "Clock rewound");
                // TODO Randomize??
                mRawLastResetTime = now;
            }
        } else {
            if ((mRawLastResetTime + mResetInterval) <= now) {
                final long offset = mRawLastResetTime % mResetInterval;
                mRawLastResetTime = ((now / mResetInterval) * mResetInterval) + offset;
            }
        }
        if (prevLastResetTime != mRawLastResetTime) {
            scheduleSaveBaseState();
        }
!!!42770999.java!!!	isUserLoadedLocked(in userId : int) : boolean
        return mUsers.get(userId) != null;
!!!42771127.java!!!	getUserShortcutsLocked(in userId : int) : ShortcutUser
        ShortcutUser userPackages = mUsers.get(userId);
        if (userPackages == null) {
            userPackages = loadUserLocked(userId);
            if (userPackages == null) {
                userPackages = new ShortcutUser(userId);
            }
            mUsers.put(userId, userPackages);
        }
        return userPackages;
!!!42771255.java!!!	forEachLoadedUserLocked(inout c : Consumer<ShortcutUser>) : void
        for (int i = mUsers.size() - 1; i >= 0; i--) {
            c.accept(mUsers.valueAt(i));
        }
!!!42771383.java!!!	getPackageShortcutsLocked(inout packageName : String, in userId : int) : ShortcutPackage
        return getUserShortcutsLocked(userId).getPackageShortcuts(this, packageName);
!!!42771511.java!!!	getLauncherShortcutsLocked(inout packageName : String, in ownerUserId : int, in launcherUserId : int) : ShortcutLauncher
        return getUserShortcutsLocked(ownerUserId)
                .getLauncherShortcuts(this, packageName, launcherUserId);
!!!42771639.java!!!	removeIcon(in userId : int, inout shortcut : ShortcutInfo) : void
        if (shortcut.getBitmapPath() != null) {
            if (DEBUG) {
                Slog.d(TAG, "Removing " + shortcut.getBitmapPath());
            }
            new File(shortcut.getBitmapPath()).delete();

            shortcut.setBitmapPath(null);
            shortcut.setIconResourceId(0);
            shortcut.clearFlags(ShortcutInfo.FLAG_HAS_ICON_FILE | ShortcutInfo.FLAG_HAS_ICON_RES);
        }
!!!42771767.java!!!	cleanupBitmapsForPackage(in userId : int, inout packageName : String) : void
        final File packagePath = new File(getUserBitmapFilePath(userId), packageName);
        if (!packagePath.isDirectory()) {
            return;
        }
        if (!(FileUtils.deleteContents(packagePath) && packagePath.delete())) {
            Slog.w(TAG, "Unable to remove directory " + packagePath);
        }
!!!42772151.java!!!	openIconFileForWrite(in userId : int, inout shortcut : ShortcutInfo) : ShortcutService::FileOutputStreamWithPath
        final File packagePath = new File(getUserBitmapFilePath(userId),
                shortcut.getPackageName());
        if (!packagePath.isDirectory()) {
            packagePath.mkdirs();
            if (!packagePath.isDirectory()) {
                throw new IOException("Unable to create directory " + packagePath);
            }
            SELinux.restorecon(packagePath);
        }

        final String baseName = String.valueOf(injectCurrentTimeMillis());
        for (int suffix = 0;; suffix++) {
            final String filename = (suffix == 0 ? baseName : baseName + "_" + suffix) + ".png";
            final File file = new File(packagePath, filename);
            if (!file.exists()) {
                if (DEBUG) {
                    Slog.d(TAG, "Saving icon to " + file.getAbsolutePath());
                }
                return new FileOutputStreamWithPath(file);
            }
        }
!!!42772279.java!!!	saveIconAndFixUpShortcut(in userId : int, inout shortcut : ShortcutInfo) : void
        if (shortcut.hasIconFile() || shortcut.hasIconResource()) {
            return;
        }

        final long token = injectClearCallingIdentity();
        try {
            // Clear icon info on the shortcut.
            shortcut.setIconResourceId(0);
            shortcut.setBitmapPath(null);

            final Icon icon = shortcut.getIcon();
            if (icon == null) {
                return; // has no icon
            }

            Bitmap bitmap;
            Bitmap bitmapToRecycle = null;
            try {
                switch (icon.getType()) {
                    case Icon.TYPE_RESOURCE: {
                        injectValidateIconResPackage(shortcut, icon);

                        shortcut.setIconResourceId(icon.getResId());
                        shortcut.addFlags(ShortcutInfo.FLAG_HAS_ICON_RES);
                        return;
                    }
                    case Icon.TYPE_BITMAP: {
                        bitmap = icon.getBitmap(); // Don't recycle in this case.
                        break;
                    }
                    default:
                        // This shouldn't happen because we've already validated the icon, but
                        // just in case.
                        throw ShortcutInfo.getInvalidIconException();
                }
                if (bitmap == null) {
                    Slog.e(TAG, "Null bitmap detected");
                    return;
                }
                // Shrink and write to the file.
                File path = null;
                try {
                    final FileOutputStreamWithPath out = openIconFileForWrite(userId, shortcut);
                    try {
                        path = out.getFile();

                        Bitmap shrunk = shrinkBitmap(bitmap, mMaxIconDimension);
                        try {
                            shrunk.compress(mIconPersistFormat, mIconPersistQuality, out);
                        } finally {
                            if (bitmap != shrunk) {
                                shrunk.recycle();
                            }
                        }

                        shortcut.setBitmapPath(out.getFile().getAbsolutePath());
                        shortcut.addFlags(ShortcutInfo.FLAG_HAS_ICON_FILE);
                    } finally {
                        IoUtils.closeQuietly(out);
                    }
                } catch (IOException|RuntimeException e) {
                    // STOPSHIP Change wtf to e
                    Slog.wtf(ShortcutService.TAG, "Unable to write bitmap to file", e);
                    if (path != null && path.exists()) {
                        path.delete();
                    }
                }
            } finally {
                if (bitmapToRecycle != null) {
                    bitmapToRecycle.recycle();
                }
                // Once saved, we won't use the original icon information, so null it out.
                shortcut.clearIcon();
            }
        } finally {
            injectRestoreCallingIdentity(token);
        }
!!!42772407.java!!!	injectValidateIconResPackage(inout shortcut : ShortcutInfo, inout icon : Icon) : void
        if (!shortcut.getPackageName().equals(icon.getResPackage())) {
            throw new IllegalArgumentException(
                    "Icon resource must reside in shortcut owner package");
        }
!!!42772535.java!!!	shrinkBitmap(inout in : Bitmap, in maxSize : int) : Bitmap
        // Original width/height.
        final int ow = in.getWidth();
        final int oh = in.getHeight();
        if ((ow <= maxSize) && (oh <= maxSize)) {
            if (DEBUG) {
                Slog.d(TAG, String.format("Icon size %dx%d, no need to shrink", ow, oh));
            }
            return in;
        }
        final int longerDimension = Math.max(ow, oh);

        // New width and height.
        final int nw = ow * maxSize / longerDimension;
        final int nh = oh * maxSize / longerDimension;
        if (DEBUG) {
            Slog.d(TAG, String.format("Icon size %dx%d, shrinking to %dx%d",
                    ow, oh, nw, nh));
        }

        final Bitmap scaledBitmap = Bitmap.createBitmap(nw, nh, Bitmap.Config.ARGB_8888);
        final Canvas c = new Canvas(scaledBitmap);

        final RectF dst = new RectF(0, 0, nw, nh);

        c.drawBitmap(in, /*src=*/ null, dst, /* paint =*/ null);

        return scaledBitmap;
!!!42772663.java!!!	isCallerSystem() : boolean
        final int callingUid = injectBinderCallingUid();
         return UserHandle.isSameApp(callingUid, Process.SYSTEM_UID);
!!!42772791.java!!!	isCallerShell() : boolean
        final int callingUid = injectBinderCallingUid();
        return callingUid == Process.SHELL_UID || callingUid == Process.ROOT_UID;
!!!42772919.java!!!	enforceSystemOrShell() : void
        Preconditions.checkState(isCallerSystem() || isCallerShell(),
                "Caller must be system or shell");
!!!42773047.java!!!	enforceShell() : void
        Preconditions.checkState(isCallerShell(), "Caller must be shell");
!!!42773175.java!!!	enforceSystem() : void
        Preconditions.checkState(isCallerSystem(), "Caller must be system");
!!!42773303.java!!!	enforceResetThrottlingPermission() : void
        if (isCallerSystem()) {
            return;
        }
        injectEnforceCallingPermission(
                android.Manifest.permission.RESET_SHORTCUT_MANAGER_THROTTLING, null);
!!!42773431.java!!!	injectEnforceCallingPermission(inout permission : String, inout message : String) : void
        mContext.enforceCallingPermission(permission, message);
!!!42773559.java!!!	verifyCaller(inout packageName : String, in userId : int) : void
        Preconditions.checkStringNotEmpty(packageName, "packageName");

        if (isCallerSystem()) {
            return; // no check
        }

        final int callingUid = injectBinderCallingUid();

        // Otherwise, make sure the arguments are valid.
        if (UserHandle.getUserId(callingUid) != userId) {
            throw new SecurityException("Invalid user-ID");
        }
        if (injectGetPackageUid(packageName, userId) == injectBinderCallingUid()) {
            return; // Caller is valid.
        }
        throw new SecurityException("Calling package name mismatch");
!!!42773687.java!!!	postToHandler(inout r : Runnable) : void
        mHandler.post(r);
!!!42773815.java!!!	enforceMaxDynamicShortcuts(in numShortcuts : int) : void
        if (numShortcuts > mMaxDynamicShortcuts) {
            throw new IllegalArgumentException("Max number of dynamic shortcuts exceeded");
        }
!!!42773943.java!!!	packageShortcutsChanged(inout packageName : String, in userId : int) : void
        if (DEBUG) {
            Slog.d(TAG, String.format(
                    "Shortcut changes: package=%s, user=%d", packageName, userId));
        }
        notifyListeners(packageName, userId);
        scheduleSaveUser(userId);
!!!42774071.java!!!	notifyListeners(inout packageName : String, in userId : int) : void
        if (!mUserManager.isUserRunning(userId)) {
            return;
        }
        postToHandler(() -> {
            final ArrayList<ShortcutChangeListener> copy;
            synchronized (mLock) {
                copy = new ArrayList<>(mListeners);
            }
            // Note onShortcutChanged() needs to be called with the system service permissions.
            for (int i = copy.size() - 1; i >= 0; i--) {
                copy.get(i).onShortcutChanged(packageName, userId);
            }
        });
!!!42774199.java!!!	fixUpIncomingShortcutInfo(inout shortcut : ShortcutInfo, inout forUpdate : boolean) : void
        Preconditions.checkNotNull(shortcut, "Null shortcut detected");
        if (shortcut.getActivityComponent() != null) {
            Preconditions.checkState(
                    shortcut.getPackageName().equals(
                            shortcut.getActivityComponent().getPackageName()),
                    "Activity package name mismatch");
        }

        if (!forUpdate) {
            shortcut.enforceMandatoryFields();
        }
        if (shortcut.getIcon() != null) {
            ShortcutInfo.validateIcon(shortcut.getIcon());
        }

        validateForXml(shortcut.getId());
        validateForXml(shortcut.getTitle());
        validatePersistableBundleForXml(shortcut.getIntentPersistableExtras());
        validatePersistableBundleForXml(shortcut.getExtras());

        shortcut.replaceFlags(0);
!!!42774327.java!!!	validatePersistableBundleForXml(inout b : PersistableBundle) : void
        if (b == null || b.size() == 0) {
            return;
        }
        for (String key : b.keySet()) {
            validateForXml(key);
            final Object value = b.get(key);
            if (value == null) {
                continue;
            } else if (value instanceof String) {
                validateForXml((String) value);
            } else if (value instanceof String[]) {
                for (String v : (String[]) value) {
                    validateForXml(v);
                }
            } else if (value instanceof PersistableBundle) {
                validatePersistableBundleForXml((PersistableBundle) value);
            }
        }
!!!42774455.java!!!	validateForXml(inout s : String) : void
        if (TextUtils.isEmpty(s)) {
            return;
        }
        for (int i = s.length() - 1; i >= 0; i--) {
            if (!isAllowedInXml(s.charAt(i))) {
                throw new IllegalArgumentException("Unsupported character detected in: " + s);
            }
        }
!!!42774583.java!!!	isAllowedInXml(in c : char) : boolean
        return (c >= 0x20 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xfffd);
!!!42774711.java!!!	setDynamicShortcuts(inout packageName : String, inout shortcutInfoList : ParceledListSlice, in userId : int) : boolean
        verifyCaller(packageName, userId);

        final List<ShortcutInfo> newShortcuts = (List<ShortcutInfo>) shortcutInfoList.getList();
        final int size = newShortcuts.size();

        synchronized (mLock) {
            final ShortcutPackage ps = getPackageShortcutsLocked(packageName, userId);

            // Throttling.
            if (!ps.tryApiCall(this)) {
                return false;
            }
            enforceMaxDynamicShortcuts(size);

            // Validate the shortcuts.
            for (int i = 0; i < size; i++) {
                fixUpIncomingShortcutInfo(newShortcuts.get(i), /* forUpdate= */ false);
            }

            // First, remove all un-pinned; dynamic shortcuts
            ps.deleteAllDynamicShortcuts(this);

            // Then, add/update all.  We need to make sure to take over "pinned" flag.
            for (int i = 0; i < size; i++) {
                final ShortcutInfo newShortcut = newShortcuts.get(i);
                ps.addDynamicShortcut(this, newShortcut);
            }
        }
        packageShortcutsChanged(packageName, userId);
        return true;
!!!42774839.java!!!	updateShortcuts(inout packageName : String, inout shortcutInfoList : ParceledListSlice, in userId : int) : boolean
        verifyCaller(packageName, userId);

        final List<ShortcutInfo> newShortcuts = (List<ShortcutInfo>) shortcutInfoList.getList();
        final int size = newShortcuts.size();

        synchronized (mLock) {
            final ShortcutPackage ps = getPackageShortcutsLocked(packageName, userId);

            // Throttling.
            if (!ps.tryApiCall(this)) {
                return false;
            }

            for (int i = 0; i < size; i++) {
                final ShortcutInfo source = newShortcuts.get(i);
                fixUpIncomingShortcutInfo(source, /* forUpdate= */ true);

                final ShortcutInfo target = ps.findShortcutById(source.getId());
                if (target != null) {
                    final boolean replacingIcon = (source.getIcon() != null);
                    if (replacingIcon) {
                        removeIcon(userId, target);
                    }

                    target.copyNonNullFieldsFrom(source);

                    if (replacingIcon) {
                        saveIconAndFixUpShortcut(userId, target);
                    }
                }
            }
        }
        packageShortcutsChanged(packageName, userId);

        return true;
!!!42774967.java!!!	addDynamicShortcuts(inout packageName : String, inout shortcutInfoList : ParceledListSlice, in userId : int) : boolean
        verifyCaller(packageName, userId);

        final List<ShortcutInfo> newShortcuts = (List<ShortcutInfo>) shortcutInfoList.getList();
        final int size = newShortcuts.size();

        synchronized (mLock) {
            final ShortcutPackage ps = getPackageShortcutsLocked(packageName, userId);

            // Throttling.
            if (!ps.tryApiCall(this)) {
                return false;
            }
            for (int i = 0; i < size; i++) {
                final ShortcutInfo newShortcut = newShortcuts.get(i);

                // Validate the shortcut.
                fixUpIncomingShortcutInfo(newShortcut, /* forUpdate= */ false);

                // Add it.
                ps.addDynamicShortcut(this, newShortcut);
            }
        }
        packageShortcutsChanged(packageName, userId);

        return true;
!!!42775095.java!!!	removeDynamicShortcuts(inout packageName : String, inout shortcutIds : List, in userId : int) : void
        verifyCaller(packageName, userId);
        Preconditions.checkNotNull(shortcutIds, "shortcutIds must be provided");

        synchronized (mLock) {
            for (int i = shortcutIds.size() - 1; i >= 0; i--) {
                getPackageShortcutsLocked(packageName, userId).deleteDynamicWithId(this,
                        Preconditions.checkStringNotEmpty((String) shortcutIds.get(i)));
            }
        }
        packageShortcutsChanged(packageName, userId);
!!!42775223.java!!!	removeAllDynamicShortcuts(inout packageName : String, in userId : int) : void
        verifyCaller(packageName, userId);

        synchronized (mLock) {
            getPackageShortcutsLocked(packageName, userId).deleteAllDynamicShortcuts(this);
        }
        packageShortcutsChanged(packageName, userId);
!!!42775351.java!!!	getDynamicShortcuts(inout packageName : String, in userId : int) : ParceledListSlice
        verifyCaller(packageName, userId);
        synchronized (mLock) {
            return getShortcutsWithQueryLocked(
                    packageName, userId, ShortcutInfo.CLONE_REMOVE_FOR_CREATOR,
                    ShortcutInfo::isDynamic);
        }
!!!42775479.java!!!	getPinnedShortcuts(inout packageName : String, in userId : int) : ParceledListSlice
        verifyCaller(packageName, userId);
        synchronized (mLock) {
            return getShortcutsWithQueryLocked(
                    packageName, userId, ShortcutInfo.CLONE_REMOVE_FOR_CREATOR,
                    ShortcutInfo::isPinned);
        }
!!!42775607.java!!!	getShortcutsWithQueryLocked(inout packageName : String, in userId : int, in cloneFlags : int, inout query : Predicate<ShortcutInfo>) : ParceledListSlice

        final ArrayList<ShortcutInfo> ret = new ArrayList<>();

        getPackageShortcutsLocked(packageName, userId).findAll(this, ret, query, cloneFlags);

        return new ParceledListSlice<>(ret);
!!!42775735.java!!!	getMaxDynamicShortcutCount(inout packageName : String, in userId : int) : int
        verifyCaller(packageName, userId);

        return mMaxDynamicShortcuts;
!!!42775863.java!!!	getRemainingCallCount(inout packageName : String, in userId : int) : int
        verifyCaller(packageName, userId);

        synchronized (mLock) {
            return mMaxUpdatesPerInterval
                    - getPackageShortcutsLocked(packageName, userId).getApiCallCount(this);
        }
!!!42775991.java!!!	getRateLimitResetTime(inout packageName : String, in userId : int) : long
        verifyCaller(packageName, userId);

        synchronized (mLock) {
            return getNextResetTimeLocked();
        }
!!!42776119.java!!!	getIconMaxDimensions(inout packageName : String, in userId : int) : int
        verifyCaller(packageName, userId);

        synchronized (mLock) {
            return mMaxIconDimension;
        }
!!!42776247.java!!!	resetThrottling() : void
        enforceSystemOrShell();

        resetThrottlingInner(getCallingUserId());
!!!42776375.java!!!	resetThrottlingInner(in userId : int) : void
        synchronized (mLock) {
            getUserShortcutsLocked(userId).resetThrottling();
        }
        scheduleSaveUser(userId);
        Slog.i(TAG, "ShortcutManager: throttling counter reset for user " + userId);
!!!42776503.java!!!	resetAllThrottlingInner() : void
        synchronized (mLock) {
            mRawLastResetTime = injectCurrentTimeMillis();
        }
        scheduleSaveBaseState();
        Slog.i(TAG, "ShortcutManager: throttling counter reset for all users");
!!!42776631.java!!!	resetPackageThrottling(inout packageName : String, in userId : int) : void
        synchronized (mLock) {
            getPackageShortcutsLocked(packageName, userId)
                    .resetRateLimitingForCommandLineNoSaving();
            saveUserLocked(userId);
        }
!!!42776759.java!!!	onApplicationActive(inout packageName : String, in userId : int) : void
        if (DEBUG) {
            Slog.d(TAG, "onApplicationActive: package=" + packageName + "  userid=" + userId);
        }
        enforceResetThrottlingPermission();
        resetPackageThrottling(packageName, userId);
!!!42776887.java!!!	hasShortcutHostPermission(inout callingPackage : String, in userId : int) : boolean
        return hasShortcutHostPermissionInner(callingPackage, userId);
!!!42777015.java!!!	hasShortcutHostPermissionInner(inout callingPackage : String, in userId : int) : boolean
        synchronized (mLock) {
            final long start = System.currentTimeMillis();

            final ShortcutUser user = getUserShortcutsLocked(userId);

            final List<ResolveInfo> allHomeCandidates = new ArrayList<>();

            // Default launcher from package manager.
            final long startGetHomeActivitiesAsUser = System.currentTimeMillis();
            final ComponentName defaultLauncher = injectPackageManagerInternal()
                    .getHomeActivitiesAsUser(allHomeCandidates, userId);
            logDurationStat(Stats.GET_DEFAULT_HOME, startGetHomeActivitiesAsUser);

            ComponentName detected;
            if (defaultLauncher != null) {
                detected = defaultLauncher;
                if (DEBUG) {
                    Slog.v(TAG, "Default launcher from PM: " + detected);
                }
            } else {
                detected = user.getLauncherComponent();

                // TODO: Make sure it's still enabled.
                if (DEBUG) {
                    Slog.v(TAG, "Cached launcher: " + detected);
                }
            }

            if (detected == null) {
                // If we reach here, that means it's the first check since the user was created,
                // and there's already multiple launchers and there's no default set.
                // Find the system one with the highest priority.
                // (We need to check the priority too because of FallbackHome in Settings.)
                // If there's no system launcher yet, then no one can access shortcuts, until
                // the user explicitly
                final int size = allHomeCandidates.size();

                int lastPriority = Integer.MIN_VALUE;
                for (int i = 0; i < size; i++) {
                    final ResolveInfo ri = allHomeCandidates.get(i);
                    if (!ri.activityInfo.applicationInfo.isSystemApp()) {
                        continue;
                    }
                    if (DEBUG) {
                        Slog.d(TAG, String.format("hasShortcutPermissionInner: pkg=%s prio=%d",
                                ri.activityInfo.getComponentName(), ri.priority));
                    }
                    if (ri.priority < lastPriority) {
                        continue;
                    }
                    detected = ri.activityInfo.getComponentName();
                    lastPriority = ri.priority;
                }
            }
            logDurationStat(Stats.LAUNCHER_PERMISSION_CHECK, start);

            if (detected != null) {
                if (DEBUG) {
                    Slog.v(TAG, "Detected launcher: " + detected);
                }
                user.setLauncherComponent(this, detected);
                return detected.getPackageName().equals(callingPackage);
            } else {
                // Default launcher not found.
                return false;
            }
        }
!!!42777143.java!!!	cleanUpPackageForAllLoadedUsers(inout packageName : String, in packageUserId : int) : void
        synchronized (mLock) {
            forEachLoadedUserLocked(user ->
                    cleanUpPackageLocked(packageName, user.getUserId(), packageUserId));
        }
!!!42777271.java!!!	cleanUpPackageLocked(inout packageName : String, in owningUserId : int, in packageUserId : int) : void
        final boolean wasUserLoaded = isUserLoadedLocked(owningUserId);

        final ShortcutUser user = getUserShortcutsLocked(owningUserId);
        boolean doNotify = false;

        // First, remove the package from the package list (if the package is a publisher).
        if (packageUserId == owningUserId) {
            if (user.removePackage(this, packageName) != null) {
                doNotify = true;
            }
        }

        // Also remove from the launcher list (if the package is a launcher).
        user.removeLauncher(packageUserId, packageName);

        // Then remove pinned shortcuts from all launchers.
        user.forAllLaunchers(l -> l.cleanUpPackage(packageName, packageUserId));

        // Now there may be orphan shortcuts because we removed pinned shortcuts at the previous
        // step.  Remove them too.
        user.forAllPackages(p -> p.refreshPinnedFlags(this));

        scheduleSaveUser(owningUserId);

        if (doNotify) {
            notifyListeners(packageName, owningUserId);
        }

        if (!wasUserLoaded) {
            // Note this will execute the scheduled save.
            unloadUserLocked(owningUserId);
        }
!!!42778807.java!!!	checkPackageChanges(in ownerUserId : int) : void
        if (DEBUG) {
            Slog.d(TAG, "checkPackageChanges() ownerUserId=" + ownerUserId);
        }
        final ArrayList<PackageWithUser> gonePackages = new ArrayList<>();

        synchronized (mLock) {
            final ShortcutUser user = getUserShortcutsLocked(ownerUserId);

            user.forAllPackageItems(spi -> {
                if (spi.getPackageInfo().isShadow()) {
                    return; // Don't delete shadow information.
                }
                final int versionCode = getApplicationVersionCode(
                        spi.getPackageName(), spi.getPackageUserId());
                if (versionCode >= 0) {
                    // Package still installed, see if it's updated.
                    getUserShortcutsLocked(ownerUserId).handlePackageUpdated(
                            this, spi.getPackageName(), versionCode);
                } else {
                    gonePackages.add(PackageWithUser.of(spi));
                }
            });
            if (gonePackages.size() > 0) {
                for (int i = gonePackages.size() - 1; i >= 0; i--) {
                    final PackageWithUser pu = gonePackages.get(i);
                    cleanUpPackageLocked(pu.packageName, ownerUserId, pu.userId);
                }
            }
        }
!!!42778935.java!!!	handlePackageAdded(inout packageName : String, in userId : int) : void
        if (DEBUG) {
            Slog.d(TAG, String.format("handlePackageAdded: %s user=%d", packageName, userId));
        }
        synchronized (mLock) {
            forEachLoadedUserLocked(user ->
                    user.attemptToRestoreIfNeededAndSave(this, packageName, userId));
        }
!!!42779063.java!!!	handlePackageUpdateFinished(inout packageName : String, in userId : int) : void
        if (DEBUG) {
            Slog.d(TAG, String.format("handlePackageUpdateFinished: %s user=%d",
                    packageName, userId));
        }
        synchronized (mLock) {
            forEachLoadedUserLocked(user ->
                    user.attemptToRestoreIfNeededAndSave(this, packageName, userId));

            final int versionCode = getApplicationVersionCode(packageName, userId);
            if (versionCode < 0) {
                return; // shouldn't happen
            }
            getUserShortcutsLocked(userId).handlePackageUpdated(this, packageName, versionCode);
        }
!!!42779191.java!!!	handlePackageRemoved(inout packageName : String, in packageUserId : int) : void
        if (DEBUG) {
            Slog.d(TAG, String.format("handlePackageRemoved: %s user=%d", packageName,
                    packageUserId));
        }
        cleanUpPackageForAllLoadedUsers(packageName, packageUserId);
!!!42779319.java!!!	handlePackageDataCleared(inout packageName : String, in packageUserId : int) : void
        if (DEBUG) {
            Slog.d(TAG, String.format("handlePackageDataCleared: %s user=%d", packageName,
                    packageUserId));
        }
        cleanUpPackageForAllLoadedUsers(packageName, packageUserId);
!!!42779447.java!!!	getPackageInfoWithSignatures(inout packageName : String, in userId : int) : PackageInfo
        return injectPackageInfo(packageName, userId, true);
!!!42779575.java!!!	injectGetPackageUid(inout packageName : String, in userId : int) : int
        final long token = injectClearCallingIdentity();
        try {
            return mIPackageManager.getPackageUid(packageName, PACKAGE_MATCH_FLAGS
                    , userId);
        } catch (RemoteException e) {
            // Shouldn't happen.
            Slog.wtf(TAG, "RemoteException", e);
            return -1;
        } finally {
            injectRestoreCallingIdentity(token);
        }
!!!42779703.java!!!	injectPackageInfo(inout packageName : String, in userId : int, inout getSignatures : boolean) : PackageInfo
        final long start = System.currentTimeMillis();
        final long token = injectClearCallingIdentity();
        try {
            return mIPackageManager.getPackageInfo(packageName, PACKAGE_MATCH_FLAGS
                    | (getSignatures ? PackageManager.GET_SIGNATURES : 0)
                    , userId);
        } catch (RemoteException e) {
            // Shouldn't happen.
            Slog.wtf(TAG, "RemoteException", e);
            return null;
        } finally {
            injectRestoreCallingIdentity(token);

            logDurationStat(
                    (getSignatures ? Stats.GET_PACKAGE_INFO_WITH_SIG : Stats.GET_PACKAGE_INFO),
                    start);
        }
!!!42779831.java!!!	injectApplicationInfo(inout packageName : String, in userId : int) : ApplicationInfo
        final long start = System.currentTimeMillis();
        final long token = injectClearCallingIdentity();
        try {
            return mIPackageManager.getApplicationInfo(packageName, PACKAGE_MATCH_FLAGS, userId);
        } catch (RemoteException e) {
            // Shouldn't happen.
            Slog.wtf(TAG, "RemoteException", e);
            return null;
        } finally {
            injectRestoreCallingIdentity(token);

            logDurationStat(Stats.GET_APPLICATION_INFO, start);
        }
!!!42779959.java!!!	isApplicationFlagSet(inout packageName : String, in userId : int, in flags : int) : boolean
        final ApplicationInfo ai = injectApplicationInfo(packageName, userId);
        return (ai != null) && ((ai.flags & flags) == flags);
!!!42780087.java!!!	isPackageInstalled(inout packageName : String, in userId : int) : boolean
        return isApplicationFlagSet(packageName, userId, ApplicationInfo.FLAG_INSTALLED);
!!!42780215.java!!!	getApplicationVersionCode(inout packageName : String, in userId : int) : int
        final ApplicationInfo ai = injectApplicationInfo(packageName, userId);
        if ((ai == null) || ((ai.flags & ApplicationInfo.FLAG_INSTALLED) == 0)) {
            return -1;
        }
        return ai.versionCode;
!!!42780343.java!!!	shouldBackupApp(inout packageName : String, in userId : int) : boolean
        return isApplicationFlagSet(packageName, userId, ApplicationInfo.FLAG_ALLOW_BACKUP);
!!!42780471.java!!!	shouldBackupApp(inout pi : PackageInfo) : boolean
        return (pi.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_BACKUP) != 0;
!!!42780599.java!!!	getBackupPayload(in userId : int) : byte
        enforceSystem();
        if (DEBUG) {
            Slog.d(TAG, "Backing up user " + userId);
        }
        synchronized (mLock) {
            final ShortcutUser user = getUserShortcutsLocked(userId);
            if (user == null) {
                Slog.w(TAG, "Can't backup: user not found: id=" + userId);
                return null;
            }

            user.forAllPackageItems(spi -> spi.refreshPackageInfoAndSave(this));

            // Then save.
            final ByteArrayOutputStream os = new ByteArrayOutputStream(32 * 1024);
            try {
                saveUserInternalLocked(userId, os, /* forBackup */ true);
            } catch (XmlPullParserException|IOException e) {
                // Shouldn't happen.
                Slog.w(TAG, "Backup failed.", e);
                return null;
            }
            return os.toByteArray();
        }
!!!42780727.java!!!	applyRestore(inout payload : byte, in userId : int) : void
        enforceSystem();
        if (DEBUG) {
            Slog.d(TAG, "Restoring user " + userId);
        }
        final ShortcutUser user;
        final ByteArrayInputStream is = new ByteArrayInputStream(payload);
        try {
            user = loadUserInternal(userId, is, /* fromBackup */ true);
        } catch (XmlPullParserException|IOException e) {
            Slog.w(TAG, "Restoration failed.", e);
            return;
        }
        synchronized (mLock) {
            mUsers.put(userId, user);

            // Then purge all the save images.
            final File bitmapPath = getUserBitmapFilePath(userId);
            final boolean success = FileUtils.deleteContents(bitmapPath);
            if (!success) {
                Slog.w(TAG, "Failed to delete " + bitmapPath);
            }

            saveUserLocked(userId);
        }
!!!42780855.java!!!	dump(inout fd : FileDescriptor, inout pw : PrintWriter, inout args : String) : void
        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
                != PackageManager.PERMISSION_GRANTED) {
            pw.println("Permission Denial: can't dump UserManager from from pid="
                    + Binder.getCallingPid()
                    + ", uid=" + Binder.getCallingUid()
                    + " without permission "
                    + android.Manifest.permission.DUMP);
            return;
        }
        dumpInner(pw, args);
!!!42780983.java!!!	dumpInner(inout pw : PrintWriter, inout args : String) : void
        synchronized (mLock) {
            final long now = injectCurrentTimeMillis();
            pw.print("Now: [");
            pw.print(now);
            pw.print("] ");
            pw.print(formatTime(now));

            pw.print("  Raw last reset: [");
            pw.print(mRawLastResetTime);
            pw.print("] ");
            pw.print(formatTime(mRawLastResetTime));

            final long last = getLastResetTimeLocked();
            pw.print("  Last reset: [");
            pw.print(last);
            pw.print("] ");
            pw.print(formatTime(last));

            final long next = getNextResetTimeLocked();
            pw.print("  Next reset: [");
            pw.print(next);
            pw.print("] ");
            pw.print(formatTime(next));

            pw.print("  Locale change seq#: ");
            pw.print(mLocaleChangeSequenceNumber.get());
            pw.println();

            pw.print("  Config:");
            pw.print("    Max icon dim: ");
            pw.println(mMaxIconDimension);
            pw.print("    Icon format: ");
            pw.println(mIconPersistFormat);
            pw.print("    Icon quality: ");
            pw.println(mIconPersistQuality);
            pw.print("    saveDelayMillis: ");
            pw.println(mSaveDelayMillis);
            pw.print("    resetInterval: ");
            pw.println(mResetInterval);
            pw.print("    maxUpdatesPerInterval: ");
            pw.println(mMaxUpdatesPerInterval);
            pw.print("    maxDynamicShortcuts: ");
            pw.println(mMaxDynamicShortcuts);
            pw.println();

            pw.println("  Stats:");
            synchronized (mStatLock) {
                final String p = "    ";
                dumpStatLS(pw, p, Stats.GET_DEFAULT_HOME, "getHomeActivities()");
                dumpStatLS(pw, p, Stats.LAUNCHER_PERMISSION_CHECK, "Launcher permission check");

                dumpStatLS(pw, p, Stats.GET_PACKAGE_INFO, "getPackageInfo()");
                dumpStatLS(pw, p, Stats.GET_PACKAGE_INFO_WITH_SIG, "getPackageInfo(SIG)");
                dumpStatLS(pw, p, Stats.GET_APPLICATION_INFO, "getApplicationInfo");
            }

            for (int i = 0; i < mUsers.size(); i++) {
                pw.println();
                mUsers.valueAt(i).dump(this, pw, "  ");
            }

            pw.println();
            pw.println("  UID state:");

            for (int i = 0; i < mUidState.size(); i++) {
                final int uid = mUidState.keyAt(i);
                final int state = mUidState.valueAt(i);
                pw.print("    UID=");
                pw.print(uid);
                pw.print(" state=");
                pw.print(state);
                if (isProcessStateForeground(state)) {
                    pw.print("  [FG]");
                }
                pw.print("  last FG=");
                pw.print(mUidLastForegroundElapsedTime.get(uid));
                pw.println();
            }
        }
!!!42781111.java!!!	formatTime(in time : long) : String
        Time tobj = new Time();
        tobj.set(time);
        return tobj.format("%Y-%m-%d %H:%M:%S");
!!!42781239.java!!!	dumpStatLS(inout pw : PrintWriter, inout prefix : String, in statId : int, inout label : String) : void
        pw.print(prefix);
        final int count = mCountStats[statId];
        final long dur = mDurationStats[statId];
        pw.println(String.format("%s: count=%d, total=%dms, avg=%.1fms",
                label, count, dur,
                (count == 0 ? 0 : ((double) dur) / count)));
!!!42781367.java!!!	onShellCommand(inout in : FileDescriptor, inout out : FileDescriptor, inout err : FileDescriptor, inout args : String, inout resultReceiver : ResultReceiver) : void

        enforceShell();

        (new MyShellCommand()).exec(this, in, out, err, args, resultReceiver);
!!!42783543.java!!!	injectCurrentTimeMillis() : long
        return System.currentTimeMillis();
!!!42783671.java!!!	injectElapsedRealtime() : long
        return SystemClock.elapsedRealtime();
!!!42783799.java!!!	injectBinderCallingUid() : int
        return getCallingUid();
!!!42783927.java!!!	getCallingUserId() : int
        return UserHandle.getUserId(injectBinderCallingUid());
!!!42784055.java!!!	injectClearCallingIdentity() : long
        return Binder.clearCallingIdentity();
!!!42784183.java!!!	injectRestoreCallingIdentity(in token : long) : void
        Binder.restoreCallingIdentity(token);
!!!42784311.java!!!	wtf(inout message : String) : void
        wtf( message, /* exception= */ null);
!!!42784439.java!!!	wtf(inout message : String, inout e : Exception) : void
        Slog.wtf(TAG, message, e);
!!!42784567.java!!!	injectSystemDataPath() : File
        return Environment.getDataSystemDirectory();
!!!42784695.java!!!	injectUserDataPath(in userId : int) : File
        return new File(Environment.getDataSystemCeDirectory(userId), DIRECTORY_PER_USER);
!!!42784823.java!!!	injectIsLowRamDevice() : boolean
        return ActivityManager.isLowRamDeviceStatic();
!!!42784951.java!!!	injectRegisterUidObserver(inout observer : IUidObserver, in which : int) : void
        try {
            ActivityManagerNative.getDefault().registerUidObserver(observer, which);
        } catch (RemoteException shouldntHappen) {
        }
!!!42785079.java!!!	injectPackageManagerInternal() : PackageManagerInternal
        return mPackageManagerInternal;
!!!42785207.java!!!	getUserBitmapFilePath(in userId : int) : File
        return new File(injectUserDataPath(userId), DIRECTORY_BITMAPS);
!!!42785335.java!!!	getShortcutsForTest() : SparseArray
        return mUsers;
!!!42785463.java!!!	getMaxDynamicShortcutsForTest() : int
        return mMaxDynamicShortcuts;
!!!42785591.java!!!	getMaxUpdatesPerIntervalForTest() : int
        return mMaxUpdatesPerInterval;
!!!42785719.java!!!	getResetIntervalForTest() : long
        return mResetInterval;
!!!42785847.java!!!	getMaxIconDimensionForTest() : int
        return mMaxIconDimension;
!!!42785975.java!!!	getIconPersistFormatForTest() : Bitmap::CompressFormat
        return mIconPersistFormat;
!!!42786103.java!!!	getIconPersistQualityForTest() : int
        return mIconPersistQuality;
!!!42786231.java!!!	getPackageShortcutForTest(inout packageName : String, inout shortcutId : String, in userId : int) : ShortcutInfo
        synchronized (mLock) {
            final ShortcutUser user = mUsers.get(userId);
            if (user == null) return null;

            final ShortcutPackage pkg = user.getAllPackagesForTest().get(packageName);
            if (pkg == null) return null;

            return pkg.findShortcutById(shortcutId);
        }
