class ConnectivityManager
!!!3433783.java!!!	isNetworkTypeValid(in networkType : int) : boolean
        return networkType >= 0 && networkType <= MAX_NETWORK_TYPE;
!!!3433911.java!!!	getNetworkTypeName(in type : int) : String
        switch (type) {
            case TYPE_MOBILE:
                return "MOBILE";
            case TYPE_WIFI:
                return "WIFI";
            case TYPE_MOBILE_MMS:
                return "MOBILE_MMS";
            case TYPE_MOBILE_SUPL:
                return "MOBILE_SUPL";
            case TYPE_MOBILE_DUN:
                return "MOBILE_DUN";
            case TYPE_MOBILE_HIPRI:
                return "MOBILE_HIPRI";
            case TYPE_WIMAX:
                return "WIMAX";
            case TYPE_BLUETOOTH:
                return "BLUETOOTH";
            case TYPE_DUMMY:
                return "DUMMY";
            case TYPE_ETHERNET:
                return "ETHERNET";
            case TYPE_MOBILE_FOTA:
                return "MOBILE_FOTA";
            case TYPE_MOBILE_IMS:
                return "MOBILE_IMS";
            case TYPE_MOBILE_CBS:
                return "MOBILE_CBS";
            case TYPE_WIFI_P2P:
                return "WIFI_P2P";
            case TYPE_MOBILE_IA:
                return "MOBILE_IA";
            case TYPE_MOBILE_EMERGENCY:
                return "MOBILE_EMERGENCY";
            case TYPE_PROXY:
                return "PROXY";
            case TYPE_VPN:
                return "VPN";
            default:
                return Integer.toString(type);
        }
!!!3434039.java!!!	isNetworkTypeMobile(in networkType : int) : boolean
        switch (networkType) {
            case TYPE_MOBILE:
            case TYPE_MOBILE_MMS:
            case TYPE_MOBILE_SUPL:
            case TYPE_MOBILE_DUN:
            case TYPE_MOBILE_HIPRI:
            case TYPE_MOBILE_FOTA:
            case TYPE_MOBILE_IMS:
            case TYPE_MOBILE_CBS:
            case TYPE_MOBILE_IA:
            case TYPE_MOBILE_EMERGENCY:
                return true;
            default:
                return false;
        }
!!!3434167.java!!!	isNetworkTypeWifi(in networkType : int) : boolean
        switch (networkType) {
            case TYPE_WIFI:
            case TYPE_WIFI_P2P:
                return true;
            default:
                return false;
        }
!!!3434423.java!!!	getNetworkPreference() : int
        return TYPE_NONE;
!!!3434551.java!!!	getActiveNetworkInfo() : NetworkInfo
        try {
            return mService.getActiveNetworkInfo();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3434679.java!!!	getActiveNetwork() : Network
        try {
            return mService.getActiveNetwork();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3434807.java!!!	getActiveNetworkForUid(in uid : int) : Network
        return getActiveNetworkForUid(uid, false);
!!!3434935.java!!!	getActiveNetworkForUid(in uid : int, inout ignoreBlocked : boolean) : Network
        try {
            return mService.getActiveNetworkForUid(uid, ignoreBlocked);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3435063.java!!!	setAlwaysOnVpnPackageForUser(in userId : int, inout vpnPackage : String, inout lockdownEnabled : boolean) : boolean
        try {
            return mService.setAlwaysOnVpnPackage(userId, vpnPackage, lockdownEnabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3435191.java!!!	getAlwaysOnVpnPackageForUser(in userId : int) : String
        try {
            return mService.getAlwaysOnVpnPackage(userId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3435319.java!!!	getActiveNetworkInfoForUid(in uid : int) : NetworkInfo
        return getActiveNetworkInfoForUid(uid, false);
!!!3435447.java!!!	getActiveNetworkInfoForUid(in uid : int, inout ignoreBlocked : boolean) : NetworkInfo
        try {
            return mService.getActiveNetworkInfoForUid(uid, ignoreBlocked);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3435575.java!!!	getNetworkInfo(in networkType : int) : NetworkInfo
        try {
            return mService.getNetworkInfo(networkType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3435703.java!!!	getNetworkInfo(inout network : Network) : NetworkInfo
        return getNetworkInfoForUid(network, Process.myUid(), false);
!!!3435831.java!!!	getNetworkInfoForUid(inout network : Network, in uid : int, inout ignoreBlocked : boolean) : NetworkInfo
        try {
            return mService.getNetworkInfoForUid(network, uid, ignoreBlocked);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3435959.java!!!	getAllNetworkInfo() : NetworkInfo
        try {
            return mService.getAllNetworkInfo();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3436087.java!!!	getNetworkForType(in networkType : int) : Network
        try {
            return mService.getNetworkForType(networkType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3436215.java!!!	getAllNetworks() : Network
        try {
            return mService.getAllNetworks();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3436343.java!!!	getDefaultNetworkCapabilitiesForUser(in userId : int) : NetworkCapabilities
        try {
            return mService.getDefaultNetworkCapabilitiesForUser(userId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3436471.java!!!	getActiveLinkProperties() : LinkProperties
        try {
            return mService.getActiveLinkProperties();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3436599.java!!!	getLinkProperties(in networkType : int) : LinkProperties
        try {
            return mService.getLinkPropertiesForType(networkType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3436727.java!!!	getLinkProperties(inout network : Network) : LinkProperties
        try {
            return mService.getLinkProperties(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3436855.java!!!	getNetworkCapabilities(inout network : Network) : NetworkCapabilities
        try {
            return mService.getNetworkCapabilities(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3436983.java!!!	getCaptivePortalServerUrl() : String
        try {
            return mService.getCaptivePortalServerUrl();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3437111.java!!!	startUsingNetworkFeature(in networkType : int, inout feature : String) : int
        checkLegacyRoutingApiAccess();
        NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
        if (netCap == null) {
            Log.d(TAG, "Can't satisfy startUsingNetworkFeature for " + networkType + ", " +
                    feature);
            return PhoneConstants.APN_REQUEST_FAILED;
        }

        NetworkRequest request = null;
        synchronized (sLegacyRequests) {
            LegacyRequest l = sLegacyRequests.get(netCap);
            if (l != null) {
                Log.d(TAG, "renewing startUsingNetworkFeature request " + l.networkRequest);
                renewRequestLocked(l);
                if (l.currentNetwork != null) {
                    return PhoneConstants.APN_ALREADY_ACTIVE;
                } else {
                    return PhoneConstants.APN_REQUEST_STARTED;
                }
            }

            request = requestNetworkForFeatureLocked(netCap);
        }
        if (request != null) {
            Log.d(TAG, "starting startUsingNetworkFeature for request " + request);
            return PhoneConstants.APN_REQUEST_STARTED;
        } else {
            Log.d(TAG, " request Failed");
            return PhoneConstants.APN_REQUEST_FAILED;
        }
!!!3437239.java!!!	stopUsingNetworkFeature(in networkType : int, inout feature : String) : int
        checkLegacyRoutingApiAccess();
        NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
        if (netCap == null) {
            Log.d(TAG, "Can't satisfy stopUsingNetworkFeature for " + networkType + ", " +
                    feature);
            return -1;
        }

        if (removeRequestForFeature(netCap)) {
            Log.d(TAG, "stopUsingNetworkFeature for " + networkType + ", " + feature);
        }
        return 1;
!!!3437367.java!!!	networkCapabilitiesForFeature(in networkType : int, inout feature : String) : NetworkCapabilities
        if (networkType == TYPE_MOBILE) {
            int cap = -1;
            if ("enableMMS".equals(feature)) {
                cap = NetworkCapabilities.NET_CAPABILITY_MMS;
            } else if ("enableSUPL".equals(feature)) {
                cap = NetworkCapabilities.NET_CAPABILITY_SUPL;
            } else if ("enableDUN".equals(feature) || "enableDUNAlways".equals(feature)) {
                cap = NetworkCapabilities.NET_CAPABILITY_DUN;
            } else if ("enableHIPRI".equals(feature)) {
                cap = NetworkCapabilities.NET_CAPABILITY_INTERNET;
            } else if ("enableFOTA".equals(feature)) {
                cap = NetworkCapabilities.NET_CAPABILITY_FOTA;
            } else if ("enableIMS".equals(feature)) {
                cap = NetworkCapabilities.NET_CAPABILITY_IMS;
            } else if ("enableCBS".equals(feature)) {
                cap = NetworkCapabilities.NET_CAPABILITY_CBS;
            } else {
                return null;
            }
            NetworkCapabilities netCap = new NetworkCapabilities();
            netCap.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR).addCapability(cap);
            netCap.maybeMarkCapabilitiesRestricted();
            return netCap;
        } else if (networkType == TYPE_WIFI) {
            if ("p2p".equals(feature)) {
                NetworkCapabilities netCap = new NetworkCapabilities();
                netCap.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
                netCap.addCapability(NetworkCapabilities.NET_CAPABILITY_WIFI_P2P);
                netCap.maybeMarkCapabilitiesRestricted();
                return netCap;
            }
        }
        return null;
!!!3437495.java!!!	inferLegacyTypeForNetworkCapabilities(inout netCap : NetworkCapabilities) : int
        if (netCap == null) {
            return TYPE_NONE;
        }

        if (!netCap.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return TYPE_NONE;
        }

        // Do this only for SUPL, until GnssLocationProvider is fixed. http://b/25876485 .
        if (!netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_SUPL)) {
            // NOTE: if this causes app breakage, we should not just comment out this early return;
            // instead, we should make this early return conditional on the requesting app's target
            // SDK version, as described in the comment above.
            return TYPE_NONE;
        }

        String type = null;
        int result = TYPE_NONE;

        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_CBS)) {
            type = "enableCBS";
            result = TYPE_MOBILE_CBS;
        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_IMS)) {
            type = "enableIMS";
            result = TYPE_MOBILE_IMS;
        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_FOTA)) {
            type = "enableFOTA";
            result = TYPE_MOBILE_FOTA;
        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_DUN)) {
            type = "enableDUN";
            result = TYPE_MOBILE_DUN;
        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_SUPL)) {
            type = "enableSUPL";
            result = TYPE_MOBILE_SUPL;
        // back out this hack for mms as they no longer need this and it's causing
        // device slowdowns - b/23350688 (note, supl still needs this)
        //} else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_MMS)) {
        //    type = "enableMMS";
        //    result = TYPE_MOBILE_MMS;
        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
            type = "enableHIPRI";
            result = TYPE_MOBILE_HIPRI;
        }
        if (type != null) {
            NetworkCapabilities testCap = networkCapabilitiesForFeature(TYPE_MOBILE, type);
            if (testCap.equalsNetCapabilities(netCap) && testCap.equalsTransportTypes(netCap)) {
                return result;
            }
        }
        return TYPE_NONE;
!!!3437623.java!!!	legacyTypeForNetworkCapabilities(inout netCap : NetworkCapabilities) : int
        if (netCap == null) return TYPE_NONE;
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_CBS)) {
            return TYPE_MOBILE_CBS;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_IMS)) {
            return TYPE_MOBILE_IMS;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_FOTA)) {
            return TYPE_MOBILE_FOTA;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_DUN)) {
            return TYPE_MOBILE_DUN;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_SUPL)) {
            return TYPE_MOBILE_SUPL;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_MMS)) {
            return TYPE_MOBILE_MMS;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
            return TYPE_MOBILE_HIPRI;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_WIFI_P2P)) {
            return TYPE_WIFI_P2P;
        }
        return TYPE_NONE;
!!!3437879.java!!!	findRequestForFeature(inout netCap : NetworkCapabilities) : NetworkRequest
        synchronized (sLegacyRequests) {
            LegacyRequest l = sLegacyRequests.get(netCap);
            if (l != null) return l.networkRequest;
        }
        return null;
!!!3438007.java!!!	renewRequestLocked(inout l : ConnectivityManager::LegacyRequest) : void
        l.expireSequenceNumber++;
        Log.d(TAG, "renewing request to seqNum " + l.expireSequenceNumber);
        sendExpireMsgForFeature(l.networkCapabilities, l.expireSequenceNumber, l.delay);
!!!3438135.java!!!	expireRequest(inout netCap : NetworkCapabilities, in sequenceNum : int) : void
        int ourSeqNum = -1;
        synchronized (sLegacyRequests) {
            LegacyRequest l = sLegacyRequests.get(netCap);
            if (l == null) return;
            ourSeqNum = l.expireSequenceNumber;
            if (l.expireSequenceNumber == sequenceNum) removeRequestForFeature(netCap);
        }
        Log.d(TAG, "expireRequest with " + ourSeqNum + ", " + sequenceNum);
!!!3438263.java!!!	requestNetworkForFeatureLocked(inout netCap : NetworkCapabilities) : NetworkRequest
        int delay = -1;
        int type = legacyTypeForNetworkCapabilities(netCap);
        try {
            delay = mService.getRestoreDefaultNetworkDelay(type);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        LegacyRequest l = new LegacyRequest();
        l.networkCapabilities = netCap;
        l.delay = delay;
        l.expireSequenceNumber = 0;
        l.networkRequest = sendRequestForNetwork(netCap, l.networkCallback, 0,
                REQUEST, type);
        if (l.networkRequest == null) return null;
        sLegacyRequests.put(netCap, l);
        sendExpireMsgForFeature(netCap, l.expireSequenceNumber, delay);
        return l.networkRequest;
!!!3438391.java!!!	sendExpireMsgForFeature(inout netCap : NetworkCapabilities, in seqNum : int, in delay : int) : void
        if (delay >= 0) {
            Log.d(TAG, "sending expire msg with seqNum " + seqNum + " and delay " + delay);
            Message msg = sCallbackHandler.obtainMessage(EXPIRE_LEGACY_REQUEST, seqNum, 0, netCap);
            sCallbackHandler.sendMessageDelayed(msg, delay);
        }
!!!3438519.java!!!	removeRequestForFeature(inout netCap : NetworkCapabilities) : boolean
        final LegacyRequest l;
        synchronized (sLegacyRequests) {
            l = sLegacyRequests.remove(netCap);
        }
        if (l == null) return false;
        unregisterNetworkCallback(l.networkCallback);
        l.clearDnsBinding();
        return true;
!!!3439415.java!!!	startNattKeepalive(inout network : Network, in intervalSeconds : int, inout callback : ConnectivityManager::PacketKeepaliveCallback, inout srcAddr : InetAddress, in srcPort : int, inout dstAddr : InetAddress) : ConnectivityManager::PacketKeepalive
        final PacketKeepalive k = new PacketKeepalive(network, callback);
        try {
            mService.startNattKeepalive(network, intervalSeconds, k.mMessenger, new Binder(),
                    srcAddr.getHostAddress(), srcPort, dstAddr.getHostAddress());
        } catch (RemoteException e) {
            Log.e(TAG, "Error starting packet keepalive: ", e);
            k.stopLooper();
            return null;
        }
        return k;
!!!3439543.java!!!	requestRouteToHost(in networkType : int, in hostAddress : int) : boolean
        return requestRouteToHostAddress(networkType, NetworkUtils.intToInetAddress(hostAddress));
!!!3439671.java!!!	requestRouteToHostAddress(in networkType : int, inout hostAddress : InetAddress) : boolean
        checkLegacyRoutingApiAccess();
        try {
            return mService.requestRouteToHostAddress(networkType, hostAddress.getAddress());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3439799.java!!!	getBackgroundDataSetting() : boolean
        // assume that background data is allowed; final authority is
        // NetworkInfo which may be blocked.
        return true;
!!!3439927.java!!!	setBackgroundDataSetting(inout allowBackgroundData : boolean) : void
        // ignored
!!!3440055.java!!!	getActiveNetworkQuotaInfo() : NetworkQuotaInfo
        try {
            return mService.getActiveNetworkQuotaInfo();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3440183.java!!!	getMobileDataEnabled() : boolean
        IBinder b = ServiceManager.getService(Context.TELEPHONY_SERVICE);
        if (b != null) {
            try {
                ITelephony it = ITelephony.Stub.asInterface(b);
                int subId = SubscriptionManager.getDefaultDataSubscriptionId();
                Log.d("ConnectivityManager", "getMobileDataEnabled()+ subId=" + subId);
                boolean retVal = it.getDataEnabled(subId);
                Log.d("ConnectivityManager", "getMobileDataEnabled()- subId=" + subId
                        + " retVal=" + retVal);
                return retVal;
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        Log.d("ConnectivityManager", "getMobileDataEnabled()- remote exception retVal=false");
        return false;
!!!3440439.java!!!	getNetworkManagementService() : INetworkManagementService
        synchronized (this) {
            if (mNMService != null) {
                return mNMService;
            }
            IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
            mNMService = INetworkManagementService.Stub.asInterface(b);
            return mNMService;
        }
!!!3440567.java!!!	addDefaultNetworkActiveListener(in l : ConnectivityManager::OnNetworkActiveListener) : void
        INetworkActivityListener rl = new INetworkActivityListener.Stub() {
            @Override
            public void onNetworkActive() throws RemoteException {
                l.onNetworkActive();
            }
        };

        try {
            getNetworkManagementService().registerNetworkActivityListener(rl);
            mNetworkActivityListeners.put(l, rl);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3440695.java!!!	removeDefaultNetworkActiveListener(inout l : ConnectivityManager::OnNetworkActiveListener) : void
        INetworkActivityListener rl = mNetworkActivityListeners.get(l);
        if (rl == null) {
            throw new IllegalArgumentException("Listener not registered: " + l);
        }
        try {
            getNetworkManagementService().unregisterNetworkActivityListener(rl);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3440823.java!!!	isDefaultNetworkActive() : boolean
        try {
            return getNetworkManagementService().isNetworkActive();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3440951.java!!!	ConnectivityManager(inout context : Context, inout service : IConnectivityManager)
        mContext = checkNotNull(context, "missing context");
        mService = checkNotNull(service, "missing IConnectivityManager");
        sInstance = this;
!!!3441079.java!!!	from(inout context : Context) : ConnectivityManager
        return (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
!!!3441207.java!!!	enforceChangePermission(inout context : Context) : void
        int uid = Binder.getCallingUid();
        Settings.checkAndNoteChangeNetworkStateOperation(context, uid, Settings
                .getPackageNameForUid(context, uid), true /* throwException */);
!!!3441335.java!!!	enforceTetherChangePermission(inout context : Context) : void
        if (context.getResources().getStringArray(
                com.android.internal.R.array.config_mobile_hotspot_provision_app).length == 2) {
            // Have a provisioning app - must only let system apps (which check this app)
            // turn on tethering
            context.enforceCallingOrSelfPermission(
                    android.Manifest.permission.TETHER_PRIVILEGED, "ConnectivityService");
        } else {
            int uid = Binder.getCallingUid();
            Settings.checkAndNoteWriteSettingsOperation(context, uid, Settings
                    .getPackageNameForUid(context, uid), true /* throwException */);
        }
!!!3441463.java!!!	getInstanceOrNull() : ConnectivityManager
        return sInstance;
!!!3441591.java!!!	getInstance() : ConnectivityManager
        if (getInstanceOrNull() == null) {
            throw new IllegalStateException("No ConnectivityManager yet constructed");
        }
        return getInstanceOrNull();
!!!3441719.java!!!	getTetherableIfaces() : String
        try {
            return mService.getTetherableIfaces();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3441847.java!!!	getTetheredIfaces() : String
        try {
            return mService.getTetheredIfaces();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3441975.java!!!	getTetheringErroredIfaces() : String
        try {
            return mService.getTetheringErroredIfaces();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3442103.java!!!	getTetheredDhcpRanges() : String
        try {
            return mService.getTetheredDhcpRanges();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3442231.java!!!	tether(inout iface : String) : int
        try {
            return mService.tether(iface);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3442359.java!!!	untether(inout iface : String) : int
        try {
            return mService.untether(iface);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3442487.java!!!	isTetheringSupported() : boolean
        try {
            return mService.isTetheringSupported();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3442871.java!!!	startTethering(in type : int, inout showProvisioningUi : boolean, in callback : ConnectivityManager::OnStartTetheringCallback) : void
        startTethering(type, showProvisioningUi, callback, null);
!!!3442999.java!!!	startTethering(in type : int, inout showProvisioningUi : boolean, in callback : ConnectivityManager::OnStartTetheringCallback, inout handler : Handler) : void
        ResultReceiver wrappedCallback = new ResultReceiver(handler) {
            @Override
            protected void onReceiveResult(int resultCode, Bundle resultData) {
                if (resultCode == TETHER_ERROR_NO_ERROR) {
                    callback.onTetheringStarted();
                } else {
                    callback.onTetheringFailed();
                }
            }
        };
        try {
            mService.startTethering(type, wrappedCallback, showProvisioningUi);
        } catch (RemoteException e) {
            Log.e(TAG, "Exception trying to start tethering.", e);
            wrappedCallback.send(TETHER_ERROR_SERVICE_UNAVAIL, null);
        }
!!!3443127.java!!!	stopTethering(in type : int) : void
        try {
            mService.stopTethering(type);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3443255.java!!!	getTetherableUsbRegexs() : String
        try {
            return mService.getTetherableUsbRegexs();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3443383.java!!!	getTetherableWifiRegexs() : String
        try {
            return mService.getTetherableWifiRegexs();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3443511.java!!!	getTetherableBluetoothRegexs() : String
        try {
            return mService.getTetherableBluetoothRegexs();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3443639.java!!!	setUsbTethering(inout enable : boolean) : int
        try {
            return mService.setUsbTethering(enable);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3443767.java!!!	getLastTetherError(inout iface : String) : int
        try {
            return mService.getLastTetherError(iface);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3443895.java!!!	reportInetCondition(in networkType : int, in percentage : int) : void
        try {
            mService.reportInetCondition(networkType, percentage);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3444023.java!!!	reportBadNetwork(inout network : Network) : void
        try {
            // One of these will be ignored because it matches system's current state.
            // The other will trigger the necessary reevaluation.
            mService.reportNetworkConnectivity(network, true);
            mService.reportNetworkConnectivity(network, false);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3444151.java!!!	reportNetworkConnectivity(inout network : Network, inout hasConnectivity : boolean) : void
        try {
            mService.reportNetworkConnectivity(network, hasConnectivity);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3444279.java!!!	setGlobalProxy(inout p : ProxyInfo) : void
        try {
            mService.setGlobalProxy(p);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3444407.java!!!	getGlobalProxy() : ProxyInfo
        try {
            return mService.getGlobalProxy();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3444535.java!!!	getProxyForNetwork(inout network : Network) : ProxyInfo
        try {
            return mService.getProxyForNetwork(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3444663.java!!!	getDefaultProxy() : ProxyInfo
        return getProxyForNetwork(getBoundNetworkForProcess());
!!!3444791.java!!!	isNetworkSupported(in networkType : int) : boolean
        try {
            return mService.isNetworkSupported(networkType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3444919.java!!!	isActiveNetworkMetered() : boolean
        try {
            return mService.isActiveNetworkMetered();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3445047.java!!!	updateLockdownVpn() : boolean
        try {
            return mService.updateLockdownVpn();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3445175.java!!!	checkMobileProvisioning(in suggestedTimeOutMs : int) : int
        int timeOutMs = -1;
        try {
            timeOutMs = mService.checkMobileProvisioning(suggestedTimeOutMs);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        return timeOutMs;
!!!3445303.java!!!	getMobileProvisioningUrl() : String
        try {
            return mService.getMobileProvisioningUrl();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3445431.java!!!	setProvisioningNotificationVisible(inout visible : boolean, in networkType : int, inout action : String) : void
        try {
            mService.setProvisioningNotificationVisible(visible, networkType, action);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3445559.java!!!	setAirplaneMode(inout enable : boolean) : void
        try {
            mService.setAirplaneMode(enable);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3445687.java!!!	registerNetworkFactory(inout messenger : Messenger, inout name : String) : void
        try {
            mService.registerNetworkFactory(messenger, name);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3445815.java!!!	unregisterNetworkFactory(inout messenger : Messenger) : void
        try {
            mService.unregisterNetworkFactory(messenger);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3445943.java!!!	registerNetworkAgent(inout messenger : Messenger, inout ni : NetworkInfo, inout lp : LinkProperties, inout nc : NetworkCapabilities, in score : int, inout misc : NetworkMisc) : int
        try {
            return mService.registerNetworkAgent(messenger, ni, lp, nc, score, misc);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3447735.java!!!	incCallbackHandlerRefCount() : void
        synchronized(sCallbackRefCount) {
            if (sCallbackRefCount.incrementAndGet() == 1) {
                // TODO: switch this to ConnectivityThread
                HandlerThread callbackThread = new HandlerThread("ConnectivityManager");
                callbackThread.start();
                sCallbackHandler = new CallbackHandler(callbackThread.getLooper(),
                        sNetworkCallback, sCallbackRefCount, this);
            }
        }
!!!3447863.java!!!	decCallbackHandlerRefCount() : void
        synchronized(sCallbackRefCount) {
            if (sCallbackRefCount.decrementAndGet() == 0) {
                sCallbackHandler.obtainMessage(CALLBACK_EXIT).sendToTarget();
                sCallbackHandler = null;
            }
        }
!!!3447991.java!!!	sendRequestForNetwork(inout need : NetworkCapabilities, inout networkCallback : ConnectivityManager::NetworkCallback, in timeoutSec : int, in action : int, in legacyType : int) : NetworkRequest
        if (networkCallback == null) {
            throw new IllegalArgumentException("null NetworkCallback");
        }
        if (need == null && action != REQUEST) {
            throw new IllegalArgumentException("null NetworkCapabilities");
        }
        try {
            incCallbackHandlerRefCount();
            synchronized(sNetworkCallback) {
                if (action == LISTEN) {
                    networkCallback.networkRequest = mService.listenForNetwork(need,
                            new Messenger(sCallbackHandler), new Binder());
                } else {
                    networkCallback.networkRequest = mService.requestNetwork(need,
                            new Messenger(sCallbackHandler), timeoutSec, new Binder(), legacyType);
                }
                if (networkCallback.networkRequest != null) {
                    sNetworkCallback.put(networkCallback.networkRequest, networkCallback);
                }
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        if (networkCallback.networkRequest == null) decCallbackHandlerRefCount();
        return networkCallback.networkRequest;
!!!3448119.java!!!	requestNetwork(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback, in timeoutMs : int, in legacyType : int) : void
        sendRequestForNetwork(request.networkCapabilities, networkCallback, timeoutMs, REQUEST,
                legacyType);
!!!3448247.java!!!	requestNetwork(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback) : void
        requestNetwork(request, networkCallback, 0,
                inferLegacyTypeForNetworkCapabilities(request.networkCapabilities));
!!!3448375.java!!!	requestNetwork(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback, in timeoutMs : int) : void
        requestNetwork(request, networkCallback, timeoutMs,
                inferLegacyTypeForNetworkCapabilities(request.networkCapabilities));
!!!3448503.java!!!	requestNetwork(inout request : NetworkRequest, inout operation : PendingIntent) : void
        checkPendingIntent(operation);
        try {
            mService.pendingRequestForNetwork(request.networkCapabilities, operation);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3448631.java!!!	releaseNetworkRequest(inout operation : PendingIntent) : void
        checkPendingIntent(operation);
        try {
            mService.releasePendingNetworkRequest(operation);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3448759.java!!!	checkPendingIntent(inout intent : PendingIntent) : void
        if (intent == null) {
            throw new IllegalArgumentException("PendingIntent cannot be null.");
        }
!!!3448887.java!!!	registerNetworkCallback(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback) : void
        sendRequestForNetwork(request.networkCapabilities, networkCallback, 0, LISTEN, TYPE_NONE);
!!!3449015.java!!!	registerNetworkCallback(inout request : NetworkRequest, inout operation : PendingIntent) : void
        checkPendingIntent(operation);
        try {
            mService.pendingListenForNetwork(request.networkCapabilities, operation);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3449143.java!!!	registerDefaultNetworkCallback(inout networkCallback : ConnectivityManager::NetworkCallback) : void
        // This works because if the NetworkCapabilities are null,
        // ConnectivityService takes them from the default request.
        //
        // Since the capabilities are exactly the same as the default request's
        // capabilities, this request is guaranteed, at all times, to be
        // satisfied by the same network, if any, that satisfies the default
        // request, i.e., the system default network.
        sendRequestForNetwork(null, networkCallback, 0, REQUEST, TYPE_NONE);
!!!3449271.java!!!	requestBandwidthUpdate(inout network : Network) : boolean
        try {
            return mService.requestBandwidthUpdate(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3449399.java!!!	unregisterNetworkCallback(inout networkCallback : ConnectivityManager::NetworkCallback) : void
        if (networkCallback == null || networkCallback.networkRequest == null ||
                networkCallback.networkRequest.requestId == REQUEST_ID_UNSET) {
            throw new IllegalArgumentException("Invalid NetworkCallback");
        }
        try {
            mService.releaseNetworkRequest(networkCallback.networkRequest);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }

        synchronized (sNetworkCallback) {
            sNetworkCallback.remove(networkCallback.networkRequest);
        }
!!!3449527.java!!!	unregisterNetworkCallback(inout operation : PendingIntent) : void
        releaseNetworkRequest(operation);
!!!3449655.java!!!	setAcceptUnvalidated(inout network : Network, inout accept : boolean, inout always : boolean) : void
        try {
            mService.setAcceptUnvalidated(network, accept, always);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3449783.java!!!	factoryReset() : void
        try {
            mService.factoryReset();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3449911.java!!!	bindProcessToNetwork(inout network : Network) : boolean
        // Forcing callers to call thru non-static function ensures ConnectivityManager
        // instantiated.
        return setProcessDefaultNetwork(network);
!!!3450039.java!!!	setProcessDefaultNetwork(inout network : Network) : boolean
        int netId = (network == null) ? NETID_UNSET : network.netId;
        if (netId == NetworkUtils.getBoundNetworkForProcess()) {
            return true;
        }
        if (NetworkUtils.bindProcessToNetwork(netId)) {
            // Set HTTP proxy system properties to match network.
            // TODO: Deprecate this static method and replace it with a non-static version.
            try {
                Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
            } catch (SecurityException e) {
                // The process doesn't have ACCESS_NETWORK_STATE, so we can't fetch the proxy.
                Log.e(TAG, "Can't set proxy properties", e);
            }
            // Must flush DNS cache as new network may have different DNS resolutions.
            InetAddress.clearDnsCache();
            // Must flush socket pool as idle sockets will be bound to previous network and may
            // cause subsequent fetches to be performed on old network.
            NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
            return true;
        } else {
            return false;
        }
!!!3450167.java!!!	getBoundNetworkForProcess() : Network
        // Forcing callers to call thru non-static function ensures ConnectivityManager
        // instantiated.
        return getProcessDefaultNetwork();
!!!3450295.java!!!	getProcessDefaultNetwork() : Network
        int netId = NetworkUtils.getBoundNetworkForProcess();
        if (netId == NETID_UNSET) return null;
        return new Network(netId);
!!!3450423.java!!!	unsupportedStartingFrom(in version : int) : void
        if (Process.myUid() == Process.SYSTEM_UID) {
            // The getApplicationInfo() call we make below is not supported in system context, and
            // we want to allow the system to use these APIs anyway.
            return;
        }

        if (mContext.getApplicationInfo().targetSdkVersion >= version) {
            throw new UnsupportedOperationException(
                    "This method is not supported in target SDK version " + version + " and above");
        }
!!!3450551.java!!!	checkLegacyRoutingApiAccess() : void
        if (mContext.checkCallingOrSelfPermission("com.android.permission.INJECT_OMADM_SETTINGS")
                == PackageManager.PERMISSION_GRANTED) {
            return;
        }

        unsupportedStartingFrom(VERSION_CODES.M);
!!!3450679.java!!!	setProcessDefaultNetworkForHostResolution(inout network : Network) : boolean
        return NetworkUtils.bindProcessToNetworkForHostResolution(
                network == null ? NETID_UNSET : network.netId);
!!!3450807.java!!!	getNetworkPolicyManager() : INetworkPolicyManager
        synchronized (this) {
            if (mNPManager != null) {
                return mNPManager;
            }
            mNPManager = INetworkPolicyManager.Stub.asInterface(ServiceManager
                    .getService(Context.NETWORK_POLICY_SERVICE));
            return mNPManager;
        }
!!!3450935.java!!!	getRestrictBackgroundStatus() : int
        try {
            return getNetworkPolicyManager().getRestrictBackgroundByCaller();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!3451063.java!!!	whatToString(in what : int) : String
        return NoPreloadHolder.sMagicDecoderRing.get(what, Integer.toString(what));
